Directory structure:
â””â”€â”€ teambtcmap-btcmap.org/
    â”œâ”€â”€ README.md
    â”œâ”€â”€ CLAUDE.md
    â”œâ”€â”€ CONTRIBUTING.md
    â”œâ”€â”€ CRUSH.md
    â”œâ”€â”€ eslint.config.js
    â”œâ”€â”€ LICENSE
    â”œâ”€â”€ netlify.toml
    â”œâ”€â”€ package.json
    â”œâ”€â”€ playwright.config.ts
    â”œâ”€â”€ postcss.config.js
    â”œâ”€â”€ SECURITY.md
    â”œâ”€â”€ svelte.config.js
    â”œâ”€â”€ tailwind.config.js
    â”œâ”€â”€ tsconfig.json
    â”œâ”€â”€ vite.config.ts
    â”œâ”€â”€ vitest.config.ts
    â”œâ”€â”€ .clauderules
    â”œâ”€â”€ .nvmrc
    â”œâ”€â”€ .prettierignore
    â”œâ”€â”€ .prettierrc
    â”œâ”€â”€ .replit
    â”œâ”€â”€ .yarnrc.yml
    â”œâ”€â”€ src/
    â”‚   â”œâ”€â”€ app.css
    â”‚   â”œâ”€â”€ app.d.ts
    â”‚   â”œâ”€â”€ app.html
    â”‚   â”œâ”€â”€ error.html
    â”‚   â”œâ”€â”€ service-worker.ts
    â”‚   â”œâ”€â”€ components/
    â”‚   â”‚   â”œâ”€â”€ Boost.svelte
    â”‚   â”‚   â”œâ”€â”€ BoostButton.svelte
    â”‚   â”‚   â”œâ”€â”€ BoostContent.svelte
    â”‚   â”‚   â”œâ”€â”€ Breadcrumbs.svelte
    â”‚   â”‚   â”œâ”€â”€ Card.svelte
    â”‚   â”‚   â”œâ”€â”€ CloseButton.svelte
    â”‚   â”‚   â”œâ”€â”€ CopyButton.svelte
    â”‚   â”‚   â”œâ”€â”€ Countdown.svelte
    â”‚   â”‚   â”œâ”€â”€ FormSuccess.svelte
    â”‚   â”‚   â”œâ”€â”€ Icon.svelte
    â”‚   â”‚   â”œâ”€â”€ InfoTooltip.svelte
    â”‚   â”‚   â”œâ”€â”€ InvoicePayment.svelte
    â”‚   â”‚   â”œâ”€â”€ InvoicePaymentStage.svelte
    â”‚   â”‚   â”œâ”€â”€ IssueCell.svelte
    â”‚   â”‚   â”œâ”€â”€ IssueIcon.svelte
    â”‚   â”‚   â”œâ”€â”€ IssuesTable.svelte
    â”‚   â”‚   â”œâ”€â”€ LatestTagger.svelte
    â”‚   â”‚   â”œâ”€â”€ LoadingSpinner.svelte
    â”‚   â”‚   â”œâ”€â”€ MapLoadingEmbed.svelte
    â”‚   â”‚   â”œâ”€â”€ MapLoadingMain.svelte
    â”‚   â”‚   â”œâ”€â”€ MerchantDetailsContent.svelte
    â”‚   â”‚   â”œâ”€â”€ OpenTicket.svelte
    â”‚   â”‚   â”œâ”€â”€ OrgBadge.svelte
    â”‚   â”‚   â”œâ”€â”€ PaymentMethodIcon.svelte
    â”‚   â”‚   â”œâ”€â”€ PrimaryButton.svelte
    â”‚   â”‚   â”œâ”€â”€ ProfileStat.svelte
    â”‚   â”‚   â”œâ”€â”€ ShowTags.svelte
    â”‚   â”‚   â”œâ”€â”€ SocialLink.svelte
    â”‚   â”‚   â”œâ”€â”€ Socials.svelte
    â”‚   â”‚   â”œâ”€â”€ SponsorBadge.svelte
    â”‚   â”‚   â”œâ”€â”€ TaggerSkeleton.svelte
    â”‚   â”‚   â”œâ”€â”€ TaggingIssues.svelte
    â”‚   â”‚   â”œâ”€â”€ ThemeToggle.svelte
    â”‚   â”‚   â”œâ”€â”€ TicketLabel.svelte
    â”‚   â”‚   â”œâ”€â”€ Tip.svelte
    â”‚   â”‚   â”œâ”€â”€ TopButton.svelte
    â”‚   â”‚   â”œâ”€â”€ area/
    â”‚   â”‚   â”‚   â”œâ”€â”€ AreaActivity.svelte
    â”‚   â”‚   â”‚   â”œâ”€â”€ AreaMap.svelte
    â”‚   â”‚   â”‚   â”œâ”€â”€ AreaMerchantDrawer.svelte
    â”‚   â”‚   â”‚   â”œâ”€â”€ AreaMerchantHighlights.svelte
    â”‚   â”‚   â”‚   â”œâ”€â”€ AreaPage.svelte
    â”‚   â”‚   â”‚   â”œâ”€â”€ AreaStats.svelte
    â”‚   â”‚   â”‚   â”œâ”€â”€ AreaTickets.svelte
    â”‚   â”‚   â”‚   â””â”€â”€ MerchantCard.svelte
    â”‚   â”‚   â”œâ”€â”€ layout/
    â”‚   â”‚   â”‚   â”œâ”€â”€ Footer.svelte
    â”‚   â”‚   â”‚   â”œâ”€â”€ Header.svelte
    â”‚   â”‚   â”‚   â”œâ”€â”€ HeaderPlaceholder.svelte
    â”‚   â”‚   â”‚   â”œâ”€â”€ NavDropdownDesktop.svelte
    â”‚   â”‚   â”‚   â””â”€â”€ NavDropdownMobile.svelte
    â”‚   â”‚   â””â”€â”€ leaderboard/
    â”‚   â”‚       â”œâ”€â”€ AreaLeaderboard.svelte
    â”‚   â”‚       â”œâ”€â”€ AreaLeaderboardDesktopTable.svelte
    â”‚   â”‚       â”œâ”€â”€ AreaLeaderboardItemName.svelte
    â”‚   â”‚       â”œâ”€â”€ AreaLeaderboardMobileCard.svelte
    â”‚   â”‚       â”œâ”€â”€ GradeDisplay.svelte
    â”‚   â”‚       â”œâ”€â”€ LeaderboardPagination.svelte
    â”‚   â”‚       â”œâ”€â”€ LeaderboardSearch.svelte
    â”‚   â”‚       â”œâ”€â”€ SortHeaderButton.svelte
    â”‚   â”‚       â”œâ”€â”€ TaggerLeaderboardDesktopTable.svelte
    â”‚   â”‚       â””â”€â”€ TaggerLeaderboardMobileCard.svelte
    â”‚   â”œâ”€â”€ lib/
    â”‚   â”‚   â”œâ”€â”€ analytics.ts
    â”‚   â”‚   â”œâ”€â”€ api-fields.ts
    â”‚   â”‚   â”œâ”€â”€ cache.ts
    â”‚   â”‚   â”œâ”€â”€ categoryMapping.test.ts
    â”‚   â”‚   â”œâ”€â”€ categoryMapping.ts
    â”‚   â”‚   â”œâ”€â”€ constants.ts
    â”‚   â”‚   â”œâ”€â”€ drawerConfig.ts
    â”‚   â”‚   â”œâ”€â”€ drawerGestureController.ts
    â”‚   â”‚   â”œâ”€â”€ drawerGestureUtils.test.ts
    â”‚   â”‚   â”œâ”€â”€ drawerGestureUtils.ts
    â”‚   â”‚   â”œâ”€â”€ gitea.ts
    â”‚   â”‚   â”œâ”€â”€ merchantDrawerHash.test.ts
    â”‚   â”‚   â”œâ”€â”€ merchantDrawerHash.ts
    â”‚   â”‚   â”œâ”€â”€ merchantDrawerLogic.ts
    â”‚   â”‚   â”œâ”€â”€ merchantDrawerStore.ts
    â”‚   â”‚   â”œâ”€â”€ merchantListStore.test.ts
    â”‚   â”‚   â”œâ”€â”€ merchantListStore.ts
    â”‚   â”‚   â”œâ”€â”€ organizationDisplayNames.ts
    â”‚   â”‚   â”œâ”€â”€ payment.ts
    â”‚   â”‚   â”œâ”€â”€ store.ts
    â”‚   â”‚   â”œâ”€â”€ types.ts
    â”‚   â”‚   â”œâ”€â”€ utils.ts
    â”‚   â”‚   â”œâ”€â”€ icons/
    â”‚   â”‚   â”‚   â”œâ”€â”€ IconApps.svelte
    â”‚   â”‚   â”‚   â”œâ”€â”€ IconMobileNav.svelte
    â”‚   â”‚   â”‚   â”œâ”€â”€ IconSocials.svelte
    â”‚   â”‚   â”‚   â””â”€â”€ types.ts
    â”‚   â”‚   â”œâ”€â”€ map/
    â”‚   â”‚   â”‚   â”œâ”€â”€ imports.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ markers.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ setup.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ viewport.test.ts
    â”‚   â”‚   â”‚   â””â”€â”€ viewport.ts
    â”‚   â”‚   â”œâ”€â”€ sync/
    â”‚   â”‚   â”‚   â”œâ”€â”€ areas.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ batchSync.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ clearTables.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ createSyncFactory.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ events.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ places.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ reports.ts
    â”‚   â”‚   â”‚   â””â”€â”€ users.ts
    â”‚   â”‚   â””â”€â”€ workers/
    â”‚   â”‚       â”œâ”€â”€ map-worker.ts
    â”‚   â”‚       â”œâ”€â”€ sync-worker-manager.ts
    â”‚   â”‚       â”œâ”€â”€ sync-worker.ts
    â”‚   â”‚       â””â”€â”€ worker-manager.ts
    â”‚   â”œâ”€â”€ routes/
    â”‚   â”‚   â”œâ”€â”€ +error.svelte
    â”‚   â”‚   â”œâ”€â”€ +layout.svelte
    â”‚   â”‚   â”œâ”€â”€ +layout.ts
    â”‚   â”‚   â”œâ”€â”€ +page.svelte
    â”‚   â”‚   â”œâ”€â”€ about-us/
    â”‚   â”‚   â”‚   â”œâ”€â”€ +page.svelte
    â”‚   â”‚   â”‚   â””â”€â”€ components/
    â”‚   â”‚   â”‚       â”œâ”€â”€ AboutCommunity.svelte
    â”‚   â”‚   â”‚       â”œâ”€â”€ AboutContributor.svelte
    â”‚   â”‚   â”‚       â”œâ”€â”€ AboutCore.svelte
    â”‚   â”‚   â”‚       â”œâ”€â”€ AboutIntegration.svelte
    â”‚   â”‚   â”‚       â”œâ”€â”€ AboutMerchant.svelte
    â”‚   â”‚   â”‚       â”œâ”€â”€ AboutPlus.svelte
    â”‚   â”‚   â”‚       â””â”€â”€ AboutTagger.svelte
    â”‚   â”‚   â”œâ”€â”€ activity/
    â”‚   â”‚   â”‚   â””â”€â”€ +page.svelte
    â”‚   â”‚   â”œâ”€â”€ add-location/
    â”‚   â”‚   â”‚   â”œâ”€â”€ +page.svelte
    â”‚   â”‚   â”‚   â””â”€â”€ endpoint/
    â”‚   â”‚   â”‚       â””â”€â”€ +server.ts
    â”‚   â”‚   â”œâ”€â”€ api/
    â”‚   â”‚   â”‚   â”œâ”€â”€ boost/
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ invoice/
    â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ generate/
    â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ +server.ts
    â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ status/
    â”‚   â”‚   â”‚   â”‚   â”‚       â””â”€â”€ +server.ts
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ post/
    â”‚   â”‚   â”‚   â”‚       â””â”€â”€ +server.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ comment/
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ invoice/
    â”‚   â”‚   â”‚   â”‚       â””â”€â”€ generate/
    â”‚   â”‚   â”‚   â”‚           â””â”€â”€ +server.ts
    â”‚   â”‚   â”‚   â””â”€â”€ search/
    â”‚   â”‚   â”‚       â””â”€â”€ places/
    â”‚   â”‚   â”‚           â””â”€â”€ +server.ts
    â”‚   â”‚   â”œâ”€â”€ apps/
    â”‚   â”‚   â”‚   â”œâ”€â”€ +page.svelte
    â”‚   â”‚   â”‚   â””â”€â”€ components/
    â”‚   â”‚   â”‚       â””â”€â”€ AppCard.svelte
    â”‚   â”‚   â”œâ”€â”€ badges/
    â”‚   â”‚   â”‚   â”œâ”€â”€ +page.svelte
    â”‚   â”‚   â”‚   â””â”€â”€ components/
    â”‚   â”‚   â”‚       â””â”€â”€ BadgeCard.svelte
    â”‚   â”‚   â”œâ”€â”€ captcha/
    â”‚   â”‚   â”‚   â””â”€â”€ +server.ts
    â”‚   â”‚   â”œâ”€â”€ comment/
    â”‚   â”‚   â”‚   â””â”€â”€ invoice/
    â”‚   â”‚   â”‚       â””â”€â”€ generate/
    â”‚   â”‚   â”‚           â””â”€â”€ +server.ts
    â”‚   â”‚   â”œâ”€â”€ communities/
    â”‚   â”‚   â”‚   â”œâ”€â”€ +page.server.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ +page.svelte
    â”‚   â”‚   â”‚   â”œâ”€â”€ [section]/
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ +page.svelte
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ +page.ts
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ components/
    â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ CommunityCard.svelte
    â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ CommunitySection.svelte
    â”‚   â”‚   â”‚   â”‚       â””â”€â”€ CommunitySkeleton.svelte
    â”‚   â”‚   â”‚   â”œâ”€â”€ add/
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ +page.svelte
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ endpoint/
    â”‚   â”‚   â”‚   â”‚       â””â”€â”€ +server.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ leaderboard/
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ +page.svelte
    â”‚   â”‚   â”‚   â””â”€â”€ map/
    â”‚   â”‚   â”‚       â””â”€â”€ +page.svelte
    â”‚   â”‚   â”œâ”€â”€ community/
    â”‚   â”‚   â”‚   â””â”€â”€ [area]/
    â”‚   â”‚   â”‚       â”œâ”€â”€ +page.server.ts
    â”‚   â”‚   â”‚       â””â”€â”€ [section]/
    â”‚   â”‚   â”‚           â”œâ”€â”€ +page.server.ts
    â”‚   â”‚   â”‚           â””â”€â”€ +page.svelte
    â”‚   â”‚   â”œâ”€â”€ countries/
    â”‚   â”‚   â”‚   â”œâ”€â”€ +page.server.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ +page.svelte
    â”‚   â”‚   â”‚   â”œâ”€â”€ [section]/
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ +page.svelte
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ +page.ts
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ components/
    â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ CountryCard.svelte
    â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ CountrySection.svelte
    â”‚   â”‚   â”‚   â”‚       â””â”€â”€ CountrySkeleton.svelte
    â”‚   â”‚   â”‚   â””â”€â”€ leaderboard/
    â”‚   â”‚   â”‚       â””â”€â”€ +page.svelte
    â”‚   â”‚   â”œâ”€â”€ country/
    â”‚   â”‚   â”‚   â””â”€â”€ [area]/
    â”‚   â”‚   â”‚       â”œâ”€â”€ +page.server.ts
    â”‚   â”‚   â”‚       â””â”€â”€ [section]/
    â”‚   â”‚   â”‚           â”œâ”€â”€ +page.server.ts
    â”‚   â”‚   â”‚           â””â”€â”€ +page.svelte
    â”‚   â”‚   â”œâ”€â”€ dashboard/
    â”‚   â”‚   â”‚   â”œâ”€â”€ +page.server.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ +page.svelte
    â”‚   â”‚   â”‚   â””â”€â”€ components/
    â”‚   â”‚   â”‚       â””â”€â”€ DashboardStat.svelte
    â”‚   â”‚   â”œâ”€â”€ leaderboard/
    â”‚   â”‚   â”‚   â”œâ”€â”€ +page.server.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ +page.svelte
    â”‚   â”‚   â”‚   â””â”€â”€ components/
    â”‚   â”‚   â”‚       â”œâ”€â”€ LeaderboardItem.svelte
    â”‚   â”‚   â”‚       â””â”€â”€ LeaderboardSkeleton.svelte
    â”‚   â”‚   â”œâ”€â”€ license/
    â”‚   â”‚   â”‚   â””â”€â”€ +page.svelte
    â”‚   â”‚   â”œâ”€â”€ map/
    â”‚   â”‚   â”‚   â”œâ”€â”€ +layout.server.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ +page.svelte
    â”‚   â”‚   â”‚   â””â”€â”€ components/
    â”‚   â”‚   â”‚       â”œâ”€â”€ MerchantDrawerDesktop.svelte
    â”‚   â”‚   â”‚       â”œâ”€â”€ MerchantDrawerHash.svelte
    â”‚   â”‚   â”‚       â”œâ”€â”€ MerchantDrawerMobile.svelte
    â”‚   â”‚   â”‚       â”œâ”€â”€ MerchantListItem.svelte
    â”‚   â”‚   â”‚       â”œâ”€â”€ MerchantListPanel.svelte
    â”‚   â”‚   â”‚       â”œâ”€â”€ MerchantPeekContentMobile.svelte
    â”‚   â”‚   â”‚       â””â”€â”€ TileLoadingIndicator.svelte
    â”‚   â”‚   â”œâ”€â”€ media/
    â”‚   â”‚   â”‚   â””â”€â”€ +page.svelte
    â”‚   â”‚   â”œâ”€â”€ merchant/
    â”‚   â”‚   â”‚   â””â”€â”€ [id]/
    â”‚   â”‚   â”‚       â”œâ”€â”€ +page.server.ts
    â”‚   â”‚   â”‚       â”œâ”€â”€ +page.svelte
    â”‚   â”‚   â”‚       â””â”€â”€ components/
    â”‚   â”‚   â”‚           â”œâ”€â”€ CommentAdd.svelte
    â”‚   â”‚   â”‚           â”œâ”€â”€ CommentAddButton.svelte
    â”‚   â”‚   â”‚           â”œâ”€â”€ MerchantButton.svelte
    â”‚   â”‚   â”‚           â”œâ”€â”€ MerchantComment.svelte
    â”‚   â”‚   â”‚           â”œâ”€â”€ MerchantEvent.svelte
    â”‚   â”‚   â”‚           â””â”€â”€ MerchantLink.svelte
    â”‚   â”‚   â”œâ”€â”€ privacy-policy/
    â”‚   â”‚   â”‚   â””â”€â”€ +page.svelte
    â”‚   â”‚   â”œâ”€â”€ report-outdated-info/
    â”‚   â”‚   â”‚   â””â”€â”€ +server.ts
    â”‚   â”‚   â”œâ”€â”€ support-us/
    â”‚   â”‚   â”‚   â”œâ”€â”€ +page.svelte
    â”‚   â”‚   â”‚   â””â”€â”€ components/
    â”‚   â”‚   â”‚       â”œâ”€â”€ DonationOption.svelte
    â”‚   â”‚   â”‚       â””â”€â”€ SupportSection.svelte
    â”‚   â”‚   â”œâ”€â”€ tagger/
    â”‚   â”‚   â”‚   â””â”€â”€ [id]/
    â”‚   â”‚   â”‚       â”œâ”€â”€ +page.svelte
    â”‚   â”‚   â”‚       â”œâ”€â”€ +page.ts
    â”‚   â”‚   â”‚       â””â”€â”€ components/
    â”‚   â”‚   â”‚           â””â”€â”€ ProfileActivity.svelte
    â”‚   â”‚   â”œâ”€â”€ tagging-issues/
    â”‚   â”‚   â”‚   â”œâ”€â”€ +page.server.ts
    â”‚   â”‚   â”‚   â””â”€â”€ +page.svelte
    â”‚   â”‚   â”œâ”€â”€ tickets/
    â”‚   â”‚   â”‚   â”œâ”€â”€ +page.server.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ +page.svelte
    â”‚   â”‚   â”‚   â””â”€â”€ components/
    â”‚   â”‚   â”‚       â””â”€â”€ OpenTicketSkeleton.svelte
    â”‚   â”‚   â”œâ”€â”€ verify-location/
    â”‚   â”‚   â”‚   â”œâ”€â”€ +page.server.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ +page.svelte
    â”‚   â”‚   â”‚   â””â”€â”€ endpoint/
    â”‚   â”‚   â”‚       â””â”€â”€ +server.ts
    â”‚   â”‚   â””â”€â”€ .well-known/
    â”‚   â”‚       â””â”€â”€ nostr.json/
    â”‚   â”‚           â””â”€â”€ +server.ts
    â”‚   â””â”€â”€ types/
    â”‚       â”œâ”€â”€ geojson-rewind.d.ts
    â”‚       â””â”€â”€ leaflet-dom.d.ts
    â”œâ”€â”€ static/
    â”‚   â”œâ”€â”€ btcmap.webmanifest
    â”‚   â”œâ”€â”€ cached.txt
    â”‚   â”œâ”€â”€ CNAME
    â”‚   â”œâ”€â”€ offline.html
    â”‚   â”œâ”€â”€ robots.txt
    â”‚   â”œâ”€â”€ assets/
    â”‚   â”‚   â””â”€â”€ btcmap-media-assets.zip
    â”‚   â”œâ”€â”€ fonts/
    â”‚   â”‚   â””â”€â”€ Manrope-Regular.ttf
    â”‚   â”œâ”€â”€ images/
    â”‚   â”‚   â”œâ”€â”€ hero-mobile-example-dark.webp
    â”‚   â”‚   â””â”€â”€ hero-mobile-example.webp
    â”‚   â””â”€â”€ nostr-badges/
    â”‚       â””â”€â”€ og-supertagger.webp
    â”œâ”€â”€ tests/
    â”‚   â”œâ”€â”€ areas.spec.ts
    â”‚   â”œâ”€â”€ boost-invoice.spec.ts
    â”‚   â”œâ”€â”€ communities.spec.ts
    â”‚   â”œâ”€â”€ community-area.spec.ts
    â”‚   â”œâ”€â”€ countries.spec.ts
    â”‚   â”œâ”€â”€ country-area.spec.ts
    â”‚   â”œâ”€â”€ home.spec.ts
    â”‚   â”œâ”€â”€ leaderboard.spec.ts
    â”‚   â”œâ”€â”€ map-drawer.spec.ts
    â”‚   â”œâ”€â”€ merchant-list-panel.spec.ts
    â”‚   â””â”€â”€ verify-location.spec.ts
    â”œâ”€â”€ .github/
    â”‚   â”œâ”€â”€ copilot-instructions.md
    â”‚   â”œâ”€â”€ dependabot.yml
    â”‚   â”œâ”€â”€ FUNDING.yml
    â”‚   â”œâ”€â”€ pull_request_template.md
    â”‚   â”œâ”€â”€ actions/
    â”‚   â”‚   â””â”€â”€ setup/
    â”‚   â”‚       â”œâ”€â”€ README.md
    â”‚   â”‚       â””â”€â”€ action.yml
    â”‚   â”œâ”€â”€ ISSUE_TEMPLATE/
    â”‚   â”‚   â”œâ”€â”€ bug_report.md
    â”‚   â”‚   â””â”€â”€ feature_request.md
    â”‚   â””â”€â”€ workflows/
    â”‚       â”œâ”€â”€ build.yml
    â”‚       â”œâ”€â”€ e2e-tests.yml
    â”‚       â”œâ”€â”€ format-and-lint.yml
    â”‚       â”œâ”€â”€ type-checks.yml
    â”‚       â””â”€â”€ unit-tests.yml
    â””â”€â”€ .husky/
        â””â”€â”€ pre-commit

================================================
FILE: README.md
================================================
# BTC Map Web App

[![Netlify Status](https://api.netlify.com/api/v1/badges/8a9b0504-641c-4975-9e2b-daefe43f93e8/deploy-status)](https://app.netlify.com/sites/btcmap/deploys)

## Getting started

1. `git clone`\
   to clone the repo and `cd` into the directory
2. `yarn`\
   to install the packages
3. `yarn dev`\
   will open the app on: http://localhost:5000

### Check your changes before commit/pushing

- `yarn run format`
- `yarn run lint`
- `yarn run typecheck`

### Build project

1. Create `.env`  
   Copy `.env.example` and save as `.env`
1. `yarn build`

_NOTE:_ BTC Map uses the latest LTS version of [node](https://nodejs.org/). If you have [NVM](https://github.com/nvm-sh/nvm), you can simply run `nvm use` in the root directory of the repo to switch to the supported node version.

#### Icons

- [Iconify](https://iconify.design/docs/icon-components/svelte/#iconify-for-svelte): for general material/fontawesome icons via `Icon.svelte`
- Custom icons (socials, apps, mobile-nav): imported as raw SVGs in `src/lib/icons/` via wrapper components (`IconSocials.svelte`, `IconApps.svelte`, `IconMobileNav.svelte`)

### E2E tests

#### Install

```sh
  yarn playwright install
```

#### Run tests

```sh
  yarn playwright test
    Runs the end-to-end tests.

  yarn playwright test --ui
    Starts the interactive UI mode.

  yarn playwright test --project=chromium
    Runs the tests only on Desktop Chrome.

  yarn playwright test example
    Runs the tests in a specific file.

  yarn playwright test --debug
    Runs the tests in debug mode.
```

## PWA

This website is a progressive web app, meaning you can install it on your mobile device and use it like a native application. Just look for the **Add to home screen** or **Install** option in your browser while visiting [btcmap.org](https://btcmap.org).

## Embedding

For information on how to embed the BTC Map web map onto your own website or application please reference our [Wiki](https://gitea.btcmap.org/teambtcmap/btcmap-general/wiki/Embedding).

---

## Attributions

Thanks to:

### Base map tiles

- [OpenFreeMap](https://openfreemap.org/)
- [OpenStreetMap](https://www.openstreetmap.org)

### Icons

Tagger profile badges by [AndrejCibik](https://twitter.com/AndrejCibik)

<a href="https://www.flaticon.com/free-icons/satoshi-nakamoto" title="satoshi nakamoto icons">Satoshi nakamoto icons created by Vitaly Gorbachev - Flaticon</a>

---

![Untitled](https://user-images.githubusercontent.com/85003930/194117128-2f96bafd-2379-407a-a584-6c03396a42cc.png)



================================================
FILE: CLAUDE.md
================================================
# BTC Map Development Guidelines

This file contains project-specific guidelines and commands for Claude Code to follow when working on this codebase.

## âš ï¸ PRE-COMMIT CHECKLIST

**BEFORE EVERY COMMIT, YOU MUST:**

1. **ğŸ¨ Format code:** Run `yarn run format:fix` (REQUIRED - NO EXCEPTIONS)
2. **ğŸ” Type check:** Run `yarn run check`
3. **ğŸ§¹ Lint:** Run `yarn run lint`
4. **ğŸ§ª Unit tests:** Run `yarn run test --run`
5. **ğŸ“ Commit format:** Use conventional commit format with issue number

**Failure to run `yarn run format:fix` before committing will result in inconsistent code formatting.**

## Additional Documentation

For comprehensive project architecture, patterns, and development workflows, see:

- [GitHub Copilot Instructions](.github/copilot-instructions.md) - Detailed project overview, framework stack, data architecture, and coding conventions

## Code Quality Commands

### Linting

```bash
yarn run lint
```

Run this command to check for TypeScript and ESLint errors. Always run this before committing changes to ensure code quality.

### Formatting

```bash
yarn run format:fix
```

Run this command to automatically format code according to project standards. Always run this before committing changes.

### Type Checking

```bash
yarn run check
```

Run this command to perform comprehensive TypeScript type checking and Svelte validation. Always run this before committing changes.

## Code Style Guidelines

### TypeScript: Prefer `type` over `interface`

- **Prefer `type` for new type definitions** - more flexible, handles unions/primitives/mapped types
- **Use `interface` only when needed** - declaration merging, or when a class must `implements` it
- **Gradually migrate** existing `interface` to `type` when touching those files

```typescript
// Preferred: type
type UserState = {
	name: string;
	isActive: boolean;
};
type ID = string | number;
type Status = 'pending' | 'active' | 'closed';

// Use interface only when necessary (e.g., class implementation)
interface Disposable {
	dispose(): void;
}
class Resource implements Disposable { ... }
```

### Imports: Separate Types from Values

- **Never mix type and value imports** in the same statement
- Use `import type { ... }` for types only (removed at compile time)
- Use `import { ... }` for values only (needed at runtime)
- This improves tree-shaking and makes code intent clearer

```typescript
// âŒ Don't mix types and values
import { merchantList, type MerchantListMode } from '$lib/merchantListStore';

// âœ… Separate type imports from value imports
import type { MerchantListMode } from '$lib/merchantListStore';
import { merchantList } from '$lib/merchantListStore';

// âœ… Type-only imports use `import type`
import type { Place, Report, AreaTags } from '$lib/types';
```

### Comments

- **Avoid JSDoc comments** (`/** */` with `@param`, `@returns`, `@description`, etc.)
- Use inline `//` comments for explaining complex logic
- Keep code self-documenting with clear variable and function names
- TypeScript types serve as documentation - explicit JSDoc is redundant

### Example:

```typescript
// âŒ Don't use JSDoc
/**
 * Updates a single place in the store
 * @param placeId - The ID of the place
 * @returns The updated place or null
 */
export const updatePlace = async (placeId: string): Promise<Place | null> => {

// âœ… Do use inline comments when needed
export const updateSinglePlace = async (placeId: string | number): Promise<Place | null> => {
	// Fetch the updated place from the API
	const response = await axios.get<Place>(...);
```

## Git Commit Guidelines

**âš ï¸ CRITICAL: Always run `yarn run format:fix` before committing!**

Follow [Conventional Commits](https://www.conventionalcommits.org/) format for all commits:

```
<type>(<scope>): <description> #<issue-number>

[optional body]

ğŸ¤– Generated with [opencode](https://opencode.ai)
```

**Note:** When using opencode, we do not set a co-author attribution

### Examples:

- `feat(map): add dark mode toggle #276`
- `fix(area-page): resolve TypeScript errors #345`
- `refactor(api): optimize data fetching logic #123`
- `docs(readme): update installation instructions #456`

**Note:** Use `#123` not `(#123)` or `[#123]` for issue references.

### Commit Types:

- `feat`: New feature
- `fix`: Bug fix
- `refactor`: Code refactoring
- `perf`: Performance improvement
- `style`: Code style changes (formatting, etc.)
- `docs`: Documentation changes
- `test`: Test-related changes
- `chore`: Maintenance tasks

### Workflow:

1. Make your changes
2. **ğŸ¨ MANDATORY:** Run `yarn run format:fix` âš ï¸ **THIS IS REQUIRED BEFORE EVERY COMMIT** âš ï¸
3. Run `yarn run check` to perform type checking
4. Run `yarn run lint` to verify no errors
5. Stage and commit with conventional format
6. Include issue number if applicable (e.g., `#276`)

**ğŸš¨ CRITICAL REMINDER:** You MUST run `yarn run format:fix` before staging any commit. This is non-negotiable and ensures consistent code formatting across the entire project.

## Project Structure Notes

- `src/lib/sync/places.ts` always runs first and populates the `$places` store with `Place[]` data
- Use `Place` type for v4 API data, `Element` type for v2 API data
- Prefer editing existing files over creating new ones
- Only create documentation files when explicitly requested



================================================
FILE: CONTRIBUTING.md
================================================
# Contributing Guidelines

Please create an issue if there is a new feature, enhancement or bug you would like to see worked on.

If you are taking on an open issue please comment on the issue stating that you would like to work on it to avoid multiple people taking on the same issue.

## Fork the repo and submit a pull request

Please run `yarn run format:fix && yarn run lint && yarn run check` after making any changes and before submitting a PR.

That's it for now, thanks for contributing!



================================================
FILE: CRUSH.md
================================================
# BTC Map Development Guide

## Build/Test Commands

- `yarn dev` - Start development server with HMR
- `yarn build` - Production build
- `yarn check` - TypeScript + Svelte validation
- `yarn lint` - ESLint check
- `yarn lint:fix` - Auto-fix ESLint issues
- `yarn format:fix` - **REQUIRED before every commit** - Prettier formatting
- `yarn typecheck` - TypeScript type checking
- `yarn playwright test` - Run all E2E tests
- `yarn playwright test tests/home.spec.ts` - Run single test file
- `yarn playwright test --headed` - Run tests with browser UI

## Code Style (Auto-enforced)

- **Tabs** for indentation, **single quotes**, **no trailing commas**
- **100 char line limit**, TailwindCSS class sorting enabled
- **TypeScript required** - avoid `any`, create types in `src/lib/types.ts`
- **Svelte v4** conventions - use stores, reactive statements, proper lifecycle
- **TailwindCSS v3** utility-first, custom Bitcoin orange/teal theme
- **Imports**: Barrel exports from `src/lib/comp.ts`, absolute paths preferred

## Architecture

- **SvelteKit** file-based routing, SSR for SEO pages
- **Leaflet + MapLibre** for interactive maps with clustering
- **LocalForage** client-side caching, sync every 10min from API
- **Mobile-first PWA** with offline support via service worker

## Map Performance Optimizations

- **Hybrid viewport + web worker loading**: Only load markers visible in current viewport
- **Lazy worker initialization**: Web workers initialized only when needed with proper feature detection
- **Viewport-based filtering**: 20% buffer around visible area for smooth panning
- **Memory management**: Cleanup out-of-bounds markers when >200 markers loaded
- **Debounced loading**: 300ms debounce on map movement to prevent excessive API calls
- **Batch processing**: 25-marker batches for optimal performance in viewport
- **MessageChannel yielding**: Proper event loop yielding in workers (no setTimeout)

## Performance Constants (Configurable)

```javascript
const MAX_LOADED_MARKERS = 200; // Memory cleanup threshold
const VIEWPORT_BATCH_SIZE = 25; // Worker batch size for viewport
const VIEWPORT_BUFFER_PERCENT = 0.2; // 20% buffer around viewport
const DEBOUNCE_DELAY = 300; // Map movement debounce (ms)
```

## Error Handling

- Use `@zerodevx/svelte-toast` for user notifications
- Axios retry logic for API failures, graceful offline degradation
- Proper TypeScript error types, avoid silent failures
- Web worker fallback to synchronous processing when workers unavailable



================================================
FILE: eslint.config.js
================================================
import js from '@eslint/js';
import eslintPluginSvelte from 'eslint-plugin-svelte';
import * as svelteParser from 'svelte-eslint-parser';
import * as typescriptParser from '@typescript-eslint/parser';
import tseslint from 'typescript-eslint';
import globals from 'globals';

export default tseslint.config(
	js.configs.recommended,
	...tseslint.configs.recommended,
	...eslintPluginSvelte.configs.recommended,
	...eslintPluginSvelte.configs['flat/prettier'],
	{
		name: 'project/typescript-config',
		files: ['**/*.ts'],
		rules: {
			'@typescript-eslint/no-unused-vars': [
				'error',
				{ argsIgnorePattern: '^_', varsIgnorePattern: '^_' }
			]
		}
	},
	{
		name: 'project/svelte-config',
		files: ['**/*.svelte'],
		languageOptions: {
			parser: svelteParser,
			parserOptions: {
				parser: typescriptParser,
				project: './tsconfig.json',
				extraFileExtensions: ['.svelte']
			},
			globals: {
				...globals.browser,
				...globals.node
			}
		},
		rules: {
			'svelte/no-unused-svelte-ignore': 'off', // These are used by vite-plugin-svelte/svelte-check, not ESLint
			'@typescript-eslint/no-unused-expressions': ['error', { allowShortCircuit: true }],
			'@typescript-eslint/no-unused-vars': [
				'error',
				{ argsIgnorePattern: '^_', varsIgnorePattern: '^_' }
			]
		}
	},
	{
		name: 'project/no-console',
		files: ['**/*.js', '**/*.ts', '**/*.svelte'],
		rules: {
			'no-console': ['error', { allow: ['info', 'warn', 'error', 'debug'] }]
		}
	},
	{
		ignores: ['.netlify', '.svelte-kit', 'static', 'build', 'spritesheet-*.ts', 'playwright-report']
	}
);



================================================
FILE: LICENSE
================================================
                    GNU AFFERO GENERAL PUBLIC LICENSE
                       Version 3, 19 November 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU Affero General Public License is a free, copyleft license for
software and other kinds of works, specifically designed to ensure
cooperation with the community in the case of network server software.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
our General Public Licenses are intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  Developers that use our General Public Licenses protect your rights
with two steps: (1) assert copyright on the software, and (2) offer
you this License which gives you legal permission to copy, distribute
and/or modify the software.

  A secondary benefit of defending all users' freedom is that
improvements made in alternate versions of the program, if they
receive widespread use, become available for other developers to
incorporate.  Many developers of free software are heartened and
encouraged by the resulting cooperation.  However, in the case of
software used on network servers, this result may fail to come about.
The GNU General Public License permits making a modified version and
letting the public access it on a server without ever releasing its
source code to the public.

  The GNU Affero General Public License is designed specifically to
ensure that, in such cases, the modified source code becomes available
to the community.  It requires the operator of a network server to
provide the source code of the modified version running there to the
users of that server.  Therefore, public use of a modified version, on
a publicly accessible server, gives the public access to the source
code of the modified version.

  An older license, called the Affero General Public License and
published by Affero, was designed to accomplish similar goals.  This is
a different license, not a version of the Affero GPL, but Affero has
released a new version of the Affero GPL which permits relicensing under
this license.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU Affero General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Remote Network Interaction; Use with the GNU General Public License.

  Notwithstanding any other provision of this License, if you modify the
Program, your modified version must prominently offer all users
interacting with it remotely through a computer network (if your version
supports such interaction) an opportunity to receive the Corresponding
Source of your version by providing access to the Corresponding Source
from a network server at no charge, through some standard or customary
means of facilitating copying of software.  This Corresponding Source
shall include the Corresponding Source for any work covered by version 3
of the GNU General Public License that is incorporated pursuant to the
following paragraph.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the work with which it is combined will remain governed by version
3 of the GNU General Public License.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU Affero General Public License from time to time.  Such new versions
will be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU Affero General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU Affero General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU Affero General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as published
    by the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If your software can interact with users remotely through a computer
network, you should also make sure that it provides a way for users to
get its source.  For example, if your program is a web application, its
interface could display a "Source" link that leads users to an archive
of the code.  There are many ways you could offer source, and different
solutions will be better for different programs; see section 13 for the
specific requirements.

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU AGPL, see
<https://www.gnu.org/licenses/>.



================================================
FILE: netlify.toml
================================================
[build]
	command = "yarn build"
	publish = "build"

[images]
  remote_images = ["https://static.btcmap.org/images/.*", "https://www.openstreetmap.org/.*", "https://avatars.githubusercontent.com/.*" ]

[functions]
  included_files = [".netlify/server/_app/immutable/assets/*.ttf"]



================================================
FILE: package.json
================================================
{
	"name": "btcmap",
	"version": "1.0.0",
	"private": true,
	"description": "Easily find places to spend sats anywhere on the planet.",
	"repository": "https://github.com/teambtcmap/btcmap.org",
	"author": "secondl1ght <secondl1ght@protonmail.com>",
	"license": "AGPL-3.0",
	"type": "module",
	"scripts": {
		"build": "vite build",
		"check": "svelte-kit sync && svelte-check --tsconfig ./tsconfig.json",
		"check:watch": "svelte-kit sync && svelte-check --tsconfig ./tsconfig.json --watch",
		"dev": "vite dev --host",
		"format": "prettier --check .",
		"format:fix": "prettier --write .",
		"lint": "eslint",
		"lint:fix": "eslint --fix",
		"prepare": "husky",
		"preview": "vite preview",
		"test": "vitest",
		"typecheck": "tsc --project ./tsconfig.json --noEmit --pretty"
	},
	"lint-staged": {
		"*": [
			"eslint",
			"prettier --check"
		]
	},
	"dependencies": {
		"@mapbox/geojson-rewind": "^0.5.2",
		"@maplibre/maplibre-gl-leaflet": "^0.1.3",
		"@tanstack/match-sorter-utils": "^8.19.4",
		"@tanstack/svelte-table": "^8.21.3",
		"@zerodevx/svelte-toast": "^0.9.6",
		"axios": "^1.13.2",
		"axios-retry": "^4.5.0",
		"chart.js": "^4.5.1",
		"d3-geo": "^3.1.1",
		"date-fns": "^4.1.0",
		"dompurify": "^3.3.1",
		"globals": "^16.5.0",
		"husky": "^9.1.7",
		"js-confetti": "^0.13.1",
		"leaflet": "^1.9.4",
		"leaflet.featuregroup.subgroup": "^1.0.2",
		"leaflet.locatecontrol": "0.85.1",
		"leaflet.markercluster": "^1.5.3",
		"localforage": "^1.10.0",
		"maplibre-gl": "^4.7.1",
		"marked": "^17.0.1",
		"qrcode": "^1.5.4",
		"svelte-eslint-parser": "^1.4.1",
		"svelte-outclick": "^3.7.1",
		"svelte-time": "^1.0.0",
		"svg-captcha": "^1.4.0",
		"tippy.js": "^6.3.7"
	},
	"devDependencies": {
		"@eslint/js": "^9.39.2",
		"@iconify/svelte": "^4.2.0",
		"@playwright/test": "^1.57.0",
		"@sveltejs/adapter-netlify": "^5.2.4",
		"@sveltejs/kit": "^2.49.2",
		"@sveltejs/vite-plugin-svelte": "^3.1.2",
		"@tailwindcss/postcss": "^4.1.18",
		"@tailwindcss/vite": "^4.1.18",
		"@types/d3-geo": "^3.1.0",
		"@types/dompurify": "^3.2.0",
		"@types/geojson": "^7946.0.16",
		"@types/leaflet": "1.9.21",
		"@types/leaflet.featuregroup.subgroup": "^1.0.4",
		"@types/leaflet.locatecontrol": "^0.82.1",
		"@types/leaflet.markercluster": "^1.5.6",
		"@types/node": "^25.0.3",
		"@types/qrcode": "^1.5.6",
		"@typescript-eslint/eslint-plugin": "^8.50.1",
		"@typescript-eslint/parser": "^8.50.1",
		"eslint": "^9.39.2",
		"eslint-config-prettier": "^10.1.8",
		"eslint-plugin-svelte": "^3.13.1",
		"jsdom": "^27.4.0",
		"lint-staged": "^16.2.7",
		"postcss": "^8.5.6",
		"prettier": "^3.7.4",
		"prettier-plugin-svelte": "^3.4.1",
		"prettier-plugin-tailwindcss": "^0.7.2",
		"svelte": "^4.2.20",
		"svelte-check": "^4.3.5",
		"svelte-preprocess": "^6.0.3",
		"tailwindcss": "^4.1.18",
		"typescript": "^5.9.3",
		"typescript-eslint": "^8.50.1",
		"vite": "^5.4.21",
		"vitest": "^4.0.16"
	},
	"packageManager": "yarn@4.12.0"
}



================================================
FILE: playwright.config.ts
================================================
import { defineConfig, devices } from '@playwright/test';

/**
 * Read environment variables from file.
 * https://github.com/motdotla/dotenv
 */
// import dotenv from 'dotenv';
// import path from 'path';
// dotenv.config({ path: path.resolve(__dirname, '.env') });

/**
 * See https://playwright.dev/docs/test-configuration.
 */
export default defineConfig({
	testDir: './tests',
	/* Run tests in files in parallel */
	fullyParallel: true,
	/* Fail the build on CI if you accidentally left test.only in the source code. */
	forbidOnly: !!process.env.CI,
	/* Retry on CI only */
	retries: process.env.CI ? 2 : 0,
	/* Use 3 workers in CI for faster parallel execution */
	workers: process.env.CI ? 3 : undefined,
	/* Reporter to use. See https://playwright.dev/docs/test-reporters */
	reporter: 'html',
	/* Shared settings for all the projects below. See https://playwright.dev/docs/api/class-testoptions. */
	use: {
		/* Base URL to use in actions like `await page.goto('/')`. */
		// baseURL: 'http://127.0.0.1:3000',

		/* Collect trace when retrying the failed test. See https://playwright.dev/docs/trace-viewer */
		trace: 'on-first-retry',

		/* CI-specific timeouts for slower environments */
		actionTimeout: process.env.CI ? 15000 : 5000,
		navigationTimeout: process.env.CI ? 60000 : 10000
	},

	/* Configure projects for major browsers */
	projects: [
		{
			name: 'chromium',
			use: {
				...devices['Desktop Chrome'],
				baseURL: 'http://127.0.0.1:4173'
			}
		}

		// {
		// 	name: 'firefox',
		// 	use: { ...devices['Desktop Firefox'] }
		// },

		// {
		// 	name: 'webkit',
		// 	use: { ...devices['Desktop Safari'] }
		// }

		/* Test against mobile viewports. */
		// {
		//   name: 'Mobile Chrome',
		//   use: { ...devices['Pixel 5'] },
		// },
		// {
		//   name: 'Mobile Safari',
		//   use: { ...devices['iPhone 12'] },
		// },

		/* Test against branded browsers. */
		// {
		//   name: 'Microsoft Edge',
		//   use: { ...devices['Desktop Edge'], channel: 'msedge' },
		// },
		// {
		//   name: 'Google Chrome',
		//   use: { ...devices['Desktop Chrome'], channel: 'chrome' },
		// },
	],

	/* Run production build for e2e tests to catch production-only errors */
	webServer: {
		command: 'yarn build && yarn preview',
		url: 'http://127.0.0.1:4173',
		reuseExistingServer: !process.env.CI,
		timeout: 120000
	},

	/* Configure timeouts */
	timeout: process.env.CI ? 180000 : 60000 // 3 minutes for CI, 1 minute for local
});



================================================
FILE: postcss.config.js
================================================
export default {
	plugins: {
		'@tailwindcss/postcss': {}
	}
};



================================================
FILE: SECURITY.md
================================================
# Security Policy

## Supported Versions

All versions.

## Reporting a Vulnerability

Please report all issues to [secondl1ght@protonmail.com](mailto:secondl1ght@protonmail.com) and I will get back to you as soon as possible. If a legitimate vulnerability is found that requires fixing, some sats may be sent in return. Keeping in mind that this is an open source project without funding. If you could include suggested actions to patch the problem that would also be helpful. Thanks.



================================================
FILE: svelte.config.js
================================================
import adapter from '@sveltejs/adapter-netlify';
import { vitePreprocess } from '@sveltejs/vite-plugin-svelte';

/** @type {import('@sveltejs/kit').Config} */
const config = {
	// Consult https://kit.svelte.dev/docs/integrations#preprocessors
	// for more information about preprocessors
	preprocess: vitePreprocess(),

	kit: {
		// adapter-auto only supports some environments, see https://kit.svelte.dev/docs/adapter-auto for a list.
		// If your environment is not supported or you settled on a specific environment, switch out the adapter.
		// See https://kit.svelte.dev/docs/adapters for more information about adapters.
		adapter: adapter(),
		alias: {
			$components: 'src/components',
			'$components/*': 'src/components/*'
		},
		serviceWorker: {
			register: true,
			options: {
				scope: '/'
			}
		},
		paths: {
			base: '',
			assets: ''
		}
	}
};

export default config;



================================================
FILE: tailwind.config.js
================================================
/** @type {import('tailwindcss').Config} */
export default {
	darkMode: 'class',
	content: ['./src/**/*.{html,js,ts,svelte}'],
	theme: {
		fontSize: {
			xs: ['12px', '16px'],
			sm: ['14px', '20px'],
			base: ['16px', '24px'],
			lg: ['18px', '28px'],
			xl: ['20px', '28px'],
			'2xl': ['24px', '32px'],
			'3xl': ['30px', '36px'],
			'4xl': ['36px', '40px'],
			'5xl': ['48px', '1'],
			'6xl': ['60px', '1'],
			'7xl': ['72px', '1'],
			'8xl': ['96px', '1'],
			'9xl': ['128px', '1']
		},
		extend: {
			colors: {
				primary: '#144046',
				body: '#3E6267',
				link: '#0099AF',
				hover: '#00B7D2',
				highlight: '#051173',
				input: '#BDD2D4',
				teal: '#E4EBEC',
				offwhite: '#F0F6F6',
				grey: '#9FB4B6',
				lightBlue: '#D4E1E2',
				error: '#DF3C3C',
				supporter: '#095D73',
				map: '#333333',
				mapButton: '#5F5F5F',
				mapHighlight: '#1C4347',
				mapLabel: '#A4A4A4',
				searchHover: '#F8F8F8',
				searchSubtext: '#999999',
				mobileMenu: '#085D69',
				mobileButtons: '#D6E4E6',
				mobileButtonsActive: '#C3DCDF',
				statPositive: '#0B9072',
				statNegative: '#EB5757',
				taggerTime: '#7C9CA0',
				created: '#10B791',
				deleted: '#EB5757',
				bitcoin: '#F7931A',
				bitcoinHover: '#F9A136',
				nostr: '#8b5cf6',
				twitter: '#1DA1F2',
				dark: '#06171C'
			},
			keyframes: {
				wiggle: {
					'0%, 100%': { transform: 'rotate(-3deg)' },
					'50%': { transform: 'rotate(3deg)' }
				}
			},
			animation: {
				wiggle: 'wiggle 1s ease-in-out infinite'
			}
		}
	},
	plugins: []
};



================================================
FILE: tsconfig.json
================================================
{
	"extends": "./.svelte-kit/tsconfig.json",
	"compilerOptions": {
		"allowJs": true,
		"checkJs": true,
		"esModuleInterop": true,
		"forceConsistentCasingInFileNames": true,
		"resolveJsonModule": true,
		"skipLibCheck": true,
		"sourceMap": true,
		"strict": true
	}
	// Path aliases are handled by https://kit.svelte.dev/docs/configuration#alias
	//
	// If you want to overwrite includes/excludes, make sure to copy over the relevant includes/excludes
	// from the referenced tsconfig.json - TypeScript does not merge them in
}



================================================
FILE: vite.config.ts
================================================
import { sveltekit } from '@sveltejs/kit/vite';
import { defineConfig } from 'vite';
import tailwindcss from '@tailwindcss/vite';

export default defineConfig({
	plugins: [tailwindcss(), sveltekit()],
	worker: {
		format: 'es'
	},
	server: {
		host: '0.0.0.0',
		port: 5000,
		allowedHosts: true
	}
});



================================================
FILE: vitest.config.ts
================================================
import { defineConfig } from 'vitest/config';
import { svelte } from '@sveltejs/vite-plugin-svelte';
import path from 'path';

export default defineConfig({
	plugins: [svelte({ hot: !process.env.VITEST })],
	test: {
		globals: true,
		environment: 'jsdom',
		exclude: ['**/node_modules/**', '**/tests/**']
	},
	resolve: {
		alias: {
			$lib: path.resolve('./src/lib'),
			$components: path.resolve('./src/components'),
			$app: path.resolve('./node_modules/@sveltejs/kit/src/runtime/app')
		}
	}
});



================================================
FILE: .clauderules
================================================
# Critical Rules - Read First

## Before Every Commit
1. Run `yarn run format:fix` (MANDATORY)
2. Run `yarn run check`
3. Run `yarn run lint`
4. Use conventional commits: `type(scope): description #issue`

## Conventional Commit Types
feat, fix, refactor, docs, test, chore, style, perf

## Code Style
- NO JSDoc comments - use inline // comments only
- TypeScript types are documentation
- Keep code self-documenting with clear names

## Framework Versions (DO NOT UPGRADE)
- Svelte v4 (not v5)
- TailwindCSS v3 (not v4)

## Additional Documentation
For comprehensive guidelines, see:
- `CLAUDE.md` - Full development guidelines and detailed commit format
- `.github/copilot-instructions.md` - Project architecture, patterns, and conventions
- `README.md` - Setup instructions and project overview
- `CONTRIBUTING.md` - Contribution workflow



================================================
FILE: .nvmrc
================================================
lts/*



================================================
FILE: .prettierignore
================================================
.DS_Store
node_modules
/build
/.svelte-kit
/package
.env
.env.*
!.env.example
.cache

# Ignore files for PNPM, NPM and YARN
pnpm-lock.yaml
package-lock.json
yarn.lock

# created spritesheets
spritesheet-*.ts

# icons
static/icons/font-awesome/
src/lib/icons/**/*.svg


================================================
FILE: .prettierrc
================================================
{
	"plugins": ["prettier-plugin-svelte", "prettier-plugin-tailwindcss"],
	"tailwindStylesheet": "./src/app.css",
	"useTabs": true,
	"singleQuote": true,
	"trailingComma": "none",
	"printWidth": 100,
	"overrides": [{ "files": "*.svelte", "options": { "parser": "svelte" } }]
}



================================================
FILE: .replit
================================================
modules = ["web", "nodejs-20"]
run = "npm run dev"

[nix]
channel = "stable-24_05"
packages = ["openssh"]

[deployment]
run = ["sh", "-c", "npm run dev"]
deploymentTarget = "cloudrun"

[[ports]]
localPort = 5173
externalPort = 80

[[ports]]
localPort = 5000
externalPort = 80

[agent]
expertMode = true

[workflows]
runButton = "Project"

[[workflows.workflow]]
name = "Pre-commit Checks"
mode = "parallel"
author = 23073448

[[workflows.workflow.tasks]]
task = "shell.exec"
args = "npm run format:fix"

[[workflows.workflow.tasks]]
task = "shell.exec"
args = "yarn run eslint"

[[workflows.workflow.tasks]]
task = "shell.exec"
args = "yarn run typecheck"

[[workflows.workflow.tasks]]
task = "shell.exec"
args = "yarn run check"

[[workflows.workflow]]
name = "Project"
mode = "parallel"
author = "agent"

[[workflows.workflow.tasks]]
task = "workflow.run"
args = "Dev Server"

[[workflows.workflow]]
name = "Dev Server"
author = "agent"

[[workflows.workflow.tasks]]
task = "shell.exec"
args = "npm run dev"
waitForPort = 5000

[workflows.workflow.metadata]
outputType = "webview"



================================================
FILE: .yarnrc.yml
================================================
nodeLinker: node-modules

yarnPath: .yarn/releases/yarn-4.12.0.cjs



================================================
FILE: src/app.css
================================================
@import 'tailwindcss';
@config '../tailwind.config.js';

@font-face {
	font-family: 'Manrope';
	src: url('/fonts/Manrope-Regular.ttf') format('truetype');
	font-display: swap;
}

@layer base {
	html {
		font-family: Manrope, sans-serif;
		@apply text-base;
	}

	::selection {
		@apply bg-[#53c5d5] text-white;
	}

	button {
		cursor: pointer;
	}

	button:disabled {
		cursor: not-allowed;
	}
}

@layer utilities {
	.gradient {
		background: -webkit-linear-gradient(45deg, #0ecd71, #040273);
		background-clip: text;
		-webkit-background-clip: text;
		-webkit-text-fill-color: transparent;
	}

	.gradient-bg {
		background: -webkit-linear-gradient(45deg, #0ecd71, #040273);
	}

	/* Hide scrollbar for Chrome, Safari and Opera */
	.hide-scroll::-webkit-scrollbar {
		@apply hidden;
	}

	/* Hide scrollbar for IE, Edge and Firefox */
	.hide-scroll {
		-ms-overflow-style: none; /* IE and Edge */
		scrollbar-width: none; /* Firefox */
	}

	.center {
		@apply absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2;
	}

	.center-fixed {
		@apply fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2;
	}

	/* Safe area insets for notched devices (iPhone X+) */
	.pt-safe {
		padding-top: env(safe-area-inset-top);
	}

	.pb-safe {
		padding-bottom: env(safe-area-inset-bottom);
	}
}

@layer components {
	.div-icon {
		background-image: url('/icons/div-icon-pin.svg');
	}

	.boosted-icon {
		background-image: url('/icons/boosted-icon-pin.svg');
	}

	/* Optimized marker styles for performance */
	.marker-normal,
	.marker-boosted {
		@apply relative flex items-center justify-center;
		width: 32px;
		height: 43px;
	}

	.marker-background {
		@apply flex h-8 w-8 items-center justify-center rounded-full;
		background: linear-gradient(135deg, #f97316 0%, #ea580c 100%);
		box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
	}

	.marker-boosted .marker-background {
		background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%);
		box-shadow: 0 2px 12px rgba(251, 191, 36, 0.5);
	}

	.marker-icon {
		@apply text-white;
		font-size: 20px;
		line-height: 1;
		margin-top: 2px;
	}

	.comment-badge {
		@apply absolute -top-1 -right-1 bg-green-600 text-xs font-bold text-white;
		@apply flex h-4 w-4 items-center justify-center rounded-full;
		transform: translate(50%, -50%);
		box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
	}

	/* Animation for boosted markers */
	@keyframes wiggle {
		0%,
		100% {
			transform: rotate(0deg);
		}
		25% {
			transform: rotate(-3deg);
		}
		75% {
			transform: rotate(3deg);
		}
	}

	.animate-wiggle {
		animation: wiggle 2s ease-in-out infinite;
	}

	/* Selected marker highlight */
	.selected-marker {
		filter: drop-shadow(0 0 4px #00b7d2) drop-shadow(0 0 8px #00b7d2) !important;
		animation: pulse-glow 2s ease-in-out infinite;
	}

	.selected-marker-boosted {
		filter: drop-shadow(0 0 4px #f7931a) drop-shadow(0 0 8px #f7931a) !important;
		animation: pulse-glow-boosted 2s ease-in-out infinite;
	}

	@keyframes pulse-glow {
		0%,
		100% {
			filter: drop-shadow(0 0 4px #00b7d2) drop-shadow(0 0 8px #00b7d2);
		}
		50% {
			filter: drop-shadow(0 0 6px #00b7d2) drop-shadow(0 0 12px #00b7d2);
		}
	}

	@keyframes pulse-glow-boosted {
		0%,
		100% {
			filter: drop-shadow(0 0 4px #f7931a) drop-shadow(0 0 8px #f7931a);
		}
		50% {
			filter: drop-shadow(0 0 6px #f7931a) drop-shadow(0 0 12px #f7931a);
		}
	}

	/* Fix for Leaflet controls not visible on mobile Firefox/Brave */
	/* Only apply to fullscreen map to avoid breaking embedded maps */
	.map-fullscreen .leaflet-bottom {
		position: fixed !important;
		bottom: 0 !important;
	}
}

/* Center icons in Leaflet control buttons */
.leaflet-bar a {
	display: flex;
	align-items: center;
	justify-content: center;
}

/* Invert custom button icons in dark mode */
.dark .leaflet-bar a img {
	filter: invert(1);
}

/* Dark mode for Leaflet controls - Tailwind gray palette */
.dark {
	--leaflet-bg: #1f2937; /* gray-800 */
	--leaflet-bg-transparent: rgba(31, 41, 55, 0.8);
	--leaflet-border: #374151; /* gray-700 */
	--leaflet-border-muted: #6b7280; /* gray-500 */
	--leaflet-text: #f3f4f6; /* gray-100 */
	--leaflet-text-muted: #9ca3af; /* gray-400 */
	--leaflet-link: #60a5fa; /* blue-400 */
}

.dark .leaflet-bar,
.dark .leaflet-control-layers {
	background-color: var(--leaflet-bg);
	border-color: var(--leaflet-border);
}

.dark .leaflet-bar a {
	color: var(--leaflet-text);
	background-color: var(--leaflet-bg);
	border-bottom-color: var(--leaflet-border);
}

.dark .leaflet-bar a:hover {
	background-color: var(--leaflet-border);
}

.dark .leaflet-control-layers-toggle {
	background-color: var(--leaflet-bg);
}

.dark .leaflet-control-layers-list {
	background-color: var(--leaflet-bg);
	color: var(--leaflet-text);
}

.dark .leaflet-control-attribution {
	background-color: var(--leaflet-bg-transparent);
	color: var(--leaflet-text-muted);
}

.dark .leaflet-control-attribution a {
	color: var(--leaflet-link);
}

.dark .leaflet-control-scale-line {
	background-color: var(--leaflet-bg-transparent);
	color: var(--leaflet-text);
	border-color: var(--leaflet-border-muted);
}



================================================
FILE: src/app.d.ts
================================================
// See https://kit.svelte.dev/docs/types#app
// for information about these interfaces
declare global {
	namespace App {
		// interface Error {}
		// interface Locals {}
		// interface PageData {}
		// interface Platform {}
	}

	interface Window {
		requestIdleCallback(
			callback: (deadline: IdleDeadline) => void,
			options?: { timeout: number }
		): number;
		cancelIdleCallback(handle: number): void;
	}

	interface IdleDeadline {
		didTimeout: boolean;
		timeRemaining(): number;
	}
}

export {};



================================================
FILE: src/app.html
================================================
<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8" />

		<!-- Preconnect to critical external origins (max 4 recommended) -->
		<link rel="preconnect" href="https://tiles.openfreemap.org" crossorigin />
		<link rel="preconnect" href="https://cdn.static.btcmap.org" crossorigin />
		<link rel="preconnect" href="https://api.btcmap.org" crossorigin />
		<link rel="preconnect" href="https://static.btcmap.org" crossorigin />

		<!-- Preload critical map marker assets -->
		<link rel="preload" href="/icons/div-icon-pin.svg" as="image" type="image/svg+xml" />
		<link rel="preload" href="/icons/boosted-icon-pin.svg" as="image" type="image/svg+xml" />

		<script>
			// theme
			if (
				localStorage.theme === 'dark' ||
				(!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)
			) {
				document.documentElement.classList.add('dark');
			} else {
				document.documentElement.classList.remove('dark');
			}

			// service worker
			navigator.serviceWorker?.ready.then((registration) => {
				const appInstalled = window.matchMedia('(display-mode: standalone)').matches;

				if (appInstalled) {
					registration.active.postMessage('CACHE_ASSETS');
				}
			});
		</script>
		<meta name="theme-color" content="#0B9072" />
		<meta name="keywords" content="bitcoin, open source, map" />
		<meta name="author" content="BTC Map" />
		<meta property="og:type" content="website" />
		<meta name="description" content="Easily find places to spend sats anywhere on the planet." />
		<meta
			property="twitter:description"
			content="Easily find places to spend sats anywhere on the planet."
		/>
		<meta property="twitter:site" content="@btcmap" />
		<meta property="twitter:card" content="summary_large_image" />
		<meta name="msapplication-TileColor" content="#0B9072" />
		<meta name="viewport" content="width=device-width" />
		<link rel="manifest" href="/btcmap.webmanifest" />
		<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png" />
		<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png" />
		<link rel="icon" href="%sveltekit.assets%/favicon.svg" />
		%sveltekit.head%
	</head>
	<body class="bg-teal dark:bg-dark">
		<div>%sveltekit.body%</div>
	</body>
</html>



================================================
FILE: src/error.html
================================================
<!doctype html>
<html lang="en">
	<head>
		<script>
			if (
				localStorage.theme === 'dark' ||
				(!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)
			) {
				document.documentElement.classList.add('dark');
			} else {
				document.documentElement.classList.remove('dark');
			}
		</script>
		<meta name="theme-color" content="#0B9072" />
		<meta name="keywords" content="bitcoin, open source, map" />
		<meta name="author" content="BTC Map" />
		<meta property="og:type" content="website" />
		<meta name="description" content="Easily find places to spend sats anywhere on the planet." />
		<meta
			property="twitter:description"
			content="Easily find places to spend sats anywhere on the planet."
		/>
		<meta property="twitter:site" content="@btcmap" />
		<meta property="twitter:card" content="summary_large_image" />
		<meta charset="utf-8" />
		<meta name="msapplication-TileColor" content="#0B9072" />
		<meta name="viewport" content="width=device-width" />
		<link rel="manifest" href="/btcmap.webmanifest" />
		<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png" />
		<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png" />
		<link rel="icon" href="./favicon.svg" />

		<style data-sveltekit>
			:root {
				--toastContainerTop: auto;
				--toastContainerRight: auto;
				--toastContainerBottom: 8rem;
				--toastContainerLeft: calc(50vw - 8rem);
			}
			.s-7IPF32Wcq3s8 {
			}
			/*
! tailwindcss v3.2.7 | MIT License | https://tailwindcss.com
*/ /*
1. Prevent padding and border from affecting element width. (https://github.com/mozdevs/cssremedy/issues/4)
2. Allow adding a border to an element by just adding a border-width. (https://github.com/tailwindcss/tailwindcss/pull/116)
*/

			*,
			::before,
			::after {
				box-sizing: border-box; /* 1 */
				border-width: 0; /* 2 */
				border-style: solid; /* 2 */
				border-color: #e5e7eb; /* 2 */
			}

			::before,
			::after {
				--tw-content: '';
			}

			/*
1. Use a consistent sensible line-height in all browsers.
2. Prevent adjustments of font size after orientation changes in iOS.
3. Use a more readable tab size.
4. Use the user's configured `sans` font-family by default.
5. Use the user's configured `sans` font-feature-settings by default.
*/

			html {
				line-height: 1.5; /* 1 */
				-webkit-text-size-adjust: 100%; /* 2 */
				-moz-tab-size: 4; /* 3 */
				-o-tab-size: 4;
				tab-size: 4; /* 3 */
				font-family:
					ui-sans-serif,
					system-ui,
					-apple-system,
					BlinkMacSystemFont,
					'Segoe UI',
					Roboto,
					'Helvetica Neue',
					Arial,
					'Noto Sans',
					sans-serif,
					'Apple Color Emoji',
					'Segoe UI Emoji',
					'Segoe UI Symbol',
					'Noto Color Emoji'; /* 4 */
				font-feature-settings: normal; /* 5 */
			}

			/*
1. Remove the margin in all browsers.
2. Inherit line-height from `html` so users can set them as a class directly on the `html` element.
*/

			body {
				margin: 0; /* 1 */
				line-height: inherit; /* 2 */
			}

			/*
1. Add the correct height in Firefox.
2. Correct the inheritance of border color in Firefox. (https://bugzilla.mozilla.org/show_bug.cgi?id=190655)
3. Ensure horizontal rules are visible by default.
*/

			hr {
				height: 0; /* 1 */
				color: inherit; /* 2 */
				border-top-width: 1px; /* 3 */
			}

			/*
Add the correct text decoration in Chrome, Edge, and Safari.
*/

			abbr:where([title]) {
				-webkit-text-decoration: underline dotted;
				text-decoration: underline dotted;
			}

			/*
Remove the default font size and weight for headings.
*/

			h1,
			h2,
			h3,
			h4,
			h5,
			h6 {
				font-size: inherit;
				font-weight: inherit;
			}

			/*
Reset links to optimize for opt-in styling instead of opt-out.
*/

			a {
				color: inherit;
				text-decoration: inherit;
			}

			/*
Add the correct font weight in Edge and Safari.
*/

			b,
			strong {
				font-weight: bolder;
			}

			/*
1. Use the user's configured `mono` font family by default.
2. Correct the odd `em` font sizing in all browsers.
*/

			code,
			kbd,
			samp,
			pre {
				font-family:
					ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New',
					monospace; /* 1 */
				font-size: 1em; /* 2 */
			}

			/*
Add the correct font size in all browsers.
*/

			small {
				font-size: 80%;
			}

			/*
Prevent `sub` and `sup` elements from affecting the line height in all browsers.
*/

			sub,
			sup {
				font-size: 75%;
				line-height: 0;
				position: relative;
				vertical-align: baseline;
			}

			sub {
				bottom: -0.25em;
			}

			sup {
				top: -0.5em;
			}

			/*
1. Remove text indentation from table contents in Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=999088, https://bugs.webkit.org/show_bug.cgi?id=201297)
2. Correct table border color inheritance in all Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=935729, https://bugs.webkit.org/show_bug.cgi?id=195016)
3. Remove gaps between table borders by default.
*/

			table {
				text-indent: 0; /* 1 */
				border-color: inherit; /* 2 */
				border-collapse: collapse; /* 3 */
			}

			/*
1. Change the font styles in all browsers.
2. Remove the margin in Firefox and Safari.
3. Remove default padding in all browsers.
*/

			button,
			input,
			optgroup,
			select,
			textarea {
				font-family: inherit; /* 1 */
				font-size: 100%; /* 1 */
				font-weight: inherit; /* 1 */
				line-height: inherit; /* 1 */
				color: inherit; /* 1 */
				margin: 0; /* 2 */
				padding: 0; /* 3 */
			}

			/*
Remove the inheritance of text transform in Edge and Firefox.
*/

			button,
			select {
				text-transform: none;
			}

			/*
1. Correct the inability to style clickable types in iOS and Safari.
2. Remove default button styles.
*/

			button,
			[type='button'],
			[type='reset'],
			[type='submit'] {
				-webkit-appearance: button; /* 1 */
				background-color: transparent; /* 2 */
				background-image: none; /* 2 */
			}

			/*
Use the modern Firefox focus style for all focusable elements.
*/

			:-moz-focusring {
				outline: auto;
			}

			/*
Remove the additional `:invalid` styles in Firefox. (https://github.com/mozilla/gecko-dev/blob/2f9eacd9d3d995c937b4251a5557d95d494c9be1/layout/style/res/forms.css#L728-L737)
*/

			:-moz-ui-invalid {
				box-shadow: none;
			}

			/*
Add the correct vertical alignment in Chrome and Firefox.
*/

			progress {
				vertical-align: baseline;
			}

			/*
Correct the cursor style of increment and decrement buttons in Safari.
*/

			::-webkit-inner-spin-button,
			::-webkit-outer-spin-button {
				height: auto;
			}

			/*
1. Correct the odd appearance in Chrome and Safari.
2. Correct the outline style in Safari.
*/

			[type='search'] {
				-webkit-appearance: textfield; /* 1 */
				outline-offset: -2px; /* 2 */
			}

			/*
Remove the inner padding in Chrome and Safari on macOS.
*/

			::-webkit-search-decoration {
				-webkit-appearance: none;
			}

			/*
1. Correct the inability to style clickable types in iOS and Safari.
2. Change font properties to `inherit` in Safari.
*/

			::-webkit-file-upload-button {
				-webkit-appearance: button; /* 1 */
				font: inherit; /* 2 */
			}

			/*
Add the correct display in Chrome and Safari.
*/

			summary {
				display: list-item;
			}

			/*
Removes the default spacing and border for appropriate elements.
*/

			blockquote,
			dl,
			dd,
			h1,
			h2,
			h3,
			h4,
			h5,
			h6,
			hr,
			figure,
			p,
			pre {
				margin: 0;
			}

			fieldset {
				margin: 0;
				padding: 0;
			}

			legend {
				padding: 0;
			}

			ol,
			ul,
			menu {
				list-style: none;
				margin: 0;
				padding: 0;
			}

			/*
Prevent resizing textareas horizontally by default.
*/

			textarea {
				resize: vertical;
			}

			/*
1. Reset the default placeholder opacity in Firefox. (https://github.com/tailwindlabs/tailwindcss/issues/3300)
2. Set the default placeholder color to the user's configured gray 400 color.
*/

			input::-moz-placeholder,
			textarea::-moz-placeholder {
				opacity: 1; /* 1 */
				color: #9ca3af; /* 2 */
			}

			input::placeholder,
			textarea::placeholder {
				opacity: 1; /* 1 */
				color: #9ca3af; /* 2 */
			}

			/*
Set the default cursor for buttons.
*/

			button,
			[role='button'] {
				cursor: pointer;
			}

			/*
Make sure disabled buttons don't get the pointer cursor.
*/
			:disabled {
				cursor: default;
			}

			/*
1. Make replaced elements `display: block` by default. (https://github.com/mozdevs/cssremedy/issues/14)
2. Add `vertical-align: middle` to align replaced elements more sensibly by default. (https://github.com/jensimmons/cssremedy/issues/14#issuecomment-634934210)
   This can trigger a poorly considered lint error in some tools but is included by design.
*/

			img,
			svg,
			video,
			canvas,
			audio,
			iframe,
			embed,
			object {
				display: block; /* 1 */
				vertical-align: middle; /* 2 */
			}

			/*
Constrain images and videos to the parent width and preserve their intrinsic aspect ratio. (https://github.com/mozdevs/cssremedy/issues/14)
*/

			img,
			video {
				max-width: 100%;
				height: auto;
			}

			/* Make elements with the HTML hidden attribute stay hidden by default */
			[hidden] {
				display: none;
			}

			*,
			::before,
			::after {
				--tw-border-spacing-x: 0;
				--tw-border-spacing-y: 0;
				--tw-translate-x: 0;
				--tw-translate-y: 0;
				--tw-rotate: 0;
				--tw-skew-x: 0;
				--tw-skew-y: 0;
				--tw-scale-x: 1;
				--tw-scale-y: 1;
				--tw-pan-x: ;
				--tw-pan-y: ;
				--tw-pinch-zoom: ;
				--tw-scroll-snap-strictness: proximity;
				--tw-ordinal: ;
				--tw-slashed-zero: ;
				--tw-numeric-figure: ;
				--tw-numeric-spacing: ;
				--tw-numeric-fraction: ;
				--tw-ring-inset: ;
				--tw-ring-offset-width: 0px;
				--tw-ring-offset-color: #fff;
				--tw-ring-color: rgb(59 130 246 / 0.5);
				--tw-ring-offset-shadow: 0 0 #0000;
				--tw-ring-shadow: 0 0 #0000;
				--tw-shadow: 0 0 #0000;
				--tw-shadow-colored: 0 0 #0000;
				--tw-blur: ;
				--tw-brightness: ;
				--tw-contrast: ;
				--tw-grayscale: ;
				--tw-hue-rotate: ;
				--tw-invert: ;
				--tw-saturate: ;
				--tw-sepia: ;
				--tw-drop-shadow: ;
				--tw-backdrop-blur: ;
				--tw-backdrop-brightness: ;
				--tw-backdrop-contrast: ;
				--tw-backdrop-grayscale: ;
				--tw-backdrop-hue-rotate: ;
				--tw-backdrop-invert: ;
				--tw-backdrop-opacity: ;
				--tw-backdrop-saturate: ;
				--tw-backdrop-sepia: ;
			}

			::backdrop {
				--tw-border-spacing-x: 0;
				--tw-border-spacing-y: 0;
				--tw-translate-x: 0;
				--tw-translate-y: 0;
				--tw-rotate: 0;
				--tw-skew-x: 0;
				--tw-skew-y: 0;
				--tw-scale-x: 1;
				--tw-scale-y: 1;
				--tw-pan-x: ;
				--tw-pan-y: ;
				--tw-pinch-zoom: ;
				--tw-scroll-snap-strictness: proximity;
				--tw-ordinal: ;
				--tw-slashed-zero: ;
				--tw-numeric-figure: ;
				--tw-numeric-spacing: ;
				--tw-numeric-fraction: ;
				--tw-ring-inset: ;
				--tw-ring-offset-width: 0px;
				--tw-ring-offset-color: #fff;
				--tw-ring-color: rgb(59 130 246 / 0.5);
				--tw-ring-offset-shadow: 0 0 #0000;
				--tw-ring-shadow: 0 0 #0000;
				--tw-shadow: 0 0 #0000;
				--tw-shadow-colored: 0 0 #0000;
				--tw-blur: ;
				--tw-brightness: ;
				--tw-contrast: ;
				--tw-grayscale: ;
				--tw-hue-rotate: ;
				--tw-invert: ;
				--tw-saturate: ;
				--tw-sepia: ;
				--tw-drop-shadow: ;
				--tw-backdrop-blur: ;
				--tw-backdrop-brightness: ;
				--tw-backdrop-contrast: ;
				--tw-backdrop-grayscale: ;
				--tw-backdrop-hue-rotate: ;
				--tw-backdrop-invert: ;
				--tw-backdrop-opacity: ;
				--tw-backdrop-saturate: ;
				--tw-backdrop-sepia: ;
			}
			.visible {
				visibility: visible;
			}
			.collapse {
				visibility: collapse;
			}
			.fixed {
				position: fixed;
			}
			.absolute {
				position: absolute;
			}
			.relative {
				position: relative;
			}
			.sticky {
				position: sticky;
			}
			.-right-2 {
				right: -0.5rem;
			}
			.-top-16 {
				top: -4rem;
			}
			.bottom-4 {
				bottom: 1rem;
			}
			.left-0 {
				left: 0px;
			}
			.left-\[-100\%\] {
				left: -100%;
			}
			.left-\[15px\] {
				left: 15px;
			}
			.left-\[26px\] {
				left: 26px;
			}
			.left-\[60px\] {
				left: 60px;
			}
			.left-\[calc\(50\%-8px\)\] {
				left: calc(50% - 8px);
			}
			.right-0 {
				right: 0px;
			}
			.right-1 {
				right: 0.25rem;
			}
			.right-6 {
				right: 1.5rem;
			}
			.right-\[8px\] {
				right: 8px;
			}
			.top-0 {
				top: 0px;
			}
			.top-1 {
				top: 0.25rem;
			}
			.top-3 {
				top: 0.75rem;
			}
			.top-3\.5 {
				top: 0.875rem;
			}
			.top-4 {
				top: 1rem;
			}
			.top-5 {
				top: 1.25rem;
			}
			.top-8 {
				top: 2rem;
			}
			.top-\[10px\] {
				top: 10px;
			}
			.top-\[122\.45px\] {
				top: 122.45px;
			}
			.top-\[55px\] {
				top: 55px;
			}
			.z-10 {
				z-index: 10;
			}
			.z-20 {
				z-index: 20;
			}
			.z-30 {
				z-index: 30;
			}
			.z-\[10000\] {
				z-index: 10000;
			}
			.z-\[2000\] {
				z-index: 2000;
			}
			.z-\[500\] {
				z-index: 500;
			}
			.m-1 {
				margin: 0.25rem;
			}
			.m-2 {
				margin: 0.5rem;
			}
			.m-4 {
				margin: 1rem;
			}
			.\!my-12 {
				margin-top: 3rem !important;
				margin-bottom: 3rem !important;
			}
			.\!my-5 {
				margin-top: 1.25rem !important;
				margin-bottom: 1.25rem !important;
			}
			.\!my-auto {
				margin-top: auto !important;
				margin-bottom: auto !important;
			}
			.mx-0 {
				margin-left: 0px;
				margin-right: 0px;
			}
			.mx-2 {
				margin-left: 0.5rem;
				margin-right: 0.5rem;
			}
			.mx-2\.5 {
				margin-left: 0.625rem;
				margin-right: 0.625rem;
			}
			.mx-3 {
				margin-left: 0.75rem;
				margin-right: 0.75rem;
			}
			.mx-5 {
				margin-left: 1.25rem;
				margin-right: 1.25rem;
			}
			.mx-auto {
				margin-left: auto;
				margin-right: auto;
			}
			.my-0 {
				margin-top: 0px;
				margin-bottom: 0px;
			}
			.my-1 {
				margin-top: 0.25rem;
				margin-bottom: 0.25rem;
			}
			.my-10 {
				margin-top: 2.5rem;
				margin-bottom: 2.5rem;
			}
			.my-16 {
				margin-top: 4rem;
				margin-bottom: 4rem;
			}
			.my-2 {
				margin-top: 0.5rem;
				margin-bottom: 0.5rem;
			}
			.my-20 {
				margin-top: 5rem;
				margin-bottom: 5rem;
			}
			.my-4 {
				margin-top: 1rem;
				margin-bottom: 1rem;
			}
			.my-5 {
				margin-top: 1.25rem;
				margin-bottom: 1.25rem;
			}
			.my-auto {
				margin-top: auto;
				margin-bottom: auto;
			}
			.\!mb-5 {
				margin-bottom: 1.25rem !important;
			}
			.mb-0 {
				margin-bottom: 0px;
			}
			.mb-1 {
				margin-bottom: 0.25rem;
			}
			.mb-10 {
				margin-bottom: 2.5rem;
			}
			.mb-16 {
				margin-bottom: 4rem;
			}
			.mb-2 {
				margin-bottom: 0.5rem;
			}
			.mb-2\.5 {
				margin-bottom: 0.625rem;
			}
			.mb-20 {
				margin-bottom: 5rem;
			}
			.mb-3 {
				margin-bottom: 0.75rem;
			}
			.mb-4 {
				margin-bottom: 1rem;
			}
			.mb-5 {
				margin-bottom: 1.25rem;
			}
			.mb-6 {
				margin-bottom: 1.5rem;
			}
			.mb-8 {
				margin-bottom: 2rem;
			}
			.ml-1 {
				margin-left: 0.25rem;
			}
			.ml-2 {
				margin-left: 0.5rem;
			}
			.ml-3 {
				margin-left: 0.75rem;
			}
			.ml-5 {
				margin-left: 1.25rem;
			}
			.ml-7 {
				margin-left: 1.75rem;
			}
			.mr-0 {
				margin-right: 0px;
			}
			.mr-1 {
				margin-right: 0.25rem;
			}
			.mr-2 {
				margin-right: 0.5rem;
			}
			.mr-4 {
				margin-right: 1rem;
			}
			.mr-5 {
				margin-right: 1.25rem;
			}
			.mt-0 {
				margin-top: 0px;
			}
			.mt-0\.5 {
				margin-top: 0.125rem;
			}
			.mt-1 {
				margin-top: 0.25rem;
			}
			.mt-10 {
				margin-top: 2.5rem;
			}
			.mt-16 {
				margin-top: 4rem;
			}
			.mt-2 {
				margin-top: 0.5rem;
			}
			.mt-2\.5 {
				margin-top: 0.625rem;
			}
			.mt-3 {
				margin-top: 0.75rem;
			}
			.mt-4 {
				margin-top: 1rem;
			}
			.mt-5 {
				margin-top: 1.25rem;
			}
			.mt-8 {
				margin-top: 2rem;
			}
			.mt-\[5\.75px\] {
				margin-top: 5.75px;
			}
			.block {
				display: block;
			}
			.inline-block {
				display: inline-block;
			}
			.inline {
				display: inline;
			}
			.flex {
				display: flex;
			}
			.inline-flex {
				display: inline-flex;
			}
			.table {
				display: table;
			}
			.grid {
				display: grid;
			}
			.contents {
				display: contents;
			}
			.hidden {
				display: none;
			}
			.h-10 {
				height: 2.5rem;
			}
			.h-12 {
				height: 3rem;
			}
			.h-14 {
				height: 3.5rem;
			}
			.h-16 {
				height: 4rem;
			}
			.h-20 {
				height: 5rem;
			}
			.h-24 {
				height: 6rem;
			}
			.h-28 {
				height: 7rem;
			}
			.h-3 {
				height: 0.75rem;
			}
			.h-32 {
				height: 8rem;
			}
			.h-4 {
				height: 1rem;
			}
			.h-5 {
				height: 1.25rem;
			}
			.h-6 {
				height: 1.5rem;
			}
			.h-60 {
				height: 15rem;
			}
			.h-7 {
				height: 1.75rem;
			}
			.h-8 {
				height: 2rem;
			}
			.h-\[100px\] {
				height: 100px;
			}
			.h-\[100vh\] {
				height: 100vh;
			}
			.h-\[200px\] {
				height: 200px;
			}
			.h-\[220px\] {
				height: 220px;
			}
			.h-\[225px\] {
				height: 225px;
			}
			.h-\[256px\] {
				height: 256px;
			}
			.h-\[28px\] {
				height: 28px;
			}
			.h-\[300px\] {
				height: 300px;
			}
			.h-\[30px\] {
				height: 30px;
			}
			.h-\[324px\] {
				height: 324px;
			}
			.h-\[32px\] {
				height: 32px;
			}
			.h-\[375px\] {
				height: 375px;
			}
			.h-\[38px\] {
				height: 38px;
			}
			.h-\[400px\] {
				height: 400px;
			}
			.h-\[40px\] {
				height: 40px;
			}
			.h-\[450px\] {
				height: 450px;
			}
			.h-\[48px\] {
				height: 48px;
			}
			.h-\[60px\] {
				height: 60px;
			}
			.h-\[648px\] {
				height: 648px;
			}
			.h-\[90px\] {
				height: 90px;
			}
			.h-\[99px\] {
				height: 99px;
			}
			.h-full {
				height: 100%;
			}
			.max-h-\[204px\] {
				max-height: 204px;
			}
			.max-h-\[300px\] {
				max-height: 300px;
			}
			.max-h-\[375px\] {
				max-height: 375px;
			}
			.max-h-\[90vh\] {
				max-height: 90vh;
			}
			.w-1 {
				width: 0.25rem;
			}
			.w-10 {
				width: 2.5rem;
			}
			.w-10\/12 {
				width: 83.333333%;
			}
			.w-14 {
				width: 3.5rem;
			}
			.w-16 {
				width: 4rem;
			}
			.w-2 {
				width: 0.5rem;
			}
			.w-20 {
				width: 5rem;
			}
			.w-24 {
				width: 6rem;
			}
			.w-28 {
				width: 7rem;
			}
			.w-3 {
				width: 0.75rem;
			}
			.w-32 {
				width: 8rem;
			}
			.w-36 {
				width: 9rem;
			}
			.w-4 {
				width: 1rem;
			}
			.w-40 {
				width: 10rem;
			}
			.w-44 {
				width: 11rem;
			}
			.w-5 {
				width: 1.25rem;
			}
			.w-52 {
				width: 13rem;
			}
			.w-6 {
				width: 1.5rem;
			}
			.w-60 {
				width: 15rem;
			}
			.w-7 {
				width: 1.75rem;
			}
			.w-8 {
				width: 2rem;
			}
			.w-80 {
				width: 20rem;
			}
			.w-96 {
				width: 24rem;
			}
			.w-\[100px\] {
				width: 100px;
			}
			.w-\[147px\] {
				width: 147px;
			}
			.w-\[150px\] {
				width: 150px;
			}
			.w-\[185px\] {
				width: 185px;
			}
			.w-\[200px\] {
				width: 200px;
			}
			.w-\[207px\] {
				width: 207px;
			}
			.w-\[220px\] {
				width: 220px;
			}
			.w-\[225px\] {
				width: 225px;
			}
			.w-\[250px\] {
				width: 250px;
			}
			.w-\[256px\] {
				width: 256px;
			}
			.w-\[275px\] {
				width: 275px;
			}
			.w-\[40px\] {
				width: 40px;
			}
			.w-\[50vw\] {
				width: 50vw;
			}
			.w-\[52px\] {
				width: 52px;
			}
			.w-\[80px\] {
				width: 80px;
			}
			.w-\[90vw\] {
				width: 90vw;
			}
			.w-\[94px\] {
				width: 94px;
			}
			.w-auto {
				width: auto;
			}
			.w-fit {
				width: -moz-fit-content;
				width: fit-content;
			}
			.w-full {
				width: 100%;
			}
			.max-w-\[300px\] {
				max-width: 300px;
			}
			.flex-grow {
				flex-grow: 1;
			}
			.grow {
				flex-grow: 1;
			}
			.border-collapse {
				border-collapse: collapse;
			}
			.transform {
				transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate))
					skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x))
					scaleY(var(--tw-scale-y));
			}
			@keyframes bounce {
				0%,
				100% {
					transform: translateY(-25%);
					animation-timing-function: cubic-bezier(0.8, 0, 1, 1);
				}

				50% {
					transform: none;
					animation-timing-function: cubic-bezier(0, 0, 0.2, 1);
				}
			}
			.animate-bounce {
				animation: bounce 1s infinite;
			}
			@keyframes ping {
				75%,
				100% {
					transform: scale(2);
					opacity: 0;
				}
			}
			.animate-ping {
				animation: ping 1s cubic-bezier(0, 0, 0.2, 1) infinite;
			}
			@keyframes pulse {
				50% {
					opacity: 0.5;
				}
			}
			.animate-pulse {
				animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
			}
			@keyframes spin {
				to {
					transform: rotate(360deg);
				}
			}
			.animate-spin {
				animation: spin 1s linear infinite;
			}
			@keyframes wiggle {
				0%,
				100% {
					transform: rotate(-3deg);
				}

				50% {
					transform: rotate(3deg);
				}
			}
			.animate-wiggle {
				animation: wiggle 1s ease-in-out infinite;
			}
			.\!cursor-crosshair {
				cursor: crosshair !important;
			}
			.cursor-pointer {
				cursor: pointer;
			}
			.resize {
				resize: both;
			}
			.list-decimal {
				list-style-type: decimal;
			}
			.list-disc {
				list-style-type: disc;
			}
			.grid-cols-2 {
				grid-template-columns: repeat(2, minmax(0, 1fr));
			}
			.grid-cols-3 {
				grid-template-columns: repeat(3, minmax(0, 1fr));
			}
			.grid-cols-4 {
				grid-template-columns: repeat(4, minmax(0, 1fr));
			}
			.grid-cols-6 {
				grid-template-columns: repeat(6, minmax(0, 1fr));
			}
			.flex-col {
				flex-direction: column;
			}
			.flex-wrap {
				flex-wrap: wrap;
			}
			.items-start {
				align-items: flex-start;
			}
			.items-end {
				align-items: flex-end;
			}
			.items-center {
				align-items: center;
			}
			.justify-start {
				justify-content: flex-start;
			}
			.justify-end {
				justify-content: flex-end;
			}
			.justify-center {
				justify-content: center;
			}
			.justify-between {
				justify-content: space-between;
			}
			.gap-10 {
				gap: 2.5rem;
			}
			.gap-5 {
				gap: 1.25rem;
			}
			.space-x-0 > :not([hidden]) ~ :not([hidden]) {
				--tw-space-x-reverse: 0;
				margin-right: calc(0px * var(--tw-space-x-reverse));
				margin-left: calc(0px * calc(1 - var(--tw-space-x-reverse)));
			}
			.space-x-1 > :not([hidden]) ~ :not([hidden]) {
				--tw-space-x-reverse: 0;
				margin-right: calc(0.25rem * var(--tw-space-x-reverse));
				margin-left: calc(0.25rem * calc(1 - var(--tw-space-x-reverse)));
			}
			.space-x-10 > :not([hidden]) ~ :not([hidden]) {
				--tw-space-x-reverse: 0;
				margin-right: calc(2.5rem * var(--tw-space-x-reverse));
				margin-left: calc(2.5rem * calc(1 - var(--tw-space-x-reverse)));
			}
			.space-x-16 > :not([hidden]) ~ :not([hidden]) {
				--tw-space-x-reverse: 0;
				margin-right: calc(4rem * var(--tw-space-x-reverse));
				margin-left: calc(4rem * calc(1 - var(--tw-space-x-reverse)));
			}
			.space-x-2 > :not([hidden]) ~ :not([hidden]) {
				--tw-space-x-reverse: 0;
				margin-right: calc(0.5rem * var(--tw-space-x-reverse));
				margin-left: calc(0.5rem * calc(1 - var(--tw-space-x-reverse)));
			}
			.space-x-4 > :not([hidden]) ~ :not([hidden]) {
				--tw-space-x-reverse: 0;
				margin-right: calc(1rem * var(--tw-space-x-reverse));
				margin-left: calc(1rem * calc(1 - var(--tw-space-x-reverse)));
			}
			.space-x-5 > :not([hidden]) ~ :not([hidden]) {
				--tw-space-x-reverse: 0;
				margin-right: calc(1.25rem * var(--tw-space-x-reverse));
				margin-left: calc(1.25rem * calc(1 - var(--tw-space-x-reverse)));
			}
			.space-x-7 > :not([hidden]) ~ :not([hidden]) {
				--tw-space-x-reverse: 0;
				margin-right: calc(1.75rem * var(--tw-space-x-reverse));
				margin-left: calc(1.75rem * calc(1 - var(--tw-space-x-reverse)));
			}
			.space-x-8 > :not([hidden]) ~ :not([hidden]) {
				--tw-space-x-reverse: 0;
				margin-right: calc(2rem * var(--tw-space-x-reverse));
				margin-left: calc(2rem * calc(1 - var(--tw-space-x-reverse)));
			}
			.space-y-0 > :not([hidden]) ~ :not([hidden]) {
				--tw-space-y-reverse: 0;
				margin-top: calc(0px * calc(1 - var(--tw-space-y-reverse)));
				margin-bottom: calc(0px * var(--tw-space-y-reverse));
			}
			.space-y-0\.5 > :not([hidden]) ~ :not([hidden]) {
				--tw-space-y-reverse: 0;
				margin-top: calc(0.125rem * calc(1 - var(--tw-space-y-reverse)));
				margin-bottom: calc(0.125rem * var(--tw-space-y-reverse));
			}
			.space-y-1 > :not([hidden]) ~ :not([hidden]) {
				--tw-space-y-reverse: 0;
				margin-top: calc(0.25rem * calc(1 - var(--tw-space-y-reverse)));
				margin-bottom: calc(0.25rem * var(--tw-space-y-reverse));
			}
			.space-y-10 > :not([hidden]) ~ :not([hidden]) {
				--tw-space-y-reverse: 0;
				margin-top: calc(2.5rem * calc(1 - var(--tw-space-y-reverse)));
				margin-bottom: calc(2.5rem * var(--tw-space-y-reverse));
			}
			.space-y-16 > :not([hidden]) ~ :not([hidden]) {
				--tw-space-y-reverse: 0;
				margin-top: calc(4rem * calc(1 - var(--tw-space-y-reverse)));
				margin-bottom: calc(4rem * var(--tw-space-y-reverse));
			}
			.space-y-2 > :not([hidden]) ~ :not([hidden]) {
				--tw-space-y-reverse: 0;
				margin-top: calc(0.5rem * calc(1 - var(--tw-space-y-reverse)));
				margin-bottom: calc(0.5rem * var(--tw-space-y-reverse));
			}
			.space-y-20 > :not([hidden]) ~ :not([hidden]) {
				--tw-space-y-reverse: 0;
				margin-top: calc(5rem * calc(1 - var(--tw-space-y-reverse)));
				margin-bottom: calc(5rem * var(--tw-space-y-reverse));
			}
			.space-y-3 > :not([hidden]) ~ :not([hidden]) {
				--tw-space-y-reverse: 0;
				margin-top: calc(0.75rem * calc(1 - var(--tw-space-y-reverse)));
				margin-bottom: calc(0.75rem * var(--tw-space-y-reverse));
			}
			.space-y-4 > :not([hidden]) ~ :not([hidden]) {
				--tw-space-y-reverse: 0;
				margin-top: calc(1rem * calc(1 - var(--tw-space-y-reverse)));
				margin-bottom: calc(1rem * var(--tw-space-y-reverse));
			}
			.space-y-40 > :not([hidden]) ~ :not([hidden]) {
				--tw-space-y-reverse: 0;
				margin-top: calc(10rem * calc(1 - var(--tw-space-y-reverse)));
				margin-bottom: calc(10rem * var(--tw-space-y-reverse));
			}
			.space-y-5 > :not([hidden]) ~ :not([hidden]) {
				--tw-space-y-reverse: 0;
				margin-top: calc(1.25rem * calc(1 - var(--tw-space-y-reverse)));
				margin-bottom: calc(1.25rem * var(--tw-space-y-reverse));
			}
			.space-y-6 > :not([hidden]) ~ :not([hidden]) {
				--tw-space-y-reverse: 0;
				margin-top: calc(1.5rem * calc(1 - var(--tw-space-y-reverse)));
				margin-bottom: calc(1.5rem * var(--tw-space-y-reverse));
			}
			.space-y-8 > :not([hidden]) ~ :not([hidden]) {
				--tw-space-y-reverse: 0;
				margin-top: calc(2rem * calc(1 - var(--tw-space-y-reverse)));
				margin-bottom: calc(2rem * var(--tw-space-y-reverse));
			}
			.self-center {
				align-self: center;
			}
			.overflow-auto {
				overflow: auto;
			}
			.overflow-scroll {
				overflow: scroll;
			}
			.overflow-y-scroll {
				overflow-y: scroll;
			}
			.whitespace-nowrap {
				white-space: nowrap;
			}
			.break-all {
				word-break: break-all;
			}
			.rounded {
				border-radius: 0.25rem;
			}
			.rounded-2xl {
				border-radius: 1rem;
			}
			.rounded-3xl {
				border-radius: 1.5rem;
			}
			.rounded-full {
				border-radius: 9999px;
			}
			.rounded-lg {
				border-radius: 0.5rem;
			}
			.rounded-sm {
				border-radius: 0.125rem;
			}
			.rounded-xl {
				border-radius: 0.75rem;
			}
			.rounded-b {
				border-bottom-right-radius: 0.25rem;
				border-bottom-left-radius: 0.25rem;
			}
			.rounded-b-2xl {
				border-bottom-right-radius: 1rem;
				border-bottom-left-radius: 1rem;
			}
			.rounded-b-3xl {
				border-bottom-right-radius: 1.5rem;
				border-bottom-left-radius: 1.5rem;
			}
			.rounded-l {
				border-top-left-radius: 0.25rem;
				border-bottom-left-radius: 0.25rem;
			}
			.rounded-r {
				border-top-right-radius: 0.25rem;
				border-bottom-right-radius: 0.25rem;
			}
			.rounded-t {
				border-top-left-radius: 0.25rem;
				border-top-right-radius: 0.25rem;
			}
			.rounded-t-2xl {
				border-top-left-radius: 1rem;
				border-top-right-radius: 1rem;
			}
			.rounded-t-3xl {
				border-top-left-radius: 1.5rem;
				border-top-right-radius: 1.5rem;
			}
			.rounded-bl-none {
				border-bottom-left-radius: 0px;
			}
			.rounded-tr-none {
				border-top-right-radius: 0px;
			}
			.border {
				border-width: 1px;
			}
			.border-2 {
				border-width: 2px;
			}
			.border-4 {
				border-width: 4px;
			}
			.border-b {
				border-bottom-width: 1px;
			}
			.border-b-0 {
				border-bottom-width: 0px;
			}
			.border-r {
				border-right-width: 1px;
			}
			.border-t {
				border-top-width: 1px;
			}
			.border-t-0 {
				border-top-width: 0px;
			}
			.border-t-\[0\.5px\] {
				border-top-width: 0.5px;
			}
			.border-none {
				border-style: none;
			}
			.border-\[\#BDD2D4\] {
				--tw-border-opacity: 1;
				border-color: rgb(189 210 212 / var(--tw-border-opacity));
			}
			.border-input {
				--tw-border-opacity: 1;
				border-color: rgb(189 210 212 / var(--tw-border-opacity));
			}
			.border-link {
				--tw-border-opacity: 1;
				border-color: rgb(0 153 175 / var(--tw-border-opacity));
			}
			.border-link\/50 {
				border-color: rgb(0 153 175 / 0.5);
			}
			.border-mapBorder {
				--tw-border-opacity: 1;
				border-color: rgb(232 232 232 / var(--tw-border-opacity));
			}
			.border-statBorder {
				--tw-border-opacity: 1;
				border-color: rgb(200 220 223 / var(--tw-border-opacity));
			}
			.border-t-link {
				--tw-border-opacity: 1;
				border-top-color: rgb(0 153 175 / var(--tw-border-opacity));
			}
			.border-t-link\/50 {
				border-top-color: rgb(0 153 175 / 0.5);
			}
			.border-t-statBorder {
				--tw-border-opacity: 1;
				border-top-color: rgb(200 220 223 / var(--tw-border-opacity));
			}
			.\!bg-dark {
				--tw-bg-opacity: 1 !important;
				background-color: rgb(6 23 28 / var(--tw-bg-opacity)) !important;
			}
			.\!bg-teal {
				--tw-bg-opacity: 1 !important;
				background-color: rgb(228 235 236 / var(--tw-bg-opacity)) !important;
			}
			.bg-\[\#10B981\] {
				--tw-bg-opacity: 1;
				background-color: rgb(16 185 129 / var(--tw-bg-opacity));
			}
			.bg-\[\#164E63\] {
				--tw-bg-opacity: 1;
				background-color: rgb(22 78 99 / var(--tw-bg-opacity));
			}
			.bg-\[\#53C5D5\] {
				--tw-bg-opacity: 1;
				background-color: rgb(83 197 213 / var(--tw-bg-opacity));
			}
			.bg-\[\#AFBBC9\] {
				--tw-bg-opacity: 1;
				background-color: rgb(175 187 201 / var(--tw-bg-opacity));
			}
			.bg-\[\#EBEFF2\] {
				--tw-bg-opacity: 1;
				background-color: rgb(235 239 242 / var(--tw-bg-opacity));
			}
			.bg-\[\#F1F7FC\] {
				--tw-bg-opacity: 1;
				background-color: rgb(241 247 252 / var(--tw-bg-opacity));
			}
			.bg-\[\#ffab01\] {
				--tw-bg-opacity: 1;
				background-color: rgb(255 171 1 / var(--tw-bg-opacity));
			}
			.bg-bitcoin {
				--tw-bg-opacity: 1;
				background-color: rgb(247 147 26 / var(--tw-bg-opacity));
			}
			.bg-black {
				--tw-bg-opacity: 1;
				background-color: rgb(0 0 0 / var(--tw-bg-opacity));
			}
			.bg-created {
				--tw-bg-opacity: 1;
				background-color: rgb(16 183 145 / var(--tw-bg-opacity));
			}
			.bg-dark {
				--tw-bg-opacity: 1;
				background-color: rgb(6 23 28 / var(--tw-bg-opacity));
			}
			.bg-deleted {
				--tw-bg-opacity: 1;
				background-color: rgb(235 87 87 / var(--tw-bg-opacity));
			}
			.bg-lightBlue {
				--tw-bg-opacity: 1;
				background-color: rgb(212 225 226 / var(--tw-bg-opacity));
			}
			.bg-link {
				--tw-bg-opacity: 1;
				background-color: rgb(0 153 175 / var(--tw-bg-opacity));
			}
			.bg-link\/25 {
				background-color: rgb(0 153 175 / 0.25);
			}
			.bg-link\/50 {
				background-color: rgb(0 153 175 / 0.5);
			}
			.bg-mobileButtons {
				--tw-bg-opacity: 1;
				background-color: rgb(214 228 230 / var(--tw-bg-opacity));
			}
			.bg-nostr {
				--tw-bg-opacity: 1;
				background-color: rgb(139 92 246 / var(--tw-bg-opacity));
			}
			.bg-offwhite {
				--tw-bg-opacity: 1;
				background-color: rgb(240 246 246 / var(--tw-bg-opacity));
			}
			.bg-primary {
				--tw-bg-opacity: 1;
				background-color: rgb(20 64 70 / var(--tw-bg-opacity));
			}
			.bg-supporter {
				--tw-bg-opacity: 1;
				background-color: rgb(9 93 115 / var(--tw-bg-opacity));
			}
			.bg-supporter\/50 {
				background-color: rgb(9 93 115 / 0.5);
			}
			.bg-teal {
				--tw-bg-opacity: 1;
				background-color: rgb(228 235 236 / var(--tw-bg-opacity));
			}
			.bg-teal\/90 {
				background-color: rgb(228 235 236 / 0.9);
			}
			.bg-twitter {
				--tw-bg-opacity: 1;
				background-color: rgb(29 161 242 / var(--tw-bg-opacity));
			}
			.bg-white {
				--tw-bg-opacity: 1;
				background-color: rgb(255 255 255 / var(--tw-bg-opacity));
			}
			.bg-white\/30 {
				background-color: rgb(255 255 255 / 0.3);
			}
			.object-cover {
				-o-object-fit: cover;
				object-fit: cover;
			}
			.p-0 {
				padding: 0px;
			}
			.p-1 {
				padding: 0.25rem;
			}
			.p-10 {
				padding: 2.5rem;
			}
			.p-2 {
				padding: 0.5rem;
			}
			.p-3 {
				padding: 0.75rem;
			}
			.p-4 {
				padding: 1rem;
			}
			.p-5 {
				padding: 1.25rem;
			}
			.p-6 {
				padding: 1.5rem;
			}
			.px-0 {
				padding-left: 0px;
				padding-right: 0px;
			}
			.px-2 {
				padding-left: 0.5rem;
				padding-right: 0.5rem;
			}
			.px-3 {
				padding-left: 0.75rem;
				padding-right: 0.75rem;
			}
			.px-3\.5 {
				padding-left: 0.875rem;
				padding-right: 0.875rem;
			}
			.px-4 {
				padding-left: 1rem;
				padding-right: 1rem;
			}
			.px-5 {
				padding-left: 1.25rem;
				padding-right: 1.25rem;
			}
			.px-8 {
				padding-left: 2rem;
				padding-right: 2rem;
			}
			.py-0 {
				padding-top: 0px;
				padding-bottom: 0px;
			}
			.py-1 {
				padding-top: 0.25rem;
				padding-bottom: 0.25rem;
			}
			.py-10 {
				padding-top: 2.5rem;
				padding-bottom: 2.5rem;
			}
			.py-2 {
				padding-top: 0.5rem;
				padding-bottom: 0.5rem;
			}
			.py-2\.5 {
				padding-top: 0.625rem;
				padding-bottom: 0.625rem;
			}
			.py-20 {
				padding-top: 5rem;
				padding-bottom: 5rem;
			}
			.py-3 {
				padding-top: 0.75rem;
				padding-bottom: 0.75rem;
			}
			.py-4 {
				padding-top: 1rem;
				padding-bottom: 1rem;
			}
			.py-5 {
				padding-top: 1.25rem;
				padding-bottom: 1.25rem;
			}
			.py-6 {
				padding-top: 1.5rem;
				padding-bottom: 1.5rem;
			}
			.pb-0 {
				padding-bottom: 0px;
			}
			.pb-10 {
				padding-bottom: 2.5rem;
			}
			.pb-14 {
				padding-bottom: 3.5rem;
			}
			.pb-20 {
				padding-bottom: 5rem;
			}
			.pb-32 {
				padding-bottom: 8rem;
			}
			.pb-5 {
				padding-bottom: 1.25rem;
			}
			.pl-0 {
				padding-left: 0px;
			}
			.pl-0\.5 {
				padding-left: 0.125rem;
			}
			.pt-0 {
				padding-top: 0px;
			}
			.pt-10 {
				padding-top: 2.5rem;
			}
			.pt-14 {
				padding-top: 3.5rem;
			}
			.pt-20 {
				padding-top: 5rem;
			}
			.pt-8 {
				padding-top: 2rem;
			}
			.text-left {
				text-align: left;
			}
			.text-center {
				text-align: center;
			}
			.text-right {
				text-align: right;
			}
			.text-2xl {
				font-size: 24px;
				line-height: 32px;
			}
			.text-3xl {
				font-size: 30px;
				line-height: 36px;
			}
			.text-4xl {
				font-size: 36px;
				line-height: 40px;
			}
			.text-5xl {
				font-size: 48px;
				line-height: 1;
			}
			.text-\[16px\] {
				font-size: 16px;
			}
			.text-base {
				font-size: 16px;
				line-height: 24px;
			}
			.text-lg {
				font-size: 18px;
				line-height: 28px;
			}
			.text-sm {
				font-size: 14px;
				line-height: 20px;
			}
			.text-xl {
				font-size: 20px;
				line-height: 28px;
			}
			.text-xs {
				font-size: 12px;
				line-height: 16px;
			}
			.font-bold {
				font-weight: 700;
			}
			.font-normal {
				font-weight: 400;
			}
			.font-semibold {
				font-weight: 600;
			}
			.uppercase {
				text-transform: uppercase;
			}
			.lowercase {
				text-transform: lowercase;
			}
			.normal-case {
				text-transform: none;
			}
			.\!leading-tight {
				line-height: 1.25 !important;
			}
			.leading-none {
				line-height: 1;
			}
			.leading-snug {
				line-height: 1.375;
			}
			.\!text-link {
				--tw-text-opacity: 1 !important;
				color: rgb(0 153 175 / var(--tw-text-opacity)) !important;
			}
			.\!text-primary {
				--tw-text-opacity: 1 !important;
				color: rgb(20 64 70 / var(--tw-text-opacity)) !important;
			}
			.\!text-white {
				--tw-text-opacity: 1 !important;
				color: rgb(255 255 255 / var(--tw-text-opacity)) !important;
			}
			.text-\[\#144046\] {
				--tw-text-opacity: 1;
				color: rgb(20 64 70 / var(--tw-text-opacity));
			}
			.text-bitcoin {
				--tw-text-opacity: 1;
				color: rgb(247 147 26 / var(--tw-text-opacity));
			}
			.text-black {
				--tw-text-opacity: 1;
				color: rgb(0 0 0 / var(--tw-text-opacity));
			}
			.text-body {
				--tw-text-opacity: 1;
				color: rgb(62 98 103 / var(--tw-text-opacity));
			}
			.text-error {
				--tw-text-opacity: 1;
				color: rgb(223 60 60 / var(--tw-text-opacity));
			}
			.text-green-500 {
				--tw-text-opacity: 1;
				color: rgb(34 197 94 / var(--tw-text-opacity));
			}
			.text-grey {
				--tw-text-opacity: 1;
				color: rgb(159 180 182 / var(--tw-text-opacity));
			}
			.text-hover {
				--tw-text-opacity: 1;
				color: rgb(0 183 210 / var(--tw-text-opacity));
			}
			.text-input {
				--tw-text-opacity: 1;
				color: rgb(189 210 212 / var(--tw-text-opacity));
			}
			.text-link {
				--tw-text-opacity: 1;
				color: rgb(0 153 175 / var(--tw-text-opacity));
			}
			.text-link\/50 {
				color: rgb(0 153 175 / 0.5);
			}
			.text-map {
				--tw-text-opacity: 1;
				color: rgb(51 51 51 / var(--tw-text-opacity));
			}
			.text-mapButton {
				--tw-text-opacity: 1;
				color: rgb(95 95 95 / var(--tw-text-opacity));
			}
			.text-mapLabel {
				--tw-text-opacity: 1;
				color: rgb(164 164 164 / var(--tw-text-opacity));
			}
			.text-mobileMenu {
				--tw-text-opacity: 1;
				color: rgb(8 93 105 / var(--tw-text-opacity));
			}
			.text-primary {
				--tw-text-opacity: 1;
				color: rgb(20 64 70 / var(--tw-text-opacity));
			}
			.text-searchSubtext {
				--tw-text-opacity: 1;
				color: rgb(153 153 153 / var(--tw-text-opacity));
			}
			.text-statNegative {
				--tw-text-opacity: 1;
				color: rgb(235 87 87 / var(--tw-text-opacity));
			}
			.text-statPositive {
				--tw-text-opacity: 1;
				color: rgb(11 144 114 / var(--tw-text-opacity));
			}
			.text-taggerTime {
				--tw-text-opacity: 1;
				color: rgb(124 156 160 / var(--tw-text-opacity));
			}
			.text-white {
				--tw-text-opacity: 1;
				color: rgb(255 255 255 / var(--tw-text-opacity));
			}
			.underline {
				text-decoration-line: underline;
			}
			.\!no-underline {
				text-decoration-line: none !important;
			}
			.no-underline {
				text-decoration-line: none;
			}
			.decoration-4 {
				text-decoration-thickness: 4px;
			}
			.underline-offset-4 {
				text-underline-offset: 4px;
			}
			.accent-link {
				accent-color: #0099af;
			}
			.opacity-10 {
				opacity: 0.1;
			}
			.opacity-25 {
				opacity: 0.25;
			}
			.opacity-50 {
				opacity: 0.5;
			}
			.opacity-75 {
				opacity: 0.75;
			}
			.opacity-80 {
				opacity: 0.8;
			}
			.shadow {
				--tw-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);
				--tw-shadow-colored:
					0 1px 3px 0 var(--tw-shadow-color), 0 1px 2px -1px var(--tw-shadow-color);
				box-shadow:
					var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000),
					var(--tw-shadow);
			}
			.shadow-2xl {
				--tw-shadow: 0 25px 50px -12px rgb(0 0 0 / 0.25);
				--tw-shadow-colored: 0 25px 50px -12px var(--tw-shadow-color);
				box-shadow:
					var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000),
					var(--tw-shadow);
			}
			.shadow-lg {
				--tw-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
				--tw-shadow-colored:
					0 10px 15px -3px var(--tw-shadow-color), 0 4px 6px -4px var(--tw-shadow-color);
				box-shadow:
					var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000),
					var(--tw-shadow);
			}
			.shadow-xl {
				--tw-shadow: 0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1);
				--tw-shadow-colored:
					0 20px 25px -5px var(--tw-shadow-color), 0 8px 10px -6px var(--tw-shadow-color);
				box-shadow:
					var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000),
					var(--tw-shadow);
			}
			.outline {
				outline-style: solid;
			}
			.drop-shadow {
				--tw-drop-shadow: drop-shadow(0 1px 2px rgb(0 0 0 / 0.1))
					drop-shadow(0 1px 1px rgb(0 0 0 / 0.06));
				filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale)
					var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia)
					var(--tw-drop-shadow);
			}
			.drop-shadow-2xl {
				--tw-drop-shadow: drop-shadow(0 25px 25px rgb(0 0 0 / 0.15));
				filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale)
					var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia)
					var(--tw-drop-shadow);
			}
			.drop-shadow-\[0px_0px_4px_rgba\(0\2c 0\2c 0\2c 0\.2\)\] {
				--tw-drop-shadow: drop-shadow(0px 0px 4px rgba(0, 0, 0, 0.2));
				filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale)
					var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia)
					var(--tw-drop-shadow);
			}
			.drop-shadow-\[0px_2px_6px_rgba\(0\2c 0\2c 0\2c 0\.15\)\] {
				--tw-drop-shadow: drop-shadow(0px 2px 6px rgba(0, 0, 0, 0.15));
				filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale)
					var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia)
					var(--tw-drop-shadow);
			}
			.drop-shadow-xl {
				--tw-drop-shadow: drop-shadow(0 20px 13px rgb(0 0 0 / 0.03))
					drop-shadow(0 8px 5px rgb(0 0 0 / 0.08));
				filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale)
					var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia)
					var(--tw-drop-shadow);
			}
			.filter {
				filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale)
					var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia)
					var(--tw-drop-shadow);
			}
			.transition {
				transition-property:
					color,
					background-color,
					border-color,
					text-decoration-color,
					fill,
					stroke,
					opacity,
					box-shadow,
					transform,
					filter,
					-webkit-backdrop-filter;
				transition-property:
					color, background-color, border-color, text-decoration-color, fill, stroke, opacity,
					box-shadow, transform, filter, backdrop-filter;
				transition-property:
					color,
					background-color,
					border-color,
					text-decoration-color,
					fill,
					stroke,
					opacity,
					box-shadow,
					transform,
					filter,
					backdrop-filter,
					-webkit-backdrop-filter;
				transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
				transition-duration: 150ms;
			}
			.transition-all {
				transition-property: all;
				transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
				transition-duration: 150ms;
			}
			.transition-colors {
				transition-property:
					color, background-color, border-color, text-decoration-color, fill, stroke;
				transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
				transition-duration: 150ms;
			}
			.transition-opacity {
				transition-property: opacity;
				transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
				transition-duration: 150ms;
			}
			.transition-shadow {
				transition-property: box-shadow;
				transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
				transition-duration: 150ms;
			}
			.transition-transform {
				transition-property: transform;
				transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
				transition-duration: 150ms;
			}
			.ease-in-out {
				transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
			}

			@font-face {
				font-family: 'Manrope';
				src: url('/fonts/Manrope-Regular.ttf') format('truetype');
			}

			html {
				font-family: Manrope, sans-serif;
				font-size: 16px;
			}

			::-moz-selection {
				color: white;
				background: #53c5d5;
			}

			::selection {
				color: white;
				background: #53c5d5;
			}

			.gradient {
				background: -webkit-linear-gradient(45deg, #0ecd71, #040273);
				-webkit-background-clip: text;
				-webkit-text-fill-color: transparent;
			}

			.gradient-bg {
				background: -webkit-linear-gradient(45deg, #0ecd71, #040273);
			}

			/* Hide scrollbar for Chrome, Safari and Opera */
			.hide-scroll::-webkit-scrollbar {
				display: none;
			}

			/* Hide scrollbar for IE, Edge and Firefox */
			.hide-scroll {
				-ms-overflow-style: none; /* IE and Edge */
				scrollbar-width: none; /* Firefox */
			}

			.div-icon {
				background-image: url('/icons/div-icon-pin.svg');
			}

			.boosted-icon {
				background-image: url('/icons/boosted-icon-pin.svg');
			}

			.center {
				position: absolute;
				top: 50%;
				left: 50%;
				transform: translateX(-50%) translateY(-50%);
			}

			.hover\:scale-110:hover {
				--tw-scale-x: 1.1;
				--tw-scale-y: 1.1;
				transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate))
					skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x))
					scaleY(var(--tw-scale-y));
			}

			@keyframes wiggle {
				0%,
				100% {
					transform: rotate(-3deg);
				}

				50% {
					transform: rotate(3deg);
				}
			}

			.hover\:animate-wiggle:hover {
				animation: wiggle 1s ease-in-out infinite;
			}

			.hover\:border-hover:hover {
				--tw-border-opacity: 1;
				border-color: rgb(0 183 210 / var(--tw-border-opacity));
			}

			.hover\:border-link:hover {
				--tw-border-opacity: 1;
				border-color: rgb(0 153 175 / var(--tw-border-opacity));
			}

			.hover\:border-white:hover {
				--tw-border-opacity: 1;
				border-color: rgb(255 255 255 / var(--tw-border-opacity));
			}

			.hover\:bg-hover:hover {
				--tw-bg-opacity: 1;
				background-color: rgb(0 183 210 / var(--tw-bg-opacity));
			}

			.hover\:bg-link:hover {
				--tw-bg-opacity: 1;
				background-color: rgb(0 153 175 / var(--tw-bg-opacity));
			}

			.hover\:bg-link\/50:hover {
				background-color: rgb(0 153 175 / 0.5);
			}

			.hover\:bg-searchHover:hover {
				--tw-bg-opacity: 1;
				background-color: rgb(248 248 248 / var(--tw-bg-opacity));
			}

			.hover\:\!text-hover:hover {
				--tw-text-opacity: 1 !important;
				color: rgb(0 183 210 / var(--tw-text-opacity)) !important;
			}

			.hover\:\!text-link:hover {
				--tw-text-opacity: 1 !important;
				color: rgb(0 153 175 / var(--tw-text-opacity)) !important;
			}

			.hover\:text-black:hover {
				--tw-text-opacity: 1;
				color: rgb(0 0 0 / var(--tw-text-opacity));
			}

			.hover\:text-hover:hover {
				--tw-text-opacity: 1;
				color: rgb(0 183 210 / var(--tw-text-opacity));
			}

			.hover\:text-link:hover {
				--tw-text-opacity: 1;
				color: rgb(0 153 175 / var(--tw-text-opacity));
			}

			.hover\:text-white:hover {
				--tw-text-opacity: 1;
				color: rgb(255 255 255 / var(--tw-text-opacity));
			}

			.hover\:no-underline:hover {
				text-decoration-line: none;
			}

			.hover\:opacity-80:hover {
				opacity: 0.8;
			}

			.hover\:shadow-2xl:hover {
				--tw-shadow: 0 25px 50px -12px rgb(0 0 0 / 0.25);
				--tw-shadow-colored: 0 25px 50px -12px var(--tw-shadow-color);
				box-shadow:
					var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000),
					var(--tw-shadow);
			}

			.hover\:drop-shadow-2xl:hover {
				--tw-drop-shadow: drop-shadow(0 25px 25px rgb(0 0 0 / 0.15));
				filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale)
					var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia)
					var(--tw-drop-shadow);
			}

			.focus\:outline-none:focus {
				outline: 2px solid transparent;
				outline-offset: 2px;
			}

			.focus\:outline-link:focus {
				outline-color: #0099af;
			}

			.focus\:drop-shadow-\[0px_2px_6px_rgba\(0\2c 0\2c 0\2c 0\.3\)\]:focus {
				--tw-drop-shadow: drop-shadow(0px 2px 6px rgba(0, 0, 0, 0.3));
				filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale)
					var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia)
					var(--tw-drop-shadow);
			}

			.active\:bg-mobileButtonsActive:active {
				--tw-bg-opacity: 1;
				background-color: rgb(195 220 223 / var(--tw-bg-opacity));
			}

			.dark .dark\:rounded-full {
				border-radius: 9999px;
			}

			.dark .dark\:border {
				border-width: 1px;
			}

			.dark .dark\:border-b {
				border-bottom-width: 1px;
			}

			.dark .dark\:border-l {
				border-left-width: 1px;
			}

			.dark .dark\:border-r {
				border-right-width: 1px;
			}

			.dark .dark\:border-t {
				border-top-width: 1px;
			}

			.dark .dark\:\!bg-\[\#202f33\] {
				--tw-bg-opacity: 1 !important;
				background-color: rgb(32 47 51 / var(--tw-bg-opacity)) !important;
			}

			.dark .dark\:\!bg-dark {
				--tw-bg-opacity: 1 !important;
				background-color: rgb(6 23 28 / var(--tw-bg-opacity)) !important;
			}

			.dark .dark\:bg-dark {
				--tw-bg-opacity: 1;
				background-color: rgb(6 23 28 / var(--tw-bg-opacity));
			}

			.dark .dark\:bg-dark\/90 {
				background-color: rgb(6 23 28 / 0.9);
			}

			.dark .dark\:bg-white {
				--tw-bg-opacity: 1;
				background-color: rgb(255 255 255 / var(--tw-bg-opacity));
			}

			.dark .dark\:bg-white\/10 {
				background-color: rgb(255 255 255 / 0.1);
			}

			.dark .dark\:bg-white\/\[0\.15\] {
				background-color: rgb(255 255 255 / 0.15);
			}

			.dark .dark\:p-0 {
				padding: 0px;
			}

			.dark .dark\:p-0\.5 {
				padding: 0.125rem;
			}

			.dark .dark\:font-normal {
				font-weight: 400;
			}

			.dark .dark\:\!text-white {
				--tw-text-opacity: 1 !important;
				color: rgb(255 255 255 / var(--tw-text-opacity)) !important;
			}

			.dark .dark\:text-link {
				--tw-text-opacity: 1;
				color: rgb(0 153 175 / var(--tw-text-opacity));
			}

			.dark .dark\:text-white {
				--tw-text-opacity: 1;
				color: rgb(255 255 255 / var(--tw-text-opacity));
			}

			.dark .dark\:text-white\/50 {
				color: rgb(255 255 255 / 0.5);
			}

			.dark .dark\:\!text-link {
				--tw-text-opacity: 1 !important;
				color: rgb(0 153 175 / var(--tw-text-opacity)) !important;
			}

			.dark .dark\:opacity-10 {
				opacity: 0.1;
			}

			.dark .dark\:hover\:\!bg-dark\/75:hover {
				background-color: rgb(6 23 28 / 0.75) !important;
			}

			.dark .dark\:hover\:bg-white\/\[0\.15\]:hover {
				background-color: rgb(255 255 255 / 0.15);
			}

			.dark .dark\:hover\:bg-link:hover {
				--tw-bg-opacity: 1;
				background-color: rgb(0 153 175 / var(--tw-bg-opacity));
			}

			.dark .dark\:hover\:\!text-link:hover {
				--tw-text-opacity: 1 !important;
				color: rgb(0 153 175 / var(--tw-text-opacity)) !important;
			}

			.dark .dark\:hover\:text-link:hover {
				--tw-text-opacity: 1;
				color: rgb(0 153 175 / var(--tw-text-opacity));
			}

			.dark .dark\:hover\:text-white\/80:hover {
				color: rgb(255 255 255 / 0.8);
			}

			@media (min-width: 768px) {
				.md\:mx-0 {
					margin-left: 0px;
					margin-right: 0px;
				}

				.md\:my-0 {
					margin-top: 0px;
					margin-bottom: 0px;
				}

				.md\:my-20 {
					margin-top: 5rem;
					margin-bottom: 5rem;
				}

				.md\:mr-0 {
					margin-right: 0px;
				}

				.md\:mr-1 {
					margin-right: 0.25rem;
				}

				.md\:mt-0 {
					margin-top: 0px;
				}

				.md\:block {
					display: block;
				}

				.md\:inline {
					display: inline;
				}

				.md\:flex {
					display: flex;
				}

				.md\:inline-flex {
					display: inline-flex;
				}

				.md\:hidden {
					display: none;
				}

				.md\:h-5 {
					height: 1.25rem;
				}

				.md\:h-\[275px\] {
					height: 275px;
				}

				.md\:h-\[300px\] {
					height: 300px;
				}

				.md\:h-\[30px\] {
					height: 30px;
				}

				.md\:h-\[380px\] {
					height: 380px;
				}

				.md\:h-\[400px\] {
					height: 400px;
				}

				.md\:h-\[450px\] {
					height: 450px;
				}

				.md\:h-\[56px\] {
					height: 56px;
				}

				.md\:h-\[588px\] {
					height: 588px;
				}

				.md\:h-\[600px\] {
					height: 600px;
				}

				.md\:w-2\/3 {
					width: 66.666667%;
				}

				.md\:w-20 {
					width: 5rem;
				}

				.md\:w-40 {
					width: 10rem;
				}

				.md\:w-96 {
					width: 24rem;
				}

				.md\:w-\[200px\] {
					width: 200px;
				}

				.md\:w-\[210px\] {
					width: 210px;
				}

				.md\:w-\[250px\] {
					width: 250px;
				}

				.md\:w-\[275px\] {
					width: 275px;
				}

				.md\:w-\[300px\] {
					width: 300px;
				}

				.md\:w-\[350px\] {
					width: 350px;
				}

				.md\:w-\[400px\] {
					width: 400px;
				}

				.md\:w-\[430px\] {
					width: 430px;
				}

				.md\:w-\[450px\] {
					width: 450px;
				}

				.md\:w-\[475px\] {
					width: 475px;
				}

				.md\:w-\[500px\] {
					width: 500px;
				}

				.md\:w-\[600px\] {
					width: 600px;
				}

				.md\:max-w-\[210px\] {
					max-width: 210px;
				}

				.md\:grid-cols-2 {
					grid-template-columns: repeat(2, minmax(0, 1fr));
				}

				.md\:justify-start {
					justify-content: flex-start;
				}

				.md\:justify-center {
					justify-content: center;
				}

				.md\:space-x-2 > :not([hidden]) ~ :not([hidden]) {
					--tw-space-x-reverse: 0;
					margin-right: calc(0.5rem * var(--tw-space-x-reverse));
					margin-left: calc(0.5rem * calc(1 - var(--tw-space-x-reverse)));
				}

				.md\:space-x-4 > :not([hidden]) ~ :not([hidden]) {
					--tw-space-x-reverse: 0;
					margin-right: calc(1rem * var(--tw-space-x-reverse));
					margin-left: calc(1rem * calc(1 - var(--tw-space-x-reverse)));
				}

				.md\:space-x-5 > :not([hidden]) ~ :not([hidden]) {
					--tw-space-x-reverse: 0;
					margin-right: calc(1.25rem * var(--tw-space-x-reverse));
					margin-left: calc(1.25rem * calc(1 - var(--tw-space-x-reverse)));
				}

				.md\:space-y-0 > :not([hidden]) ~ :not([hidden]) {
					--tw-space-y-reverse: 0;
					margin-top: calc(0px * calc(1 - var(--tw-space-y-reverse)));
					margin-bottom: calc(0px * var(--tw-space-y-reverse));
				}

				.md\:space-y-40 > :not([hidden]) ~ :not([hidden]) {
					--tw-space-y-reverse: 0;
					margin-top: calc(10rem * calc(1 - var(--tw-space-y-reverse)));
					margin-bottom: calc(10rem * var(--tw-space-y-reverse));
				}

				.md\:rounded-l {
					border-top-left-radius: 0.25rem;
					border-bottom-left-radius: 0.25rem;
				}

				.md\:rounded-r {
					border-top-right-radius: 0.25rem;
					border-bottom-right-radius: 0.25rem;
				}

				.md\:rounded-bl-none {
					border-bottom-left-radius: 0px;
				}

				.md\:rounded-tr-none {
					border-top-right-radius: 0px;
				}

				.md\:border-b-0 {
					border-bottom-width: 0px;
				}

				.md\:border-r {
					border-right-width: 1px;
				}

				.md\:p-10 {
					padding: 2.5rem;
				}

				.md\:px-0 {
					padding-left: 0px;
					padding-right: 0px;
				}

				.md\:py-1 {
					padding-top: 0.25rem;
					padding-bottom: 0.25rem;
				}

				.md\:py-3 {
					padding-top: 0.75rem;
					padding-bottom: 0.75rem;
				}

				.md\:pb-32 {
					padding-bottom: 8rem;
				}

				.md\:text-left {
					text-align: left;
				}

				.md\:text-right {
					text-align: right;
				}

				.md\:text-5xl {
					font-size: 48px;
					line-height: 1;
				}

				.md\:text-lg {
					font-size: 18px;
					line-height: 28px;
				}
			}

			@media (min-width: 1024px) {
				.lg\:\!my-auto {
					margin-top: auto !important;
					margin-bottom: auto !important;
				}

				.lg\:mx-0 {
					margin-left: 0px;
					margin-right: 0px;
				}

				.lg\:mx-auto {
					margin-left: auto;
					margin-right: auto;
				}

				.lg\:my-0 {
					margin-top: 0px;
					margin-bottom: 0px;
				}

				.lg\:mb-0 {
					margin-bottom: 0px;
				}

				.lg\:mr-5 {
					margin-right: 1.25rem;
				}

				.lg\:inline-block {
					display: inline-block;
				}

				.lg\:inline {
					display: inline;
				}

				.lg\:flex {
					display: flex;
				}

				.lg\:inline-flex {
					display: inline-flex;
				}

				.lg\:grid {
					display: grid;
				}

				.lg\:hidden {
					display: none;
				}

				.lg\:h-14 {
					height: 3.5rem;
				}

				.lg\:h-5 {
					height: 1.25rem;
				}

				.lg\:h-\[271\.5px\] {
					height: 271.5px;
				}

				.lg\:h-\[30px\] {
					height: 30px;
				}

				.lg\:w-1\/2 {
					width: 50%;
				}

				.lg\:w-10\/12 {
					width: 83.333333%;
				}

				.lg\:w-14 {
					width: 3.5rem;
				}

				.lg\:w-5 {
					width: 1.25rem;
				}

				.lg\:w-\[100px\] {
					width: 100px;
				}

				.lg\:w-\[475px\] {
					width: 475px;
				}

				.lg\:w-\[650px\] {
					width: 650px;
				}

				.lg\:w-\[675px\] {
					width: 675px;
				}

				.lg\:w-\[700px\] {
					width: 700px;
				}

				.lg\:w-\[75px\] {
					width: 75px;
				}

				.lg\:w-\[800px\] {
					width: 800px;
				}

				.lg\:w-\[830px\] {
					width: 830px;
				}

				.lg\:grid-cols-3 {
					grid-template-columns: repeat(3, minmax(0, 1fr));
				}

				.lg\:space-x-0 > :not([hidden]) ~ :not([hidden]) {
					--tw-space-x-reverse: 0;
					margin-right: calc(0px * var(--tw-space-x-reverse));
					margin-left: calc(0px * calc(1 - var(--tw-space-x-reverse)));
				}

				.lg\:space-x-10 > :not([hidden]) ~ :not([hidden]) {
					--tw-space-x-reverse: 0;
					margin-right: calc(2.5rem * var(--tw-space-x-reverse));
					margin-left: calc(2.5rem * calc(1 - var(--tw-space-x-reverse)));
				}

				.lg\:space-x-2 > :not([hidden]) ~ :not([hidden]) {
					--tw-space-x-reverse: 0;
					margin-right: calc(0.5rem * var(--tw-space-x-reverse));
					margin-left: calc(0.5rem * calc(1 - var(--tw-space-x-reverse)));
				}

				.lg\:space-x-4 > :not([hidden]) ~ :not([hidden]) {
					--tw-space-x-reverse: 0;
					margin-right: calc(1rem * var(--tw-space-x-reverse));
					margin-left: calc(1rem * calc(1 - var(--tw-space-x-reverse)));
				}

				.lg\:space-x-5 > :not([hidden]) ~ :not([hidden]) {
					--tw-space-x-reverse: 0;
					margin-right: calc(1.25rem * var(--tw-space-x-reverse));
					margin-left: calc(1.25rem * calc(1 - var(--tw-space-x-reverse)));
				}

				.lg\:space-y-0 > :not([hidden]) ~ :not([hidden]) {
					--tw-space-y-reverse: 0;
					margin-top: calc(0px * calc(1 - var(--tw-space-y-reverse)));
					margin-bottom: calc(0px * var(--tw-space-y-reverse));
				}

				.lg\:space-y-5 > :not([hidden]) ~ :not([hidden]) {
					--tw-space-y-reverse: 0;
					margin-top: calc(1.25rem * calc(1 - var(--tw-space-y-reverse)));
					margin-bottom: calc(1.25rem * var(--tw-space-y-reverse));
				}

				.lg\:rounded-full {
					border-radius: 9999px;
				}

				.lg\:border-b-0 {
					border-bottom-width: 0px;
				}

				.lg\:border-r {
					border-right-width: 1px;
				}

				.lg\:border-none {
					border-style: none;
				}

				.lg\:py-0 {
					padding-top: 0px;
					padding-bottom: 0px;
				}

				.lg\:pb-0 {
					padding-bottom: 0px;
				}

				.lg\:pt-0 {
					padding-top: 0px;
				}

				.lg\:text-left {
					text-align: left;
				}

				.lg\:no-underline {
					text-decoration-line: none;
				}

				.dark .dark\:lg\:rounded {
					border-radius: 0.25rem;
				}

				.dark .dark\:lg\:bg-white\/10 {
					background-color: rgb(255 255 255 / 0.1);
				}

				.dark .dark\:lg\:py-8 {
					padding-top: 2rem;
					padding-bottom: 2rem;
				}
			}

			@media (min-width: 1280px) {
				.xl\:mx-0 {
					margin-left: 0px;
					margin-right: 0px;
				}

				.xl\:mb-0 {
					margin-bottom: 0px;
				}

				.xl\:mt-0 {
					margin-top: 0px;
				}

				.xl\:block {
					display: block;
				}

				.xl\:flex {
					display: flex;
				}

				.xl\:hidden {
					display: none;
				}

				.xl\:w-3\/4 {
					width: 75%;
				}

				.xl\:w-\[100px\] {
					width: 100px;
				}

				.xl\:w-\[1200px\] {
					width: 1200px;
				}

				.xl\:w-\[500px\] {
					width: 500px;
				}

				.xl\:grid-cols-4 {
					grid-template-columns: repeat(4, minmax(0, 1fr));
				}

				.xl\:space-x-16 > :not([hidden]) ~ :not([hidden]) {
					--tw-space-x-reverse: 0;
					margin-right: calc(4rem * var(--tw-space-x-reverse));
					margin-left: calc(4rem * calc(1 - var(--tw-space-x-reverse)));
				}

				.xl\:space-x-5 > :not([hidden]) ~ :not([hidden]) {
					--tw-space-x-reverse: 0;
					margin-right: calc(1.25rem * var(--tw-space-x-reverse));
					margin-left: calc(1.25rem * calc(1 - var(--tw-space-x-reverse)));
				}

				.xl\:space-y-0 > :not([hidden]) ~ :not([hidden]) {
					--tw-space-y-reverse: 0;
					margin-top: calc(0px * calc(1 - var(--tw-space-y-reverse)));
					margin-bottom: calc(0px * var(--tw-space-y-reverse));
				}

				.xl\:border-b-0 {
					border-bottom-width: 0px;
				}

				.xl\:border-r {
					border-right-width: 1px;
				}

				.xl\:pt-0 {
					padding-top: 0px;
				}

				.xl\:text-left {
					text-align: left;
				}
			}

			._toastContainer.s--bA00mryVvOe {
				top: var(--toastContainerTop, 1.5rem);
				right: var(--toastContainerRight, 2rem);
				bottom: var(--toastContainerBottom, auto);
				left: var(--toastContainerLeft, auto);
				position: fixed;
				margin: 0;
				padding: 0;
				list-style-type: none;
				pointer-events: none;
				z-index: var(--toastContainerZIndex, 9999);
			}
			.s--bA00mryVvOe {
			}
			._toastItem.s-o5uJgpq4oQeR {
				width: var(--toastWidth, 16rem);
				height: var(--toastHeight, auto);
				min-height: var(--toastMinHeight, 3.5rem);
				margin: var(--toastMargin, 0 0 0.5rem 0);
				padding: var(--toastPadding, 0);
				background: var(--toastBackground, rgba(66, 66, 66, 0.9));
				color: var(--toastColor, #fff);
				box-shadow: var(
					--toastBoxShadow,
					0 4px 6px -1px rgba(0, 0, 0, 0.1),
					0 2px 4px -1px rgba(0, 0, 0, 0.06)
				);
				border: var(--toastBorder, none);
				border-radius: var(--toastBorderRadius, 0.125rem);
				position: relative;
				display: flex;
				flex-direction: row;
				align-items: center;
				overflow: hidden;
				will-change: transform, opacity;
				-webkit-tap-highlight-color: transparent;
			}
			._toastMsg.s-o5uJgpq4oQeR {
				padding: var(--toastMsgPadding, 0.75rem 0.5rem);
				flex: 1 1 0%;
			}
			.pe.s-o5uJgpq4oQeR,
			._toastMsg.s-o5uJgpq4oQeR a {
				pointer-events: auto;
			}
			._toastBtn.s-o5uJgpq4oQeR {
				width: var(--toastBtnWidth, 2rem);
				height: var(--toastBtnHeight, 100%);
				cursor: pointer;
				outline: none;
			}
			._toastBtn.s-o5uJgpq4oQeR::after {
				content: var(--toastBtnContent, 'âœ•');
				font: var(--toastBtnFont, 1rem sans-serif);
				display: flex;
				align-items: center;
				justify-content: center;
			}
			._toastBar.s-o5uJgpq4oQeR {
				top: var(--toastBarTop, auto);
				right: var(--toastBarRight, auto);
				bottom: var(--toastBarBottom, 0);
				left: var(--toastBarLeft, 0);
				height: var(--toastBarHeight, 6px);
				width: var(--toastBarWidth, 100%);
				position: absolute;
				display: block;
				-webkit-appearance: none;
				-moz-appearance: none;
				appearance: none;
				border: none;
				background: transparent;
				pointer-events: none;
			}
			._toastBar.s-o5uJgpq4oQeR::-webkit-progress-bar {
				background: transparent;
			}
			._toastBar.s-o5uJgpq4oQeR::-webkit-progress-value {
				background: var(
					--toastProgressBackground,
					var(--toastBarBackground, rgba(33, 150, 243, 0.75))
				);
			}
			._toastBar.s-o5uJgpq4oQeR::-moz-progress-bar {
				background: var(
					--toastProgressBackground,
					var(--toastBarBackground, rgba(33, 150, 243, 0.75))
				);
			}
			.s-o5uJgpq4oQeR {
			}
			.tippy-box[data-animation='fade'][data-state='hidden'] {
				opacity: 0;
			}
			[data-tippy-root] {
				max-width: calc(100vw - 10px);
			}
			.tippy-box {
				position: relative;
				background-color: #333;
				color: #fff;
				border-radius: 4px;
				font-size: 14px;
				line-height: 1.4;
				white-space: normal;
				outline: 0;
				transition-property: transform, visibility, opacity;
			}
			.tippy-box[data-placement^='top'] > .tippy-arrow {
				bottom: 0;
			}
			.tippy-box[data-placement^='top'] > .tippy-arrow:before {
				bottom: -7px;
				left: 0;
				border-width: 8px 8px 0;
				border-top-color: initial;
				transform-origin: center top;
			}
			.tippy-box[data-placement^='bottom'] > .tippy-arrow {
				top: 0;
			}
			.tippy-box[data-placement^='bottom'] > .tippy-arrow:before {
				top: -7px;
				left: 0;
				border-width: 0 8px 8px;
				border-bottom-color: initial;
				transform-origin: center bottom;
			}
			.tippy-box[data-placement^='left'] > .tippy-arrow {
				right: 0;
			}
			.tippy-box[data-placement^='left'] > .tippy-arrow:before {
				border-width: 8px 0 8px 8px;
				border-left-color: initial;
				right: -7px;
				transform-origin: center left;
			}
			.tippy-box[data-placement^='right'] > .tippy-arrow {
				left: 0;
			}
			.tippy-box[data-placement^='right'] > .tippy-arrow:before {
				left: -7px;
				border-width: 8px 8px 8px 0;
				border-right-color: initial;
				transform-origin: center right;
			}
			.tippy-box[data-inertia][data-state='visible'] {
				transition-timing-function: cubic-bezier(0.54, 1.5, 0.38, 1.11);
			}
			.tippy-arrow {
				width: 16px;
				height: 16px;
				color: #333;
			}
			.tippy-arrow:before {
				content: '';
				position: absolute;
				border-color: transparent;
				border-style: solid;
			}
			.tippy-content {
				position: relative;
				padding: 5px 9px;
				z-index: 1;
			}
			.s-IuPAlcK389th {
			}
			.tippy-box[data-animation='fade'][data-state='hidden'] {
				opacity: 0;
			}
			[data-tippy-root] {
				max-width: calc(100vw - 10px);
			}
			.tippy-box {
				position: relative;
				background-color: #333;
				color: #fff;
				border-radius: 4px;
				font-size: 14px;
				line-height: 1.4;
				white-space: normal;
				outline: 0;
				transition-property: transform, visibility, opacity;
			}
			.tippy-box[data-placement^='top'] > .tippy-arrow {
				bottom: 0;
			}
			.tippy-box[data-placement^='top'] > .tippy-arrow:before {
				bottom: -7px;
				left: 0;
				border-width: 8px 8px 0;
				border-top-color: initial;
				transform-origin: center top;
			}
			.tippy-box[data-placement^='bottom'] > .tippy-arrow {
				top: 0;
			}
			.tippy-box[data-placement^='bottom'] > .tippy-arrow:before {
				top: -7px;
				left: 0;
				border-width: 0 8px 8px;
				border-bottom-color: initial;
				transform-origin: center bottom;
			}
			.tippy-box[data-placement^='left'] > .tippy-arrow {
				right: 0;
			}
			.tippy-box[data-placement^='left'] > .tippy-arrow:before {
				border-width: 8px 0 8px 8px;
				border-left-color: initial;
				right: -7px;
				transform-origin: center left;
			}
			.tippy-box[data-placement^='right'] > .tippy-arrow {
				left: 0;
			}
			.tippy-box[data-placement^='right'] > .tippy-arrow:before {
				left: -7px;
				border-width: 8px 8px 8px 0;
				border-right-color: initial;
				transform-origin: center right;
			}
			.tippy-box[data-inertia][data-state='visible'] {
				transition-timing-function: cubic-bezier(0.54, 1.5, 0.38, 1.11);
			}
			.tippy-arrow {
				width: 16px;
				height: 16px;
				color: #333;
			}
			.tippy-arrow:before {
				content: '';
				position: absolute;
				border-color: transparent;
				border-style: solid;
			}
			.tippy-content {
				position: relative;
				padding: 5px 9px;
				z-index: 1;
			}
			.s-bTo5KS4HDVB- {
			}
			.tippy-box[data-animation='fade'][data-state='hidden'] {
				opacity: 0;
			}
			[data-tippy-root] {
				max-width: calc(100vw - 10px);
			}
			.tippy-box {
				position: relative;
				background-color: #333;
				color: #fff;
				border-radius: 4px;
				font-size: 14px;
				line-height: 1.4;
				white-space: normal;
				outline: 0;
				transition-property: transform, visibility, opacity;
			}
			.tippy-box[data-placement^='top'] > .tippy-arrow {
				bottom: 0;
			}
			.tippy-box[data-placement^='top'] > .tippy-arrow:before {
				bottom: -7px;
				left: 0;
				border-width: 8px 8px 0;
				border-top-color: initial;
				transform-origin: center top;
			}
			.tippy-box[data-placement^='bottom'] > .tippy-arrow {
				top: 0;
			}
			.tippy-box[data-placement^='bottom'] > .tippy-arrow:before {
				top: -7px;
				left: 0;
				border-width: 0 8px 8px;
				border-bottom-color: initial;
				transform-origin: center bottom;
			}
			.tippy-box[data-placement^='left'] > .tippy-arrow {
				right: 0;
			}
			.tippy-box[data-placement^='left'] > .tippy-arrow:before {
				border-width: 8px 0 8px 8px;
				border-left-color: initial;
				right: -7px;
				transform-origin: center left;
			}
			.tippy-box[data-placement^='right'] > .tippy-arrow {
				left: 0;
			}
			.tippy-box[data-placement^='right'] > .tippy-arrow:before {
				left: -7px;
				border-width: 8px 8px 8px 0;
				border-right-color: initial;
				transform-origin: center right;
			}
			.tippy-box[data-inertia][data-state='visible'] {
				transition-timing-function: cubic-bezier(0.54, 1.5, 0.38, 1.11);
			}
			.tippy-arrow {
				width: 16px;
				height: 16px;
				color: #333;
			}
			.tippy-arrow:before {
				content: '';
				position: absolute;
				border-color: transparent;
				border-style: solid;
			}
			.tippy-content {
				position: relative;
				padding: 5px 9px;
				z-index: 1;
			}
			.s-9coVUeQFfuX9 {
			}
			.tippy-box[data-animation='fade'][data-state='hidden'] {
				opacity: 0;
			}
			[data-tippy-root] {
				max-width: calc(100vw - 10px);
			}
			.tippy-box {
				position: relative;
				background-color: #333;
				color: #fff;
				border-radius: 4px;
				font-size: 14px;
				line-height: 1.4;
				white-space: normal;
				outline: 0;
				transition-property: transform, visibility, opacity;
			}
			.tippy-box[data-placement^='top'] > .tippy-arrow {
				bottom: 0;
			}
			.tippy-box[data-placement^='top'] > .tippy-arrow:before {
				bottom: -7px;
				left: 0;
				border-width: 8px 8px 0;
				border-top-color: initial;
				transform-origin: center top;
			}
			.tippy-box[data-placement^='bottom'] > .tippy-arrow {
				top: 0;
			}
			.tippy-box[data-placement^='bottom'] > .tippy-arrow:before {
				top: -7px;
				left: 0;
				border-width: 0 8px 8px;
				border-bottom-color: initial;
				transform-origin: center bottom;
			}
			.tippy-box[data-placement^='left'] > .tippy-arrow {
				right: 0;
			}
			.tippy-box[data-placement^='left'] > .tippy-arrow:before {
				border-width: 8px 0 8px 8px;
				border-left-color: initial;
				right: -7px;
				transform-origin: center left;
			}
			.tippy-box[data-placement^='right'] > .tippy-arrow {
				left: 0;
			}
			.tippy-box[data-placement^='right'] > .tippy-arrow:before {
				left: -7px;
				border-width: 8px 8px 8px 0;
				border-right-color: initial;
				transform-origin: center right;
			}
			.tippy-box[data-inertia][data-state='visible'] {
				transition-timing-function: cubic-bezier(0.54, 1.5, 0.38, 1.11);
			}
			.tippy-arrow {
				width: 16px;
				height: 16px;
				color: #333;
			}
			.tippy-arrow:before {
				content: '';
				position: absolute;
				border-color: transparent;
				border-style: solid;
			}
			.tippy-content {
				position: relative;
				padding: 5px 9px;
				z-index: 1;
			}
			.s-YmZUhGvHaPy- {
			}
			.tippy-box[data-animation='fade'][data-state='hidden'] {
				opacity: 0;
			}
			[data-tippy-root] {
				max-width: calc(100vw - 10px);
			}
			.tippy-box {
				position: relative;
				background-color: #333;
				color: #fff;
				border-radius: 4px;
				font-size: 14px;
				line-height: 1.4;
				white-space: normal;
				outline: 0;
				transition-property: transform, visibility, opacity;
			}
			.tippy-box[data-placement^='top'] > .tippy-arrow {
				bottom: 0;
			}
			.tippy-box[data-placement^='top'] > .tippy-arrow:before {
				bottom: -7px;
				left: 0;
				border-width: 8px 8px 0;
				border-top-color: initial;
				transform-origin: center top;
			}
			.tippy-box[data-placement^='bottom'] > .tippy-arrow {
				top: 0;
			}
			.tippy-box[data-placement^='bottom'] > .tippy-arrow:before {
				top: -7px;
				left: 0;
				border-width: 0 8px 8px;
				border-bottom-color: initial;
				transform-origin: center bottom;
			}
			.tippy-box[data-placement^='left'] > .tippy-arrow {
				right: 0;
			}
			.tippy-box[data-placement^='left'] > .tippy-arrow:before {
				border-width: 8px 0 8px 8px;
				border-left-color: initial;
				right: -7px;
				transform-origin: center left;
			}
			.tippy-box[data-placement^='right'] > .tippy-arrow {
				left: 0;
			}
			.tippy-box[data-placement^='right'] > .tippy-arrow:before {
				left: -7px;
				border-width: 8px 8px 8px 0;
				border-right-color: initial;
				transform-origin: center right;
			}
			.tippy-box[data-inertia][data-state='visible'] {
				transition-timing-function: cubic-bezier(0.54, 1.5, 0.38, 1.11);
			}
			.tippy-arrow {
				width: 16px;
				height: 16px;
				color: #333;
			}
			.tippy-arrow:before {
				content: '';
				position: absolute;
				border-color: transparent;
				border-style: solid;
			}
			.tippy-content {
				position: relative;
				padding: 5px 9px;
				z-index: 1;
			}
			.s-UdDNsCxEGJ1I {
			}
			.tippy-box[data-animation='fade'][data-state='hidden'] {
				opacity: 0;
			}
			[data-tippy-root] {
				max-width: calc(100vw - 10px);
			}
			.tippy-box {
				position: relative;
				background-color: #333;
				color: #fff;
				border-radius: 4px;
				font-size: 14px;
				line-height: 1.4;
				white-space: normal;
				outline: 0;
				transition-property: transform, visibility, opacity;
			}
			.tippy-box[data-placement^='top'] > .tippy-arrow {
				bottom: 0;
			}
			.tippy-box[data-placement^='top'] > .tippy-arrow:before {
				bottom: -7px;
				left: 0;
				border-width: 8px 8px 0;
				border-top-color: initial;
				transform-origin: center top;
			}
			.tippy-box[data-placement^='bottom'] > .tippy-arrow {
				top: 0;
			}
			.tippy-box[data-placement^='bottom'] > .tippy-arrow:before {
				top: -7px;
				left: 0;
				border-width: 0 8px 8px;
				border-bottom-color: initial;
				transform-origin: center bottom;
			}
			.tippy-box[data-placement^='left'] > .tippy-arrow {
				right: 0;
			}
			.tippy-box[data-placement^='left'] > .tippy-arrow:before {
				border-width: 8px 0 8px 8px;
				border-left-color: initial;
				right: -7px;
				transform-origin: center left;
			}
			.tippy-box[data-placement^='right'] > .tippy-arrow {
				left: 0;
			}
			.tippy-box[data-placement^='right'] > .tippy-arrow:before {
				left: -7px;
				border-width: 8px 8px 8px 0;
				border-right-color: initial;
				transform-origin: center right;
			}
			.tippy-box[data-inertia][data-state='visible'] {
				transition-timing-function: cubic-bezier(0.54, 1.5, 0.38, 1.11);
			}
			.tippy-arrow {
				width: 16px;
				height: 16px;
				color: #333;
			}
			.tippy-arrow:before {
				content: '';
				position: absolute;
				border-color: transparent;
				border-style: solid;
			}
			.tippy-content {
				position: relative;
				padding: 5px 9px;
				z-index: 1;
			}
			.s-KjPfieA6wgHW {
			}
			.lottie-player.s-qj4I1T-sSF2O {
				box-sizing: border-box;
				display: flex;
				flex-direction: column;
				transition: box-shadow 0.6s;
			}
			.lottie-player.is-zoomed.s-qj4I1T-sSF2O {
				position: absolute;
				top: 0;
				left: 0;
				right: 0;
				box-shadow: 0px 0px 56px -14px rgba(0, 0, 0, 0.6);
				margin: 100px;
				border-radius: 6px;
			}
			.animation.s-qj4I1T-sSF2O {
				overflow: hidden;
			}
			.lottie-player-error.s-qj4I1T-sSF2O {
				display: flex;
				justify-content: center;
				height: 100%;
				align-items: center;
			}
			.s-qj4I1T-sSF2O {
			}
			.lottie-player-controls.s-3wExF9IcTfDu.s-3wExF9IcTfDu {
				align-items: center;
				display: flex;
				justify-content: space-between;
				padding: 4px 8px;
				font-family:
					'Lucida Sans', 'Lucida Sans Regular', 'Lucida Grande', 'Lucida Sans Unicode', Geneva,
					Verdana, sans-serif !important;
			}
			.lottie-player-controls.s-3wExF9IcTfDu > div.s-3wExF9IcTfDu {
				margin-left: 4px;
			}
			.spacer.s-3wExF9IcTfDu.s-3wExF9IcTfDu {
				flex-grow: 1;
				width: 14px;
			}
			.btn.s-3wExF9IcTfDu.s-3wExF9IcTfDu {
				cursor: pointer;
				fill: #999;
				width: 14px;
			}
			.btn.s-3wExF9IcTfDu.s-3wExF9IcTfDu:hover {
				fill: #222;
			}
			.btn.active.s-3wExF9IcTfDu.s-3wExF9IcTfDu {
				fill: #555;
			}
			.progress.s-3wExF9IcTfDu.s-3wExF9IcTfDu {
				-webkit-appearance: none;
				-moz-apperance: none;
				width: 100%;
				margin: 0 10px;
				height: 4px;
				border-radius: 3px;
				cursor: pointer;
			}
			.progress.s-3wExF9IcTfDu.s-3wExF9IcTfDu:focus {
				outline: none;
				border: none;
			}
			.progress.s-3wExF9IcTfDu.s-3wExF9IcTfDu::-moz-range-track {
				cursor: pointer;
				background: none;
				border: none;
				outline: none;
			}
			.progress.s-3wExF9IcTfDu.s-3wExF9IcTfDu::-webkit-slider-thumb {
				-webkit-appearance: none !important;
				height: 13px;
				width: 13px;
				border: 0;
				border-radius: 50%;
				background: #0fccce;
				cursor: pointer;
			}
			.progress.s-3wExF9IcTfDu.s-3wExF9IcTfDu::-moz-range-thumb {
				-moz-appearance: none !important;
				height: 13px;
				width: 13px;
				border: 0;
				border-radius: 50%;
				background: #0fccce;
				cursor: pointer;
			}
			.progress.s-3wExF9IcTfDu.s-3wExF9IcTfDu::-ms-track {
				width: 100%;
				height: 3px;
				cursor: pointer;
				background: transparent;
				border-color: transparent;
				color: transparent;
			}
			.progress.s-3wExF9IcTfDu.s-3wExF9IcTfDu::-ms-fill-lower {
				background: #ccc;
				border-radius: 3px;
			}
			.progress.s-3wExF9IcTfDu.s-3wExF9IcTfDu::-ms-fill-upper {
				background: #ccc;
				border-radius: 3px;
			}
			.progress.s-3wExF9IcTfDu.s-3wExF9IcTfDu::-ms-thumb {
				border: 0;
				height: 15px;
				width: 15px;
				border-radius: 50%;
				background: #0fccce;
				cursor: pointer;
			}
			.progress.s-3wExF9IcTfDu.s-3wExF9IcTfDu:focus::-ms-fill-lower {
				background: #ccc;
			}
			.progress.s-3wExF9IcTfDu.s-3wExF9IcTfDu:focus::-ms-fill-upper {
				background: #ccc;
			}
			.popover.s-3wExF9IcTfDu.s-3wExF9IcTfDu {
				padding: 10px;
				background: #fff;
				font-family:
					'Lucida Sans', 'Lucida Sans Regular', 'Lucida Grande', 'Lucida Sans Unicode', Geneva,
					Verdana, sans-serif;
				font-size: 0.75rem;
				border-radius: 5px;
			}
			.popover-snapshot.s-3wExF9IcTfDu.s-3wExF9IcTfDu {
				width: 150px;
			}
			.popover-snapshot.s-3wExF9IcTfDu h5.s-3wExF9IcTfDu {
				margin: 5px 0 10px 0;
				font-size: 0.75rem;
			}
			.popover-snapshot.s-3wExF9IcTfDu a.s-3wExF9IcTfDu {
				display: block;
				text-decoration: none;
			}
			.popover-snapshot.s-3wExF9IcTfDu a.s-3wExF9IcTfDu:before {
				content: 'â¥¼';
				margin-right: 5px;
			}
			.popover-snapshot.s-3wExF9IcTfDu .note.s-3wExF9IcTfDu {
				display: block;
				margin-top: 10px;
				color: #999;
			}
			.popover-info.s-3wExF9IcTfDu.s-3wExF9IcTfDu {
				width: 250px;
			}
			.frame-number.s-3wExF9IcTfDu.s-3wExF9IcTfDu {
				outline: none;
				border: 1px #ccc solid;
				border-radius: 3px;
				width: 40px;
				text-align: center;
				color: #999;
				font-size: 0.7rem;
				padding: 0;
				font-family: inherit;
			}
			.popover-background.s-3wExF9IcTfDu.s-3wExF9IcTfDu {
				width: 350px;
			}
			.s-3wExF9IcTfDu.s-3wExF9IcTfDu {
			}
			.text-input.s-FAR6CNS3AKMk.s-FAR6CNS3AKMk {
				border: 1px #ccc solid;
				border-radius: 5px;
				padding: 3px;
				width: 60px;
				margin: 0;
			}
			.color-picker.s-FAR6CNS3AKMk.s-FAR6CNS3AKMk {
				display: flex;
				flex-direction: row;
				justify-content: space-between;
				height: 90px;
			}
			.color-selectors.s-FAR6CNS3AKMk.s-FAR6CNS3AKMk {
				display: flex;
				flex-direction: column;
				justify-content: space-between;
			}
			.color-component.s-FAR6CNS3AKMk.s-FAR6CNS3AKMk {
				display: flex;
				flex-direction: row;
				font-size: 12px;
				align-items: center;
				justify-content: center;
			}
			.color-component.s-FAR6CNS3AKMk strong.s-FAR6CNS3AKMk {
				width: 40px;
			}
			.color-component.s-FAR6CNS3AKMk input[type='range'].s-FAR6CNS3AKMk {
				margin: 0 0 0 10px;
			}
			.color-component.s-FAR6CNS3AKMk input[type='number'].s-FAR6CNS3AKMk {
				width: 50px;
				margin: 0 0 0 10px;
			}
			.color-preview.s-FAR6CNS3AKMk.s-FAR6CNS3AKMk {
				font-size: 12px;
				display: flex;
				flex-direction: column;
				align-items: center;
				justify-content: space-between;
			}
			.preview.s-FAR6CNS3AKMk.s-FAR6CNS3AKMk {
				height: 60px;
				width: 60px;
			}
			.s-FAR6CNS3AKMk.s-FAR6CNS3AKMk {
			}
			h4.s-KTHskE21cQF1 {
				font-size: 0.85rem;
				padding: 5px;
				margin: 0;
			}
			.property.s-KTHskE21cQF1 {
				display: flex;
				flex-direction: row;
				font-size: 0.75rem;
				align-items: center;
				justify-content: space-between;
				padding: 3px 5px;
			}
			.label.s-KTHskE21cQF1 {
				display: block;
				color: #999;
			}
			.value.s-KTHskE21cQF1 {
				display: block;
				color: #666;
			}
			.s-KTHskE21cQF1 {
			}
			.popover.s-oupNGAfIHUau.s-oupNGAfIHUau {
				position: relative;
			}
			.popover-content.s-oupNGAfIHUau.s-oupNGAfIHUau {
				display: inline-block;
				position: absolute;
				opacity: 1;
				visibility: visible;
				transform: translate(0, -10px);
				box-shadow: 0 2px 5px 0 rgba(0, 0, 0, 0.26);
				transition: all 0.3s cubic-bezier(0.75, -0.02, 0.2, 0.97);
			}
			.popover-content.hidden.s-oupNGAfIHUau.s-oupNGAfIHUau {
				opacity: 0;
				visibility: hidden;
				transform: translate(0, 0px);
			}
			.arrow.s-oupNGAfIHUau.s-oupNGAfIHUau {
				position: absolute;
				z-index: -1;
				content: '';
				bottom: -9px;
				border-style: solid;
				border-width: 10px 10px 0px 10px;
			}
			.left-align.s-oupNGAfIHUau.s-oupNGAfIHUau,
			.left-align.s-oupNGAfIHUau .arrow.s-oupNGAfIHUau {
				left: 0;
				right: unset;
			}
			.right-align.s-oupNGAfIHUau.s-oupNGAfIHUau,
			.right-align.s-oupNGAfIHUau .arrow.s-oupNGAfIHUau {
				right: 0;
				left: unset;
			}
			.s-oupNGAfIHUau.s-oupNGAfIHUau {
			}
		</style>
		<title>BTC Map - Error</title>
		<!-- HEAD_svelte-12p4y40_START -->
		<meta
			name="lightning"
			content="lnurlp:LNURL1DP68GURN8GHJ7CM0WFJJUCN5VDKKZUPWDAEXWTMVDE6HYMRS9ARKXVN4W5EQPSYZ34"
			class="s-7IPF32Wcq3s8"
		/>
		<meta property="alby:image" content="/images/logo.svg" class="s-7IPF32Wcq3s8" />
		<meta property="alby:name" content="BTC Map" class="s-7IPF32Wcq3s8" />
		<!-- HEAD_svelte-12p4y40_END -->
		<!-- HEAD_svelte-1gr44ch_START -->
		<meta property="og:image" content="https://btcmap.org/images/og/home.png" />
		<meta property="twitter:title" content="BTC Map" />
		<meta property="twitter:image" content="https://btcmap.org/images/og/home.png" />
		<!-- HEAD_svelte-1gr44ch_END -->
	</head>
	<body class="bg-teal dark:bg-dark">
		<div>
			<div class="bg-teal dark:bg-dark">
				<div class="relative mx-auto w-10/12 xl:w-[1200px]">
					<header>
						<a href="/"><img src="/images/logo.svg" alt="logo" class="mx-auto w-32 py-5" /></a>
					</header>

					<div class="space-y-10 py-10 text-center">
						<a href="/" class="text-xl font-semibold text-link transition-colors hover:text-hover"
							>Home</a
						>
						<h1 class="text-4xl text-primary md:text-5xl dark:text-white">
							%sveltekit.status%: %sveltekit.error.message%
						</h1>
						<h2 class="text-xl font-semibold text-primary dark:text-white">
							Please try again or contact BTC Map.
						</h2>
					</div>

					<footer class="flex flex-wrap justify-center gap-5 pb-5">
						<a
							href="https://x.com/btcmap"
							target="_blank"
							rel="noreferrer"
							class="inline-block rounded-full bg-link p-2 text-white transition-colors hover:bg-hover dark:bg-white/[0.15] dark:hover:bg-link"
							><svg width="28px" height="28px">
								<use width="28px" height="28px" href="/icons/spritesheet-socials.svg#x"></use></svg
						></a>
						<a
							href="https://nostr.com/npub1864jglrrhv6alguwql9pqtmd5296nww5dpcewapmmcazk8vq4mks0tt2tq"
							target="_blank"
							rel="noreferrer"
							class="inline-block rounded-full bg-link p-2 text-white transition-colors hover:bg-hover dark:bg-white/[0.15] dark:hover:bg-link"
							><svg width="28px" height="28px">
								<use
									width="28px"
									height="28px"
									href="/icons/spritesheet-socials.svg#nostr"
								></use></svg
						></a>
						<a
							href="https://discord.gg/wPqva83uzq"
							target="_blank"
							rel="noreferrer"
							class="inline-block rounded-full bg-link p-2 text-white transition-colors hover:bg-hover dark:bg-white/[0.15] dark:hover:bg-link"
							><svg width="28px" height="28px">
								<use
									width="28px"
									height="28px"
									href="/icons/spritesheet-socials.svg#discord"
								></use></svg
						></a>
						<a
							href="https://github.com/teambtcmap"
							target="_blank"
							rel="noreferrer"
							class="inline-block rounded-full bg-link p-2 text-white transition-colors hover:bg-hover dark:bg-white/[0.15] dark:hover:bg-link"
							><svg width="28px" height="28px">
								<use
									width="28px"
									height="28px"
									href="/icons/spritesheet-socials.svg#github"
								></use></svg
						></a>
						<a
							href="https://amboss.space/community/edf8d227-9bc7-4cb2-af2a-66c1b455109a"
							target="_blank"
							rel="noreferrer"
							class="inline-block rounded-full bg-link p-2 text-white transition-colors hover:bg-hover dark:bg-white/[0.15] dark:hover:bg-link"
							><svg width="28px" height="28px">
								<use
									width="28px"
									height="28px"
									href="/icons/spritesheet-socials.svg#amboss"
								></use></svg
						></a>
					</footer>
				</div>
			</div>
			<ul class="_toastContainer s--bA00mryVvOe"></ul>
		</div>
	</body>
</html>



================================================
FILE: src/service-worker.ts
================================================
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-nocheck

/// <reference types="@sveltejs/kit" />
/// <reference no-default-lib="true"/>
/// <reference lib="esnext" />
/// <reference lib="webworker" />

const sw = /** @type {ServiceWorkerGlobalScope} */ /** @type {unknown} */ self;
import { build, files, version } from '$service-worker';

// Create a unique cache name for this deployment
const CACHE = `cache-${version}`;

const ASSETS = [
	...build, // the app itself
	...files // everything in `static`
];

sw.addEventListener('install', (event) => {
	// Create a new cache and add offline file to it
	async function addFileToCache() {
		const cache = await caches.open(CACHE);
		await cache.addAll(['/offline.html', '/images/logo.svg']);
	}

	event.waitUntil(addFileToCache());
});

sw.addEventListener('activate', (event) => {
	// Remove previous cached data from disk
	async function deleteOldCaches() {
		for (const key of await caches.keys()) {
			if (key !== CACHE) await caches.delete(key);
		}
	}

	event.waitUntil(deleteOldCaches());
});

sw.addEventListener('message', (event) => {
	async function cacheAssets() {
		// Create a new cache and add all files to it
		const cache = await caches.open(CACHE);
		const cached = await cache.match('/cached.txt');

		if (cached) return;

		await cache.addAll(ASSETS);
	}

	if (event.data === 'CACHE_ASSETS') {
		event.waitUntil(cacheAssets());
	}
});

sw.addEventListener('fetch', (event) => {
	// ignore POST requests etc
	if (event.request.method !== 'GET') return;

	// ignore requests from chrome-extension etc
	if (event.request.url.indexOf('http') === -1) return;

	async function respond() {
		const url = new URL(event.request.url);
		const cache = await caches.open(CACHE);

		// Don't cache external map tile/style/sprite resources to prevent stale map data
		// Map styles and sprites can change, and caching them causes issues like missing icons
		// Exception: fonts are stable and benefit from caching for repeat visitors
		const isFontResource =
			url.hostname === 'tiles.openfreemap.org' && url.pathname.includes('/fonts/');
		const isMapResource =
			(url.hostname === 'tiles.openfreemap.org' && !isFontResource) ||
			(url.hostname === 'static.btcmap.org' && url.pathname.includes('map-styles'));

		// `build`/`files` can always be served from the cache
		if (ASSETS.includes(url.pathname)) {
			const res = await cache.match(url.pathname);
			if (res) return res;
		}

		// for everything else, try the network first, but
		// fall back to the cache if we're offline
		try {
			const response = await fetch(event.request);

			// Only cache non-map resources to avoid serving stale map styles/sprites
			if (response.status === 200 && !isMapResource) {
				cache.put(event.request, response.clone());
			}

			return response;
		} catch {
			const cachedPage = await cache.match(event.request);

			if (cachedPage && cachedPage.status === 200) {
				return cachedPage;
			} else {
				return cache.match('/offline.html');
			}
		}
	}

	event.respondWith(respond());
});



================================================
FILE: src/components/Boost.svelte
================================================
<script lang="ts">
	import { invalidateAll } from '$app/navigation';
	import CloseButton from '$components/CloseButton.svelte';
	import { boost, resetBoost, lastUpdatedPlaceId } from '$lib/store';
	import OutClick from 'svelte-outclick';
	import { fly } from 'svelte/transition';
	import BoostContent from '$components/BoostContent.svelte';

	let boostComplete = false;

	const closeModal = () => {
		if (boostComplete) {
			invalidateAll();
		}
		$boost = undefined;
		$resetBoost = $resetBoost + 1;
		$lastUpdatedPlaceId = undefined;
		boostComplete = false;
	};

	const handleOutClick = () => {
		// Never close the boost modal on outside clicks to prevent accidental loss of progress
	};

	const handleBoostComplete = () => {
		boostComplete = true;
	};
</script>

{#if $boost}
	<OutClick on:outclick={handleOutClick}>
		<div
			transition:fly={{ y: 200, duration: 300 }}
			class="center-fixed z-[2000] max-h-[90vh] w-[90vw] overflow-auto rounded-xl border border-gray-300 bg-white p-6 text-left shadow-2xl md:w-[430px] dark:border-white/95 dark:bg-dark"
		>
			<CloseButton on:click={closeModal} />

			<BoostContent
				merchantId={$boost.id}
				merchantName={$boost.name}
				onComplete={handleBoostComplete}
			/>
		</div>
	</OutClick>
{/if}



================================================
FILE: src/components/BoostButton.svelte
================================================
<script lang="ts">
	import Icon from '$components/Icon.svelte';
	import { boost, resetBoost } from '$lib/store';
	import type { Place } from '$lib/types';
	import axios from 'axios';
	import axiosRetry from 'axios-retry';

	export let merchant: Place | undefined;
	export let boosted: string | undefined;
	export let style: 'button' | 'link' = 'button';

	axiosRetry(axios, { retries: 3, retryDelay: axiosRetry.exponentialDelay });

	let boostLoading = false;

	const resetBoostLoading = () => {
		boostLoading = false;
	};

	const startBoost = async () => {
		if (!merchant) return;

		boostLoading = true;

		$boost = {
			id: merchant.id,
			name: merchant.name || '',
			boost: boosted || ''
		};
	};

	$: $resetBoost && resetBoostLoading();
</script>

{#if style === 'button'}
	<button
		id="boost-button"
		on:click={startBoost}
		disabled={boostLoading}
		class="{boosted
			? 'bg-bitcoin hover:bg-bitcoinHover'
			: 'bg-link hover:bg-hover'} mx-auto flex w-40 items-center justify-center rounded-xl p-3 text-center font-semibold text-white transition-colors"
	>
		<Icon w="20" h="20" class="mr-1 text-white" icon="arrow_circle_up" type="material" />
		{boostLoading ? 'Boosting...' : boosted ? 'Extend Boost' : 'Boost'}
	</button>
{:else}
	<button
		id="boost-button"
		on:click={startBoost}
		disabled={boostLoading || Boolean($boost)}
		class="inline-flex items-center space-x-1 font-semibold text-link transition-colors hover:text-hover"
	>
		<Icon w="16" h="16" icon="arrow_circle_up" class="shrink-0" type="material" />
		<p class="text-sm">{boostLoading ? 'Boosting...' : boosted ? 'Extend Boost' : 'Boost'}</p>
	</button>
{/if}



================================================
FILE: src/components/BoostContent.svelte
================================================
<script lang="ts">
	import Icon from '$components/Icon.svelte';
	import IconSocials from '$lib/icons/IconSocials.svelte';
	import PrimaryButton from '$components/PrimaryButton.svelte';
	import { PAYMENT_ERROR_MESSAGE, STATUS_CHECK_ERROR_MESSAGE } from '$lib/constants';
	import { boost, boostHash, lastUpdatedPlaceId } from '$lib/store';
	import { updateSinglePlace } from '$lib/sync/places';
	import { errToast, warningToast } from '$lib/utils';
	import axios from 'axios';
	import { fade } from 'svelte/transition';
	import { onDestroy } from 'svelte';
	import InvoicePaymentStage from '$components/InvoicePaymentStage.svelte';

	export let merchantId: number | string;
	export let merchantName: string | undefined = undefined;
	export let onComplete: (() => void) | undefined = undefined;

	let stage = 0;

	const values = [
		{ sats: 5000, time: 1 },
		{ sats: 10000, time: 3 },
		{ sats: 30000, time: 12 }
	];

	let tooltip = false;
	let selectedBoost: { sats: number; time: number; expires: Date } | undefined;
	let invoice = '';
	let invoiceId = '';
	let loading = false;

	onDestroy(() => {
		stage = 0;
		invoice = '';
		invoiceId = '';
		loading = false;
		selectedBoost = undefined;
		tooltip = false;
	});

	const handlePaymentSuccess = async () => {
		if ($boostHash === invoiceId) {
			return;
		}
		$boostHash = invoiceId;

		try {
			const response = await axios.post('/api/boost/post', {
				invoice_id: invoiceId
			});

			stage = 2;
			console.info(response);

			if (merchantId) {
				await updateSinglePlace(merchantId);
				lastUpdatedPlaceId.set(Number(merchantId));
			}

			if (onComplete) {
				onComplete();
			}
		} catch (error) {
			warningToast('Could not finalize boost, please contact BTC Map.');
			console.error(error);
		}
	};

	const handlePaymentError = (error: unknown) => {
		console.error('Payment error:', error);
	};

	const handleStatusCheckError = (error: unknown) => {
		errToast(STATUS_CHECK_ERROR_MESSAGE);
		console.error(error);
	};

	const generateInvoice = () => {
		loading = true;

		const timeToDays: Record<number, number> = { 1: 30, 3: 90, 12: 365 };
		const days = selectedBoost?.time
			? timeToDays[selectedBoost.time] || selectedBoost.time
			: undefined;

		if (!days || days <= 0) {
			errToast('Invalid boost duration');
			loading = false;
			return;
		}

		const placeId = Number(merchantId);
		if (!placeId || isNaN(placeId)) {
			errToast('Invalid merchant ID');
			loading = false;
			return;
		}

		axios
			.post('/api/boost/invoice/generate', {
				place_id: placeId,
				days: days
			})
			.then(function (response) {
				invoice = response.data.invoice;
				invoiceId = response.data.invoice_id;
				stage = 1;
				loading = false;
			})
			.catch(function (error) {
				errToast(PAYMENT_ERROR_MESSAGE);
				console.error(error);
				loading = false;
			});
	};
</script>

{#if stage === 0}
	<div class="space-y-4">
		<div>
			<p class="mb-2 text-xl font-bold text-primary dark:text-white">Boost Location</p>

			<p class="text-sm text-body dark:text-white">
				Make this merchant stand out in bitcoin orange on the map, shine in the search results, and
				be discovered in the exclusive boosted locations map!
			</p>

			<button
				on:mouseenter={() => (tooltip = true)}
				on:mouseleave={() => (tooltip = false)}
				class="relative text-sm text-link transition-colors hover:text-hover"
				>See how it looks
				{#if tooltip}
					<div
						transition:fade={{ delay: 0, duration: 100 }}
						class="absolute -top-16 left-[26px] w-[52px] rounded-lg border border-gray-300 bg-white py-2 shadow-lg dark:border-white/95 dark:bg-dark"
					>
						<img
							src="/icons/boosted-icon-pin.svg"
							alt="Boosted pin"
							class="mx-auto"
							width="32"
							height="43"
						/>
						<Icon
							w="20"
							h="20"
							class="absolute top-3.5 left-[15px] animate-wiggle text-white"
							icon="currency_bitcoin"
							type="material"
						/>
					</div>
				{/if}
			</button>
		</div>

		<div class="space-y-2 md:flex md:space-y-0 md:space-x-2">
			{#each values as value, index (index)}
				<button
					on:click={() => {
						let dateNow = new Date();
						let currentBoost =
							$boost && $boost.boost && new Date($boost.boost) > dateNow
								? new Date($boost.boost)
								: undefined;
						selectedBoost = {
							sats: value.sats,
							time: value.time,
							expires: currentBoost
								? new Date(currentBoost.setMonth(currentBoost.getMonth() + value.time))
								: new Date(dateNow.setMonth(dateNow.getMonth() + value.time))
						};
					}}
					class="relative w-full space-y-0.5 rounded-xl border-2 py-1 {selectedBoost &&
					selectedBoost.time === value.time
						? 'border-link text-link'
						: 'border-gray-300 text-primary dark:border-white/95 dark:text-white'} text-center transition-colors hover:border-link hover:text-link dark:hover:text-link"
				>
					{#if value.time === 3}
						<img src="/icons/star.svg" alt="star" class="absolute top-1 right-1" />
					{/if}

					<p class="text-xs">{value.time} month{value.time > 1 ? 's' : ''}</p>
					<p class="font-bold">{value.sats.toLocaleString()} sats</p>
				</button>
			{/each}
		</div>

		<p class="text-xs text-body dark:text-white">
			The fee is used to support the BTC Map open source project and continue it's development.
		</p>

		<PrimaryButton
			style="w-full rounded-xl p-3 {!selectedBoost ? 'opacity-50 hover:bg-link' : ''}"
			disabled={!selectedBoost || loading}
			{loading}
			on:click={generateInvoice}
		>
			{selectedBoost
				? `Boost for ${selectedBoost.time} month${selectedBoost.time > 1 ? 's' : ''}`
				: 'Boost'}
		</PrimaryButton>
	</div>
{:else if stage === 1}
	<InvoicePaymentStage
		{invoice}
		{invoiceId}
		onSuccess={handlePaymentSuccess}
		onError={handlePaymentError}
		onStatusCheckError={handleStatusCheckError}
		description={selectedBoost
			? `Boost this location for <strong>${selectedBoost.time} month${selectedBoost.time > 1 ? 's' : ''} <br /> ${selectedBoost.sats.toLocaleString()} sats</strong>`
			: ''}
	/>
{:else}
	<div class="space-y-4 text-center">
		<p
			class="text-xl font-bold text-primary dark:text-white {merchantName?.match('([^ ]{14})')
				? 'break-all'
				: ''}"
		>
			Thank you for supporting {merchantName || 'this location'} & BTC Map!
		</p>

		<p class="text-body dark:text-white">
			This location will be boosted until <br />
			<strong
				>{selectedBoost?.expires.toLocaleDateString(undefined, {
					year: 'numeric',
					month: 'long',
					day: 'numeric'
				})}</strong
			>
		</p>

		<a
			href="https://twitter.com/share?text=I just boosted {merchantName
				? encodeURIComponent(merchantName)
				: 'this location'} on @btcmap. Check them out!&url=https://btcmap.org/merchant/{merchantId}&hashtags=bitcoin"
			target="_blank"
			rel="noreferrer"
			class="mx-auto flex w-[200px] items-center justify-center rounded-xl bg-twitter py-3 text-white"
			>Share on Twitter <IconSocials w="24" h="24" class="ml-2" icon="x" /></a
		>

		<p class="text-sm text-body dark:text-white">
			Sharing your support may encourage <br /> others to show theirs ğŸ¥°
		</p>
	</div>
{/if}



================================================
FILE: src/components/Breadcrumbs.svelte
================================================
<script lang="ts">
	import Icon from '$components/Icon.svelte';
	type Routes = { name: string; url: string }[];
	export let routes: Routes;
</script>

<div
	class="-mx-10 flex w-full flex-wrap items-center gap-3 px-4 py-5 md:mx-auto xl:w-[1200px] xl:px-0"
>
	{#each routes as route, index (index)}
		<!-- eslint-disable svelte/no-navigation-without-resolve -->
		<a
			href={route.url}
			class="text-sm text-link transition-colors hover:text-hover {index === routes.length - 1
				? 'font-bold'
				: 'font-normal'}"
		>
			<!-- eslint-enable svelte/no-navigation-without-resolve -->
			{route.name}
		</a>
		{#if index !== routes.length - 1}
			<Icon type="fa" icon="chevron-right" w="8" h="8" class="text-link" />
		{/if}
	{/each}
</div>



================================================
FILE: src/components/Card.svelte
================================================
<script lang="ts">
	// we could get rid of this if we use container queries: https://tailwindcss.com/docs/responsive-design#container-queries
	// but we would need to migrate to tailwindcss v4
	export let headerAlign: 'center' | 'responsive' = 'responsive';
</script>

<!-- prettier-ignore -->
<div class="flex w-full flex-col rounded-3xl border border-gray-300 dark:border-white/95 dark:bg-white/10">
	<!-- prettier-ignore -->
	<div
		class="border-b border-gray-300 p-5 text-lg font-semibold text-primary dark:border-white/95 dark:text-white {headerAlign ===
		'center'
			? 'text-center'
			: 'text-center lg:text-left'}"
	>
		<slot name="header" />
	</div>

	<div class="flex flex-1 flex-col justify-between gap-4">
		<div class="flex flex-col items-center gap-4">
			<slot name="body" />
		</div>

		{#if $$slots.footer}
			<div class="flex justify-center pb-4">
				<slot name="footer" />
			</div>
		{/if}
	</div>
</div>



================================================
FILE: src/components/CloseButton.svelte
================================================
<script lang="ts">
	export let position: string = 'flex justify-end';
	export let colors: string =
		'text-primary dark:text-white dark:hover:text-white/80 hover:text-link';

	import Icon from '$components/Icon.svelte';
</script>

<div class={position}>
	<button on:click type="button" aria-label="Close">
		<Icon w="25" h="25" class="{colors} transition-colors" icon="close_round" />
	</button>
</div>



================================================
FILE: src/components/CopyButton.svelte
================================================
<script lang="ts">
	import Icon from '$components/Icon.svelte';

	export let value: string;

	let copied = false;

	const copy = (field: string) => {
		navigator.clipboard.writeText(field);
		copied = true;
		setTimeout(() => (copied = false), 2100);
	};
</script>

<button class="text-link transition-colors hover:text-hover" on:click={() => copy(value)}>
	{#if copied}
		<Icon type="fa" icon="check" w="24" h="24" />
	{:else}
		<Icon type="fa" icon="clipboard" w="24" h="24" />
	{/if}
</button>



================================================
FILE: src/components/Countdown.svelte
================================================
<script lang="ts">
	export let date: string;
	export let style = '';

	import { onDestroy } from 'svelte';

	// Set the date we're counting down to
	const countDownDate = new Date(date).getTime();

	let days: string | number = '- -';
	let hours: string | number = '- -';
	let minutes: string | number = '- -';
	let seconds: string | number = '- -';
	let distance = 0;

	// Update the count down every 1 second
	const timer = setInterval(function () {
		// Get today's date and time
		const now = new Date().getTime();

		// Find the distance between now and the count down date
		distance = countDownDate - now;

		// Time calculations for days, hours, minutes and seconds
		days = Math.floor(distance / (1000 * 60 * 60 * 24));
		hours = Math.floor((distance % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
		minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));
		seconds = Math.floor((distance % (1000 * 60)) / 1000);

		// If the count down is finished, clear the interval
		if (distance < 0) {
			clearInterval(timer);
		}
	}, 1000);

	onDestroy(() => {
		clearInterval(timer);
	});
</script>

{#if distance < 0}
	<div class={style}>0d 0h 0m 0s</div>
{:else}
	<div class={style}>{days + 'd ' + hours + 'h ' + minutes + 'm ' + seconds + 's '}</div>
{/if}



================================================
FILE: src/components/FormSuccess.svelte
================================================
<script lang="ts">
	export let type: string;
	export let text: string;
	export let issue: number;
	export let buttonWidth = 'w-52';

	import HeaderPlaceholder from '$components/layout/HeaderPlaceholder.svelte';
	import PrimaryButton from '$components/PrimaryButton.svelte';
	import { theme } from '$lib/store';
	import { detectTheme } from '$lib/utils';
</script>

<div class="mt-10 flex items-center justify-center pb-20 text-center md:pb-32">
	<div>
		{#if typeof window !== 'undefined'}
			<h2
				class="{detectTheme() === 'dark' || $theme === 'dark'
					? 'text-white'
					: 'gradient'} mb-5 text-4xl font-semibold"
			>
				{type} Submitted!
			</h2>
		{:else}
			<HeaderPlaceholder />
		{/if}
		<p class="mb-5 w-full text-primary md:w-[500px] dark:text-white">
			{text} You may also monitor the progress of your submission here:
			<a
				href="https://gitea.btcmap.org/teambtcmap/btcmap-data/issues/{issue}"
				target="_blank"
				rel="noreferrer"
				class="text-link transition-colors hover:text-hover">Issue #{issue}</a
			>.
		</p>

		<PrimaryButton on:click style="{buttonWidth} py-3 mx-auto mt-10 rounded-xl">
			Submit another {type.toLowerCase()}
		</PrimaryButton>
	</div>
</div>



================================================
FILE: src/components/Icon.svelte
================================================
<script lang="ts">
	import IconIconify from '@iconify/svelte';

	export let w: string;
	export let h: string;
	let className: string | undefined = undefined;
	export { className as class };
	export let icon: string;
	export let type: 'material' | 'fa' = 'material';

	const materialExceptions: Record<string, string> = {
		camping: 'material-symbols:camping-rounded',
		gate: 'material-symbols:gate',
		cooking: 'material-symbols:cooking',
		dentistry: 'material-symbols:dentistry',
		sauna: 'material-symbols:sauna',
		info_outline: 'material-symbols:info-outline',
		skull: 'material-symbols:skull',
		currency_bitcoin: 'material-symbols:currency-bitcoin',
		close_round: 'ic:round-close'
	};

	const faBrandIcons = ['x-twitter', 'instagram', 'facebook', 'twitter'];

	$: formattedIcon =
		type === 'material'
			? materialExceptions[icon] || `ic:outline-${icon.replace(/_/g, '-')}`
			: faBrandIcons.includes(icon)
				? `fa6-brands:${icon}`
				: `fa6-solid:${icon}`;
</script>

<IconIconify icon={formattedIcon} width={w} height={h} class={className} />



================================================
FILE: src/components/InfoTooltip.svelte
================================================
<script lang="ts">
	export let tooltip: string;
	import tippy from 'tippy.js';
	import Icon from '$components/Icon.svelte';

	let infoTooltip: HTMLButtonElement;

	$: infoTooltip &&
		tippy([infoTooltip], {
			content: tooltip
		});
</script>

<button bind:this={infoTooltip}>
	<Icon
		type="fa"
		icon="circle-info"
		w="16"
		h="16"
		class="inline align-middle text-base text-primary dark:text-white"
	/>
</button>



================================================
FILE: src/components/InvoicePayment.svelte
================================================
<script lang="ts">
	import {
		CONFETTI_CANVAS_Z_INDEX,
		POLLING_INTERVAL,
		QR_CODE_SIZE,
		PAYMENT_ERROR_MESSAGE,
		BREAKPOINTS
	} from '$lib/constants';
	import { pollInvoiceStatus, isInvoicePaid } from '$lib/payment';
	import { errToast } from '$lib/utils';
	import JSConfetti from 'js-confetti';
	import { tick, onDestroy } from 'svelte';
	import { invalidateAll } from '$app/navigation';

	export let invoice = '';
	export let invoiceId = '';
	export let onSuccess: () => void = () => {};
	export let onError: (error: unknown) => void = () => {};
	export let onStatusCheckError: (error: unknown) => void = () => {};

	let qr: HTMLCanvasElement;
	let polling = false;
	let pollInterval: ReturnType<typeof setInterval>;

	const jsConfetti = new JSConfetti();

	const generateQR = async () => {
		await tick();

		try {
			const QRCode = await import('qrcode');
			QRCode.default.toCanvas(
				qr,
				invoice,
				{ width: window.innerWidth > BREAKPOINTS.md ? QR_CODE_SIZE.desktop : QR_CODE_SIZE.mobile },
				function (error: Error | null | undefined) {
					if (error) {
						errToast(PAYMENT_ERROR_MESSAGE);
						console.error(error);
						onError(error);
					}
				}
			);
		} catch (error) {
			errToast('Could not load QR generator. Please try again.');
			console.error('Failed to load QRCode module:', error);
			onError(error);
		}
	};

	const checkInvoiceStatus = async () => {
		if (!invoiceId) return;

		try {
			const response = await pollInvoiceStatus(invoiceId);
			if (isInvoicePaid(response.data.status)) {
				polling = false;
				clearInterval(pollInterval);
				invalidateAll(); // Refresh UI immediately
				jsConfetti.addConfetti();
				onSuccess();
			}
		} catch (error) {
			console.error('Error checking invoice status:', error);
			onStatusCheckError(error);
		}
	};

	const startPolling = () => {
		polling = true;
		pollInterval = setInterval(checkInvoiceStatus, POLLING_INTERVAL);
	};

	const stopPolling = () => {
		if (pollInterval) {
			clearInterval(pollInterval);
			polling = false;
		}
	};

	// Generate QR when invoice changes
	$: if (invoice && qr) {
		generateQR();
	}

	// Start polling when invoiceId is set
	$: if (invoiceId && !polling) {
		startPolling();
	}

	// Set up confetti canvas z-index when QR canvas is ready
	$: if (qr) {
		const confettiCanvas = document.querySelector('canvas');
		if (confettiCanvas) {
			confettiCanvas.style.zIndex = CONFETTI_CANVAS_Z_INDEX;
		}
	}

	// Cleanup polling on component destroy
	onDestroy(() => {
		stopPolling();
	});
</script>

<canvas
	class="mx-auto h-[200px] w-[200px] rounded-2xl border-2 border-gray-300 transition-colors hover:border-link md:h-[275px] md:w-[275px] dark:border-white/95"
	bind:this={qr}
/>



================================================
FILE: src/components/InvoicePaymentStage.svelte
================================================
<script lang="ts">
	import CopyButton from '$components/CopyButton.svelte';
	import InvoicePayment from '$components/InvoicePayment.svelte';

	export let invoice: string;
	export let invoiceId: string;
	export let onSuccess: () => void | Promise<void>;
	export let onError: (error: unknown) => void;
	export let onStatusCheckError: (error: unknown) => void;
	export let description: string = '';

	// HTML description is controlled by the parent components (BoostContent)
	// Content is generated from trusted variables, not user input
	$: descriptionHtml = description;
</script>

<div class="space-y-4 text-center">
	<p class="text-xl font-bold text-primary dark:text-white">Scan or click to pay with lightning</p>

	<a href="lightning:{invoice}" class="inline-block">
		<InvoicePayment {invoice} {invoiceId} {onSuccess} {onError} {onStatusCheckError} />
	</a>

	{#if descriptionHtml}
		<p class="text-body dark:text-white">
			<!-- eslint-disable-next-line svelte/no-at-html-tags -->
			{@html descriptionHtml}
		</p>
	{/if}

	<div
		class="flex w-full items-center justify-between space-x-2 rounded-xl border-2 border-gray-300 p-2 md:justify-center dark:border-white/95"
	>
		<p class="hidden text-sm text-body md:block dark:text-white">
			{invoice.slice(0, 39)}...
		</p>
		<p class="block text-sm text-body uppercase md:hidden dark:text-white">
			Invoice <img
				src="/icons/ln-highlight.svg"
				alt="protocol"
				class="mb-1 inline dark:rounded-full dark:bg-white dark:p-0.5"
			/>
		</p>

		<CopyButton value={invoice} />
	</div>

	<slot />
</div>



================================================
FILE: src/components/IssueCell.svelte
================================================
<script lang="ts">
	import IssueIcon from '$components/IssueIcon.svelte';

	export let id: 'icon' | 'name' | 'type' | 'viewLink' | 'editLink' | 'helpLink';
	export let value: string;
</script>

{#if id === 'icon'}
	<IssueIcon icon={value} />
{:else if id === 'name'}
	{value}
{:else if id === 'type'}
	{value}
{:else if id === 'viewLink'}
	<a
		href="https://www.openstreetmap.org/{value}"
		target="_blank"
		rel="noreferrer"
		class="text-link transition-colors hover:text-hover"
	>
		View
	</a>
{:else if id === 'editLink'}
	<a
		href="https://www.openstreetmap.org/edit?{value}"
		target="_blank"
		rel="noreferrer"
		class="text-link transition-colors hover:text-hover"
	>
		Edit
	</a>
{:else if id === 'helpLink' && value}
	<!-- eslint-disable svelte/no-navigation-without-resolve -->
	<a
		href={value}
		target="_blank"
		rel="noreferrer"
		class="text-link transition-colors hover:text-hover"
	>
		<!-- eslint-enable svelte/no-navigation-without-resolve -->
		Help
	</a>
{/if}



================================================
FILE: src/components/IssueIcon.svelte
================================================
<script lang="ts">
	import Icon from '$components/Icon.svelte';
	import type { IssueIcon } from '$lib/types';

	export let icon: IssueIcon | string;

	const iconMap: Record<string, string> = {
		'fa-calendar-days': 'calendar-days',
		'fa-clipboard-question': 'clipboard-question',
		'fa-hourglass-end': 'hourglass-end',
		'fa-icons': 'icons',
		'fa-list-check': 'list-check',
		'fa-spell-check': 'spell-check',
		'fa-hourglass-half': 'hourglass-half'
	};

	$: faIcon = iconMap[icon] || 'question';
</script>

<div class="w-3 shrink-0">
	<Icon type="fa" icon={faIcon} w="12" h="12" />
</div>



================================================
FILE: src/components/IssuesTable.svelte
================================================
<script lang="ts">
	import Icon from '$components/Icon.svelte';
	import IssueCell from '$components/IssueCell.svelte';
	import { theme } from '$lib/store';
	import type { RpcIssue } from '$lib/types';
	import { debounce, detectTheme, getIssueHelpLink, getIssueIcon, isEven } from '$lib/utils';
	import { rankItem } from '@tanstack/match-sorter-utils';
	import type {
		ColumnDef,
		FilterFn,
		OnChangeFn,
		PaginationState,
		SortingState,
		Table,
		TableOptions
	} from '@tanstack/svelte-table';
	import {
		createSvelteTable,
		flexRender,
		getCoreRowModel,
		getFilteredRowModel,
		getPaginationRowModel,
		getSortedRowModel
	} from '@tanstack/svelte-table';
	import type { Readable } from 'svelte/store';
	import { writable } from 'svelte/store';

	export let title: string;
	export let issues: RpcIssue[];
	export let loading: boolean;
	export let initialPageSize = 10;

	type IssueFormatted = {
		icon: string;
		name: string;
		type: string;
		viewLink: string;
		editLink: string;
		helpLink: string | undefined;
	};

	let table: Readable<Table<IssueFormatted>> | undefined;
	let tableRendered = false;

	const pageSizes = [10, 20, 30, 40, 50];

	let globalFilter = '';
	let searchInput: HTMLInputElement;

	const handleKeyUp = (e: KeyboardEvent) => {
		$table?.setGlobalFilter(String((e.target as HTMLInputElement)?.value));
	};

	const searchDebounce = debounce((e) => handleKeyUp(e));

	const renderTable = () => {
		const data = issues.map((issue) => {
			const icon = getIssueIcon(issue.issue_code);
			const name = issue.element_name;
			var type: string = 'TODO';
			if (issue.issue_code == 'missing_icon') {
				type = 'Icon is missing';
			} else if (issue.issue_code == 'not_verified') {
				type = 'Last verification date is missing';
			} else if (issue.issue_code == 'outdated') {
				type = 'Outdated, needs re-verification';
			} else if (issue.issue_code == 'outdated_soon') {
				type = 'Soon to be outdated, needs re-verification';
			} else if (issue.issue_code.startsWith('invalid_tag_value')) {
				type = `Tag value is not formatted properly (${issue.issue_code})`;
			} else if (issue.issue_code.startsWith('misspelled_tag_name')) {
				type = `Spelling issue in tag name (${issue.issue_code})`;
			} else {
				type = issue.issue_code;
			}
			const viewLink = `${issue.element_osm_type}/${issue.element_osm_id}`;
			const editLink = `${issue.element_osm_type}=${issue.element_osm_id}`;
			const helpLink = getIssueHelpLink(issue.issue_code);
			return { icon, name, type, viewLink, editLink, helpLink };
		});

		const columns: ColumnDef<IssueFormatted>[] = [
			{
				accessorKey: 'icon',
				header: '',
				cell: (info) => flexRender(IssueCell, { id: 'icon', value: info.getValue() }),
				enableSorting: false,
				enableGlobalFilter: false
			},
			{
				accessorKey: 'name',
				header: 'Merchant Name',
				cell: (info) => flexRender(IssueCell, { id: 'name', value: info.getValue() }),
				// @ts-expect-error fuzzy filter is registered via filterFns option
				filterFn: 'fuzzy',
				enableGlobalFilter: true
			},
			{
				accessorKey: 'type',
				header: 'Description',
				cell: (info) => flexRender(IssueCell, { id: 'type', value: info.getValue() }),
				enableGlobalFilter: false
			},
			{
				accessorKey: 'viewLink',
				header: '',
				cell: (info) => flexRender(IssueCell, { id: 'viewLink', value: info.getValue() }),
				enableSorting: false,
				enableGlobalFilter: false
			},
			{
				accessorKey: 'editLink',
				header: '',
				cell: (info) => flexRender(IssueCell, { id: 'editLink', value: info.getValue() }),
				enableSorting: false,
				enableGlobalFilter: false
			},
			{
				accessorKey: 'helpLink',
				header: '',
				cell: (info) => flexRender(IssueCell, { id: 'helpLink', value: info.getValue() }),
				enableSorting: false,
				enableGlobalFilter: false
			}
		];

		let sorting: SortingState = [];

		const setSorting: OnChangeFn<SortingState> = (updater) => {
			if (updater instanceof Function) {
				sorting = updater(sorting);
			} else {
				sorting = updater;
			}
			options.update((old) => ({
				...old,
				state: {
					...old.state,
					sorting
				}
			}));
		};

		let pagination: PaginationState = {
			pageIndex: 0,
			pageSize: initialPageSize
		};

		const setPagination: OnChangeFn<PaginationState> = (updater) => {
			if (updater instanceof Function) {
				pagination = updater(pagination);
			} else {
				pagination = updater;
			}
			options.update((old) => ({
				...old,
				state: {
					...old.state,
					pagination
				}
			}));
		};

		// https://tanstack.com/table/v8/docs/framework/svelte/examples/filtering
		// eslint-disable-next-line @typescript-eslint/no-explicit-any
		const fuzzyFilter: FilterFn<any> = (row, columnId, value, addMeta) => {
			// Rank the item
			const itemRank = rankItem(row.getValue(columnId), value);

			// Store the itemRank info
			addMeta({ itemRank });

			// Return if the item should be filtered in/out
			return itemRank.passed;
		};

		const options = writable<TableOptions<IssueFormatted>>({
			data,
			columns,
			state: {
				sorting,
				pagination
			},
			filterFns: {
				fuzzy: fuzzyFilter
			},
			onSortingChange: setSorting,
			onPaginationChange: setPagination,
			globalFilterFn: fuzzyFilter,
			getCoreRowModel: getCoreRowModel(),
			getSortedRowModel: getSortedRowModel(),
			getPaginationRowModel: getPaginationRowModel(),
			getFilteredRowModel: getFilteredRowModel()
		});

		table = createSvelteTable(options);

		tableRendered = true;
	};

	$: !loading && !tableRendered && renderTable();
</script>

<section id="issues">
	<div class="w-full rounded-3xl border border-gray-300 dark:border-white/95 dark:bg-white/10">
		<h3
			class="border-b border-gray-300 p-5 text-center text-lg font-semibold text-primary md:text-left dark:border-white/95 dark:text-white"
		>
			{title}

			{#if !loading}
				({issues.length})
			{/if}
		</h3>

		{#if loading}
			<div class="p-5">
				<div
					class="flex h-[572px] w-full animate-pulse items-center justify-center rounded-3xl border border-link/50"
				>
					<Icon type="fa" icon="table" w="96" h="96" class="animate-pulse text-link/50" />
				</div>
			</div>
		{:else if !issues.length}
			<p class="w-full p-5 text-center text-primary dark:text-white">No tagging issues!</p>
		{:else if $table}
			<div class="relative text-primary dark:text-white">
				<input
					type="text"
					placeholder="Search..."
					class="w-full bg-primary/5 px-5 py-2.5 text-sm focus:outline-primary dark:bg-white/5 dark:focus:outline-white"
					bind:value={globalFilter}
					on:keyup={searchDebounce}
					bind:this={searchInput}
				/>
				{#if globalFilter}
					<button
						class="absolute top-1/2 right-3 -translate-y-1/2"
						on:click={() => {
							globalFilter = '';
							$table?.setGlobalFilter('');
						}}
					>
						<Icon type="fa" icon="circle-xmark" w="16" h="16" />
					</button>
				{:else}
					<button
						class="absolute top-1/2 right-3 -translate-y-1/2"
						on:click={() => {
							searchInput.focus();
						}}
					>
						<Icon type="fa" icon="magnifying-glass" w="16" h="16" />
					</button>
				{/if}
			</div>
			{#if $table.getFilteredRowModel().rows.length === 0}
				<p class="w-full p-5 text-center text-primary dark:text-white">No results found.</p>
			{:else}
				<div class="overflow-x-auto">
					<table class="w-full text-left whitespace-nowrap text-primary dark:text-white">
						<thead>
							{#each $table.getHeaderGroups() as headerGroup, index (index)}
								<tr>
									{#each headerGroup.headers as header, index (index)}
										<th colSpan={header.colSpan} class="px-5 pt-5 pb-2.5">
											{#if !header.isPlaceholder}
												<button
													class="flex items-center gap-x-2 select-none"
													on:click={header.column.getToggleSortingHandler()}
												>
													<svelte:component
														this={flexRender(header.column.columnDef.header, header.getContext())}
													/>
													{#if header.column.getIsSorted().toString() === 'asc'}
														<Icon type="fa" icon="caret-up" w="8" h="8" />
													{:else if header.column.getIsSorted().toString() === 'desc'}
														<Icon type="fa" icon="caret-down" w="8" h="8" />
													{/if}
												</button>
											{/if}
										</th>
									{/each}
								</tr>
							{/each}
						</thead>
						<tbody>
							{#each $table.getRowModel().rows as row, index (index)}
								<tr class={isEven(index) ? 'bg-primary/5 dark:bg-white/5' : ''}>
									{#each row.getVisibleCells() as cell, index (index)}
										<td class="px-5 py-2.5">
											<svelte:component
												this={flexRender(cell.column.columnDef.cell, cell.getContext())}
											/>
										</td>
									{/each}
								</tr>
							{/each}
						</tbody>
					</table>
				</div>

				<div
					class="flex w-full flex-col gap-5 px-5 pt-2.5 pb-5 text-primary md:flex-row md:items-center md:justify-between dark:text-white"
				>
					<select
						value={$table?.getState().pagination.pageSize}
						on:change={(e) => {
							// @ts-expect-error e.target is the select element
							$table?.setPageSize(Number(e.target?.value));
						}}
						class="cursor-pointer bg-transparent focus:outline-primary dark:focus:outline-white"
					>
						{#each pageSizes as pageSize (pageSize)}
							<option value={pageSize}>
								Show {pageSize}
							</option>
						{/each}
					</select>

					<div class="flex flex-col gap-5 md:flex-row md:items-center">
						<div class="flex items-center justify-between gap-5 md:justify-start">
							<div class="flex items-center gap-5">
								<button
									class="text-xl font-bold {!$table?.getCanPreviousPage()
										? 'cursor-not-allowed opacity-50'
										: ''}"
									on:click={() => $table?.firstPage()}
									disabled={!$table?.getCanPreviousPage()}
								>
									&lt;&lt;
								</button>
								<button
									class="text-xl font-bold {!$table?.getCanPreviousPage()
										? 'cursor-not-allowed opacity-50'
										: ''}"
									on:click={() => $table?.previousPage()}
									disabled={!$table?.getCanPreviousPage()}
								>
									&lt;
								</button>
							</div>
							<div class="flex items-center gap-5">
								<button
									class="text-xl font-bold {!$table?.getCanNextPage()
										? 'cursor-not-allowed opacity-50'
										: ''}"
									on:click={() => $table?.nextPage()}
									disabled={!$table?.getCanNextPage()}
								>
									&gt;
								</button>
								<button
									class="text-xl font-bold {!$table?.getCanNextPage()
										? 'cursor-not-allowed opacity-50'
										: ''}"
									on:click={() => $table?.lastPage()}
									disabled={!$table?.getCanNextPage()}
								>
									&gt;&gt;
								</button>
							</div>
						</div>

						<span class="flex items-center justify-center gap-1 md:justify-start">
							<div>Page</div>
							<strong>
								{$table?.getState().pagination.pageIndex + 1} of
								{$table?.getPageCount().toLocaleString()}
							</strong>
						</span>
					</div>
				</div>
			{/if}
		{/if}
	</div>
</section>

{#if typeof window !== 'undefined'}
	{#if detectTheme() === 'dark' || $theme === 'dark'}
		<style>
			select option {
				--tw-bg-opacity: 1;
				background-color: rgb(55 65 81 / var(--tw-bg-opacity));
			}
		</style>
	{/if}
{/if}



================================================
FILE: src/components/LatestTagger.svelte
================================================
<script lang="ts">
	import Tip from '$components/Tip.svelte';
	import type { EventType, User } from '$lib/types';
	import Time from 'svelte-time';
	import { resolve } from '$app/paths';

	export let location: string;
	export let action: EventType;
	export let user: User | undefined = undefined;
	export let time: string;
	export let latest: boolean;
	export let merchantId: string;

	$: deleteLink = merchantId.split(':');

	$: profile = user && user['osm_json'];
	$: regexMatch = profile && profile.description.match('(lightning:[^)]+)');
	$: lightning = regexMatch && regexMatch[0].slice(10);

	$: username = profile && profile['display_name'];
</script>

<div
	class="flex flex-col items-center gap-2 p-5 text-center text-xl lg:flex-row lg:gap-5 lg:text-left"
>
	<!-- dot -->
	<span class="relative mx-auto mb-2 flex h-3 w-3 lg:mx-0 lg:mb-0">
		<span
			class="{latest
				? 'animate-ping'
				: ''} absolute inline-flex h-full w-full rounded-full {action === 'create'
				? 'bg-created'
				: action === 'delete'
					? 'bg-deleted'
					: 'bg-link'} opacity-75"
		/>
		<span
			class="relative inline-flex h-3 w-3 rounded-full {action === 'create'
				? 'bg-created'
				: action === 'delete'
					? 'bg-deleted'
					: 'bg-link'}"
		/>
	</span>

	<div class="w-full flex-wrap items-center justify-between space-y-2 lg:flex lg:space-y-0">
		<!-- event information -->
		<div class="space-y-2 lg:space-y-0">
			<span class="text-primary lg:mr-5 dark:text-white">
				<!-- location -->
				<!-- eslint-disable svelte/no-navigation-without-resolve -->
				<a
					href={action === 'delete'
						? `https://www.openstreetmap.org/${deleteLink[0]}/${deleteLink[1]}`
						: `/merchant/${merchantId}`}
					target={action === 'delete' ? '_blank' : null}
					rel={action === 'delete' ? 'noreferrer' : null}
					class="break-all text-link transition-colors hover:text-hover"
				>
					<!-- eslint-enable svelte/no-navigation-without-resolve -->
					{location}
					{#if action === 'delete'}
						<svg
							class="inline"
							width="16"
							height="16"
							viewBox="0 0 16 16"
							fill="none"
							xmlns="http://www.w3.org/2000/svg"
						>
							<path
								d="M3 13L13 3M13 3H5.5M13 3V10.5"
								stroke="currentColor"
								stroke-width="1.5"
								stroke-linecap="round"
								stroke-linejoin="round"
							/>
						</svg>
					{/if}
				</a>

				<!-- action -->
				was
				<strong>{action}d</strong>

				<!-- user -->
				{#if user && username}
					by <a
						href={resolve(`/tagger/${user.id}`)}
						class="block break-all text-link transition-colors hover:text-hover lg:inline"
						>{username}
					</a>
				{/if}
			</span>

			<!-- time ago -->
			<span
				class="block text-center font-semibold text-taggerTime lg:inline dark:text-white/70 {lightning
					? 'lg:mr-5'
					: ''}"
			>
				<Time live={3000} relative timestamp={time} />
			</span>
		</div>

		<!-- lightning tip button -->
		{#if lightning}
			<Tip destination={lightning} class="mx-auto block lg:mx-0 lg:inline" />
		{/if}
	</div>
</div>



================================================
FILE: src/components/LoadingSpinner.svelte
================================================
<script lang="ts">
	export let color = 'text-white';
	export let size = 'h-6 w-6';
	export let style: undefined | string = undefined;
</script>

<svg
	class="{style} animate-spin {size} {color} mx-auto"
	xmlns="http://www.w3.org/2000/svg"
	fill="none"
	viewBox="0 0 24 24"
>
	<circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4" />
	<path
		class="opacity-75"
		fill="currentColor"
		d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
	/>
</svg>



================================================
FILE: src/components/MapLoadingEmbed.svelte
================================================
<script lang="ts">
	export let style: undefined | string = undefined;

	import LoadingSpinner from '$components/LoadingSpinner.svelte';
</script>

<div
	class="w-full {style} absolute top-0 left-0 z-[25] flex items-center justify-center bg-teal dark:bg-dark"
>
	<div class="space-y-6">
		<LoadingSpinner color="text-link" />
		<p class="text-center font-semibold text-primary dark:text-white">Loading map...</p>
	</div>
</div>



================================================
FILE: src/components/MapLoadingMain.svelte
================================================
<script lang="ts">
	export let progress: number | undefined;
	export let status: string | undefined = undefined;

	import { fade } from 'svelte/transition';

	let shouldHide = false;

	// Watch for 100% completion to hide
	$: if (progress === 100) {
		shouldHide = true;
	}

	// Reset shouldHide when progress is actively loading (> 0 and < 100)
	$: if (progress !== undefined && progress > 0 && progress < 100) {
		shouldHide = false;
	}

	// Show loading indicator only when actively loading (progress > 0) and not hidden
	// Also create a typed variable for use in template
	$: shouldShow = progress !== undefined && progress > 0 && !shouldHide;
	$: displayProgress = progress ?? 0; // Provide fallback for template usage
</script>

{#if shouldShow}
	<div
		out:fade={{ delay: 1000 }}
		class="absolute top-1/2 left-1/2 z-[10000] -translate-x-1/2 -translate-y-1/2 space-y-2 rounded-lg border-2 border-primary bg-teal p-4 drop-shadow-2xl dark:border-white dark:bg-dark"
	>
		<p class="text-center text-primary dark:text-white">
			{status || 'Loading map...'}
		</p>

		<div class="mx-auto w-[200px] rounded-full bg-link/25">
			<div
				class="h-2 min-w-2 rounded-full bg-link transition-all duration-500"
				style:width={displayProgress.toString() + '%'}
			/>
		</div>

		{#if displayProgress > 0 && displayProgress < 100}
			<p class="text-center text-xs text-primary/75 dark:text-white/75">
				{Math.round(displayProgress)}%
			</p>
		{/if}
	</div>
{/if}



================================================
FILE: src/components/MerchantDetailsContent.svelte
================================================
<script lang="ts">
	import Icon from '$components/Icon.svelte';
	import { formatVerifiedHuman } from '$lib/utils';
	import { resolve } from '$app/paths';
	import Time from 'svelte-time';
	import type { Place } from '$lib/types';
	import PaymentMethodIcon from '$components/PaymentMethodIcon.svelte';

	export let merchant: Place;
	export let isUpToDate: boolean;
	export let isBoosted: boolean;
	export let boostLoading: boolean;
	export let onBoostClick: () => void;
	export let isLoading: boolean = false;
</script>

<div class="space-y-4">
	{#if merchant.name}
		<a
			href={resolve(`/merchant/${merchant.id}`)}
			class="inline-block text-xl leading-snug font-bold text-link transition-colors hover:text-hover"
			title="Merchant name"
		>
			{merchant.name}
		</a>
	{:else if isLoading}
		<div class="h-7 w-3/4 animate-pulse rounded-lg bg-link/50"></div>
	{/if}

	{#if merchant.address}
		<p class="text-body dark:text-white" title="Address">
			{merchant.address}
		</p>
	{:else if isLoading}
		<div class="h-5 w-1/2 animate-pulse rounded bg-link/50"></div>
	{/if}

	{#if merchant.opening_hours}
		<div class="flex items-start space-x-2" title="Opening hours">
			<Icon
				w="16"
				h="16"
				class="mt-1 shrink-0 text-primary dark:text-white"
				icon="schedule"
				type="material"
			/>
			<span class="text-body dark:text-white">{merchant.opening_hours}</span>
		</div>
	{/if}

	<div class="grid grid-cols-2 gap-2">
		<a
			href="geo:{merchant.lat},{merchant.lon}"
			class="flex flex-col items-center rounded-lg border border-gray-300 py-3 text-primary transition-colors hover:border-link hover:text-link dark:border-white/95 dark:text-white dark:hover:text-link"
		>
			<Icon w="24" h="24" icon="explore" type="material" />
			<span class="mt-1 text-xs">Navigate</span>
		</a>

		<!-- eslint-disable svelte/no-navigation-without-resolve -->
		<!-- External link to OpenStreetMap -->
		<a
			href={merchant.osm_url || `https://www.openstreetmap.org/node/${merchant.id}`}
			target="_blank"
			rel="noreferrer"
			class="flex flex-col items-center rounded-lg border border-gray-300 py-3 text-primary transition-colors hover:border-link hover:text-link dark:border-white/95 dark:text-white dark:hover:text-link"
		>
			<Icon w="24" h="24" icon="edit" type="material" />
			<span class="mt-1 text-xs">Edit</span>
		</a>
		<!-- eslint-enable svelte/no-navigation-without-resolve -->

		<a
			href={resolve(`/merchant/${merchant.id}`)}
			class="flex flex-col items-center rounded-lg border border-gray-300 py-3 text-primary transition-colors hover:border-link hover:text-link dark:border-white/95 dark:text-white dark:hover:text-link"
		>
			<Icon w="24" h="24" icon="share" type="material" />
			<span class="mt-1 text-xs">Share</span>
		</a>

		<a
			href={resolve(`/merchant/${merchant.id}#comments`)}
			class="flex flex-col items-center rounded-lg border border-gray-300 py-3 text-primary transition-colors hover:border-link hover:text-link dark:border-white/95 dark:text-white dark:hover:text-link"
		>
			<div class="text-lg font-bold">
				{merchant.comments || 0}
			</div>
			<span class="mt-1 text-xs">Comments</span>
		</a>
	</div>

	<div class="border-t border-gray-300 pt-4 dark:border-white/95">
		{#if merchant['osm:payment:onchain'] || merchant['osm:payment:lightning'] || merchant['osm:payment:lightning_contactless'] || merchant['osm:payment:bitcoin']}
			<div class="mb-4">
				<span class="block text-xs text-mapLabel dark:text-white/70">Payment Methods</span>
				<div class="mt-1 flex space-x-2">
					<PaymentMethodIcon
						status={merchant['osm:payment:onchain']}
						method="btc"
						label="On-chain"
					/>
					<PaymentMethodIcon
						status={merchant['osm:payment:lightning']}
						method="ln"
						label="Lightning"
					/>
					<PaymentMethodIcon
						status={merchant['osm:payment:lightning_contactless']}
						method="nfc"
						label="Lightning contactless"
					/>
				</div>
			</div>
		{:else if isLoading}
			<div class="mb-4">
				<div class="h-3 w-24 animate-pulse rounded bg-link/50"></div>
				<div class="mt-1 flex space-x-2">
					<div class="h-8 w-16 animate-pulse rounded bg-link/50"></div>
					<div class="h-8 w-16 animate-pulse rounded bg-link/50"></div>
					<div class="h-8 w-16 animate-pulse rounded bg-link/50"></div>
				</div>
			</div>
		{/if}

		<div class="mb-4">
			<span
				class="block text-xs text-mapLabel dark:text-white/70"
				title="Completed by BTC Map community members">Last Surveyed</span
			>
			{#if merchant.verified_at}
				<span class="block text-body dark:text-white">
					{formatVerifiedHuman(merchant.verified_at)}
					{#if isUpToDate}
						<Icon
							w="16"
							h="16"
							class="inline text-primary dark:text-white"
							icon="verified"
							type="material"
						/>
					{:else}
						<Icon
							w="16"
							h="16"
							class="inline text-primary dark:text-white"
							icon="error_outline"
							type="material"
						/>
					{/if}
				</span>
			{:else if isLoading}
				<div class="mt-1 h-5 w-32 animate-pulse rounded bg-link/50"></div>
			{:else}
				<span class="block text-body dark:text-white" title="Not verified">---</span>
			{/if}
			<!-- eslint-disable svelte/no-navigation-without-resolve -->
			<a
				href={`${resolve('/verify-location')}?id=${merchant.id}`}
				class="text-xs text-link transition-colors hover:text-hover"
				title="Help improve the data for everyone"
			>
				Verify Location
			</a>
			<!-- eslint-enable svelte/no-navigation-without-resolve -->
		</div>

		<div>
			{#if isBoosted && merchant.boosted_until}
				<span
					class="block text-xs text-mapLabel dark:text-white/70"
					title="This location is boosted!">Boost Expires</span
				>
				<span class="block text-body dark:text-white">
					<Time live={3000} relative={true} timestamp={merchant.boosted_until} />
				</span>
			{/if}

			<button
				title={isBoosted ? 'Extend Boost' : 'Boost'}
				on:click={onBoostClick}
				disabled={boostLoading}
				class="mt-2 flex h-[32px] items-center justify-center space-x-2 rounded-lg border border-gray-300 px-3 text-primary transition-colors hover:border-link hover:text-link dark:border-white/95 dark:text-white dark:hover:text-link"
			>
				{#if !boostLoading}
					<Icon w="16" h="16" icon="arrow_circle_up" type="material" />
				{/if}
				<span class="text-xs">{boostLoading ? 'Boosting...' : isBoosted ? 'Extend' : 'Boost'}</span>
			</button>
		</div>
	</div>

	<a
		href={resolve(`/merchant/${merchant.id}`)}
		class="mt-4 block rounded-lg bg-link py-3 text-center text-white transition-colors hover:bg-hover"
	>
		View Full Details
	</a>
</div>



================================================
FILE: src/components/OpenTicket.svelte
================================================
<script lang="ts">
	import Time from 'svelte-time';

	import Icon from '$components/Icon.svelte';
	import TicketLabel from '$components/TicketLabel.svelte';

	export let assignees: { html_url: string; avatar_url: string; login: string }[] = [];
	export let comments: number = 0;
	export let created: string = new Date().toISOString();
	export let url: string = '';
	export let labels: { name: string; description?: string }[] = [];
	export let id: number = 0;
	export let name: string = '';
	export let user: { html_url: string; login: string } = { html_url: '', login: '' };
</script>

<div
	class="border-t-statBorder w-full items-center justify-between space-y-1 border-t p-5 text-center md:flex md:space-y-0 md:text-left"
>
	<div class="items-center space-y-1 md:flex md:space-y-0 md:space-x-2">
		<Icon type="fa" icon="ticket" w="20" h="20" class="text-xl text-link" />

		<div>
			<p>
				<!-- eslint-disable svelte/no-navigation-without-resolve -->
				<a
					href={url}
					target="_blank"
					rel="noreferrer"
					class="mr-1 text-lg font-semibold text-primary transition-colors hover:text-link dark:text-white dark:hover:text-link"
				>
					<!-- eslint-enable svelte/no-navigation-without-resolve -->
					{name}
				</a>

				<span class="block md:inline">
					{#each labels || [] as label, index (index)}
						<TicketLabel title={label?.name} tooltip={label?.description} />
					{/each}
				</span>
			</p>

			<p class="text-body dark:text-white">
				#{id} opened <Time live={3000} relative timestamp={created} />
				<br class="block md:hidden" />
				by
				<!-- eslint-disable svelte/no-navigation-without-resolve -->
				<a
					href={user.html_url}
					target="_blank"
					rel="noreferrer"
					class="transition-colors hover:text-link"
				>
					<!-- eslint-enable svelte/no-navigation-without-resolve -->
					{user.login}
				</a>
			</p>
		</div>
	</div>

	<div class="space-y-1 md:flex md:space-y-0 md:space-x-2">
		<div class="flex flex-wrap justify-center md:justify-start">
			{#each assignees || [] as assignee, index (index)}
				<!-- eslint-disable-next-line svelte/no-navigation-without-resolve -->
				<a href={assignee?.html_url} target="_blank" rel="noreferrer" class="mr-1 mb-1">
					<img
						src={assignee?.avatar_url}
						alt="avatar"
						title={assignee?.login}
						class="h-8 w-8 rounded-full object-cover"
					/>
				</a>
			{/each}
		</div>

		<div class="items-center md:flex">
			<Icon type="fa" icon="comment" w="16" h="16" class="text-link md:mr-1" />
			<strong class="text-primary dark:text-white">{comments}</strong>
		</div>
	</div>
</div>



================================================
FILE: src/components/OrgBadge.svelte
================================================
<script lang="ts">
	export let org: string;

	$: organizations = org
		? org
				.split(',')
				.map((o) => o.trim())
				.filter((o) => o.length > 0)
		: [];
</script>

{#if organizations.length > 0}
	<div class="mx-auto flex flex-wrap justify-center gap-1">
		{#each organizations as organization (organization)}
			<p
				class="w-fit rounded-full bg-[#10B981] px-3.5 py-1 text-xs font-semibold whitespace-nowrap text-white uppercase"
				title="Organization"
			>
				{organization}
			</p>
		{/each}
	</div>
{/if}



================================================
FILE: src/components/PaymentMethodIcon.svelte
================================================
<script lang="ts">
	import { onMount } from 'svelte';
	import { detectTheme } from '$lib/utils';

	export let status: 'yes' | 'no' | undefined;
	export let method: 'btc' | 'ln' | 'nfc';
	export let label: string;
	export let variant: 'default' | 'teal' = 'default';
	export let size: 'sm' | 'md' = 'sm';

	let imgElement: HTMLImageElement | undefined = undefined;
	export { imgElement as element };

	const iconPaths = {
		btc: {
			yes: { light: '/icons/btc-highlight.svg', dark: '/icons/btc-highlight-dark.svg' },
			no: {
				light: variant === 'teal' ? '/icons/btc-no-teal.svg' : '/icons/btc-no.svg',
				dark: '/icons/btc-no-dark.svg'
			},
			unknown: { light: '/icons/btc.svg', dark: '/icons/btc-dark.svg' }
		},
		ln: {
			yes: { light: '/icons/ln-highlight.svg', dark: '/icons/ln-highlight-dark.svg' },
			no: {
				light: variant === 'teal' ? '/icons/ln-no-teal.svg' : '/icons/ln-no.svg',
				dark: '/icons/ln-no-dark.svg'
			},
			unknown: { light: '/icons/ln.svg', dark: '/icons/ln-dark.svg' }
		},
		nfc: {
			yes: { light: '/icons/nfc-highlight.svg', dark: '/icons/nfc-highlight-dark.svg' },
			no: {
				light: variant === 'teal' ? '/icons/nfc-no-teal.svg' : '/icons/nfc-no.svg',
				dark: '/icons/nfc-no-dark.svg'
			},
			unknown: { light: '/icons/nfc.svg', dark: '/icons/nfc-dark.svg' }
		}
	};

	let isDark = false;

	onMount(() => {
		isDark = detectTheme() === 'dark';
	});

	$: statusKey = (status === 'yes' ? 'yes' : status === 'no' ? 'no' : 'unknown') as
		| 'yes'
		| 'no'
		| 'unknown';
	$: iconSrc = isDark ? iconPaths[method][statusKey].dark : iconPaths[method][statusKey].light;
	$: titleText =
		status === 'yes'
			? `${label} accepted`
			: status === 'no'
				? `${label} not accepted`
				: `${label} unknown`;
	$: sizeClass = size === 'md' ? 'h-8 w-8' : 'h-6 w-6';
</script>

<img bind:this={imgElement} src={iconSrc} alt={method} class={sizeClass} title={titleText} />



================================================
FILE: src/components/PrimaryButton.svelte
================================================
<script lang="ts">
	import LoadingSpinner from '$components/LoadingSpinner.svelte';

	export let style: string;
	export let link: undefined | string = undefined;
	export let type: undefined | 'button' | 'submit' = undefined;
	export let external: undefined | boolean = undefined;
	export let disabled: undefined | boolean = undefined;
	export let loading: undefined | boolean = undefined;

	const baseStyles =
		'block bg-link text-center font-semibold text-white hover:bg-hover transition-colors';

	$: combinedStyles = `${baseStyles} ${style}`;
</script>

{#if link}
	<!-- eslint-disable svelte/no-navigation-without-resolve -->
	<a
		href={link}
		target={external ? '_blank' : undefined}
		rel={external ? 'noreferrer' : undefined}
		class={combinedStyles}
	>
		<!-- eslint-enable svelte/no-navigation-without-resolve -->
		<slot />
	</a>
{:else}
	<button on:click {type} {disabled} class={combinedStyles}>
		{#if loading}
			<LoadingSpinner />
		{:else}
			<slot />
		{/if}
	</button>
{/if}



================================================
FILE: src/components/ProfileStat.svelte
================================================
<script lang="ts">
	import tippy from 'tippy.js';
	import Icon from '$components/Icon.svelte';

	export let title: string;
	export let stat: number | undefined;
	export let percent: string | undefined = undefined;
	export let border: string | undefined = undefined;
	export let tooltip: undefined | string = undefined;

	let tooltipElement: HTMLButtonElement;

	$: tooltipElement &&
		tippy([tooltipElement], {
			content: tooltip,
			allowHTML: true
		});
</script>

<div class="space-y-5 p-5 {border}">
	<h3 class="text-center text-lg font-semibold text-primary md:text-left dark:text-white">
		{title}
		{#if tooltip}
			<button bind:this={tooltipElement}>
				<Icon type="fa" icon="circle-info" w="16" h="16" class="text-base" />
			</button>
		{/if}
	</h3>

	<div class="flex justify-center md:justify-start">
		{#if stat !== undefined}
			<span class="text-5xl font-semibold text-primary dark:text-white">{stat}</span>
			{#if percent}
				<span class="ml-1 text-lg text-body dark:text-white">({percent}%)</span>
			{/if}
		{:else}
			<!-- loading skeleton -->
			<span class="h-[48px] w-[150px] animate-pulse rounded-xl bg-link/50" />
		{/if}
	</div>
</div>



================================================
FILE: src/components/ShowTags.svelte
================================================
<script lang="ts">
	import CloseButton from '$components/CloseButton.svelte';
	import { showTags } from '$lib/store';
	import OutClick from 'svelte-outclick';
	import { fly } from 'svelte/transition';

	const closeModal = () => ($showTags = undefined);
</script>

{#if $showTags}
	<OutClick excludeQuerySelectorAll="#show-tags" on:outclick={closeModal}>
		<div
			transition:fly={{ y: 200, duration: 300 }}
			class="center-fixed z-[2000] max-h-[90vh] w-[90vw] overflow-auto rounded-xl border border-gray-300 bg-white p-6 text-left shadow-2xl md:h-[400px] md:w-[430px] dark:border-white/95 dark:bg-dark"
		>
			<CloseButton on:click={closeModal} />

			<div class="space-y-2">
				{#each Object.entries($showTags) as tag, index (index)}
					<div>
						<span class="font-semibold text-primary dark:font-normal dark:text-white">{tag[0]}</span
						><span class="dark:text-white">=</span><span
							class="font-semibold text-body dark:text-white">{tag[1]}</span
						>
					</div>
				{/each}
			</div>
		</div>
	</OutClick>
{/if}



================================================
FILE: src/components/SocialLink.svelte
================================================
<script lang="ts">
	import type { SocialIconName } from '$lib/icons/types';
	import IconSocials from '$lib/icons/IconSocials.svelte';

	export let url: string;
	export let social: SocialIconName;

	const socialLabels: Record<string, string> = {
		matrix: 'Matrix',
		github: 'GitHub',
		amboss: 'Amboss',
		nostr: 'Nostr',
		x: 'X (Twitter)'
	};
</script>

<!-- eslint-disable svelte/no-navigation-without-resolve -->
<a
	href={url}
	target="_blank"
	rel="noreferrer"
	aria-label={`Visit us on ${socialLabels[social] || social}`}
	class="inline-block rounded-full bg-link p-2 text-white transition-colors hover:bg-hover dark:bg-white/[0.15] dark:hover:bg-link"
>
	<!-- eslint-enable svelte/no-navigation-without-resolve -->
	<IconSocials w="28" h="28" icon={social} />
</a>



================================================
FILE: src/components/Socials.svelte
================================================
<script lang="ts">
	export let website: undefined | string = undefined;
	export let email: undefined | string = undefined;
	export let nostr: undefined | string = undefined;
	export let twitter: undefined | string = undefined;
	export let meetup: undefined | string = undefined;
	export let eventbrite: undefined | string = undefined;
	export let telegram: undefined | string = undefined;
	export let discord: undefined | string = undefined;
	export let youtube: undefined | string = undefined;
	export let github: undefined | string = undefined;
	export let reddit: undefined | string = undefined;
	export let instagram: undefined | string = undefined;
	export let whatsapp: undefined | string = undefined;
	export let facebook: undefined | string = undefined;
	export let linkedin: undefined | string = undefined;
	export let rss: undefined | string = undefined;
	export let signal: undefined | string = undefined;
	export let simplex: undefined | string = undefined;

	export let style: undefined | string = undefined;

	import Icon from '$components/Icon.svelte';
	import IconSocials from '$lib/icons/IconSocials.svelte';
</script>

<div class="flex flex-wrap items-center justify-center {style || ''}">
	{#if website}
		<!-- eslint-disable svelte/no-navigation-without-resolve -->
		<a href={website} target="_blank" rel="noreferrer" class="m-1">
			<span class="flex h-[40px] w-[40px] items-center justify-center rounded-full bg-bitcoin">
				<Icon type="fa" icon="globe" w="28" h="28" class="text-white" />
			</span>
		</a>
	{/if}
	{#if email}
		<a href="mailto:{email}" target="_blank" rel="noreferrer" class="m-1">
			<span class="flex h-[40px] w-[40px] items-center justify-center rounded-full bg-[#53C5D5]">
				<Icon type="fa" icon="envelope" w="28" h="28" class="text-white" />
			</span>
		</a>
	{/if}
	{#if nostr}
		<a href="https://nostr.com/{nostr}" target="_blank" rel="noreferrer" class="m-1">
			<span class="flex h-[40px] w-[40px] items-center justify-center rounded-full bg-nostr">
				<IconSocials w="28" h="28" icon="nostr" class="text-white" />
			</span>
		</a>
	{/if}
	{#if twitter}
		<a href={twitter} target="_blank" rel="noreferrer" class="m-1">
			<span class="flex h-[40px] w-[40px] items-center justify-center rounded-full bg-black">
				<IconSocials w="25" h="25" icon="x" class="text-white" />
			</span>
		</a>
	{/if}
	{#if meetup}
		<a href={meetup} target="_blank" rel="noreferrer" class="m-1">
			<img src="/icons/socials/meetup.jpg" alt="meetup" class="h-10 w-10 rounded-full" />
		</a>
	{/if}
	{#if eventbrite}
		<a href={eventbrite} target="_blank" rel="noreferrer" class="m-1">
			<img src="/icons/socials/eventbrite.png" alt="eventbrite" class="h-10 w-10 rounded-full" />
		</a>
	{/if}
	{#if telegram}
		<a href={telegram} target="_blank" rel="noreferrer" class="m-1">
			<img src="/icons/socials/telegram.svg" alt="telegram" />
		</a>
	{/if}
	{#if discord}
		<a href={discord} target="_blank" rel="noreferrer" class="m-1">
			<img src="/icons/socials/discord.svg" alt="discord" />
		</a>
	{/if}
	{#if youtube}
		<a href={youtube} target="_blank" rel="noreferrer" class="m-1">
			<img src="/icons/socials/youtube.svg" alt="youtube" />
		</a>
	{/if}
	{#if github}
		<a href={github} target="_blank" rel="noreferrer" class="m-1">
			<img src="/icons/socials/github.svg" alt="github" />
		</a>
	{/if}
	{#if reddit}
		<a href={reddit} target="_blank" rel="noreferrer" class="m-1">
			<img src="/icons/socials/reddit.svg" alt="reddit" />
		</a>
	{/if}
	{#if instagram}
		<a href={instagram} target="_blank" rel="noreferrer" class="m-1">
			<img src="/icons/socials/instagram.svg" alt="instagram" class="h-10 w-10 rounded-full" />
		</a>
	{/if}
	{#if whatsapp}
		<a href={whatsapp} target="_blank" rel="noreferrer" class="m-1">
			<img src="/icons/socials/whatsapp.svg" alt="whatsapp" />
		</a>
	{/if}
	{#if facebook}
		<a href={facebook} target="_blank" rel="noreferrer" class="m-1">
			<img src="/icons/socials/facebook.svg" alt="facebook" />
		</a>
	{/if}
	{#if linkedin}
		<a href={linkedin} target="_blank" rel="noreferrer" class="m-1">
			<img src="/icons/socials/linkedin.svg" alt="linkedin" />
		</a>
	{/if}
	{#if rss}
		<a href={rss} target="_blank" rel="noreferrer" class="m-1">
			<span class="flex h-[40px] w-[40px] items-center justify-center rounded-full bg-orange-500">
				<Icon type="fa" icon="rss" w="28" h="28" class="text-white" />
			</span>
		</a>
	{/if}
	{#if signal}
		<a href={signal} target="_blank" rel="noreferrer" class="m-1">
			<img src="/icons/socials/signal.svg" alt="signal" class="h-10 w-10 rounded-full" />
		</a>
	{/if}
	{#if simplex}
		<a href={simplex} target="_blank" rel="noreferrer" class="m-1">
			<!-- eslint-enable svelte/no-navigation-without-resolve -->
			<img src="/icons/socials/simplex.jpg" alt="simplex" class="h-10 w-10 rounded-full" />
		</a>
	{/if}
</div>



================================================
FILE: src/components/SponsorBadge.svelte
================================================
<p class="gradient-bg mx-auto w-32 rounded-full py-1 text-xs font-semibold text-white">
	BTC Map Sponsor
</p>



================================================
FILE: src/components/TaggerSkeleton.svelte
================================================
<div
	class="items-center justify-between space-y-2 p-5 md:flex md:space-y-0 md:space-x-5 lg:space-x-0"
>
	<div class="items-center space-y-2 md:flex md:space-y-0 md:space-x-5">
		<!-- dot placeholder -->
		<div class="mx-auto h-3 w-3 animate-pulse rounded-full bg-link/50 md:mx-0" />

		<!-- event placeholder -->
		<div
			class="mx-auto h-[38px] w-full animate-pulse rounded-xl bg-link/50 md:mx-0 md:h-[30px] md:w-[450px]"
		/>
	</div>

	<!-- tipping button placeholder -->
	<div
		class="mx-auto h-[38px] w-full animate-pulse rounded-lg bg-link/50 md:mx-0 md:h-[30px] md:w-20"
	/>
</div>



================================================
FILE: src/components/TaggingIssues.svelte
================================================
<script lang="ts">
	import CloseButton from '$components/CloseButton.svelte';
	import Icon from '$components/Icon.svelte';
	import IssueIcon from '$components/IssueIcon.svelte';
	import { taggingIssues } from '$lib/store';
	import { getIssueHelpLink, getIssueIcon } from '$lib/utils';
	import OutClick from 'svelte-outclick';
	import { fly } from 'svelte/transition';

	const closeModal = () => ($taggingIssues = undefined);
</script>

{#if $taggingIssues}
	<OutClick excludeQuerySelectorAll="#tagging-issues" on:outclick={closeModal}>
		<div
			transition:fly={{ y: 200, duration: 300 }}
			class="center-fixed z-[2000] max-h-[90vh] w-[90vw] overflow-auto rounded-xl border border-gray-300 bg-white p-6 text-left shadow-2xl md:h-[400px] md:w-[430px] dark:border-white/95 dark:bg-dark"
		>
			<CloseButton on:click={closeModal} />

			<div class="space-y-2 text-primary dark:text-white">
				{#if $taggingIssues.length}
					{#each $taggingIssues as issue, index (index)}
						<div class="flex items-center space-x-2">
							<IssueIcon icon={getIssueIcon(issue.type)} />
							<p>{issue.description}</p>
							{#if getIssueHelpLink(issue.type)}
								<!-- eslint-disable svelte/no-navigation-without-resolve -->
								<a
									href={getIssueHelpLink(issue.type)}
									target="_blank"
									rel="noreferrer"
									class="text-link transition-colors hover:text-hover"
								>
									<!-- eslint-enable svelte/no-navigation-without-resolve -->
									Help
								</a>
							{/if}
						</div>
					{/each}
				{:else}
					<div class="flex items-center space-x-2">
						<Icon type="fa" icon="thumbs-up" w="12" h="12" />
						<p>No tagging issues!</p>
					</div>
				{/if}
			</div>
		</div>
	</OutClick>
{/if}



================================================
FILE: src/components/ThemeToggle.svelte
================================================
<script lang="ts">
	import { theme } from '$lib/store';
	import type { Theme } from '$lib/types';
	import { detectTheme } from '$lib/utils';
	import { onMount } from 'svelte';

	let currentTheme: undefined | Theme;

	onMount(() => {
		currentTheme = detectTheme();
	});

	const toggleTheme = () => {
		if (detectTheme() === 'dark') {
			localStorage.theme = 'light';
			document.documentElement.classList.remove('dark');
			currentTheme = 'light';
			$theme = 'light';
		} else {
			localStorage.theme = 'dark';
			document.documentElement.classList.add('dark');
			currentTheme = 'dark';
			$theme = 'dark';
		}
	};
</script>

<button
	on:click={toggleTheme}
	disabled={!currentTheme}
	aria-label={!currentTheme
		? 'Theme toggle loading'
		: currentTheme === 'dark'
			? 'Switch to light mode'
			: 'Switch to dark mode'}
	title={!currentTheme
		? 'Theme toggle loading'
		: currentTheme === 'dark'
			? 'Switch to light mode'
			: 'Switch to dark mode'}
	class="h-10 w-10 text-link transition-colors hover:text-hover dark:text-white dark:hover:text-link"
>
	{#if currentTheme === 'dark'}
		<svg
			xmlns="http://www.w3.org/2000/svg"
			viewBox="0 0 24 24"
			fill="currentColor"
			data-v-4fa90e7f=""
			><path d="M20.993 13.313a6 6 0 01-7.306-7.306 7 7 0 107.306 7.306z" /><path
				fill-rule="evenodd"
				d="M4.5 8.25a.5.5 0 01.5.5v1.5a.5.5 0 01-1 0v-1.5a.5.5 0 01.5-.5z"
				clip-rule="evenodd"
			/><path
				fill-rule="evenodd"
				d="M3.25 9.5a.5.5 0 01.5-.5h1.5a.5.5 0 010 1h-1.5a.5.5 0 01-.5-.5zM7.5 3a.5.5 0 01.5.5v2a.5.5 0 01-1 0v-2a.5.5 0 01.5-.5z"
				clip-rule="evenodd"
			/><path
				fill-rule="evenodd"
				d="M6 4.5a.5.5 0 01.5-.5h2a.5.5 0 010 1h-2a.5.5 0 01-.5-.5z"
				clip-rule="evenodd"
			/></svg
		>
	{:else if currentTheme === 'light'}
		<svg
			xmlns="http://www.w3.org/2000/svg"
			viewBox="0 0 24 24"
			fill="currentColor"
			data-v-4fa90e7f=""
			><path
				d="M12 16.5A4.505 4.505 0 017.5 12c0-2.481 2.019-4.5 4.5-4.5s4.5 2.019 4.5 4.5-2.019 4.5-4.5 4.5z"
			/><path
				fill-rule="evenodd"
				d="M12 3a.5.5 0 01.5.5v2a.5.5 0 01-1 0v-2A.5.5 0 0112 3zM18 12a.5.5 0 01.5-.5h2a.5.5 0 010 1h-2a.5.5 0 01-.5-.5zM3 12a.5.5 0 01.5-.5h2a.5.5 0 010 1h-2A.5.5 0 013 12zM12 18a.5.5 0 01.5.5v2a.5.5 0 01-1 0v-2a.5.5 0 01.5-.5zM18.354 5.646a.5.5 0 010 .708l-1.5 1.5a.5.5 0 01-.708-.708l1.5-1.5a.5.5 0 01.708 0zM7.854 16.146a.5.5 0 010 .708l-1.5 1.5a.5.5 0 01-.708-.708l1.5-1.5a.5.5 0 01.708 0zM5.646 5.646a.5.5 0 01.708 0l1.5 1.5a.5.5 0 11-.708.708l-1.5-1.5a.5.5 0 010-.708zM16.146 16.146a.5.5 0 01.708 0l1.5 1.5a.5.5 0 01-.708.708l-1.5-1.5a.5.5 0 010-.708z"
				clip-rule="evenodd"
			/></svg
		>
	{/if}
</button>



================================================
FILE: src/components/TicketLabel.svelte
================================================
<script lang="ts">
	export let title: string;
	export let tooltip: string | undefined;
	import tippy from 'tippy.js';

	let labelTooltip: HTMLSpanElement;

	$: tooltip &&
		tooltip.length &&
		labelTooltip &&
		tippy([labelTooltip], {
			content: tooltip
		});
</script>

<span
	bind:this={labelTooltip}
	class="mr-1 mb-1 inline-block rounded-full border border-link bg-link/25 p-1 text-xs text-primary dark:text-white"
	>{title}</span
>



================================================
FILE: src/components/Tip.svelte
================================================
<script lang="ts">
	import { TipType } from '$lib/types';

	export let user: undefined | string = undefined;
	export let destination: string;
	let className: undefined | string = undefined;
	export { className as class };
	export let type: TipType = TipType.Address;
</script>

{#if user}
	<div class="!my-12">
		<!-- eslint-disable svelte/no-navigation-without-resolve -->
		<a
			href={type === 'url' ? destination : `lightning:${destination}`}
			target={type === 'url' ? '_blank' : null}
			rel={type === 'url' ? 'noreferrer' : null}
			class="w-full rounded-xl bg-link p-3 px-5 text-center font-semibold text-white transition-colors hover:bg-hover md:text-lg"
		>
			<!-- eslint-enable svelte/no-navigation-without-resolve -->
			<!--  lightning icon -->
			<svg
				class="hidden h-7 w-7 md:inline"
				width="16"
				height="17"
				viewBox="0 0 16 17"
				fill="none"
				xmlns="http://www.w3.org/2000/svg"
			>
				<path
					d="M8.66674 1.83334L2.72904 8.95858C2.4965 9.23763 2.38023 9.37715 2.37846 9.49498C2.37691 9.59742 2.42256 9.69488 2.50224 9.75927C2.5939 9.83334 2.77552 9.83334 3.13876 9.83334H8.00007L7.3334 15.1667L13.2711 8.04144C13.5036 7.7624 13.6199 7.62287 13.6217 7.50504C13.6232 7.4026 13.5776 7.30514 13.4979 7.24075C13.4062 7.16668 13.2246 7.16668 12.8614 7.16668H8.00007L8.66674 1.83334Z"
					stroke="currentColor"
					stroke-width="1.41667"
					stroke-linecap="round"
					stroke-linejoin="round"
				/>
			</svg>
			Tip {user}
		</a>
	</div>
{:else}
	<!-- eslint-disable svelte/no-navigation-without-resolve -->
	<a
		href={type === 'url' ? destination : `lightning:${destination}`}
		target={type === 'url' ? '_blank' : null}
		rel={type === 'url' ? 'noreferrer' : null}
		class="w-full rounded-lg border border-link py-2 text-center text-sm font-semibold text-link hover:border-white hover:bg-link hover:text-white md:w-20 md:py-1 {className} transition-colors"
	>
		<!-- eslint-enable svelte/no-navigation-without-resolve -->
		<!--  lightning icon -->
		<svg
			class="inline"
			width="16"
			height="17"
			viewBox="0 0 16 17"
			fill="none"
			xmlns="http://www.w3.org/2000/svg"
		>
			<path
				d="M8.66674 1.83334L2.72904 8.95858C2.4965 9.23763 2.38023 9.37715 2.37846 9.49498C2.37691 9.59742 2.42256 9.69488 2.50224 9.75927C2.5939 9.83334 2.77552 9.83334 3.13876 9.83334H8.00007L7.3334 15.1667L13.2711 8.04144C13.5036 7.7624 13.6199 7.62287 13.6217 7.50504C13.6232 7.4026 13.5776 7.30514 13.4979 7.24075C13.4062 7.16668 13.2246 7.16668 12.8614 7.16668H8.00007L8.66674 1.83334Z"
				stroke="currentColor"
				stroke-width="1.41667"
				stroke-linecap="round"
				stroke-linejoin="round"
			/>
		</svg>
		Tip
	</a>
{/if}



================================================
FILE: src/components/TopButton.svelte
================================================
<script lang="ts">
	import Icon from '$components/Icon.svelte';
	export let scroll: undefined | HTMLElement = undefined;
	export let style: undefined | string = undefined;
</script>

<button
	on:click={() => (scroll ? scroll : window).scrollTo({ top: 0, behavior: 'smooth' })}
	class="mx-auto h-8 w-8 animate-bounce rounded-full bg-link text-white hover:bg-hover {style} flex items-center justify-center transition-colors"
>
	<Icon type="fa" icon="chevron-up" w="16" h="16" />
</button>



================================================
FILE: src/components/area/AreaActivity.svelte
================================================
<script lang="ts">
	import LatestTagger from '$components/LatestTagger.svelte';
	import TaggerSkeleton from '$components/TaggerSkeleton.svelte';
	import TopButton from '$components/TopButton.svelte';
	import Icon from '$components/Icon.svelte';
	import type { ActivityEvent, User } from '$lib/types.js';
	import { resolve } from '$app/paths';

	export let alias: string;
	export let name: string;
	export let dataInitialized: boolean;
	export let eventElements: ActivityEvent[];
	export let taggers: User[];

	let hideArrow = false;
	let activityDiv: HTMLDivElement;

	let eventCount = 25;
	$: eventElementsPaginated = eventElements.slice(0, eventCount);

	let taggerCount = 25;
	$: taggersPaginated = taggers.slice(0, taggerCount);
	let taggerDiv: HTMLDivElement;
</script>

<section id="taggers">
	<!-- prettier-ignore -->
	<div class="w-full rounded-3xl border border-gray-300 dark:border-white/95 dark:bg-white/10">
		<!-- prettier-ignore -->
		<h3
			class="border-b border-gray-300 p-5 text-center text-lg font-semibold text-primary md:text-left dark:border-white/95 dark:text-white"
		>
			{name || 'BTC Map Area'} Supertaggers
		</h3>

		<div bind:this={taggerDiv} class="hide-scroll max-h-[375px] overflow-scroll p-1">
			{#if taggers && taggers.length}
				<div class="flex flex-wrap items-center justify-center">
					{#each taggersPaginated as tagger (tagger.id)}
						<div class="m-4 space-y-1 transition-transform hover:scale-110">
							<a href={resolve(`/tagger/${tagger.id}`)}>
								<img
									src={tagger.osm_json.img
										? tagger.osm_json.img.href
										: '/images/satoshi-nakamoto.png'}
									alt="avatar"
									class="mx-auto h-20 w-20 rounded-full object-cover"
									on:error={function () {
										this.src = '/images/satoshi-nakamoto.png';
									}}
								/>
								<p class="text-center font-semibold text-body dark:text-white">
									{tagger.osm_json.display_name.length > 21
										? tagger.osm_json.display_name.slice(0, 18) + '...'
										: tagger.osm_json.display_name}
								</p>
							</a>
						</div>
					{/each}
				</div>

				{#if taggersPaginated.length !== taggers.length}
					<button
						class="mx-auto !mb-4 block text-xl font-semibold text-link transition-colors hover:text-hover"
						on:click={() => (taggerCount = taggerCount + 25)}>Load More</button
					>
				{/if}
			{:else if !dataInitialized}
				<div class="flex flex-wrap items-center justify-center">
					{#each Array(5) as _, index (index)}
						<div class="m-4 space-y-1 transition-transform hover:scale-110">
							<p class="mx-auto h-20 w-20 animate-pulse rounded-full bg-link/50" />
							<p class="mx-auto h-5 w-28 animate-pulse rounded bg-link/50" />
						</div>
					{/each}
				</div>
			{:else}
				<p class="p-5 text-center text-body dark:text-white">No supertaggers to display.</p>
			{/if}
		</div>
	</div>
</section>

<section id="activity">
	<!-- prettier-ignore -->
	<div class="w-full rounded-3xl border border-gray-300 dark:border-white/95 dark:bg-white/10">
		<!-- prettier-ignore -->
		<h3
			class="border-b border-gray-300 p-5 text-center text-lg font-semibold text-primary md:text-left dark:border-white/95 dark:text-white"
		>
			{name || 'BTC Map Area'} Activity
		</h3>

		<div
			bind:this={activityDiv}
			class="hide-scroll relative max-h-[375px] space-y-2 overflow-y-scroll"
			on:scroll={() => {
				if (dataInitialized && !hideArrow) {
					hideArrow = true;
				}
			}}
		>
			{#if eventElements && eventElements.length}
				{#each eventElementsPaginated as event (event['created_at'])}
					<LatestTagger
						location={event.location}
						action={event.type}
						user={event.tagger}
						time={event['created_at']}
						latest={event === eventElements[0] ? true : false}
						merchantId={event.merchantId}
					/>
				{/each}

				{#if eventElementsPaginated.length !== eventElements.length}
					<button
						class="mx-auto !mb-5 block text-xl font-semibold text-link transition-colors hover:text-hover"
						on:click={() => (eventCount = eventCount + 25)}>Load More</button
					>
				{:else if eventElements.length > 10}
					<TopButton scroll={activityDiv} style="!mb-5" />
				{/if}

				{#if !hideArrow && eventElements.length > 5}
					<Icon
						type="fa"
						icon="chevron-down"
						w="16"
						h="16"
						class="absolute bottom-4 left-[calc(50%-8px)] z-20 animate-bounce text-primary dark:text-white"
					/>
				{/if}
			{:else if !dataInitialized}
				{#each Array(5) as _, index (index)}
					<TaggerSkeleton />
				{/each}
			{:else}
				<p class="p-5 text-body dark:text-white">No activity to display.</p>
			{/if}
		</div>
	</div>
</section>

<section id="atom">
	<!-- prettier-ignore -->
	<div class="w-full rounded-3xl border border-gray-300 dark:border-white/95 dark:bg-white/10">
		<!-- prettier-ignore -->
		<h3
			class="border-b border-gray-300 p-5 text-center text-lg font-semibold text-primary md:text-left dark:border-white/95 dark:text-white"
		>
			{name || 'BTC Map Area'} Atom Feeds
		</h3>

		<ul class="space-y-5 p-5 text-lg font-semibold text-primary dark:text-white">
			<li>
				<a
					class="text-link transition-colors hover:text-hover"
					href="https://api.btcmap.org/feeds/new-places/{alias}"
					target="_blank"
					rel="noreferrer"
				>
					New Places
				</a>
				<Icon type="fa" icon="location-pin" w="18" h="18" class="ml-1 inline align-middle" />
			</li>
			<li>
				<a
					class="text-link transition-colors hover:text-hover"
					href="https://api.btcmap.org/feeds/new-comments/{alias}"
					target="_blank"
					rel="noreferrer"
				>
					New Comments
				</a>
				<Icon type="fa" icon="comment" w="18" h="18" class="ml-1 inline align-middle" />
			</li>
		</ul>
	</div>
</section>



================================================
FILE: src/components/area/AreaMap.svelte
================================================
<script lang="ts">
	import { browser } from '$app/environment';
	import { GradeTable } from '$lib/constants';
	import AreaMerchantDrawer from '$components/area/AreaMerchantDrawer.svelte';
	import Icon from '$components/Icon.svelte';
	import MapLoadingEmbed from '$components/MapLoadingEmbed.svelte';
	import ShowTags from '$components/ShowTags.svelte';
	import TaggingIssues from '$components/TaggingIssues.svelte';
	import { loadMapDependencies } from '$lib/map/imports';
	import {
		attribution,
		changeDefaultIcons,
		generateIcon,
		generateMarker,
		geolocate,
		layers
	} from '$lib/map/setup';
	import { theme } from '$lib/store';
	import type { BaseMaps, DomEventType, Grade, Leaflet, Place } from '$lib/types';
	import { getGrade } from '$lib/utils';
	import type { GeoJSON } from 'geojson';
	import type { Map } from 'leaflet';
	import { onDestroy, onMount } from 'svelte';
	import tippy from 'tippy.js';

	export let name: string;
	export let geoJSON: GeoJSON;
	export let filteredPlaces: Place[];

	// Local drawer state
	let selectedMerchantId: number | null = null;

	const openDrawer = (id: number) => {
		selectedMerchantId = id;
	};

	const closeDrawer = () => {
		selectedMerchantId = null;
	};

	let total: number | undefined;
	let upToDate: number | undefined;
	let upToDatePercent: string | undefined;

	let grade: Grade;

	let gradeTooltip: HTMLButtonElement;

	$: gradeTooltip &&
		tippy([gradeTooltip], {
			content: GradeTable,
			allowHTML: true
		});

	let mapElement: HTMLDivElement;
	let map: Map;
	let mapLoaded = false;

	let baseMaps: BaseMaps;

	let leaflet: Leaflet;
	let DomEvent: DomEventType;
	let LocateControl: typeof import('leaflet.locatecontrol').LocateControl;

	const closePopup = () => {
		map.closePopup();
	};

	$: $theme !== undefined && mapLoaded && closePopup();

	const toggleTheme = () => {
		if ($theme === 'dark') {
			baseMaps['OpenFreeMap Liberty'].remove();
			baseMaps['OpenFreeMap Dark'].addTo(map);
		} else {
			baseMaps['OpenFreeMap Dark'].remove();
			baseMaps['OpenFreeMap Liberty'].addTo(map);
		}
	};

	$: $theme !== undefined && mapLoaded && toggleTheme();

	onMount(async () => {
		if (browser) {
			const deps = await loadMapDependencies();
			leaflet = deps.leaflet;
			DomEvent = deps.leaflet.DomEvent;
			LocateControl = deps.LocateControl;

			initialRenderComplete = true;
		}
	});

	onDestroy(async () => {
		if (map) {
			console.info('Unloading Leaflet map.');
			map.remove();
		}
	});

	let initialRenderComplete = false;
	let dataInitialized = false;

	const initializeData = () => {
		if (dataInitialized) return;

		const populateMap = () => {
			// add map
			map = leaflet.map(mapElement, { attributionControl: false, maxZoom: 19 });

			// add tiles and basemaps
			const layersResult = layers(leaflet, map);
			baseMaps = layersResult.baseMaps;

			// change broken marker image path in prod
			leaflet.Icon.Default.prototype.options.imagePath = '/icons/';

			// add OSM attribution
			attribution(leaflet, map);

			// create marker cluster groups

			/* eslint-disable no-undef */
			// @ts-expect-error L is injected globally by leaflet.markercluster
			let markers = L.markerClusterGroup();
			/* eslint-enable no-undef */
			let upToDateLayer = leaflet.featureGroup.subGroup(markers);

			// add locate button to map
			geolocate(leaflet, map, LocateControl);

			// change default icons
			changeDefaultIcons(true, leaflet, mapElement, DomEvent);

			// add area poly to map
			leaflet.geoJSON(geoJSON, { style: { fill: false } }).addTo(map);

			// add places to map
			filteredPlaces.forEach((place) => {
				const commentsCount = place.comments || 0;
				const boosted = place.boosted_until ? Date.parse(place.boosted_until) > Date.now() : false;

				let divIcon = generateIcon(leaflet, place.icon, boosted, commentsCount);

				let marker = generateMarker({
					lat: place.lat,
					long: place.lon,
					icon: divIcon,
					placeId: place.id,
					leaflet,
					verify: true,
					onMarkerClick: (id) => openDrawer(Number(id))
				});

				upToDateLayer.addLayer(marker);

				if (upToDate === undefined) {
					upToDate = 1;
				} else {
					upToDate++;
				}

				if (total === undefined) {
					total = 1;
				} else {
					total++;
				}
			});

			map.addLayer(markers);
			map.addLayer(upToDateLayer);

			map.fitBounds(leaflet.geoJSON(geoJSON).getBounds());

			// Close drawer when clicking on map (not on markers)
			map.on('click', () => {
				if (selectedMerchantId) {
					closeDrawer();
				}
			});

			mapLoaded = true;
		};

		populateMap();

		if (!upToDate) {
			upToDate = 0;
		}

		if (!total) {
			total = 0;
		}

		upToDatePercent = upToDate ? (upToDate / (total / 100)).toFixed(0) : '0';

		grade = getGrade(Number(upToDatePercent));

		dataInitialized = true;
	};

	$: geoJSON && filteredPlaces && initialRenderComplete && !dataInitialized && initializeData();
</script>

<section id="map-section">
	<!-- prettier-ignore -->
	<h3
		class="rounded-t-3xl border border-b-0 border-gray-300 p-5 text-center text-lg font-semibold text-primary md:text-left dark:border-white/95 dark:bg-white/10 dark:text-white"
	>
		{name || 'BTC Map Area'} Map
		<div class="flex items-center space-x-1 text-link">
			{#if dataInitialized}
				<div class="flex items-center space-x-1">
					{#each Array(grade) as _, index (index)}
						<Icon type="fa" icon="star" w="16" h="16" />
					{/each}
				</div>

				<div class="flex items-center space-x-1">
					{#each Array(5 - grade) as _, index (index)}
						<Icon type="fa" icon="star" w="16" h="16" class="opacity-25" />
					{/each}
				</div>
			{:else}
				<div class="flex items-center space-x-1">
					{#each Array(5) as _, index (index)}
						<Icon type="fa" icon="star" w="16" h="16" class="animate-pulse text-link/50" />
					{/each}
				</div>
			{/if}

			<button bind:this={gradeTooltip}>
				<Icon type="fa" icon="circle-info" w="14" h="14" class="text-sm" />
			</button>
		</div>
	</h3>

	<div class="relative">
		<div class="overflow-hidden rounded-b-3xl">
			<!-- prettier-ignore -->
			<div
				bind:this={mapElement}
				class="z-10 h-[300px] border border-gray-300 !bg-teal text-left md:h-[600px] dark:border-white/95 dark:!bg-[#202f33]"
			/>
			{#if !mapLoaded}
				<MapLoadingEmbed
					style="h-[300px] md:h-[600px] border border-gray-300 dark:border-white/95"
				/>
			{/if}
		</div>
		<AreaMerchantDrawer merchantId={selectedMerchantId} onClose={closeDrawer} />
	</div>

	<ShowTags />
	<TaggingIssues />
</section>



================================================
FILE: src/components/area/AreaMerchantDrawer.svelte
================================================
<script lang="ts">
	import { fly } from 'svelte/transition';
	import CloseButton from '$components/CloseButton.svelte';
	import MerchantDetailsContent from '$components/MerchantDetailsContent.svelte';
	import { boost } from '$lib/store';
	import {
		calcVerifiedDate,
		isUpToDate as checkUpToDate,
		isBoosted as checkBoosted,
		handleBoost as boostMerchant,
		clearBoostState,
		fetchMerchantDetails
	} from '$lib/merchantDrawerLogic';
	import type { Place } from '$lib/types';

	export let merchantId: number | null = null;
	export let onClose: () => void;

	let merchant: Place | null = null;
	let isLoading = false;
	let lastFetchedId: number | null = null;
	let abortController: AbortController | null = null;

	const verifiedDate = calcVerifiedDate();
	$: isUpToDate = checkUpToDate(merchant, verifiedDate);
	$: isBoosted = checkBoosted(merchant);

	let boostLoading = false;
	const setBoostLoading = (loading: boolean) => {
		boostLoading = loading;
	};

	// Fetch merchant data when merchantId changes
	$: if (merchantId && merchantId !== lastFetchedId) {
		// Cancel any pending request
		if (abortController) {
			abortController.abort();
		}
		abortController = new AbortController();

		fetchMerchantDetails(
			merchantId,
			merchantId,
			(m) => (merchant = m),
			(f) => (isLoading = f),
			(id) => (lastFetchedId = id),
			abortController.signal
		);
	}

	const closeDrawer = () => {
		clearBoostState();
		boostLoading = false;
		merchant = null;
		lastFetchedId = null;
		if (abortController) {
			abortController.abort();
			abortController = null;
		}
		onClose();
	};

	const handleBoost = () => boostMerchant(merchant, merchantId, setBoostLoading);

	$: if ($boost !== undefined && merchant) {
		// Boost state changed - refresh merchant data
		if (merchantId) {
			fetchMerchantDetails(
				merchantId,
				merchantId,
				(m) => (merchant = m),
				(f) => (isLoading = f),
				(id) => (lastFetchedId = id)
			);
		}
	}

	function handleKeydown(event: KeyboardEvent) {
		if (event.key === 'Escape') {
			event.preventDefault();
			closeDrawer();
		}
	}
</script>

<svelte:window on:keydown={handleKeydown} />

{#if merchantId}
	<div
		transition:fly={{ x: -300, duration: 200 }}
		class="absolute top-0 left-0 z-[1001] flex h-full w-full flex-col bg-white shadow-xl md:w-[280px] dark:bg-dark"
		role="dialog"
		aria-modal="true"
	>
		<div class="flex shrink-0 items-center justify-end bg-white p-2 dark:bg-dark">
			<CloseButton on:click={closeDrawer} />
		</div>

		<div class="min-h-0 flex-1 overflow-x-visible overflow-y-auto">
			{#if !merchant && isLoading}
				<!-- Loading skeleton -->
				<div class="space-y-4 px-5 pb-4">
					<div class="h-6 w-3/4 animate-pulse rounded-lg bg-link/50"></div>
					<div class="h-4 w-1/2 animate-pulse rounded bg-link/50"></div>
					<div class="flex space-x-2">
						<div class="h-8 w-14 animate-pulse rounded bg-link/50"></div>
						<div class="h-8 w-14 animate-pulse rounded bg-link/50"></div>
					</div>
					<div class="grid grid-cols-2 gap-2">
						<div class="h-16 animate-pulse rounded-lg bg-link/50"></div>
						<div class="h-16 animate-pulse rounded-lg bg-link/50"></div>
					</div>
				</div>
			{:else if merchant}
				<div class="px-5 pb-4">
					<MerchantDetailsContent
						{merchant}
						{isUpToDate}
						{isBoosted}
						{boostLoading}
						onBoostClick={handleBoost}
						{isLoading}
					/>
				</div>
			{/if}
		</div>
	</div>
{/if}



================================================
FILE: src/components/area/AreaMerchantHighlights.svelte
================================================
<script lang="ts">
	import MerchantCard from '$components/area/MerchantCard.svelte';
	import type { Place } from '$lib/types';
	import { isBoosted } from '$lib/utils';
	import { resolve } from '$app/paths';

	export let dataInitialized: boolean;
	export let filteredPlaces: Place[];

	$: boosts =
		filteredPlaces &&
		filteredPlaces
			.filter((p) => isBoosted(p))
			.toSorted((a, b) => Date.parse(b.boosted_until || '') - Date.parse(a.boosted_until || ''));

	$: latest =
		filteredPlaces &&
		filteredPlaces
			.toSorted((a, b) => Date.parse(b.created_at || '') - Date.parse(a.created_at || ''))
			.slice(0, 6);
</script>

<section id="boosted">
	<!-- prettier-ignore -->
	<div class="w-full rounded-3xl border border-gray-300 dark:border-white/95 dark:bg-white/10">
		<!-- prettier-ignore -->
		<h3
			class="border-b border-gray-300 p-5 text-center text-lg font-semibold text-primary md:text-left dark:border-white/95 dark:text-white"
		>
			Boosted Merchants
		</h3>

		<div class="w-full px-2 py-6 sm:px-5">
			{#if !dataInitialized}
				<div class="grid w-full grid-cols-1 gap-6 lg:grid-cols-2 xl:grid-cols-3">
					{#each Array(3) as _, index (index)}
						<div class="h-56 animate-pulse rounded-2xl bg-link/50" />
					{/each}
				</div>
			{:else if boosts.length}
				<div class="grid w-full grid-cols-1 gap-6 lg:grid-cols-2 xl:grid-cols-3">
					{#each boosts as merchant (merchant.id)}
						<MerchantCard {merchant} />
					{/each}
				</div>
			{:else}
				<p class="text-center text-primary sm:text-left dark:text-white">
					No boosted merchants in this area.
				</p>
			{/if}
		</div>
	</div>
</section>

<section id="latest">
	<!-- prettier-ignore -->
	<div class="w-full rounded-3xl border border-gray-300 dark:border-white/95 dark:bg-white/10">
		<!-- prettier-ignore -->
		<h3
			class="border-b border-gray-300 p-5 text-center text-lg font-semibold text-primary md:text-left dark:border-white/95 dark:text-white"
		>
			Latest Added
		</h3>

		<div class="w-full px-2 py-6 sm:px-5">
			{#if !dataInitialized}
				<div class="grid w-full grid-cols-1 gap-6 lg:grid-cols-2 xl:grid-cols-3">
					{#each Array(3) as _, index (index)}
						<div class="h-56 animate-pulse rounded-2xl bg-link/50" />
					{/each}
				</div>
			{:else if latest.length}
				<div class="grid w-full grid-cols-1 gap-6 lg:grid-cols-2 xl:grid-cols-3">
					{#each latest as merchant (merchant.id)}
						<MerchantCard {merchant} />
					{/each}
				</div>
			{:else}
				<p class="text-center text-primary sm:text-left dark:text-white">
					No latest added in this area. You can <a
						href={resolve('/add-location')}
						class="text-link transition-colors hover:text-hover">add a new merchant</a
					> now!
				</p>
			{/if}
		</div>
	</div>
</section>



================================================
FILE: src/components/area/AreaPage.svelte
================================================
<script lang="ts">
	import { browser } from '$app/environment';
	import { page } from '$app/stores';
	import { goto } from '$app/navigation';

	export let type: 'country' | 'community';
	export let data: AreaPageProps;

	import AreaActivity from '$components/area/AreaActivity.svelte';
	import AreaMap from '$components/area/AreaMap.svelte';
	import AreaMerchantHighlights from '$components/area/AreaMerchantHighlights.svelte';
	import AreaStats from '$components/area/AreaStats.svelte';
	import AreaTickets from '$components/area/AreaTickets.svelte';
	import Boost from '$components/Boost.svelte';
	import Icon from '$components/Icon.svelte';
	import IssuesTable from '$components/IssuesTable.svelte';
	import OrgBadge from '$components/OrgBadge.svelte';
	import Socials from '$components/Socials.svelte';
	import SponsorBadge from '$components/SponsorBadge.svelte';
	import Tip from '$components/Tip.svelte';

	import {
		areaError,
		areas,
		placesError,
		places,
		eventError,
		events,
		reportError,
		reports,
		userError,
		users
	} from '$lib/store';
	import { areasSync } from '$lib/sync/areas';
	import { eventsSync } from '$lib/sync/events';
	import { reportsSync } from '$lib/sync/reports';
	import { usersSync } from '$lib/sync/users';
	import { batchSync } from '$lib/sync/batchSync';
	import {
		TipType,
		type ActivityEvent,
		type AreaPageProps,
		type AreaTags,
		type Event,
		type Place,
		type Report,
		type RpcIssue,
		type User
	} from '$lib/types.js';
	import { errToast, formatElementID, validateContinents } from '$lib/utils';
	import { PLACE_FIELD_SETS, buildFieldsParam } from '$lib/api-fields';
	import axios from 'axios';
	import axiosRetry from 'axios-retry';
	import rewind from '@mapbox/geojson-rewind';
	import { geoContains } from 'd3-geo';
	import { onMount } from 'svelte';

	axiosRetry(axios, { retries: 3, retryDelay: axiosRetry.exponentialDelay });

	onMount(() => {
		batchSync([areasSync, reportsSync, eventsSync, usersSync]);
	});

	// alert for user errors
	$: $userError && errToast($userError);
	// alert for event errors
	$: $eventError && errToast($eventError);
	// alert for element errors
	$: $placesError && errToast($placesError);
	// alert for area errors
	$: $areaError && errToast($areaError);
	// alert for report errors
	$: $reportError && errToast($reportError);

	enum Sections {
		merchants = 'Merchants',
		stats = 'Stats',
		activity = 'Activity',
		maintain = 'Maintain'
	}

	const sections = Object.values(Sections);
	let scrolled = false;

	// Map section names to URL-friendly slugs
	const sectionSlugs: Record<Sections, string> = {
		[Sections.merchants]: 'merchants',
		[Sections.stats]: 'stats',
		[Sections.activity]: 'activity',
		[Sections.maintain]: 'maintain'
	};

	// Reverse mapping from slugs to sections
	const slugToSection: Record<string, Sections> = {
		merchants: Sections.merchants,
		stats: Sections.stats,
		activity: Sections.activity,
		maintain: Sections.maintain
	};

	// Get the current section from the route parameter
	$: currentSection = $page.params.section || 'merchants';
	$: activeSection = slugToSection[currentSection] || Sections.merchants;

	// Handle section change
	const handleSectionChange = (section: Sections) => {
		const slug = sectionSlugs[section];
		const areaId = data.id;
		// eslint-disable-next-line svelte/no-navigation-without-resolve
		goto(`/${type}/${areaId}/${slug}`);
	};

	// No need for hash handling anymore - sections are handled by route parameters

	let dataInitialized = false;
	let elementsLoading = false;

	// Fetch places for area using geographic filtering + enrichment with verification data
	const fetchPlacesForArea = async (areaId: string): Promise<Place[]> => {
		try {
			elementsLoading = true;

			// Step 1: Geographic filtering (fast, uses existing store)
			const area = $areas.find((a) => a.id === areaId);
			if (!area || !area.tags.geo_json) {
				console.error('Area not found or missing geo_json:', areaId);
				return [];
			}

			const allPlaces = $places;
			const rewoundPoly = rewind(area.tags.geo_json, true);
			const areaPlaces = allPlaces.filter((place: Place) => {
				return place.lat && place.lon && geoContains(rewoundPoly, [place.lon, place.lat]);
			});

			console.info(`Geographic filtering found ${areaPlaces.length} places for ${areaId}`);

			// Step 2: Enrich with verification data from API (batched requests)
			const placeIds = areaPlaces.map((p) => p.id);
			const batchSize = 20;
			const enrichedPlaces: Place[] = [];

			console.info(
				`Enriching ${placeIds.length} places with verification data in ${Math.ceil(placeIds.length / batchSize)} batches`
			);

			for (let i = 0; i < placeIds.length; i += batchSize) {
				const batch = placeIds.slice(i, i + batchSize);
				const batchPromises = batch.map((id) =>
					axios
						.get<Place>(
							`https://api.btcmap.org/v4/places/${id}?fields=${buildFieldsParam(PLACE_FIELD_SETS.COMPLETE_PLACE)}`
						)
						.then((response) => response.data)
						.catch((error) => {
							console.warn(`Failed to fetch place ${id}:`, error.response?.status);
							return null;
						})
				);

				const batchResults = await Promise.all(batchPromises);
				const validPlaces = batchResults
					.filter((place): place is Place => place !== null)
					.filter((place) => !place.deleted_at);
				enrichedPlaces.push(...validPlaces);

				console.info(
					`Batch ${Math.floor(i / batchSize) + 1} completed: ${validPlaces.length}/${batch.length} successful`
				);
			}

			console.info(`Successfully enriched ${enrichedPlaces.length} places for ${areaId}`);
			return enrichedPlaces;
		} catch (error) {
			console.error('Failed to fetch places for area:', areaId, error);
			return [];
		} finally {
			elementsLoading = false;
		}
	};

	const initializeData = async () => {
		if (dataInitialized) return;

		const areaFound = $areas.find((area) => {
			if (type === 'community') {
				return (
					area.id == data.id &&
					area.tags.type === 'community' &&
					area.tags.geo_json &&
					area.tags.name &&
					area.tags['icon:square'] &&
					area.tags.continent &&
					Object.keys(area.tags).find((key) => key.includes('contact'))
				);
			} else {
				return (
					area.id == data.id &&
					area.tags.type === 'country' &&
					area.id.length === 2 &&
					area.tags.geo_json &&
					area.tags.name &&
					area.tags.continent &&
					validateContinents(area.tags.continent)
				);
			}
		});

		if (!areaFound) {
			console.error(`Could not find ${type}, please try again or contact BTC Map.`);
			// eslint-disable-next-line svelte/no-navigation-without-resolve
			goto('/404');
			return;
		}

		areaReports = $reports
			? $reports
					.filter((report) => report.area_id === data.id)
					.sort((a, b) => Date.parse(b['created_at']) - Date.parse(a['created_at']))
			: [];

		area = areaFound.tags;

		avatar =
			type === 'community'
				? `https://btcmap.org/.netlify/images?url=${area['icon:square']}&fit=cover&w=256&h=256`
				: `https://static.btcmap.org/images/countries/${areaFound.id}.svg`;
		description = area.description;

		if (type === 'community') {
			org = area.organization;
			sponsor = area.sponsor;
			website = area['contact:website'];
			email = area['contact:email'];
			nostr = area['contact:nostr'];
			twitter = area['contact:twitter'];
			meetup = area['contact:meetup'];
			eventbrite = area['contact:eventbrite'];
			telegram = area['contact:telegram'];
			discord = area['contact:discord'];
			youtube = area['contact:youtube'];
			github = area['contact:github'];
			reddit = area['contact:reddit'];
			instagram = area['contact:instagram'];
			whatsapp = area['contact:whatsapp'];
			facebook = area['contact:facebook'];
			linkedin = area['contact:linkedin'];
			rss = area['contact:rss'];
			signal = area['contact:signal'];
			simplex = area['contact:simplex'];

			if (area['tips:lightning_address']) {
				lightning = {
					destination: area['tips:lightning_address'],
					type: TipType.Address
				};
			} else if (area['tips:url']) {
				lightning = { destination: area['tips:url'], type: TipType.Url };
			}
		}

		const rewoundPoly = rewind(area.geo_json, true);

		// For AreaMap, filter places from client store
		filteredPlaces = $places.filter((place: Place) => {
			if (geoContains(rewoundPoly, [place.lon, place.lat])) {
				return true;
			} else {
				return false;
			}
		});

		issues = data.issues;

		dataInitialized = true;

		// Fetch places in the background for rich components
		if (browser) {
			const places = await fetchPlacesForArea(areaFound.id);
			filteredPlaces = places;

			// Process events after places are loaded, only if events and users stores are populated
			if ($events.length && $users.length) {
				const areaEvents = $events.filter((event) =>
					filteredPlaces.find((place) => place.osm_id === event.element_id)
				);

				areaEvents.sort((a, b) => Date.parse(b['created_at']) - Date.parse(a['created_at']));

				const findUser = (tagger: Event) => {
					let foundUser = $users.find((user) => user.id == tagger['user_id']);

					if (foundUser) {
						if (!taggers.find((tagger) => tagger.id === foundUser?.id)) {
							taggers.push(foundUser);
						}

						return foundUser;
					} else {
						return undefined;
					}
				};

				areaEvents.forEach((event) => {
					let placeMatch = filteredPlaces.find((place) => place.osm_id === event['element_id']);

					let location = placeMatch?.name || undefined;

					let tagger = findUser(event);

					eventElements.push({
						...event,
						location: location || formatElementID(event['element_id']),
						merchantId: event['element_id'],
						tagger
					});
				});

				eventElements = eventElements;
				taggers = taggers;
			}
		}
	};

	$: $areas && $areas.length && $places && $places.length && !dataInitialized && initializeData();

	let area: AreaTags;
	let filteredPlaces: Place[] = [];
	let areaReports: Report[];

	let avatar: string;
	const alias = data.id;
	const name = data.name;
	let description: string | undefined;
	let org: string | undefined;
	let sponsor: boolean | undefined;
	let website: string | undefined;
	let email: string | undefined;
	let nostr: string | undefined;
	let twitter: string | undefined;
	let meetup: string | undefined;
	let eventbrite: string | undefined;
	let telegram: string | undefined;
	let discord: string | undefined;
	let youtube: string | undefined;
	let github: string | undefined;
	let reddit: string | undefined;
	let instagram: string | undefined;
	let whatsapp: string | undefined;
	let facebook: string | undefined;
	let linkedin: string | undefined;
	let rss: string | undefined;
	let signal: string | undefined;
	let simplex: string | undefined;
	let lightning: { destination: string; type: TipType } | undefined;

	let eventElements: ActivityEvent[] = [];
	let taggers: User[] = [];

	let issues: RpcIssue[] = [];
</script>

<main class="my-10 space-y-16 text-center md:my-20">
	<section id="profile" class="space-y-8">
		<div class="space-y-2">
			{#if avatar}
				<img
					src={avatar}
					alt="avatar"
					class="mx-auto h-32 w-32 rounded-full object-cover"
					on:error={function () {
						this.src = '/images/bitcoin.svg';
					}}
				/>
			{:else}
				<div class="mx-auto h-32 w-32 animate-pulse rounded-full bg-link/50" />
			{/if}
			<h1 class="text-4xl !leading-tight font-semibold text-primary dark:text-white">
				{name || 'BTC Map Area'}
			</h1>
			{#if org}
				<OrgBadge {org} />
			{/if}
			{#if sponsor}
				<SponsorBadge />
			{/if}
			{#if description}
				<p class="text-xl text-primary dark:text-white">{description}</p>
			{/if}
			{#if alias && type === 'community'}
				<!-- eslint-disable svelte/no-navigation-without-resolve -->
				<a
					href={`/communities/map?community=${alias}`}
					class="inline-flex items-center justify-center text-xs text-link transition-colors hover:text-hover"
					>View on community map <svg
						class="ml-1 w-3"
						width="16"
						height="16"
						viewBox="0 0 16 16"
						fill="none"
						xmlns="http://www.w3.org/2000/svg"
					>
						<path
							d="M3 13L13 3M13 3H5.5M13 3V10.5"
							stroke="currentColor"
							stroke-width="1.5"
							stroke-linecap="round"
							stroke-linejoin="round"
						/>
					</svg></a
				>
				<!-- eslint-enable svelte/no-navigation-without-resolve -->
			{/if}
		</div>

		{#if type === 'community'}
			{#if dataInitialized}
				<Socials
					{website}
					{email}
					{nostr}
					{twitter}
					{meetup}
					{eventbrite}
					{telegram}
					{discord}
					{youtube}
					{github}
					{reddit}
					{instagram}
					{whatsapp}
					{facebook}
					{linkedin}
					{rss}
					{signal}
					{simplex}
				/>
			{:else}
				<div class="flex flex-wrap items-center justify-center">
					{#each Array(3) as _, index (index)}
						<div class="m-1 h-10 w-10 animate-pulse rounded-full bg-link/50" />
					{/each}
				</div>
			{/if}

			{#if lightning}
				<Tip destination={lightning.destination} type={lightning.type} user={name} />
			{/if}
		{/if}
	</section>

	<div
		on:scroll={() => (scrolled = true)}
		class="hide-scroll relative grid w-full auto-cols-[minmax(150px,_1fr)] grid-flow-col overflow-x-auto"
	>
		{#each sections as section, index (index)}
			<button
				on:click={() => handleSectionChange(section)}
				class="border-b-4 pb-3 text-center text-lg text-link transition-colors hover:border-link {activeSection ===
				section
					? 'border-link font-bold'
					: 'border-link/25'}"
			>
				{section}
			</button>
		{/each}

		{#if !scrolled}
			<div
				class="absolute top-0 right-0 flex h-8 w-8 items-center justify-center rounded-full bg-[#cce3e6] sm:hidden"
			>
				<Icon type="fa" icon="chevron-right" w="16" h="16" class="text-link" />
			</div>
		{/if}
	</div>

	{#if activeSection === Sections.merchants}
		<AreaMap {name} geoJSON={area?.geo_json} {filteredPlaces} />
		<AreaMerchantHighlights
			dataInitialized={dataInitialized && !elementsLoading}
			{filteredPlaces}
		/>
		{#if browser}
			<Boost />
		{/if}
	{:else if activeSection === Sections.stats}
		{#if areaReports && areaReports.length > 0}
			<AreaStats {name} {filteredPlaces} {areaReports} areaTags={area} />
		{:else}
			<div class="text-center text-primary dark:text-white">
				<p class="text-xl">Data will appear within 24 hours.</p>
			</div>
		{/if}
	{:else if activeSection === Sections.activity}
		<AreaActivity
			{alias}
			{name}
			dataInitialized={dataInitialized && !elementsLoading}
			{eventElements}
			{taggers}
		/>
	{:else if activeSection === Sections.maintain}
		<IssuesTable
			title="{name || 'BTC Map Area'} Tagging Issues"
			{issues}
			loading={!(dataInitialized && !elementsLoading)}
		/>
		<AreaTickets tickets={data.tickets} title="{name || 'BTC Map Area'} Open Tickets" />
	{/if}
</main>



================================================
FILE: src/components/area/AreaStats.svelte
================================================
<script lang="ts">
	import { browser } from '$app/environment';
	import Icon from '$components/Icon.svelte';
	import ProfileStat from '$components/ProfileStat.svelte';
	import { calcVerifiedDate, verifiedArr } from '$lib/map/setup';
	import { theme } from '$lib/store';
	import type { Place, Report, AreaTags } from '$lib/types.js';
	import { detectTheme, updateChartThemes } from '$lib/utils';
	import Chart from 'chart.js/auto';
	import { onMount } from 'svelte';

	export let name: string;
	export let filteredPlaces: Place[];
	export let areaReports: Report[];
	export let areaTags: AreaTags | undefined = undefined;

	const getPopulationDate = (tags: AreaTags | undefined): string | undefined => {
		if (!tags) return undefined;
		// Prefer population:date over population:year, convert year to string if needed
		return (
			tags['population:date'] ||
			(tags['population:year'] ? String(tags['population:year']) : undefined)
		);
	};

	let initialRenderComplete = false;
	let dataInitialized = false;

	const initializeData = () => {
		if (dataInitialized) return;

		filteredPlaces.forEach((place) => {
			// get date from 1 year ago to add verified check if survey is current
			let verifiedDate = calcVerifiedDate();
			let verified = verifiedArr(place);

			if (verified.length && Date.parse(verified[0]) > verifiedDate) {
				if (upToDate === undefined) {
					upToDate = 1;
				} else {
					upToDate++;
				}
			} else {
				if (outdated === undefined) {
					outdated = 1;
				} else {
					outdated++;
				}
			}

			if (place['osm:payment:bitcoin']) {
				if (legacy === undefined) {
					legacy = 1;
				} else {
					legacy++;
				}
			}

			if (total === undefined) {
				total = 1;
			} else {
				total++;
			}
		});

		if (!upToDate) {
			upToDate = 0;
		}

		if (!outdated) {
			outdated = 0;
		}

		if (!legacy) {
			legacy = 0;
		}

		if (!total) {
			total = 0;
		}

		upToDatePercent = upToDate ? (upToDate / (total / 100)).toFixed(0) : '0';

		const populateCharts = () => {
			const chartsReports = [...areaReports].sort(
				(a, b) => Date.parse(a['created_at']) - Date.parse(b['created_at'])
			);

			const today = new Date();
			const latestReport = chartsReports[chartsReports.length - 1];
			const latestReportDate = new Date(latestReport.created_at);
			const reportIsCurrent =
				today.getDate() === latestReportDate.getDate() &&
				today.getMonth() === latestReportDate.getMonth() &&
				today.getFullYear() === latestReportDate.getFullYear();

			if (!reportIsCurrent) {
				chartsReports.push({
					...latestReport,
					id: latestReport.id + 1,
					date: `${today.getFullYear()}-${today.getMonth() + 1}-${today.getDate()}`,
					created_at: today.toISOString(),
					updated_at: today.toISOString()
				});
			}

			const theme = detectTheme();

			updatedChart = new Chart(updatedChartCanvas, {
				type: 'pie',
				data: {
					labels: ['Recently Verified', 'Outdated'],
					datasets: [
						{
							label: 'Locations',
							data: [upToDate, outdated],
							backgroundColor: ['rgb(16, 183, 145)', 'rgb(235, 87, 87)'],
							hoverOffset: 4
						}
					]
				},
				options: {
					maintainAspectRatio: false,
					plugins: {
						legend: {
							labels: {
								font: {
									weight: 600
								}
							}
						}
					}
				}
			});

			let percents = chartsReports.filter((report) => report.tags.up_to_date_percent);

			upToDateChart = new Chart(upToDateChartCanvas, {
				type: 'line',
				data: {
					labels: percents.map(({ date }) => date),
					datasets: [
						{
							label: 'Recently Verified Percent',
							data: percents.map(({ tags: { up_to_date_percent } }) => up_to_date_percent),
							fill: {
								target: 'origin',
								above: 'rgba(11, 144, 114, 0.2)'
							},
							borderColor: 'rgb(11, 144, 114)',
							tension: 0.1,
							pointStyle: false
						}
					]
				},
				options: {
					maintainAspectRatio: false,
					plugins: {
						legend: {
							labels: {
								font: {
									weight: 600
								}
							}
						}
					},
					scales: {
						x: {
							ticks: {
								maxTicksLimit: 5,
								font: {
									weight: 600
								}
							},
							grid: {
								color: theme === 'dark' ? 'rgba(255, 255, 255, 0.15)' : 'rgba(0, 0, 0, 0.1)'
							}
						},
						y: {
							min: 0,
							max: 100,
							ticks: {
								precision: 0,
								font: {
									weight: 600
								}
							},
							grid: {
								color: theme === 'dark' ? 'rgba(255, 255, 255, 0.15)' : 'rgba(0, 0, 0, 0.1)'
							}
						}
					},
					interaction: {
						intersect: false
					}
				}
			});

			totalChart = new Chart(totalChartCanvas, {
				type: 'line',
				data: {
					labels: chartsReports.map(({ date }) => date),
					datasets: [
						{
							label: 'Total Locations',
							data: chartsReports.map(({ tags: { total_elements } }) => total_elements),
							fill: {
								target: 'origin',
								above: 'rgba(0, 153, 175, 0.2)'
							},
							borderColor: 'rgb(0, 153, 175)',
							tension: 0.1,
							pointStyle: false
						}
					]
				},
				options: {
					maintainAspectRatio: false,
					plugins: {
						legend: {
							labels: {
								font: {
									weight: 600
								}
							}
						}
					},
					scales: {
						x: {
							ticks: {
								maxTicksLimit: 5,
								font: {
									weight: 600
								}
							},
							grid: {
								color: theme === 'dark' ? 'rgba(255, 255, 255, 0.15)' : 'rgba(0, 0, 0, 0.1)'
							}
						},
						y: {
							min: 0,
							grace: '5%',
							ticks: {
								precision: 0,
								font: {
									weight: 600
								}
							},
							grid: {
								color: theme === 'dark' ? 'rgba(255, 255, 255, 0.15)' : 'rgba(0, 0, 0, 0.1)'
							}
						}
					},
					interaction: {
						intersect: false
					}
				}
			});

			chartsLoading = false;
		};

		populateCharts();

		dataInitialized = true;
	};

	// Check if places have verification data (indicator that enrichment is complete)
	$: hasVerificationData =
		filteredPlaces &&
		filteredPlaces.length > 0 &&
		filteredPlaces.some(
			(p) => p['osm:survey:date'] || p['osm:check_date'] || p['osm:check_date:currency:XBT']
		);

	// Only initialize when we have verification data
	$: hasVerificationData &&
		areaReports &&
		initialRenderComplete &&
		!dataInitialized &&
		initializeData();

	let total: number | undefined;
	let upToDate: number | undefined;
	let outdated: number | undefined;
	let legacy: number | undefined;

	let upToDatePercent: string | undefined;

	let updatedChartCanvas: HTMLCanvasElement;
	// eslint-disable-next-line @typescript-eslint/no-unused-vars
	let updatedChart;

	let chartsLoading = true;
	let upToDateChartCanvas: HTMLCanvasElement;
	let upToDateChart: Chart<'line', number[], string>;
	let totalChartCanvas: HTMLCanvasElement;
	let totalChart: Chart<'line', number[], string>;

	$: $theme !== undefined && !chartsLoading && updateChartThemes([upToDateChart, totalChart]);

	onMount(async () => {
		if (browser) {
			// setup charts
			updatedChartCanvas.getContext('2d');
			upToDateChartCanvas.getContext('2d');
			totalChartCanvas.getContext('2d');

			initialRenderComplete = true;
		}
	});
</script>

<section id="stats">
	{#if areaTags && (areaTags.population || areaTags.area_km2)}
		<div
			class="mb-5 grid gap-4 rounded-3xl border border-gray-300 p-6 md:grid-cols-2 dark:border-white/95 dark:bg-white/10"
		>
			{#if areaTags.population}
				<div class="flex flex-col">
					<span class="text-sm tracking-wide text-gray-600 uppercase dark:text-gray-300"
						>Population</span
					>
					<span class="text-2xl font-bold text-primary dark:text-white">
						{parseInt(areaTags.population).toLocaleString()}
					</span>
					{#if getPopulationDate(areaTags)}
						<span class="text-xs text-gray-500 dark:text-gray-400">
							as of {getPopulationDate(areaTags)}
						</span>
					{/if}
				</div>
			{/if}
			{#if areaTags.area_km2}
				<div class="flex flex-col">
					<span class="text-sm tracking-wide text-gray-600 uppercase dark:text-gray-300">Area</span>
					<span class="text-2xl font-bold text-primary dark:text-white">
						{areaTags.area_km2.toLocaleString()} kmÂ²
					</span>
				</div>
			{/if}
		</div>
	{/if}

	<div
		class="border border-gray-300 dark:border-white/95 dark:bg-white/10 {total === 0
			? 'rounded-3xl'
			: 'rounded-t-3xl'} grid md:grid-cols-2 xl:grid-cols-2"
	>
		<ProfileStat
			title="Total Locations"
			stat={total}
			border="border-b xl:border-b-0 md:border-r border-gray-300 dark:border-white/95"
		/>
		<ProfileStat
			title="Recently Verified Locations"
			stat={upToDate}
			percent={total && total > 0 ? upToDatePercent : undefined}
			border="border-b xl:border-b-0 xl:border-r border-gray-300 dark:border-white/95"
			tooltip="Locations that have been verified within one year."
		/>
	</div>

	<div
		class="{total === 0
			? 'hidden'
			: ''} relative rounded-b-3xl border border-t-0 border-gray-300 p-5 dark:border-white/95 dark:bg-white/10"
	>
		{#if chartsLoading}
			<div>
				<Icon
					type="fa"
					icon="chart-pie"
					w="208"
					h="208"
					class="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 animate-pulse text-link/50"
				/>
			</div>
		{/if}

		<canvas bind:this={updatedChartCanvas} width="100%" height="250" />
	</div>
</section>

<section id="charts" class="space-y-10">
	<div class="w-full rounded-3xl border border-gray-300 dark:border-white/95 dark:bg-white/10">
		<h3
			class="border-b border-gray-300 p-5 text-center text-lg font-semibold text-primary md:text-left dark:border-white/95 dark:text-white"
		>
			{name || 'BTC Map Area'} Charts
		</h3>

		<div class="border-b border-gray-300 p-5 dark:border-white/95">
			<div class="relative">
				{#if chartsLoading}
					<div
						class="absolute top-0 left-0 flex h-[400px] w-full animate-pulse items-center justify-center rounded-3xl border border-link/50"
					>
						<Icon type="fa" icon="chart-area" w="96" h="96" class="animate-pulse text-link/50" />
					</div>
				{/if}
				<canvas bind:this={totalChartCanvas} width="100%" height="400" />
			</div>
			<p class="mt-1 text-center text-sm text-body dark:text-white">
				*Locations accepting any bitcoin payment method.
			</p>
		</div>

		<div class="border-gray-300 p-5 dark:border-white/95">
			<div class="relative">
				{#if chartsLoading}
					<div
						class="absolute top-0 left-0 flex h-[400px] w-full animate-pulse items-center justify-center rounded-3xl border border-link/50"
					>
						<Icon type="fa" icon="chart-area" w="96" h="96" class="animate-pulse text-link/50" />
					</div>
				{/if}
				<canvas bind:this={upToDateChartCanvas} width="100%" height="400" />
			</div>
			<p class="mt-1 text-center text-sm text-body dark:text-white">
				*Locations with a <em>survey:date</em>, <em>check_date</em>, or
				<em>check_date:currency:XBT</em> tag less than one year old.
			</p>
		</div>
	</div>
</section>

<p class="text-center text-sm text-body md:text-left dark:text-white">
	*More information on bitcoin mapping tags can be found <a
		href="https://gitea.btcmap.org/teambtcmap/btcmap-general/wiki/Tagging-Merchants#tagging-guidance"
		target="_blank"
		rel="noreferrer"
		class="text-link transition-colors hover:text-hover">here</a
	>.
	<br />
	*Chart data updated once every 24 hours.
</p>



================================================
FILE: src/components/area/AreaTickets.svelte
================================================
<script lang="ts">
	import InfoTooltip from '$components/InfoTooltip.svelte';
	import OpenTicket from '$components/OpenTicket.svelte';
	import type { Tickets } from '$lib/types.js';
	import { errToast } from '$lib/utils';

	export let title: string;
	export let tickets: Tickets;
	import type { GiteaLabel, GiteaIssue } from '$lib/types';

	$: filteredTickets = tickets === 'error' ? [] : tickets;

	$: add = filteredTickets.filter((issue: GiteaIssue) =>
		issue.labels.some((label: GiteaLabel) => label.name === 'location-submission')
	);
	$: verify = filteredTickets.filter((issue: GiteaIssue) =>
		issue.labels.some((label: GiteaLabel) => label.name === 'location-verification')
	);
	$: community = filteredTickets.filter((issue: GiteaIssue) =>
		issue.labels.some((label: GiteaLabel) => label.name === 'community-submission')
	);

	const ticketTypes = ['Add', 'Verify', 'Community'];
	let showType = 'Add';

	$: ticketError = tickets === 'error';

	$: if (ticketError) {
		errToast('Could not load open tickets, please try again or contact BTC Map.');
	}

	$: totalTickets = add.length + verify.length + community.length;
</script>

<section id="tickets">
	<div class="w-full rounded-3xl border border-gray-300 dark:border-white/95 dark:bg-white/10">
		<div class="p-5 text-lg font-semibold text-primary dark:text-white">
			<h3 class="mb-2 text-center md:text-left">
				{title}
				{#if filteredTickets.length && !ticketError}
					<span class="text-base">({totalTickets})</span>
				{/if}
				<InfoTooltip
					tooltip="Tickets up for grabs from our noob forms! Anybody can help add or verify submissions on OpenStreetMap."
				/>
			</h3>

			{#each ticketTypes as type (type)}
				<button
					class="mx-auto block w-40 border border-link py-2 text-center md:inline {type === 'Add'
						? 'rounded-t md:rounded-l md:rounded-tr-none'
						: type === 'Verify'
							? 'rounded-b md:rounded-r md:rounded-bl-none'
							: ''} {showType === type ? 'bg-link text-white' : ''} transition-colors"
					on:click={() => (showType = type)}
					disabled={!filteredTickets.length || ticketError}
				>
					{type}
				</button>
			{/each}
		</div>

		{#if filteredTickets.length && !ticketError}
			{#if showType === 'Add'}
				{#if add.length}
					{#each add as ticket (ticket.number)}
						<OpenTicket
							assignees={ticket.assignees}
							comments={ticket.comments}
							created={ticket.created_at}
							url={ticket.html_url}
							labels={ticket.labels}
							id={ticket.number}
							name={ticket.title}
							user={ticket.user}
						/>
					{/each}
				{:else}
					<p
						class="border-t border-gray-300 p-5 text-center text-body dark:border-white/95 dark:text-white"
					>
						No open <strong>add</strong> tickets.
					</p>
				{/if}
			{:else if showType === 'Verify'}
				{#if verify.length}
					{#each verify as ticket (ticket.number)}
						<OpenTicket
							assignees={ticket.assignees}
							comments={ticket.comments}
							created={ticket.created_at}
							url={ticket.html_url}
							labels={ticket.labels}
							id={ticket.number}
							name={ticket.title}
							user={ticket.user}
						/>
					{/each}
				{:else}
					<p
						class="border-t border-gray-300 p-5 text-center text-body dark:border-white/95 dark:text-white"
					>
						No open <strong>verify</strong> tickets.
					</p>
				{/if}
			{:else if showType === 'Community'}
				{#if community.length}
					{#each community as ticket (ticket.number)}
						<OpenTicket
							assignees={ticket.assignees}
							comments={ticket.comments}
							created={ticket.created_at}
							url={ticket.html_url}
							labels={ticket.labels}
							id={ticket.number}
							name={ticket.title}
							user={ticket.user}
						/>
					{/each}
				{:else}
					<p
						class="border-t border-gray-300 p-5 text-center text-body dark:border-white/95 dark:text-white"
					>
						No open <strong>community</strong> tickets.
					</p>
				{/if}
			{/if}
		{:else if ticketError}
			<p
				class="border-t border-gray-300 p-5 text-center text-body dark:border-white/95 dark:text-white"
			>
				Error fetching tickets. Please try again or contact BTC Map support.
			</p>
		{/if}
	</div>
</section>



================================================
FILE: src/components/area/MerchantCard.svelte
================================================
<script lang="ts">
	import BoostButton from '$components/BoostButton.svelte';
	import Icon from '$components/Icon.svelte';
	import { calcVerifiedDate, verifiedArr } from '$lib/map/setup';
	import type { Place } from '$lib/types';
	import { isBoosted, formatOpeningHours, fetchEnhancedPlace } from '$lib/utils';
	import Time from 'svelte-time';
	import tippy from 'tippy.js';
	import { resolve } from '$app/paths';
	import { onMount } from 'svelte';

	export let merchant: Place;

	// Enhanced merchant data (fetched on-demand if basic data is missing)
	let enhancedMerchant: Place | null = null;
	let isEnhancing = false;

	// Check if we need to fetch enhanced data (only essential fields)
	$: needsEnhancement = !merchant.name || !merchant.address;

	// Fetch enhanced data when needed
	async function enhanceMerchantData() {
		if (!needsEnhancement || isEnhancing) return;

		isEnhancing = true;
		try {
			const enhanced = await fetchEnhancedPlace(merchant.id.toString());
			if (enhanced) {
				enhancedMerchant = enhanced;
			}
		} catch (error) {
			console.error('Failed to enhance merchant data:', error);
		} finally {
			isEnhancing = false;
		}
	}

	// Auto-enhance on mount if needed
	onMount(() => {
		if (needsEnhancement) {
			enhanceMerchantData();
		}
	});

	// Use enhanced data if available, otherwise fall back to original
	$: displayMerchant = enhancedMerchant || merchant;

	// Make boosted reactive and handle undefined displayMerchant
	$: boosted = displayMerchant ? isBoosted(displayMerchant) : false;

	// Use internal Place ID for merchant link, fallback to OSM ID
	$: merchantLinkId = merchant.id || displayMerchant?.osm_id;

	// Make all displayMerchant property accesses reactive with safe defaults
	$: icon = displayMerchant?.icon || 'question_mark';
	$: address = displayMerchant?.address;
	$: website = displayMerchant?.website;
	$: openingHours = displayMerchant?.opening_hours;
	$: phone = displayMerchant?.phone;
	$: email = displayMerchant?.email;
	$: twitter = displayMerchant?.twitter;
	$: instagram = displayMerchant?.instagram;
	$: facebook = displayMerchant?.facebook;
	$: verified = displayMerchant ? verifiedArr(displayMerchant) : [];
	const verifiedDate = calcVerifiedDate();

	let outdatedTooltip: HTMLDivElement;

	$: outdatedTooltip &&
		tippy([outdatedTooltip], {
			content: 'Outdated please re-verify'
		});
</script>

<div
	class="flex flex-col justify-between rounded-2xl border bg-white/50 p-4 text-left transition-shadow hover:shadow-lg sm:p-6 dark:bg-white/5 {boosted
		? 'border-bitcoin'
		: 'border-gray-300 dark:border-white/95'}"
>
	<div>
		<div class="mb-3 flex w-full flex-col items-center justify-between gap-2 sm:flex-row">
			<a
				href={resolve(`/merchant/${merchantLinkId}`)}
				class="inline-flex w-full flex-col items-center gap-2 font-bold transition-colors sm:w-auto sm:flex-row {boosted
					? 'text-bitcoin hover:text-bitcoinHover'
					: 'text-link hover:text-hover'}"
			>
				<Icon
					w="24"
					h="24"
					icon={icon !== 'question_mark' ? icon : 'currency_bitcoin'}
					type="material"
					class="shrink-0"
				/>
				<p class="text-lg break-all">{displayMerchant.name || 'BTC Map Merchant'}</p>
			</a>
		</div>

		<div class="mb-3 w-full space-y-2 break-all text-primary dark:text-white">
			{#if address}
				<div class="flex items-center space-x-2 font-medium">
					<Icon w="16" h="16" icon="location_on" type="material" class="shrink-0" />
					<a
						href="geo:{merchant.lat},{merchant.lon}"
						class="text-sm underline decoration-primary decoration-1 underline-offset-4 dark:decoration-white"
					>
						{address}
					</a>
				</div>
			{/if}

			{#if website}
				<div class="flex items-center space-x-2">
					<Icon w="16" h="16" icon="language" type="material" class="shrink-0" />
					<!-- eslint-disable svelte/no-navigation-without-resolve -->
					<a
						href={website.startsWith('http') ? website : `https://${website}`}
						target="_blank"
						rel="noreferrer"
						class="text-sm underline decoration-primary decoration-1 underline-offset-4 dark:decoration-white"
					>
						<!-- eslint-enable svelte/no-navigation-without-resolve -->
						{website}
					</a>
				</div>
			{/if}

			{#if openingHours}
				<div class="flex items-center space-x-2">
					<Icon w="16" h="16" icon="schedule" type="material" class="shrink-0" />
					<div class="text-sm">
						<time class="flex flex-col items-start">
							<!-- eslint-disable-next-line svelte/no-at-html-tags - we sanitize the content in formatOpeningHours -->
							{@html formatOpeningHours(openingHours)}
						</time>
					</div>
				</div>
			{/if}

			{#if phone}
				<div class="flex items-center space-x-2">
					<Icon w="16" h="16" icon="phone" type="material" class="shrink-0" />
					<a
						href="tel:{phone}"
						class="text-sm underline decoration-primary decoration-1 underline-offset-4 dark:decoration-white"
					>
						{phone}
					</a>
				</div>
			{/if}

			{#if email}
				<div class="flex items-center space-x-2">
					<Icon w="16" h="16" icon="email" type="material" class="shrink-0" />
					<a
						href="mailto:{email}"
						class="text-sm underline decoration-primary decoration-1 underline-offset-4 dark:decoration-white"
					>
						{email}
					</a>
				</div>
			{/if}

			<div class="flex items-center space-x-2">
				{#if twitter}
					<!-- eslint-disable svelte/no-navigation-without-resolve -->
					<a
						href={twitter.startsWith('http') ? twitter : `https://twitter.com/${twitter}`}
						target="_blank"
						rel="noreferrer"
					>
						<!-- eslint-enable svelte/no-navigation-without-resolve -->

						<Icon w="16" h="16" icon="x-twitter" type="fa" />
					</a>
				{/if}

				{#if instagram}
					<!-- eslint-disable svelte/no-navigation-without-resolve -->
					<a
						href={instagram.startsWith('http') ? instagram : `https://instagram.com/${instagram}`}
						target="_blank"
						rel="noreferrer"
					>
						<!-- eslint-enable svelte/no-navigation-without-resolve -->

						<Icon w="16" h="16" icon="instagram" type="fa" />
					</a>
				{/if}

				{#if facebook}
					<!-- eslint-disable svelte/no-navigation-without-resolve -->
					<a
						href={facebook.startsWith('http') ? facebook : `https://facebook.com/${facebook}`}
						target="_blank"
						rel="noreferrer"
					>
						<!-- eslint-enable svelte/no-navigation-without-resolve -->

						<Icon w="16" h="16" icon="facebook" type="fa" />
					</a>
				{/if}
			</div>
		</div>
	</div>

	<div class="w-full space-y-2 border-t border-gray-300 pt-3 dark:border-gray-300/25">
		{#if verified.length}
			<div class="flex items-center space-x-1">
				<p class="text-sm font-semibold text-gray-500 dark:text-gray-400">
					Last Surveyed: <span class="text-primary dark:text-white">{verified[0]}</span>
				</p>

				{#if !(Date.parse(verified[0]) > verifiedDate)}
					<div bind:this={outdatedTooltip} class="text-primary dark:text-white">
						<Icon w="16" h="16" icon="error_outline" type="material" class="shrink-0" />
					</div>
				{/if}
			</div>
		{:else}
			<div class="flex items-center space-x-1 text-gray-500 dark:text-gray-400">
				<Icon w="16" h="16" icon="sentiment_dissatisfied" type="material" class="shrink-0" />
				<p class="text-sm font-semibold">Not Verified</p>
			</div>
		{/if}

		{#if boosted}
			<div class="flex items-center space-x-1">
				<p class="text-sm font-semibold text-gray-500 dark:text-gray-400">
					Boost Expires: <span class="text-primary dark:text-white"
						><Time live={3000} relative={true} timestamp={merchant.boosted_until} /></span
					>
				</p>
			</div>
		{/if}

		<div class="flex justify-between space-x-2 sm:justify-start">
			<a
				href={resolve(`/merchant/${merchantLinkId}`)}
				class="inline-flex items-center space-x-1 font-semibold text-link transition-colors hover:text-hover"
				title="Help improve the data for everyone"
			>
				<Icon w="16" h="16" icon="verified" type="material" class="shrink-0" />
				<p class="text-sm">Verify</p>
			</a>

			<BoostButton {merchant} boosted={boosted ? merchant.boosted_until : undefined} style="link" />
		</div>
	</div>
</div>



================================================
FILE: src/components/layout/Footer.svelte
================================================
<script lang="ts">
	import SocialLink from '$components/SocialLink.svelte';
	import { socials } from '$lib/store';

	const links = [
		{ link: '/about-us', name: 'About Us' },
		{ link: '/media', name: 'Media' },
		{ link: '/license', name: 'License' },
		{ link: '/privacy-policy', name: 'Privacy' },
		{ link: 'https://stats.uptimerobot.com/7kgEVtzlV1', name: 'Status' },
		{ link: 'https://bitcoin.rocks/business/', name: 'Bitcoin for Business', external: true },
		{ link: '/bitcoin.pdf', name: 'White Paper' },
		{ link: '/cypherpunks-manifesto.pdf', name: 'Cypherpunks' }
	];
</script>

<footer class="w-full items-center justify-between space-y-5 pb-5 xl:flex xl:space-y-0">
	<div class="flex flex-wrap justify-center gap-5 xl:block xl:space-x-5">
		<SocialLink url={$socials.matrix} social="matrix" />
		<SocialLink url={$socials.github} social="github" />
		<SocialLink url={$socials.amboss} social="amboss" />
		<SocialLink url={$socials.nostr} social="nostr" />
		<SocialLink url={$socials.x} social="x" />
	</div>

	<div class="flex flex-wrap justify-center xl:block">
		{#each links as link (link.name)}
			<!-- eslint-disable svelte/no-navigation-without-resolve -->
			<a
				href={link.link}
				target={link.external ? '_blank' : null}
				rel={link.external ? 'noreferrer' : null}
				class="mx-2.5 {link.name !== 'Cypherpunks'
					? 'mb-2.5 xl:mb-0'
					: ''} text-sm text-link transition-colors hover:text-hover dark:text-white/50 dark:hover:text-link"
			>
				{link.name}
			</a>
			<!-- eslint-enable svelte/no-navigation-without-resolve -->
		{/each}
	</div>
</footer>



================================================
FILE: src/components/layout/Header.svelte
================================================
<script lang="ts">
	import type { MobileNavIconName } from '$lib/icons/types';
	import type { DropdownLink } from '$lib/types';
	import IconMobileNav from '$lib/icons/IconMobileNav.svelte';
	import NavDropdownDesktop from '$components/layout/NavDropdownDesktop.svelte';
	import NavDropdownMobile from '$components/layout/NavDropdownMobile.svelte';
	import ThemeToggle from '$components/ThemeToggle.svelte';
	import { afterNavigate } from '$app/navigation';

	const navLinks: { title: string; url: string; icon: MobileNavIconName }[] = [
		{ title: 'Maps', url: '', icon: 'map' },
		{ title: 'Apps', url: '/apps', icon: 'apps' },
		{ title: 'Stats', url: '', icon: 'stats' },
		{ title: 'Areas', url: '', icon: 'areas' },
		{ title: 'Maintain', url: '', icon: 'contribute' },
		{ title: 'Wiki', url: 'https://gitea.btcmap.org/teambtcmap/btcmap-general/wiki', icon: 'wiki' },
		{ title: 'Blog', url: 'https://blog.btcmap.org', icon: 'dash' },
		{ title: 'Support Us', url: '/support-us', icon: 'support' }
	];

	const mapsDropdownLinks: DropdownLink[] = [
		{ title: 'Merchant Map', url: '/map', icon: 'add' },
		{ title: 'Community Map', url: '/communities/map', icon: 'communities' }
	];

	const statsDropdownLinks: DropdownLink[] = [
		{ title: 'Dashboard', url: '/dashboard', icon: 'dash' },
		{ title: 'Tagger Leaderboard', url: '/leaderboard', icon: 'leader' },
		{ title: 'Community Leaderboard', url: '/communities/leaderboard', icon: 'communities' },
		{ title: 'Country Leaderboard', url: '/countries/leaderboard', icon: 'countries' }
	];

	const maintainDropdownLinks: DropdownLink[] = [
		{ title: 'Add Location', url: '/add-location', icon: 'add' },
		{ title: 'Add Community', url: '/communities/add', icon: 'communities' },
		{ title: 'Open Tickets', url: '/tickets', icon: 'ticket' },
		{ title: 'Tagging Activity', url: '/activity', icon: 'activity' },
		{ title: 'Tagging Issues', url: '/tagging-issues', icon: 'issue' }
	];

	const areasDropdownLinks: DropdownLink[] = [
		{ title: 'Communities', url: '/communities', icon: 'communities' },
		{ title: 'Countries', url: '/countries', icon: 'countries' }
	];

	let showMobileMenu = false;

	afterNavigate(() => {
		showMobileMenu = false;
	});
</script>

<!-- desktop header -->
<header class="relative z-30 mx-auto hidden w-[1200px] items-center justify-between py-5 xl:flex">
	<!-- eslint-disable svelte/no-navigation-without-resolve -->
	<a href="/">
		<img src="/images/logo.svg" alt="logo" class="w-16" />
	</a>
	<!-- eslint-enable svelte/no-navigation-without-resolve -->

	<nav class="flex flex-wrap space-x-16">
		{#each navLinks as link (link.title)}
			<!-- dropdown menu -->
			{#if link.title === 'Maps'}
				<NavDropdownDesktop
					title={link.title}
					links={mapsDropdownLinks}
					top="add"
					bottom="communities"
				/>

				<!-- dropdown menu -->
			{:else if link.title === 'Stats'}
				<NavDropdownDesktop
					title={link.title}
					links={statsDropdownLinks}
					top="dash"
					bottom="countries"
				/>

				<!-- dropdown menu -->
			{:else if link.title === 'Maintain'}
				<NavDropdownDesktop
					title={link.title}
					links={maintainDropdownLinks}
					top="add"
					bottom="issue"
				/>

				<!-- dropdown menu -->
			{:else if link.title === 'Areas'}
				<NavDropdownDesktop
					title={link.title}
					links={areasDropdownLinks}
					top="communities"
					bottom="countries"
				/>
			{:else}
				<!-- regular links -->
				<!-- eslint-disable svelte/no-navigation-without-resolve -->
				<a
					href={link.url}
					class="text-xl font-semibold text-link transition-colors hover:text-hover dark:text-white dark:hover:text-link"
				>
					{link.title}
				</a>
				<!-- eslint-enable svelte/no-navigation-without-resolve -->
			{/if}
		{/each}
	</nav>

	<ThemeToggle />
</header>

<!-- mobile header -->
<header
	class="sticky top-0 z-30 flex w-full items-center justify-between px-4 py-5 xl:hidden {showMobileMenu
		? 'bg-teal dark:bg-dark'
		: 'bg-teal/90 dark:bg-dark/90'}"
>
	<!-- eslint-disable-next-line svelte/no-navigation-without-resolve -->
	<a href="/">
		<img src="/images/logo.svg" alt="logo" class="w-16" />
	</a>

	<div class="space-x-4">
		<ThemeToggle />

		<!-- menu toggle -->
		<button on:click={() => (showMobileMenu = !showMobileMenu)}>
			<IconMobileNav
				w={showMobileMenu ? '28' : '34'}
				h={showMobileMenu ? '27' : '12'}
				class="mx-auto mb-3 text-mobileMenu dark:text-white"
				icon={showMobileMenu ? 'close' : 'bars'}
			/>
			<span class="font-semibold text-mobileMenu uppercase dark:text-white">Menu</span>
		</button>
	</div>

	<!-- menu -->
	<nav
		class="hide-scroll absolute top-[122.45px] z-30 {showMobileMenu
			? 'left-0'
			: 'left-[-100%]'} h-[calc(100dvh-122.45px)] w-full space-y-2 overflow-y-auto border-t border-[#BDD2D4] bg-teal p-8 transition-all ease-in-out dark:bg-dark"
	>
		{#each navLinks as link (link.title)}
			<!-- dropdown menu -->
			{#if link.title === 'Maps'}
				<NavDropdownMobile title={link.title} icon={link.icon} links={mapsDropdownLinks} />

				<!-- dropdown menu -->
			{:else if link.title === 'Stats'}
				<NavDropdownMobile title={link.title} icon={link.icon} links={statsDropdownLinks} />

				<!-- dropdown menu -->
			{:else if link.title === 'Areas'}
				<NavDropdownMobile title={link.title} icon={link.icon} links={areasDropdownLinks} />

				<!-- dropdown menu -->
			{:else if link.title === 'Maintain'}
				<NavDropdownMobile title={link.title} icon={link.icon} links={maintainDropdownLinks} />

				<!-- regular links -->
			{:else}
				<!-- eslint-disable-next-line svelte/no-navigation-without-resolve -->
				<a href={link.url} class="flex w-full items-center text-xl text-link dark:text-white">
					<span
						class="mr-4 rounded-full bg-mobileButtons p-3 transition-colors active:bg-mobileButtonsActive"
					>
						<IconMobileNav w="24" h="24" icon={link.icon} />
					</span>
					<span>{link.title}</span>
				</a>
			{/if}
		{/each}
	</nav>
</header>



================================================
FILE: src/components/layout/HeaderPlaceholder.svelte
================================================
<div class="h-[60px] w-full" />



================================================
FILE: src/components/layout/NavDropdownDesktop.svelte
================================================
<script lang="ts">
	import type { DropdownLink } from '$lib/types';
	import OutClick from 'svelte-outclick';
	import Icon from '$components/Icon.svelte';

	export let title: string;
	export let links: DropdownLink[];
	export let top: string;
	export let bottom: string;

	let show = false;

	import { afterNavigate } from '$app/navigation';

	afterNavigate(() => {
		show = false;
	});
</script>

<!-- dropdown menu -->
<div class="relative">
	<button
		id="dropdown-{title.toLowerCase()}"
		on:click={() => (show = !show)}
		class="{show
			? 'dark:!text-link'
			: ''} mt-4 mr-4 flex items-center text-xl font-semibold text-link transition-colors hover:text-hover md:mt-0 md:mr-0 dark:text-white dark:hover:text-link"
	>
		{title}
		<Icon type="fa" icon="chevron-down" w="16" h="16" class="ml-1" />
	</button>

	<!-- dropdown items -->
	{#if show}
		<OutClick
			excludeQuerySelectorAll={`#dropdown-${title.toLowerCase()}`}
			on:outclick={() => (show = false)}
		>
			<div class="absolute top-8 right-0 z-50 w-[185px] rounded-2xl shadow-lg">
				{#each links as link (link.url)}
					<!-- eslint-disable svelte/no-navigation-without-resolve -->
					<a
						href={link.url}
						target={link.external ? '_blank' : null}
						rel={link.external ? 'noreferrer' : null}
						class="flex w-full items-center justify-center bg-link p-4 text-center text-xl font-semibold text-white hover:bg-hover {link.icon ===
						top
							? 'rounded-t-2xl'
							: link.icon === bottom
								? 'rounded-b-2xl'
								: ''} transition-colors"
					>
						<!-- eslint-enable svelte/no-navigation-without-resolve -->
						{link.title}
						{#if link.external}
							<Icon type="fa" icon="arrow-up-right-from-square" w="16" h="16" class="ml-1" />
						{/if}
					</a>
				{/each}
			</div>
		</OutClick>
	{/if}
</div>



================================================
FILE: src/components/layout/NavDropdownMobile.svelte
================================================
<script lang="ts">
	import Icon from '$components/Icon.svelte';
	import type { MobileNavIconName } from '$lib/icons/types';
	import IconMobileNav from '$lib/icons/IconMobileNav.svelte';
	import type { DropdownLink } from '$lib/types';
	import OutClick from 'svelte-outclick';

	export let title: string;
	export let icon: MobileNavIconName;
	export let links: DropdownLink[];

	let show = false;

	// Type assertion needed because template literal creates union of all possible strings
	$: displayIcon = (show ? `${icon}-highlight` : icon) as MobileNavIconName;
</script>

<!-- dropdown menu -->
<button
	id="dropdown-{title.toLowerCase()}-mobile"
	on:click={() => (show = !show)}
	class="w-full {show ? 'text-[#144046]' : 'text-link'} flex items-center text-xl dark:text-white"
>
	<span
		class="mr-4 rounded-full bg-mobileButtons p-3 transition-colors active:bg-mobileButtonsActive"
	>
		<IconMobileNav w="24" h="24" icon={displayIcon} />
	</span>
	<span>{title}</span>
</button>

<!-- dropdown items -->
{#if show}
	<OutClick
		excludeQuerySelectorAll={`#dropdown-${title.toLowerCase()}-mobile`}
		on:outclick={() => (show = false)}
	>
		<div class="ml-7 space-y-2">
			{#each links as link (link.url)}
				<!-- eslint-disable svelte/no-navigation-without-resolve -->
				<a
					href={link.url}
					target={link.external ? '_blank' : null}
					rel={link.external ? 'noreferrer' : null}
					class="flex w-full items-center text-xl text-link dark:text-white"
				>
					<!-- eslint-enable svelte/no-navigation-without-resolve -->
					<span
						class="mr-4 rounded-full bg-mobileButtons p-3 transition-colors active:bg-mobileButtonsActive"
					>
						<IconMobileNav w="24" h="24" icon={link.icon} />
					</span>
					<span>{link.title}</span>
					{#if link.external}
						<Icon type="fa" icon="arrow-up-right-from-square" w="16" h="16" class="ml-1" />
					{/if}
				</a>
			{/each}
		</div>
	</OutClick>
{/if}



================================================
FILE: src/components/leaderboard/AreaLeaderboard.svelte
================================================
<script lang="ts">
	import {
		createSvelteTable,
		getCoreRowModel,
		getSortedRowModel,
		getPaginationRowModel,
		getFilteredRowModel,
		type ColumnDef,
		type TableOptions,
		type SortingState,
		type PaginationState,
		type OnChangeFn,
		type FilterFn
	} from '@tanstack/svelte-table';
	import { writable, derived } from 'svelte/store';
	import { onMount } from 'svelte';
	import { areaError, areas, reportError, reports, syncStatus, theme } from '$lib/store';
	import type { AreaType, LeaderboardArea, Report } from '$lib/types';
	import { errToast, getGrade, validateContinents, detectTheme, debounce } from '$lib/utils';

	import AreaLeaderboardMobileCard from '$components/leaderboard/AreaLeaderboardMobileCard.svelte';
	import AreaLeaderboardDesktopTable from '$components/leaderboard/AreaLeaderboardDesktopTable.svelte';
	import LeaderboardSearch from '$components/leaderboard/LeaderboardSearch.svelte';
	import LeaderboardPagination from '$components/leaderboard/LeaderboardPagination.svelte';
	import SortHeaderButton from '$components/leaderboard/SortHeaderButton.svelte';
	import { rankItem } from '@tanstack/match-sorter-utils';
	import tippy from 'tippy.js';

	import { GradeTable } from '$lib/constants';
	import Icon from '$components/Icon.svelte';

	export let type: AreaType;
	export let initialPageSize = 10;

	const pageSizes = [10, 20, 30, 40, 50];
	let globalFilter = '';

	// Tooltip references for header tooltips only
	let totalTooltip: HTMLButtonElement;
	let upToDateTooltip: HTMLButtonElement;
	let gradeTooltip: HTMLButtonElement;

	// Alert for errors - more idiomatic Svelte
	$: if ($areaError) errToast($areaError);
	$: if ($reportError) errToast($reportError);

	// More idiomatic Svelte using derived stores
	const areasFiltered = derived([areas, reports], ([$areas, $reports]) => {
		if (!$reports?.length) return [];

		return $areas.filter((area) => {
			if (type === 'community') {
				return (
					area.tags.type === 'community' &&
					area.tags.geo_json &&
					area.tags.name &&
					area.tags['icon:square'] &&
					area.tags.continent &&
					Object.keys(area.tags).find((key) => key.includes('contact')) &&
					$reports.find((report) => report.area_id === area.id)
				);
			} else {
				return (
					area.tags.type === 'country' &&
					area.id.length === 2 &&
					area.tags.geo_json &&
					area.tags.name &&
					area.tags.continent &&
					validateContinents(area.tags.continent)
				);
			}
		});
	});

	const areaReports = derived([areasFiltered, reports], ([$areasFiltered, $reports]) => {
		if (!$areasFiltered?.length || !$reports?.length) return [];

		return $reports
			.filter((report) => $areasFiltered.find((area) => area.id === report.area_id))
			.sort((a, b) => Date.parse(b.created_at) - Date.parse(a.created_at));
	});

	// Scoring function for leaderboard
	const score = (report: Report): number => {
		return Math.max(report.tags.total_elements - report.tags.outdated_elements * 5, 0);
	};

	// Derived store for leaderboard data
	const leaderboard = derived(
		[areasFiltered, areaReports, syncStatus],
		([$areasFiltered, $areaReports, $syncStatus]) => {
			if (!$areasFiltered.length || !$areaReports.length || $syncStatus) {
				return [];
			}

			const result: LeaderboardArea[] = [];

			$areasFiltered.forEach((area) => {
				const areaReport = $areaReports.find((report) => report.area_id === area.id);

				if (areaReport) {
					const grade = getGrade(areaReport.tags.up_to_date_percent);
					result.push({ ...area, report: areaReport, grade });
				}
			});

			// Apply the same sorting logic as the original component
			return result.sort((a, b) => {
				const aScore = score(a.report);
				const bScore = score(b.report);

				// Primary sort: by score (descending - higher scores first)
				if (bScore !== aScore) {
					return bScore - aScore;
				}

				// Secondary sort: by total elements (descending - more locations first)
				return b.report.tags.total_elements - a.report.tags.total_elements;
			});
		}
	);

	// Create a derived store for leaderboard with positions
	const leaderboardWithPositions = derived(leaderboard, ($leaderboard) => {
		return $leaderboard.map((item, index) => ({
			...item,
			position: index + 1 // Position based on sorted order
		}));
	});

	// Fuzzy filter for global search
	// eslint-disable-next-line @typescript-eslint/no-explicit-any
	const fuzzyFilter: FilterFn<any> = (row, columnId, value, addMeta) => {
		const itemRank = rankItem(row.getValue(columnId), value);
		addMeta({ itemRank });
		return itemRank.passed;
	};

	// Column definitions - static, defined once
	const columns: ColumnDef<LeaderboardArea & { position: number }>[] = [
		{
			id: 'position',
			header: 'Position',
			accessorFn: (row) => row.position,
			cell: (info) => {
				const position = info.getValue() as number;
				if (position === 1) return 'ğŸ¥‡';
				if (position === 2) return 'ğŸ¥ˆ';
				if (position === 3) return 'ğŸ¥‰';
				return position.toString();
			},
			enableSorting: true,
			enableGlobalFilter: false,
			sortingFn: (a, b) => {
				return a.original.position - b.original.position;
			}
		},
		{
			id: 'name',
			header: 'Name',
			accessorFn: (row) => row.tags?.name || 'Unknown',
			cell: (info) => info.row.original,
			enableSorting: true,
			// @ts-expect-error TanStack table expects string literal for filterFn but we're using custom fuzzy filter
			filterFn: 'fuzzy',
			enableGlobalFilter: true
		},
		{
			id: 'total',
			header: 'Total Locations',
			accessorFn: (row) => row.report?.tags?.total_elements || 0,
			enableSorting: true,
			enableGlobalFilter: false
		},
		{
			id: 'upToDateElements',
			header: 'Verified Locations',
			accessorFn: (row) => row.report?.tags?.up_to_date_elements || 0,
			enableSorting: true,
			enableGlobalFilter: false
		},
		{
			id: 'grade',
			header: () => {
				return `Grade`;
			},
			accessorFn: (row) => row.grade || 0,
			cell: (info) => info.getValue(),
			sortingFn: (a, b) => {
				const aGrade = a.original.grade || 0;
				const bGrade = b.original.grade || 0;

				// Primary sort: by grade (descending - higher grades first)
				if (bGrade !== aGrade) {
					return bGrade - aGrade;
				}

				// Secondary sort: by up_to_date_percent (descending - higher percentages first)
				const aPercent = a.original.report?.tags?.up_to_date_percent || 0;
				const bPercent = b.original.report?.tags?.up_to_date_percent || 0;
				return bPercent - aPercent;
			},
			enableSorting: true,
			enableGlobalFilter: false
		}
	];

	// Table state - initialized once
	let sorting: SortingState = [{ id: 'position', desc: false }];
	let pagination: PaginationState = {
		pageIndex: 0,
		pageSize: initialPageSize
	};

	const setSorting: OnChangeFn<SortingState> = (updater) => {
		if (updater instanceof Function) {
			sorting = updater(sorting);
		} else {
			sorting = updater;
		}
		options.update((old) => ({
			...old,
			state: {
				...old.state,
				sorting
			}
		}));
	};

	const setPagination: OnChangeFn<PaginationState> = (updater) => {
		if (updater instanceof Function) {
			pagination = updater(pagination);
		} else {
			pagination = updater;
		}
		options.update((old) => ({
			...old,
			state: {
				...old.state,
				pagination
			}
		}));
	};

	// Table options store - created once
	const options = writable<TableOptions<LeaderboardArea & { position: number }>>({
		data: [], // Start with empty data
		columns,
		state: {
			sorting,
			pagination
		},
		filterFns: {
			fuzzy: fuzzyFilter
		},
		onSortingChange: setSorting,
		onPaginationChange: setPagination,
		globalFilterFn: fuzzyFilter,
		getCoreRowModel: getCoreRowModel(),
		getSortedRowModel: getSortedRowModel(),
		getPaginationRowModel: getPaginationRowModel(),
		getFilteredRowModel: getFilteredRowModel()
	});

	// Create table instance once
	const table = createSvelteTable(options);

	// Update only data reactively, not entire table
	$: if ($leaderboardWithPositions) {
		options.update((current) => ({
			...current,
			data: $leaderboardWithPositions
		}));
	}

	// Search handlers
	const handleKeyUp = (e: KeyboardEvent) => {
		$table?.setGlobalFilter(String((e.target as HTMLInputElement)?.value));
	};

	const searchDebounce = debounce((e) => handleKeyUp(e));

	// Loading state
	$: loading =
		$syncStatus || ($leaderboardWithPositions.length === 0 && !$areaError && !$reportError);

	// Better lifecycle management
	onMount(() => {
		setHeaderTooltips();
	});

	// Simplified tooltip setup function for header tooltips only
	const setHeaderTooltips = () => {
		if (totalTooltip) {
			tippy(totalTooltip, {
				content: 'All locations inc. ATMS',
				allowHTML: true
			});
		}

		if (upToDateTooltip) {
			tippy(upToDateTooltip, {
				content: 'Locations verified within the past year',
				allowHTML: true
			});
		}

		if (gradeTooltip) {
			tippy(gradeTooltip, {
				content: GradeTable,
				allowHTML: true
			});
		}
	};

	// Set header tooltips when elements are available
	$: upToDateTooltip && totalTooltip && gradeTooltip && setHeaderTooltips();
</script>

<section id="leaderboard" aria-labelledby="leaderboard-title">
	<div
		class="w-full rounded-3xl border border-gray-300 bg-white dark:border-white/95 dark:bg-white/10"
	>
		<header>
			<h2
				id="leaderboard-title"
				class="border-b border-gray-300 p-5 text-center text-lg font-semibold text-primary md:text-left dark:border-white/95 dark:text-white"
			>
				{type === 'community' ? 'Community' : 'Country'} Leaderboard
				{#if !loading && $leaderboardWithPositions.length > 0}
					({$leaderboardWithPositions.length})
				{/if}
			</h2>
		</header>

		{#if loading}
			<div class="p-5">
				<div
					class="flex h-[572px] w-full animate-pulse items-center justify-center rounded-3xl border border-link/50"
					role="status"
					aria-live="polite"
				>
					<Icon type="fa" icon="table" w="96" h="96" class="animate-pulse text-link/50" />
				</div>
			</div>
		{:else if $leaderboardWithPositions.length === 0}
			<p class="w-full p-5 text-center text-primary dark:text-white">No data available</p>
		{:else}
			<LeaderboardSearch table={$table} bind:globalFilter {searchDebounce} />

			{#if $table.getFilteredRowModel().rows.length === 0}
				<p class="w-full p-5 text-center text-primary dark:text-white">No results found.</p>
			{:else}
				<!-- Mobile: Three-row card layout with sorting headers -->
				<div class="block lg:hidden">
					<!-- Mobile sorting headers -->
					<div class="border-b border-gray-300 bg-primary/5 dark:border-white/95 dark:bg-white/5">
						<div class="grid grid-cols-4 gap-3 px-4 py-3 text-center text-xs">
							<SortHeaderButton
								column={$table?.getColumn('position')}
								label="Position"
								ariaLabel="Sort by position"
							/>

							<SortHeaderButton
								column={$table?.getColumn('total')}
								label="Total"
								ariaLabel="Sort by total locations"
							/>

							<SortHeaderButton
								column={$table?.getColumn('upToDateElements')}
								label="Verified"
								ariaLabel="Sort by verified locations"
							/>

							<SortHeaderButton
								column={$table?.getColumn('grade')}
								label="Grade"
								ariaLabel="Sort by grade"
							/>
						</div>
					</div>

					<AreaLeaderboardMobileCard table={$table} {type} />
				</div>

				<AreaLeaderboardDesktopTable
					table={$table}
					{type}
					bind:totalTooltip
					bind:upToDateTooltip
					bind:gradeTooltip
				/>

				<LeaderboardPagination table={$table} {pageSizes} />
			{/if}

			<footer
				class="border-t border-gray-300 px-5 pt-2.5 pb-5 text-sm text-body dark:border-white/95 dark:text-white"
			>
				<p>Position is calculated as follows:</p>

				<ul class="list-inside list-disc">
					<li>Primary: Total locations minus 5x outdated elements.</li>
					<li>Secondary: Total number of locations.</li>
				</ul>

				<p>Locations include ATMs.</p>
			</footer>
		{/if}
	</div>
</section>

{#if typeof window !== 'undefined'}
	{#if detectTheme() === 'dark' || $theme === 'dark'}
		<style>
			select option {
				--tw-bg-opacity: 1;
				background-color: rgb(55 65 81 / var(--tw-bg-opacity));
			}
		</style>
	{/if}
{/if}



================================================
FILE: src/components/leaderboard/AreaLeaderboardDesktopTable.svelte
================================================
<script lang="ts">
	import type { AreaType } from '$lib/types';
	import type { Table } from '@tanstack/svelte-table';
	import { flexRender } from '@tanstack/svelte-table';
	import { isEven } from '$lib/utils';
	import AreaLeaderboardItemName from '$components/leaderboard/AreaLeaderboardItemName.svelte';
	import GradeDisplay from '$components/leaderboard/GradeDisplay.svelte';
	import Icon from '$components/Icon.svelte';

	// eslint-disable-next-line @typescript-eslint/no-explicit-any
	export let table: Table<any>;
	export let type: AreaType;
	export let totalTooltip: HTMLButtonElement;
	export let upToDateTooltip: HTMLButtonElement;
	export let gradeTooltip: HTMLButtonElement;
</script>

<div class="hidden lg:block" role="region" aria-label="Leaderboard table">
	<table class="w-full text-left text-xs text-primary lg:text-sm xl:text-lg dark:text-white">
		<thead>
			{#each table.getHeaderGroups() as headerGroup (headerGroup.id)}
				<tr>
					{#each headerGroup.headers as header (header.id)}
						<th
							colSpan={header.colSpan}
							class="px-2 pt-5 pb-2.5 md:px-5"
							class:text-center={header.column.id !== 'name'}
							aria-sort={header.column.getIsSorted() === 'asc'
								? 'ascending'
								: header.column.getIsSorted() === 'desc'
									? 'descending'
									: 'none'}
						>
							{#if !header.isPlaceholder}
								<button
									type="button"
									class="flex items-center gap-x-1 leading-tight select-none md:gap-x-2"
									class:mx-auto={header.column.id !== 'name'}
									class:cursor-pointer={header.column.getCanSort()}
									class:justify-center={header.column.id !== 'name'}
									on:click={header.column.getToggleSortingHandler()}
									on:keydown={(e) => {
										if (e.key === 'Enter' || e.key === ' ') {
											e.preventDefault();
											header.column.getToggleSortingHandler()?.(e);
										}
									}}
									tabindex={header.column.getCanSort() ? 0 : -1}
									aria-label={header.column.getCanSort()
										? `Sort by ${header.column.columnDef.header}, currently ${
												header.column.getIsSorted() === 'asc'
													? 'ascending'
													: header.column.getIsSorted() === 'desc'
														? 'descending'
														: 'unsorted'
											}`
										: String(header.column.columnDef.header)}
								>
									<span class="break-words">
										<svelte:component
											this={flexRender(header.column.columnDef.header, header.getContext())}
										/>
									</span>
									{#if header.column.id === 'total'}
										<button
											bind:this={totalTooltip}
											type="button"
											class="ml-1 cursor-default"
											aria-label="Information about total locations"
										>
											<Icon type="fa" icon="circle-info" w="14" h="14" class="text-sm" />
										</button>
									{:else if header.column.id === 'upToDateElements'}
										<button
											bind:this={upToDateTooltip}
											type="button"
											class="ml-1 cursor-default"
											aria-label="Information about verified locations"
										>
											<Icon type="fa" icon="circle-info" w="14" h="14" class="text-sm" />
										</button>
									{:else if header.column.id === 'grade'}
										<button
											bind:this={gradeTooltip}
											type="button"
											class="ml-1 cursor-default"
											aria-label="Information about Grade metric"
										>
											<Icon type="fa" icon="circle-info" w="14" h="14" class="text-sm" />
										</button>
									{/if}
									{#if header.column.getIsSorted().toString() === 'asc'}
										<span aria-hidden="true">â–²</span>
									{:else if header.column.getIsSorted().toString() === 'desc'}
										<span aria-hidden="true">â–¼</span>
									{/if}
								</button>
							{/if}
						</th>
					{/each}
				</tr>
			{/each}
		</thead>
		<tbody>
			{#each table.getRowModel().rows as row, index (row.id)}
				<tr class={isEven(index) ? 'bg-primary/5 dark:bg-white/5' : ''}>
					{#each row.getVisibleCells() as cell (cell.id)}
						<td
							class="px-2 py-2.5 md:px-5"
							class:text-center={cell.column.id === 'position' ||
								cell.column.id === 'grade' ||
								cell.column.id === 'total' ||
								cell.column.id === 'upToDateElements'}
							class:text-2xl={cell.column.id === 'position'}
						>
							{#if cell.column.id === 'name'}
								<AreaLeaderboardItemName
									{type}
									avatar={type === 'community'
										? cell.row.original.tags?.['icon:square'] || ''
										: `https://static.btcmap.org/images/countries/${cell.row.original.id}.svg`}
									name={cell.row.original.tags?.name || 'Unknown'}
									id={cell.row.original.tags?.url_alias || cell.row.original.id || ''}
								/>
							{:else if cell.column.id === 'grade'}
								{@const grade = cell.row.original.grade || 0}
								{@const percentage = cell.row.original.report?.tags?.up_to_date_percent}
								{@const avgDate = cell.row.original.report?.tags?.avg_verification_date}
								<GradeDisplay {grade} {percentage} {avgDate} size="large" />
							{:else}
								<svelte:component
									this={flexRender(cell.column.columnDef.cell, cell.getContext())}
								/>
							{/if}
						</td>
					{/each}
				</tr>
			{/each}
		</tbody>
	</table>
</div>



================================================
FILE: src/components/leaderboard/AreaLeaderboardItemName.svelte
================================================
<script lang="ts">
	import type { AreaType } from '$lib/types';

	export let type: AreaType;
	export let avatar: string;
	export let name: string;
	export let id: string;

	$: avatarSrc =
		type === 'community'
			? `https://btcmap.org/.netlify/images?url=${avatar}&fit=cover&w=256&h=256`
			: avatar;

	$: hasLongName = name?.match(/[^ ]{21}/);
	$: displayName = name || 'Unknown';

	function handleImageError(event: Event) {
		const img = event.target as HTMLImageElement;
		img.src = '/images/bitcoin.svg';
	}
</script>

{#if name}
	<div class="flex items-center gap-3">
		<img
			src={avatarSrc}
			alt="{displayName} avatar"
			class="h-10 w-10 shrink-0 rounded-full object-cover"
			on:error={handleImageError}
			loading="lazy"
		/>
		<!-- eslint-disable svelte/no-navigation-without-resolve -->
		<a
			href={`/${type}/${id}`}
			class="font-medium text-link transition-colors hover:text-hover {hasLongName
				? 'break-all'
				: ''}"
			aria-label="View {displayName} details"
		>
			<!-- eslint-enable svelte/no-navigation-without-resolve -->
			{displayName}
		</a>
	</div>
{:else}
	<!-- Skeleton loading state -->
	<div class="flex items-center gap-3" role="status" aria-label="Loading area information">
		<div class="h-10 w-10 shrink-0 animate-pulse rounded-full bg-link/50" aria-hidden="true"></div>
		<div class="h-5 w-24 animate-pulse rounded bg-link/50" aria-hidden="true"></div>
		<span class="sr-only">Loading...</span>
	</div>
{/if}



================================================
FILE: src/components/leaderboard/AreaLeaderboardMobileCard.svelte
================================================
<script lang="ts">
	import type { AreaType } from '$lib/types';
	import type { Table } from '@tanstack/svelte-table';
	import { isEven } from '$lib/utils';
	import GradeDisplay from '$components/leaderboard/GradeDisplay.svelte';

	// eslint-disable-next-line @typescript-eslint/no-explicit-any
	export let table: Table<any>;
	export let type: AreaType;
</script>

<!-- Mobile cards -->
<div class="space-y-1">
	{#each table.getRowModel().rows as row, index (row.id)}
		{@const area = row.original}
		{@const position = area.position}
		{@const grade = area.grade || 0}
		{@const percentage = area.report?.tags?.up_to_date_percent}
		{@const avgDate = area.report?.tags?.avg_verification_date}
		{@const totalElements = area.report?.tags?.total_elements || 0}
		{@const upToDateElements = area.report?.tags?.up_to_date_elements || 0}

		<!-- Card with three-row layout -->
		<div
			class="space-y-4 p-4 {isEven(index)
				? 'bg-primary/5 dark:bg-white/5'
				: 'bg-white dark:bg-transparent'}"
			role="row"
		>
			<!-- Row 1: Larger Avatar -->
			<div class="flex justify-center">
				<img
					src={type === 'community'
						? `https://btcmap.org/.netlify/images?url=${area.tags?.['icon:square'] || ''}&fit=cover&w=256&h=256`
						: `https://static.btcmap.org/images/countries/${area.id}.svg`}
					alt="{area.tags?.name || 'Unknown'} avatar"
					class="h-16 w-16 rounded-full object-cover"
					on:error={(e) => {
						const target = e.target;
						if (target instanceof HTMLImageElement) {
							target.src = '/images/bitcoin.svg';
						}
					}}
					loading="lazy"
				/>
			</div>

			<!-- Row 2: Name (centered and prominent) -->
			<div class="text-center">
				<!-- eslint-disable svelte/no-navigation-without-resolve -->
				<a
					href={`/${type}/${area.tags?.url_alias || area.id || ''}`}
					class="text-lg font-semibold text-link transition-colors hover:text-hover {area.tags?.name?.match(
						/[^ ]{21}/
					)
						? 'break-all'
						: ''}"
					aria-label="View {area.tags?.name || 'Unknown'} details"
				>
					<!-- eslint-enable svelte/no-navigation-without-resolve -->
					{area.tags?.name || 'Unknown'}
				</a>
			</div>

			<!-- Row 3: Stats in a 4-column grid (no headers, just data) -->
			<div class="grid grid-cols-4 gap-3 text-center text-sm">
				<!-- Position -->
				<div class="text-lg">
					{#if position === 1}ğŸ¥‡
					{:else if position === 2}ğŸ¥ˆ
					{:else if position === 3}ğŸ¥‰
					{:else}
						<span class="font-semibold text-primary dark:text-white">{position}</span>
					{/if}
				</div>

				<!-- Total Locations -->
				<div class="text-sm font-semibold text-primary dark:text-white">
					{totalElements}
				</div>

				<!-- Verified Locations -->
				<div class="text-sm font-semibold text-primary dark:text-white">
					{upToDateElements}
				</div>

				<!-- Grade -->
				<div class="text-sm">
					<GradeDisplay {grade} {percentage} {avgDate} size="small" />
				</div>
			</div>
		</div>
	{/each}
</div>



================================================
FILE: src/components/leaderboard/GradeDisplay.svelte
================================================
<script lang="ts">
	export let grade: number = 0;
	export let percentage: number | undefined = undefined;
	export let avgDate: string | undefined = undefined;
	export let size: 'small' | 'medium' | 'large' = 'medium';
	export let showTooltip: boolean = true;

	const sizeClasses = {
		small: 'text-sm',
		medium: 'text-base',
		large: 'text-lg'
	};

	// Svelte action for grade tooltips
	function gradeTooltipAction(node: HTMLElement, data: { percentage?: number; avgDate?: string }) {
		// Tippy instance - using object with destroy method since tippy.js types are complex with dynamic imports
		let instance: { destroy(): void } | undefined;

		async function setup() {
			if (showTooltip && data.percentage !== undefined) {
				// Dynamic import for tippy.js to avoid SSR issues
				const { default: tippy } = await import('tippy.js');

				let content = `${data.percentage.toFixed(1)}% up-to-date`;

				if (data.avgDate) {
					const verificationDate = new Date(data.avgDate);
					const now = new Date();
					const diffTime = now.getTime() - verificationDate.getTime();
					const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));
					content += `<br>Average verification: ${diffDays} days ago`;
				}

				instance = tippy(node, {
					content,
					allowHTML: true
				});
			}
		}

		function cleanup() {
			if (instance) {
				instance.destroy();
				instance = undefined;
			}
		}

		setup();

		return {
			update(newData: { percentage?: number; avgDate?: string }) {
				cleanup();
				data = newData;
				setup();
			},
			destroy() {
				cleanup();
			}
		};
	}
</script>

{#if grade > 0}
	<div
		class="cursor-help font-semibold text-primary dark:text-white {sizeClasses[size]}"
		class:flex={size === 'large'}
		class:justify-center={size === 'large'}
		role="img"
		aria-label="{grade} out of 5 stars{percentage ? `, ${percentage.toFixed(1)}% up-to-date` : ''}"
		use:gradeTooltipAction={{ percentage, avgDate }}
	>
		{'â˜…'.repeat(grade)}{'â˜†'.repeat(5 - grade)}
	</div>
{:else}
	<span class="text-primary dark:text-white {sizeClasses[size]}">N/A</span>
{/if}



================================================
FILE: src/components/leaderboard/LeaderboardPagination.svelte
================================================
<script lang="ts">
	import type { Table } from '@tanstack/svelte-table';

	// eslint-disable-next-line @typescript-eslint/no-explicit-any
	export let table: Table<any>;
	export let pageSizes: number[] = [10, 20, 30, 40, 50];
</script>

<!-- Pagination -->
<div
	class="flex w-full flex-col gap-5 px-5 pt-2.5 pb-5 text-primary md:flex-row md:items-center md:justify-between dark:text-white"
>
	<select
		value={table?.getState().pagination.pageSize}
		on:change={(e) => {
			// @ts-expect-error Select onChange event target type assertion for page size change
			table?.setPageSize(Number(e.target?.value));
		}}
		class="cursor-pointer bg-transparent focus:outline-primary dark:focus:outline-white"
		aria-label="Items per page"
	>
		{#each pageSizes as pageSize (pageSize)}
			<option value={pageSize}>
				Show {pageSize}
			</option>
		{/each}
	</select>

	<div class="flex flex-col gap-5 md:flex-row md:items-center">
		<div class="flex items-center justify-between gap-5 md:justify-start">
			<div class="flex items-center gap-5">
				<button
					type="button"
					class="text-xl font-bold {!table?.getCanPreviousPage()
						? 'cursor-not-allowed opacity-50'
						: ''}"
					on:click={() => table?.firstPage()}
					disabled={!table?.getCanPreviousPage()}
					aria-label="Go to first page"
				>
					&lt;&lt;
				</button>
				<button
					type="button"
					class="text-xl font-bold {!table?.getCanPreviousPage()
						? 'cursor-not-allowed opacity-50'
						: ''}"
					on:click={() => table?.previousPage()}
					disabled={!table?.getCanPreviousPage()}
					aria-label="Go to previous page"
				>
					&lt;
				</button>
			</div>
			<div class="flex items-center gap-5">
				<button
					type="button"
					class="text-xl font-bold {!table?.getCanNextPage()
						? 'cursor-not-allowed opacity-50'
						: ''}"
					on:click={() => table?.nextPage()}
					disabled={!table?.getCanNextPage()}
					aria-label="Go to next page"
				>
					&gt;
				</button>
				<button
					type="button"
					class="text-xl font-bold {!table?.getCanNextPage()
						? 'cursor-not-allowed opacity-50'
						: ''}"
					on:click={() => table?.lastPage()}
					disabled={!table?.getCanNextPage()}
					aria-label="Go to last page"
				>
					&gt;&gt;
				</button>
			</div>
		</div>

		<span class="flex items-center justify-center gap-1 md:justify-start" aria-live="polite">
			<div>Page</div>
			<strong>
				{table?.getState().pagination.pageIndex + 1} of
				{table?.getPageCount().toLocaleString()}
			</strong>
		</span>
	</div>
</div>



================================================
FILE: src/components/leaderboard/LeaderboardSearch.svelte
================================================
<script lang="ts">
	import type { Table } from '@tanstack/svelte-table';
	import Icon from '$components/Icon.svelte';

	// eslint-disable-next-line @typescript-eslint/no-explicit-any
	export let table: Table<any>;
	export let globalFilter: string = '';
	export let searchDebounce: (e: Event) => void;

	let searchInput: HTMLInputElement;

	function clearSearch() {
		globalFilter = '';
		table?.setGlobalFilter('');
	}

	function focusSearch() {
		searchInput.focus();
	}
</script>

<div class="relative text-primary dark:text-white">
	<input
		type="text"
		placeholder="Search..."
		class="w-full bg-primary/5 px-5 py-2.5 text-sm focus:outline-primary dark:bg-white/5 dark:focus:outline-white"
		bind:value={globalFilter}
		on:keyup={searchDebounce}
		bind:this={searchInput}
		aria-label="Search leaderboard"
	/>
	{#if globalFilter}
		<button
			type="button"
			class="absolute top-1/2 right-3 -translate-y-1/2"
			on:click={clearSearch}
			aria-label="Clear search"
		>
			<Icon type="fa" icon="circle-xmark" w="16" h="16" />
		</button>
	{:else}
		<button
			type="button"
			class="absolute top-1/2 right-3 -translate-y-1/2"
			on:click={focusSearch}
			aria-label="Focus search"
		>
			<Icon type="fa" icon="magnifying-glass" w="16" h="16" />
		</button>
	{/if}
</div>



================================================
FILE: src/components/leaderboard/SortHeaderButton.svelte
================================================
<script lang="ts">
	import type { Column } from '@tanstack/svelte-table';

	// eslint-disable-next-line @typescript-eslint/no-explicit-any
	export let column: Column<any> | undefined;
	export let label: string;
	export let ariaLabel: string;
</script>

<button
	type="button"
	class="flex cursor-pointer items-center justify-center gap-1 text-body transition-colors select-none hover:text-primary dark:text-white/70 dark:hover:text-white"
	on:click={(e) => column?.getToggleSortingHandler()?.(e)}
	aria-label={ariaLabel}
	disabled={!column}
>
	<span>{label}</span>
	{#if column?.getIsSorted() === 'asc'}
		<span aria-hidden="true" class="text-xs">â–²</span>
	{:else if column?.getIsSorted() === 'desc'}
		<span aria-hidden="true" class="text-xs">â–¼</span>
	{/if}
</button>



================================================
FILE: src/components/leaderboard/TaggerLeaderboardDesktopTable.svelte
================================================
<script lang="ts">
	import type { Table } from '@tanstack/svelte-table';
	import { flexRender } from '@tanstack/svelte-table';
	import { resolve } from '$app/paths';
	import type { TaggerLeaderboard } from '$lib/types';
	import { isEven } from '$lib/utils';
	import Tip from '$components/Tip.svelte';

	type TaggerRow = TaggerLeaderboard & {
		position: number;
		tipDestination?: string;
	};

	export let table: Table<TaggerRow>;
</script>

<div class="hidden lg:block" role="region" aria-label="Tagger leaderboard table">
	<table class="w-full text-left text-xs text-primary lg:text-sm xl:text-lg dark:text-white">
		<thead>
			{#each table.getHeaderGroups() as headerGroup (headerGroup.id)}
				<tr>
					{#each headerGroup.headers as header (header.id)}
						<th
							colSpan={header.colSpan}
							class="px-2 pt-5 pb-2.5 md:px-5"
							class:text-center={header.column.id !== 'name'}
							aria-sort={header.column.getIsSorted() === 'asc'
								? 'ascending'
								: header.column.getIsSorted() === 'desc'
									? 'descending'
									: 'none'}
						>
							{#if !header.isPlaceholder}
								<button
									type="button"
									class="flex items-center gap-x-1 leading-tight select-none md:gap-x-2"
									class:mx-auto={header.column.id !== 'name'}
									class:cursor-pointer={header.column.getCanSort()}
									class:justify-center={header.column.id !== 'name'}
									on:click={header.column.getToggleSortingHandler()}
									on:keydown={(e) => {
										if (e.key === 'Enter' || e.key === ' ') {
											e.preventDefault();
											header.column.getToggleSortingHandler()?.(e);
										}
									}}
									tabindex={header.column.getCanSort() ? 0 : -1}
									aria-label={header.column.getCanSort()
										? 'Sort by ' +
											header.column.columnDef.header +
											', currently ' +
											(header.column.getIsSorted() === 'asc'
												? 'ascending'
												: header.column.getIsSorted() === 'desc'
													? 'descending'
													: 'unsorted')
										: String(header.column.columnDef.header)}
								>
									<span class="break-words">
										<svelte:component
											this={flexRender(header.column.columnDef.header, header.getContext())}
										/>
									</span>
									{#if header.column.getIsSorted().toString() === 'asc'}
										<span aria-hidden="true">â–²</span>
									{:else if header.column.getIsSorted().toString() === 'desc'}
										<span aria-hidden="true">â–¼</span>
									{/if}
								</button>
							{/if}
						</th>
					{/each}
				</tr>
			{/each}
		</thead>
		<tbody>
			{#each table.getRowModel().rows as row (row.id)}
				<tr class={isEven(row.original.position - 1) ? 'bg-primary/5 dark:bg-white/5' : ''}>
					{#each row.getVisibleCells() as cell (cell.id)}
						<td class="px-2 py-3 md:px-5" class:text-center={cell.column.id !== 'name'}>
							{#if cell.column.id === 'position'}
								{#if row.original.position === 1}ğŸ¥‡
								{:else if row.original.position === 2}ğŸ¥ˆ
								{:else if row.original.position === 3}ğŸ¥‰
								{:else}
									{row.original.position}
								{/if}
							{:else if cell.column.id === 'name'}
								<div class="flex items-center gap-3">
									<img
										src={row.original.avatar}
										alt={row.original.tagger}
										class="h-12 w-12 rounded-full object-cover"
										on:error={(event) => {
											const target = event.target;
											if (target instanceof HTMLImageElement) {
												target.src = '/images/satoshi-nakamoto.png';
											}
										}}
										loading="lazy"
									/>
									<a
										href={resolve(`/tagger/${row.original.id}`)}
										class="text-link transition-colors hover:text-hover"
									>
										{row.original.tagger}
									</a>
								</div>
							{:else if cell.column.id === 'tip'}
								{#if row.original.tipDestination}
									<Tip destination={row.original.tipDestination} class="mx-auto block" />
								{/if}
							{:else}
								<svelte:component
									this={flexRender(cell.column.columnDef.cell, cell.getContext())}
								/>
							{/if}
						</td>
					{/each}
				</tr>
			{/each}
		</tbody>
	</table>
</div>



================================================
FILE: src/components/leaderboard/TaggerLeaderboardMobileCard.svelte
================================================
<script lang="ts">
	import type { Table } from '@tanstack/svelte-table';
	import type { TaggerLeaderboard } from '$lib/types';
	import { resolve } from '$app/paths';
	import { isEven } from '$lib/utils';
	import Icon from '$components/Icon.svelte';

	type TaggerRow = TaggerLeaderboard & {
		position: number;
		tipDestination?: string;
	};

	export let table: Table<TaggerRow>;
</script>

<!-- Mobile cards -->
<div class="space-y-1 lg:hidden">
	{#each table.getRowModel().rows as row (row.id)}
		{@const tagger = row.original}

		<!-- Card with three-row layout -->
		<div
			class="space-y-4 p-4 {isEven(tagger.position - 1)
				? 'bg-primary/5 dark:bg-white/5'
				: 'bg-white dark:bg-transparent'}"
			role="row"
		>
			<!-- Row 1: Position, Avatar, Name -->
			<div class="flex items-center gap-3">
				<!-- Position -->
				<div class="text-2xl">
					{#if tagger.position === 1}ğŸ¥‡
					{:else if tagger.position === 2}ğŸ¥ˆ
					{:else if tagger.position === 3}ğŸ¥‰
					{:else}
						<span class="font-semibold text-primary dark:text-white">{tagger.position}</span>
					{/if}
				</div>

				<!-- Avatar -->
				<img
					src={tagger.avatar}
					alt={tagger.tagger}
					class="h-16 w-16 rounded-full object-cover"
					on:error={(event) => {
						const target = event.target;
						if (target instanceof HTMLImageElement) {
							target.src = '/images/satoshi-nakamoto.png';
						}
					}}
					loading="lazy"
				/>

				<!-- Name (flex-1 to take remaining space) -->
				<div class="min-w-0 flex-1">
					<a
						href={resolve(`/tagger/${tagger.id}`)}
						class="text-lg font-semibold break-words text-link transition-colors hover:text-hover"
					>
						{tagger.tagger}
					</a>
				</div>

				<!-- Tip button -->
				{#if tagger.tipDestination}
					<div class="ml-auto">
						<a
							href={`lightning:${tagger.tipDestination}`}
							target="_blank"
							rel="noreferrer"
							class="text-primary transition-colors hover:text-hover dark:text-white"
						>
							<Icon type="fa" icon="bolt" w="16" h="16" />
						</a>
					</div>
				{/if}
			</div>

			<!-- Row 2: Stats in a 3-column grid (no headers, just data) -->
			<div class="grid grid-cols-3 gap-3 text-center text-sm">
				<!-- Total Edits -->
				<div>
					<p class="text-body dark:text-white/70">Total</p>
					<p class="font-semibold text-primary dark:text-white">{tagger.total.toLocaleString()}</p>
				</div>

				<!-- Created -->
				<div>
					<p class="text-body dark:text-white/70">Created</p>
					<p class="font-semibold text-primary dark:text-white">
						{tagger.created.toLocaleString()}
					</p>
				</div>

				<!-- Updated -->
				<div>
					<p class="text-body dark:text-white/70">Updated</p>
					<p class="font-semibold text-primary dark:text-white">
						{tagger.updated.toLocaleString()}
					</p>
				</div>
			</div>
		</div>
	{/each}
</div>



================================================
FILE: src/lib/analytics.ts
================================================
// Privacy-focused analytics using Umami
// No cookies, no PII, GDPR compliant
// Only enabled in production

import { dev } from '$app/environment';

const ANALYTICS_HOSTNAME = 'btcmap.org';

type EventName =
	| 'search_query'
	| 'search_button_click'
	| 'category_filter'
	| 'boost_layer_toggle'
	| 'nearby_button_click'
	| 'worldwide_mode_click'
	| 'nearby_mode_click'
	| 'home_button_click'
	| 'show_all_on_map_click'
	| 'merchant_list_item_click'
	| 'nearby_filter_input'
	| 'zoom_in_click'
	| 'zoom_out_click'
	| 'fullscreen_click'
	| 'locate_click'
	| 'add_location_click'
	| 'community_map_click'
	| 'data_refresh_click'
	| 'layer_change'
	| 'drawer_swipe_expand'
	| 'drawer_swipe_collapse'
	| 'drawer_swipe_dismiss'
	| 'drawer_collapse_button_click';

declare global {
	interface Window {
		umami?: {
			track: (eventName: string, eventData?: Record<string, unknown>) => void;
		};
	}
}

export const trackEvent = (eventName: EventName, eventData?: Record<string, unknown>): void => {
	if (dev) return;
	if (typeof window === 'undefined') return;
	if (window.location.hostname !== ANALYTICS_HOSTNAME) return;
	if (!window.umami) return;

	window.umami.track(eventName, eventData);
};



================================================
FILE: src/lib/api-fields.ts
================================================
import type { Place } from './types';

export const PLACE_FIELDS = {
	CORE: [
		'id',
		'lat',
		'lon',
		'icon',
		'comments',
		'boosted_until'
	] as const satisfies (keyof Place)[],
	SYNC: ['deleted_at', 'updated_at'] as const satisfies (keyof Place)[],
	POPUP: [
		'name',
		'address',
		'description',
		'phone',
		'website',
		'twitter',
		'facebook',
		'instagram',
		'email',
		'opening_hours',
		'created_at',
		'verified_at',
		'osm_id',
		'osm_url',
		'osm:contact:instagram',
		'osm:contact:twitter',
		'osm:contact:facebook',
		'osm:contact:phone',
		'osm:contact:website',
		'osm:contact:email',
		'required_app_url',
		'osm:payment:onchain',
		'osm:payment:lightning',
		'osm:payment:lightning_contactless',
		'osm:payment:bitcoin',
		'osm:payment:uri',
		'osm:payment:coinos',
		'osm:payment:pouch',
		'osm:payment:lightning:companion_app_url',
		'osm:amenity',
		'osm:category',
		'osm:survey:date',
		'osm:check_date',
		'osm:check_date:currency:XBT',
		'osm:note'
	] as const satisfies (keyof Place)[]
} as const;

export const PLACE_FIELD_SETS = {
	MAP_SYNC: [...PLACE_FIELDS.CORE, ...PLACE_FIELDS.SYNC],
	COMPLETE_PLACE: [...PLACE_FIELDS.CORE, ...PLACE_FIELDS.SYNC, ...PLACE_FIELDS.POPUP],
	LIST_ITEM: [
		'name',
		'address',
		'icon',
		'boosted_until',
		'verified_at',
		'osm:payment:onchain',
		'osm:payment:lightning',
		'osm:payment:lightning_contactless'
	] as const satisfies (keyof Place)[]
} as const;

export const buildFieldsParam = (fields: readonly string[]) => fields.join(',');



================================================
FILE: src/lib/cache.ts
================================================
import type { Area } from '$lib/types';

class ServerCache {
	private static instance: ServerCache;
	private areasCache: Area[] = [];
	private lastSync: Date | null = null;

	private constructor() {}

	public static getInstance(): ServerCache {
		if (!ServerCache.instance) {
			ServerCache.instance = new ServerCache();
		}
		return ServerCache.instance;
	}

	public getAreas(): Area[] {
		return this.areasCache;
	}

	public setAreas(areas: Area[]): void {
		this.areasCache = areas;
		this.lastSync = new Date();
	}

	public getLastSync(): Date | null {
		return this.lastSync;
	}
}

export const serverCache = ServerCache.getInstance();



================================================
FILE: src/lib/categoryMapping.test.ts
================================================
import { describe, it, expect } from 'vitest';
import type { Place } from '$lib/types';
import {
	CATEGORY_GROUPS,
	CATEGORIES,
	CATEGORY_ENTRIES,
	createEmptyCategoryCounts,
	countMerchantsByCategory,
	filterMerchantsByCategory,
	placeMatchesCategory,
	type CategoryKey
} from './categoryMapping';

// Helper to create mock Place objects with specific icons
function createMockPlace(overrides: Partial<Place> = {}): Place {
	return {
		id: Math.floor(Math.random() * 10000),
		lat: 0,
		lon: 0,
		name: 'Test Place',
		...overrides
	} as Place;
}

describe('categoryMapping', () => {
	describe('CATEGORY_GROUPS', () => {
		it('should have "all" category with empty icons array', () => {
			expect(CATEGORY_GROUPS.all.icons).toEqual([]);
			expect(CATEGORY_GROUPS.all.label).toBe('All');
		});

		it('should have expected categories', () => {
			const expectedCategories = [
				'all',
				'restaurants',
				'shopping',
				'groceries',
				'coffee',
				'atms',
				'hotels',
				'beauty'
			];
			expect(Object.keys(CATEGORY_GROUPS)).toEqual(expectedCategories);
		});

		it('should have non-empty icons for all categories except "all"', () => {
			for (const [key, group] of Object.entries(CATEGORY_GROUPS)) {
				if (key === 'all') {
					expect(group.icons).toEqual([]);
				} else {
					expect(group.icons.length).toBeGreaterThan(0);
				}
			}
		});
	});

	describe('CATEGORIES', () => {
		it('should match CATEGORY_GROUPS keys in order', () => {
			expect(CATEGORIES).toEqual(Object.keys(CATEGORY_GROUPS));
		});

		it('should have "all" as the first category', () => {
			expect(CATEGORIES[0]).toBe('all');
		});
	});

	describe('CATEGORY_ENTRIES', () => {
		it('should have correctly typed entries', () => {
			expect(CATEGORY_ENTRIES.length).toBe(Object.keys(CATEGORY_GROUPS).length);
			for (const [key, value] of CATEGORY_ENTRIES) {
				expect(CATEGORY_GROUPS[key]).toBe(value);
			}
		});
	});

	describe('createEmptyCategoryCounts', () => {
		it('should return counts object with all categories set to 0', () => {
			const counts = createEmptyCategoryCounts();

			for (const category of CATEGORIES) {
				expect(counts[category]).toBe(0);
			}
		});

		it('should return a new object each time', () => {
			const counts1 = createEmptyCategoryCounts();
			const counts2 = createEmptyCategoryCounts();

			expect(counts1).not.toBe(counts2);
		});
	});

	describe('countMerchantsByCategory', () => {
		it('should return empty counts for empty array', () => {
			const counts = countMerchantsByCategory([]);

			expect(counts.all).toBe(0);
			for (const category of CATEGORIES) {
				expect(counts[category]).toBe(0);
			}
		});

		it('should count "all" as total merchants', () => {
			const merchants = [
				createMockPlace({ icon: 'restaurant' }),
				createMockPlace({ icon: 'local_cafe' }),
				createMockPlace({ icon: 'unknown_icon' })
			];

			const counts = countMerchantsByCategory(merchants);

			expect(counts.all).toBe(3);
		});

		it('should count restaurants correctly', () => {
			const merchants = [
				createMockPlace({ icon: 'restaurant' }),
				createMockPlace({ icon: 'local_pizza' }),
				createMockPlace({ icon: 'lunch_dining' }),
				createMockPlace({ icon: 'local_cafe' }) // coffee, not restaurant
			];

			const counts = countMerchantsByCategory(merchants);

			expect(counts.restaurants).toBe(3);
			expect(counts.coffee).toBe(1);
		});

		it('should count all category types', () => {
			const merchants = [
				createMockPlace({ icon: 'restaurant' }), // restaurants
				createMockPlace({ icon: 'storefront' }), // shopping
				createMockPlace({ icon: 'local_grocery_store' }), // groceries
				createMockPlace({ icon: 'local_cafe' }), // coffee
				createMockPlace({ icon: 'local_atm' }), // atms
				createMockPlace({ icon: 'hotel' }), // hotels
				createMockPlace({ icon: 'content_cut' }) // beauty
			];

			const counts = countMerchantsByCategory(merchants);

			expect(counts.all).toBe(7);
			expect(counts.restaurants).toBe(1);
			expect(counts.shopping).toBe(1);
			expect(counts.groceries).toBe(1);
			expect(counts.coffee).toBe(1);
			expect(counts.atms).toBe(1);
			expect(counts.hotels).toBe(1);
			expect(counts.beauty).toBe(1);
		});

		it('should handle merchants without icons', () => {
			const merchants = [
				createMockPlace({ icon: 'restaurant' }),
				createMockPlace({ icon: undefined }),
				createMockPlace({}) // no icon property
			];

			const counts = countMerchantsByCategory(merchants);

			expect(counts.all).toBe(3);
			expect(counts.restaurants).toBe(1);
		});

		it('should handle merchants with unknown icons', () => {
			const merchants = [
				createMockPlace({ icon: 'unknown_icon_1' }),
				createMockPlace({ icon: 'unknown_icon_2' }),
				createMockPlace({ icon: 'restaurant' })
			];

			const counts = countMerchantsByCategory(merchants);

			expect(counts.all).toBe(3);
			expect(counts.restaurants).toBe(1);
			// Unknown icons shouldn't be counted in any specific category
			const sumOfCategories = CATEGORIES.filter((c) => c !== 'all').reduce(
				(sum, cat) => sum + counts[cat],
				0
			);
			expect(sumOfCategories).toBe(1);
		});

		it('should handle multiple icons mapping to same category', () => {
			const merchants = [
				createMockPlace({ icon: 'storefront' }), // shopping
				createMockPlace({ icon: 'local_mall' }) // also shopping
			];

			const counts = countMerchantsByCategory(merchants);

			expect(counts.shopping).toBe(2);
		});
	});

	describe('filterMerchantsByCategory', () => {
		const merchants = [
			createMockPlace({ id: 1, icon: 'restaurant' }),
			createMockPlace({ id: 2, icon: 'local_pizza' }),
			createMockPlace({ id: 3, icon: 'local_cafe' }),
			createMockPlace({ id: 4, icon: 'storefront' }),
			createMockPlace({ id: 5, icon: 'unknown' }),
			createMockPlace({ id: 6 }) // no icon
		];

		it('should return all merchants for "all" category', () => {
			const filtered = filterMerchantsByCategory(merchants, 'all');

			expect(filtered).toBe(merchants); // Same reference
			expect(filtered.length).toBe(6);
		});

		it('should filter restaurants correctly', () => {
			const filtered = filterMerchantsByCategory(merchants, 'restaurants');

			expect(filtered.length).toBe(2);
			expect(filtered.map((m) => m.id)).toEqual([1, 2]);
		});

		it('should filter coffee correctly', () => {
			const filtered = filterMerchantsByCategory(merchants, 'coffee');

			expect(filtered.length).toBe(1);
			expect(filtered[0].id).toBe(3);
		});

		it('should filter shopping correctly', () => {
			const filtered = filterMerchantsByCategory(merchants, 'shopping');

			expect(filtered.length).toBe(1);
			expect(filtered[0].id).toBe(4);
		});

		it('should return empty array when no matches', () => {
			const filtered = filterMerchantsByCategory(merchants, 'atms');

			expect(filtered).toEqual([]);
		});

		it('should return empty array for empty input', () => {
			const filtered = filterMerchantsByCategory([], 'restaurants');

			expect(filtered).toEqual([]);
		});

		it('should not modify original array', () => {
			const original = [...merchants];
			filterMerchantsByCategory(merchants, 'restaurants');

			expect(merchants).toEqual(original);
		});

		it('should filter correctly for each category', () => {
			const testMerchants = [
				createMockPlace({ icon: 'restaurant' }),
				createMockPlace({ icon: 'local_pizza' }),
				createMockPlace({ icon: 'lunch_dining' }),
				createMockPlace({ icon: 'storefront' }),
				createMockPlace({ icon: 'local_mall' }),
				createMockPlace({ icon: 'local_grocery_store' }),
				createMockPlace({ icon: 'local_cafe' }),
				createMockPlace({ icon: 'local_atm' }),
				createMockPlace({ icon: 'hotel' }),
				createMockPlace({ icon: 'content_cut' })
			];

			const categoryTests: [CategoryKey, number][] = [
				['all', 10],
				['restaurants', 3],
				['shopping', 2],
				['groceries', 1],
				['coffee', 1],
				['atms', 1],
				['hotels', 1],
				['beauty', 1]
			];

			for (const [category, expectedCount] of categoryTests) {
				const filtered = filterMerchantsByCategory(testMerchants, category);
				expect(filtered.length).toBe(expectedCount);
			}
		});
	});

	describe('placeMatchesCategory', () => {
		it('should return true for "all" category regardless of icon', () => {
			expect(placeMatchesCategory(createMockPlace({ icon: 'restaurant' }), 'all')).toBe(true);
			expect(placeMatchesCategory(createMockPlace({ icon: 'unknown' }), 'all')).toBe(true);
			expect(placeMatchesCategory(createMockPlace({}), 'all')).toBe(true);
		});

		it('should return false for places without icons (except "all")', () => {
			expect(placeMatchesCategory(createMockPlace({}), 'restaurants')).toBe(false);
			expect(placeMatchesCategory(createMockPlace({ icon: undefined }), 'coffee')).toBe(false);
		});

		it('should correctly match restaurant icons', () => {
			expect(placeMatchesCategory(createMockPlace({ icon: 'restaurant' }), 'restaurants')).toBe(
				true
			);
			expect(placeMatchesCategory(createMockPlace({ icon: 'local_pizza' }), 'restaurants')).toBe(
				true
			);
			expect(placeMatchesCategory(createMockPlace({ icon: 'lunch_dining' }), 'restaurants')).toBe(
				true
			);
			expect(placeMatchesCategory(createMockPlace({ icon: 'local_cafe' }), 'restaurants')).toBe(
				false
			);
		});

		it('should correctly match each category', () => {
			const categoryIconTests: [CategoryKey, string, boolean][] = [
				['shopping', 'storefront', true],
				['shopping', 'local_mall', true],
				['shopping', 'restaurant', false],
				['groceries', 'local_grocery_store', true],
				['groceries', 'storefront', false],
				['coffee', 'local_cafe', true],
				['coffee', 'restaurant', false],
				['atms', 'local_atm', true],
				['atms', 'hotel', false],
				['hotels', 'hotel', true],
				['hotels', 'local_atm', false],
				['beauty', 'content_cut', true],
				['beauty', 'restaurant', false]
			];

			for (const [category, icon, expected] of categoryIconTests) {
				expect(placeMatchesCategory(createMockPlace({ icon }), category)).toBe(expected);
			}
		});

		it('should return false for unknown icons in specific categories', () => {
			expect(placeMatchesCategory(createMockPlace({ icon: 'unknown_icon' }), 'restaurants')).toBe(
				false
			);
			expect(placeMatchesCategory(createMockPlace({ icon: 'random' }), 'coffee')).toBe(false);
		});
	});
});



================================================
FILE: src/lib/categoryMapping.ts
================================================
import type { Place } from '$lib/types';

export const CATEGORY_GROUPS = {
	all: {
		label: 'All',
		icons: [] as string[]
	},
	restaurants: {
		label: 'Restaurants',
		icons: ['restaurant', 'local_pizza', 'lunch_dining']
	},
	shopping: {
		label: 'Shopping',
		icons: ['storefront', 'local_mall']
	},
	groceries: {
		label: 'Groceries',
		icons: ['local_grocery_store']
	},
	coffee: {
		label: 'Coffee',
		icons: ['local_cafe']
	},
	atms: {
		label: 'ATMs',
		icons: ['local_atm']
	},
	hotels: {
		label: 'Hotels',
		icons: ['hotel']
	},
	beauty: {
		label: 'Beauty Salons',
		icons: ['content_cut']
	}
} as const;

export type CategoryKey = keyof typeof CATEGORY_GROUPS;

// Explicit array for guaranteed order and clarity (could derive from CATEGORY_GROUPS but kept explicit)
export const CATEGORIES: readonly CategoryKey[] = [
	'all',
	'restaurants',
	'shopping',
	'groceries',
	'coffee',
	'atms',
	'hotels',
	'beauty'
] as const;

export const CATEGORY_ENTRIES = Object.entries(CATEGORY_GROUPS) as [
	CategoryKey,
	(typeof CATEGORY_GROUPS)[CategoryKey]
][];

export type CategoryCounts = Record<CategoryKey, number>;

// Build icon -> category lookup map once at module initialization
// (avoids rebuilding on every countMerchantsByCategory call during pan/zoom)
const ICON_TO_CATEGORY = new Map<string, CategoryKey>();
for (const [key, group] of Object.entries(CATEGORY_GROUPS)) {
	if (key === 'all') continue;
	for (const icon of group.icons) {
		ICON_TO_CATEGORY.set(icon, key as CategoryKey);
	}
}

export const createEmptyCategoryCounts = (): CategoryCounts => {
	return CATEGORIES.reduce((acc, category) => {
		acc[category] = 0;
		return acc;
	}, {} as CategoryCounts);
};

export const countMerchantsByCategory = (merchants: Place[]): CategoryCounts => {
	const counts = createEmptyCategoryCounts();

	counts.all = merchants.length;

	for (const merchant of merchants) {
		if (!merchant.icon) continue;
		const category = ICON_TO_CATEGORY.get(merchant.icon);
		if (category) {
			counts[category] += 1;
		}
	}

	return counts;
};

export const filterMerchantsByCategory = (merchants: Place[], category: CategoryKey): Place[] => {
	if (category === 'all') return merchants;

	const categoryIcons = CATEGORY_GROUPS[category].icons;
	return merchants.filter((merchant) => categoryIcons.some((icon) => merchant.icon === icon));
};

// Check if a single place matches a category (used for map marker filtering)
export const placeMatchesCategory = (place: Place, category: CategoryKey): boolean => {
	if (category === 'all') return true;
	if (!place.icon) return false;
	return ICON_TO_CATEGORY.get(place.icon) === category;
};



================================================
FILE: src/lib/constants.ts
================================================
export const CONFETTI_CANVAS_Z_INDEX = '2001';
export const POLLING_INTERVAL = 2500;
export const QR_CODE_SIZE = { mobile: 200, desktop: 275 };
export const PAYMENT_ERROR_MESSAGE =
	'Could not generate invoice, please try again or contact BTC Map.';
export const STATUS_CHECK_ERROR_MESSAGE =
	'Could not check invoice status, please try again or contact BTC Map.';

// Tailwind breakpoints (must match tailwind.config.js default breakpoints)
export const BREAKPOINTS = {
	sm: 640,
	md: 768,
	lg: 1024,
	xl: 1280,
	'2xl': 1536
} as const;

// Layout widths for merchant list and drawer (in pixels)
export const MERCHANT_LIST_WIDTH = 320;
export const MERCHANT_DRAWER_WIDTH = 400;

// Base padding (px) for fitBounds - visual buffer from viewport edges
export const MAP_FIT_BOUNDS_PADDING = 50;

// MERCHANT LIST ZOOM BEHAVIOR:
// â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
// â”‚ Zoom < 11  â”‚ No data shown - "zoom in" message                          â”‚
// â”‚ Zoom 11-14 â”‚ API search with 1.5x radius, max 99 results                â”‚
// â”‚ Zoom 15+   â”‚ Use loaded markers with 1.5x bounds, enrich when open      â”‚
// â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
// All zoom levels use 1.5x radius multiplier for consistent "nearby" count.

// Zoom 17+: Leaflet clustering disabled, individual markers shown
export const CLUSTERING_DISABLED_ZOOM = 17;

// Zoom 1-5: Boosted markers are clustered (too zoomed out, would be crowded)
// Zoom 6-16: Boosted markers are NOT clustered (stand out from regular markers)
export const BOOSTED_CLUSTERING_MAX_ZOOM = 5;

// Zoom 15+: Use loaded viewport markers (instant, no API latency)
// Fetches enriched Place data (icons, addresses) only when panel is open
export const MERCHANT_LIST_MIN_ZOOM = 15;

// Zoom 11-14: "Low density" mode - use API search with result limit
// If results exceed MERCHANT_LIST_MAX_ITEMS, we hide the list and show "zoom in"
export const MERCHANT_LIST_LOW_ZOOM = 11;

// Max merchants to display in list and count shown on button
// When count exceeds this, button shows ">99" and list shows 99 items
export const MERCHANT_LIST_MAX_ITEMS = 99;

// Radius multiplier for "nearby" search (extends beyond viewport for context)
// Used consistently across all zoom levels for predictable count behavior
export const NEARBY_RADIUS_MULTIPLIER = 1.5;

// Map viewport marker loading
export const MAX_LOADED_MARKERS = 200;
export const VIEWPORT_BATCH_SIZE = 25;
export const VIEWPORT_BUFFER_PERCENT = 0.2;
export const MAP_DEBOUNCE_DELAY = 300;
export const MARKER_CLICK_THROTTLE = 100;

// Default map position (CuraÃ§ao)
export const DEFAULT_MAP_LAT = 12.11209;
export const DEFAULT_MAP_LNG = -68.91119;
export const DEFAULT_MAP_ZOOM = 15;

export const GradeTable = `<table>
<thead>
    <tr>
        <th class='mr-1 inline-block'>Up-To-Date</th>
        <th>Grade</th>
    </tr>
</thead>
<tbody>
    <tr>
        <td>95-100%</td>
        <td>5 Star</td>
    </tr>
    <tr>
        <td>75-95%</td>
        <td>4 Star</td>
    </tr>
    <tr>
        <td>50-75%</td>
        <td>3 Star</td>
    </tr>
    <tr>
        <td>25-50%</td>
        <td>2 Star</td>
    </tr>
    <tr>
        <td>0-25%</td>
        <td>1 Star</td>
    </tr>
</tbody>
</table>`;



================================================
FILE: src/lib/drawerConfig.ts
================================================
// Drawer gesture configuration constants
// These values control the behavior of the mobile drawer's swipe gestures

// Drawer height states
export const PEEK_HEIGHT = 140; // Collapsed state height - shows merchant name and quick info

// Gesture thresholds
export const VELOCITY_THRESHOLD = 0.5; // px/ms - minimum velocity for flick gesture detection
export const DISTANCE_THRESHOLD = 80; // px - minimum drag distance to trigger snap
export const DISMISS_THRESHOLD = 60; // px - drag distance below peek to trigger dismiss
export const POSITION_THRESHOLD_PERCENT = 0.3; // When to snap up vs down (30% of total height)

// Velocity tracking
export const VELOCITY_SAMPLE_COUNT = 5; // Number of velocity samples for smoothing

// Spring animation config
export const SPRING_CONFIG = { stiffness: 0.2, damping: 0.75 }; // Smooth but responsive feel

// Scroll-aware drag thresholds (for expanded content swipe-to-collapse)
export const SCROLL_DRAG_THRESHOLD = 10; // px to decide drag vs scroll
export const SCROLL_TOP_THRESHOLD = 1; // px tolerance for scroll position (handles browser rounding)



================================================
FILE: src/lib/drawerGestureController.ts
================================================
// Store-based gesture controller for mobile drawer
// Consolidates all gesture state and handlers in one place

import { writable, derived, get } from 'svelte/store';
import { spring } from 'svelte/motion';
import {
	PEEK_HEIGHT,
	VELOCITY_THRESHOLD,
	SPRING_CONFIG,
	DISMISS_THRESHOLD,
	SCROLL_DRAG_THRESHOLD,
	SCROLL_TOP_THRESHOLD
} from './drawerConfig';
import { trackEvent } from '$lib/analytics';
import {
	determineSnapState,
	updateVelocity,
	createVelocityState,
	type VelocityState
} from './drawerGestureUtils';

export interface DrawerGestureState {
	expanded: boolean;
	isDragging: boolean;
	expandedHeight: number;
}

interface InternalGestureState {
	activePointerId: number | null;
	startY: number;
	initialHeight: number;
	velocityState: VelocityState;
	touchStartY: number | null;
	isInCollapseDrag: boolean;
}

function createDrawerGestureController() {
	// Public state (exposed to component)
	const expanded = writable(false);
	const isDragging = writable(false);
	const expandedHeight = writable(500);

	// Spring-animated height
	const drawerHeight = spring(PEEK_HEIGHT, SPRING_CONFIG);

	// Internal gesture tracking (not exposed)
	const internal: InternalGestureState = {
		activePointerId: null,
		startY: 0,
		initialHeight: PEEK_HEIGHT,
		velocityState: createVelocityState(0, 0),
		touchStartY: null,
		isInCollapseDrag: false
	};

	// Callbacks for external actions
	let onDismiss: (() => void) | null = null;

	// Reset internal state
	function resetInternalState() {
		internal.activePointerId = null;
		internal.startY = 0;
		internal.velocityState = createVelocityState(0, 0);
		internal.touchStartY = null;
		internal.isInCollapseDrag = false;
		isDragging.set(false);
	}

	// Pointer event handlers (for handle/peek area)
	function handlePointerDown(event: PointerEvent, captureTarget: HTMLElement | null) {
		if (internal.activePointerId !== null) return;

		internal.activePointerId = event.pointerId;
		isDragging.set(true);
		internal.startY = event.clientY;
		internal.initialHeight = get(drawerHeight);
		internal.velocityState = createVelocityState(event.clientY, event.timeStamp);

		if (captureTarget) {
			try {
				captureTarget.setPointerCapture(event.pointerId);
			} catch {
				// Pointer capture not supported or failed
			}
		}
	}

	function handlePointerMove(event: PointerEvent) {
		if (event.pointerId !== internal.activePointerId || !get(isDragging)) return;

		const currentY = event.clientY;
		internal.velocityState = updateVelocity(currentY, event.timeStamp, internal.velocityState);

		const isExpanded = get(expanded);
		const maxHeight = get(expandedHeight);
		const deltaY = internal.startY - currentY;
		const minHeight = isExpanded ? PEEK_HEIGHT : 0;
		const newHeight = Math.max(minHeight, Math.min(maxHeight, internal.initialHeight + deltaY));

		drawerHeight.set(newHeight, { hard: true });
	}

	function handlePointerUp(event: PointerEvent, capturedElement: HTMLElement | null) {
		if (event.pointerId !== internal.activePointerId) return;

		const finalHeight = get(drawerHeight);
		const totalDelta = finalHeight - internal.initialHeight;
		const isExpanded = get(expanded);
		const maxHeight = get(expandedHeight);

		// Release pointer capture safely
		if (capturedElement) {
			try {
				capturedElement.releasePointerCapture(event.pointerId);
			} catch {
				// Already released or invalid
			}
		}

		// Check for dismiss gesture when in peek state
		const velocity = internal.velocityState.velocity;
		const shouldDismiss =
			!isExpanded &&
			(velocity < -VELOCITY_THRESHOLD || finalHeight < PEEK_HEIGHT - DISMISS_THRESHOLD);

		if (shouldDismiss) {
			trackEvent('drawer_swipe_dismiss');
			onDismiss?.();
		} else {
			const snapState = determineSnapState(velocity, totalDelta, finalHeight, maxHeight);
			// Track swipe expand/collapse only when state changes
			if (snapState.expanded !== isExpanded) {
				trackEvent(snapState.expanded ? 'drawer_swipe_expand' : 'drawer_swipe_collapse');
			}
			expanded.set(snapState.expanded);
			drawerHeight.set(snapState.height);
		}

		resetInternalState();
	}

	function handlePointerCancel(event: PointerEvent) {
		if (event.pointerId !== internal.activePointerId) return;

		const isExpanded = get(expanded);
		const maxHeight = get(expandedHeight);

		// Snap back to previous state
		drawerHeight.set(isExpanded ? maxHeight : PEEK_HEIGHT);
		resetInternalState();
	}

	// Touch event handlers (for expanded content area - Google Maps style)
	function handleContentTouchStart(event: TouchEvent) {
		if (!get(expanded) || event.touches.length !== 1) return;
		internal.touchStartY = event.touches[0].clientY;
		internal.isInCollapseDrag = false;
	}

	function handleContentTouchMove(event: TouchEvent, scrollTop: number) {
		if (!get(expanded) || internal.touchStartY === null || event.touches.length !== 1) return;

		const touch = event.touches[0];
		const deltaY = touch.clientY - internal.touchStartY;

		// At scroll top AND dragging down â†’ enter collapse drag mode
		if (scrollTop <= SCROLL_TOP_THRESHOLD && deltaY > SCROLL_DRAG_THRESHOLD) {
			event.preventDefault();

			if (!internal.isInCollapseDrag) {
				internal.isInCollapseDrag = true;
				isDragging.set(true);
				internal.startY = touch.clientY;
				internal.touchStartY = touch.clientY;
				internal.initialHeight = get(drawerHeight);
				internal.velocityState = createVelocityState(touch.clientY, event.timeStamp);
			} else {
				const currentY = touch.clientY;
				internal.velocityState = updateVelocity(currentY, event.timeStamp, internal.velocityState);

				const maxHeight = get(expandedHeight);
				const dragDelta = internal.startY - currentY;
				const newHeight = Math.max(
					PEEK_HEIGHT,
					Math.min(maxHeight, internal.initialHeight + dragDelta)
				);
				drawerHeight.set(newHeight, { hard: true });
			}
		} else if (internal.isInCollapseDrag && scrollTop > SCROLL_TOP_THRESHOLD) {
			// User scrolled back up during collapse drag - cancel it
			internal.isInCollapseDrag = false;
			isDragging.set(false);
			internal.velocityState = createVelocityState(0, 0);
			drawerHeight.set(get(expandedHeight));
		}
	}

	function handleContentTouchEnd() {
		if (internal.isInCollapseDrag) {
			const finalHeight = get(drawerHeight);
			const totalDelta = finalHeight - internal.initialHeight;
			const maxHeight = get(expandedHeight);
			const velocity = internal.velocityState.velocity;
			const snapState = determineSnapState(velocity, totalDelta, finalHeight, maxHeight);
			// Track collapse from content swipe (can only collapse, not expand, from content drag)
			if (!snapState.expanded) {
				trackEvent('drawer_swipe_collapse');
			}
			expanded.set(snapState.expanded);
			drawerHeight.set(snapState.height);
		}
		resetInternalState();
	}

	// Public methods for drawer control
	function expand() {
		expanded.set(true);
		drawerHeight.set(get(expandedHeight));
	}

	function collapse() {
		expanded.set(false);
		drawerHeight.set(PEEK_HEIGHT);
	}

	function toggle() {
		if (get(expanded)) {
			collapse();
		} else {
			expand();
		}
	}

	function resetToPeek() {
		expanded.set(false);
		drawerHeight.set(PEEK_HEIGHT, { hard: true });
		resetInternalState();
	}

	function setExpandedHeight(height: number) {
		expandedHeight.set(height);
		if (get(expanded)) {
			drawerHeight.set(height);
		}
	}

	function setDismissCallback(callback: (() => void) | null) {
		onDismiss = callback;
	}

	// Derived store for component binding
	const state = derived(
		[expanded, isDragging, expandedHeight],
		([$expanded, $isDragging, $expandedHeight]) => ({
			expanded: $expanded,
			isDragging: $isDragging,
			expandedHeight: $expandedHeight
		})
	);

	return {
		// Stores
		expanded,
		isDragging,
		expandedHeight,
		drawerHeight,
		state,

		// Pointer handlers
		handlePointerDown,
		handlePointerMove,
		handlePointerUp,
		handlePointerCancel,

		// Touch handlers
		handleContentTouchStart,
		handleContentTouchMove,
		handleContentTouchEnd,

		// Control methods
		expand,
		collapse,
		toggle,
		resetToPeek,
		setExpandedHeight,
		setDismissCallback
	};
}

// Export singleton instance
export const drawerGesture = createDrawerGestureController();

// Export type for component usage
export type DrawerGestureController = ReturnType<typeof createDrawerGestureController>;



================================================
FILE: src/lib/drawerGestureUtils.test.ts
================================================
import { describe, it, expect } from 'vitest';
import {
	determineSnapState,
	updateVelocity,
	createVelocityState,
	resetVelocityState,
	calculateDragHeight
} from './drawerGestureUtils';
import { PEEK_HEIGHT } from './drawerConfig';

describe('determineSnapState', () => {
	const EXPANDED = 667;

	it('snaps to expanded on high upward velocity', () => {
		const result = determineSnapState(0.6, 50, 300, EXPANDED);
		expect(result).toEqual({ expanded: true, height: EXPANDED });
	});

	it('snaps to peek on high downward velocity', () => {
		const result = determineSnapState(-0.6, -50, 300, EXPANDED);
		expect(result).toEqual({ expanded: false, height: PEEK_HEIGHT });
	});

	it('snaps to expanded on large upward distance', () => {
		const result = determineSnapState(0.1, 100, 400, EXPANDED);
		expect(result).toEqual({ expanded: true, height: EXPANDED });
	});

	it('snaps to peek on large downward distance', () => {
		const result = determineSnapState(0.1, -100, 200, EXPANDED);
		expect(result).toEqual({ expanded: false, height: PEEK_HEIGHT });
	});

	it('snaps to nearest on small movement - above threshold', () => {
		// threshold = 140 + (667-140)*0.3 = 298.1
		const result = determineSnapState(0.1, 10, 350, EXPANDED);
		expect(result).toEqual({ expanded: true, height: EXPANDED });
	});

	it('snaps to nearest on small movement - below threshold', () => {
		const result = determineSnapState(0.1, -10, 200, EXPANDED);
		expect(result).toEqual({ expanded: false, height: PEEK_HEIGHT });
	});

	it('velocity takes priority over distance', () => {
		// High upward velocity should expand even with downward distance
		const result = determineSnapState(0.6, -100, 200, EXPANDED);
		expect(result).toEqual({ expanded: true, height: EXPANDED });
	});

	it('handles edge case at exact threshold', () => {
		// At exactly the velocity threshold
		const result = determineSnapState(0.5, 0, 300, EXPANDED);
		// 0.5 is not > 0.5, so it falls through to distance check
		// Distance is 0, which is not > 80 or < -80
		// Falls through to position check: 300 > 298.1 â†’ expanded
		expect(result).toEqual({ expanded: true, height: EXPANDED });
	});
});

describe('updateVelocity', () => {
	it('returns new state with updated velocity', () => {
		const initial = createVelocityState(100, 1000);
		const result = updateVelocity(90, 1010, initial);

		expect(result.lastY).toBe(90);
		expect(result.lastTime).toBe(1010);
		expect(result.samples.length).toBe(1);
		expect(result.velocity).toBe(1); // (100-90)/10 = 1 px/ms
	});

	it('calculates negative velocity for downward movement', () => {
		const initial = createVelocityState(100, 1000);
		const result = updateVelocity(110, 1010, initial);

		expect(result.velocity).toBe(-1); // (100-110)/10 = -1 px/ms
	});

	it('maintains rolling average of samples', () => {
		let state = createVelocityState(100, 1000);
		for (let i = 1; i <= 6; i++) {
			state = updateVelocity(100 - i * 10, 1000 + i * 10, state);
		}
		// Should only keep last 5 samples
		expect(state.samples.length).toBe(5);
	});

	it('does not update velocity if time delta is zero', () => {
		const initial = createVelocityState(100, 1000);
		const result = updateVelocity(90, 1000, initial);
		expect(result.velocity).toBe(0);
		expect(result.samples.length).toBe(0);
		// But should still update position
		expect(result.lastY).toBe(90);
		expect(result.lastTime).toBe(1000);
	});

	it('does not mutate original state', () => {
		const initial = createVelocityState(100, 1000);
		const originalSamples = initial.samples;
		updateVelocity(90, 1010, initial);

		expect(initial.samples).toBe(originalSamples);
		expect(initial.samples.length).toBe(0);
		expect(initial.velocity).toBe(0);
		expect(initial.lastY).toBe(100);
	});

	it('averages multiple velocity samples', () => {
		let state = createVelocityState(100, 1000);
		// First move: 10px in 10ms = 1 px/ms
		state = updateVelocity(90, 1010, state);
		// Second move: 20px in 10ms = 2 px/ms
		state = updateVelocity(70, 1020, state);

		expect(state.samples.length).toBe(2);
		expect(state.velocity).toBe(1.5); // (1 + 2) / 2
	});
});

describe('createVelocityState', () => {
	it('creates state with given initial values', () => {
		const state = createVelocityState(250, 12345);

		expect(state.lastY).toBe(250);
		expect(state.lastTime).toBe(12345);
		expect(state.samples).toEqual([]);
		expect(state.velocity).toBe(0);
	});
});

describe('resetVelocityState', () => {
	it('creates zeroed state', () => {
		const state = resetVelocityState();

		expect(state.lastY).toBe(0);
		expect(state.lastTime).toBe(0);
		expect(state.samples).toEqual([]);
		expect(state.velocity).toBe(0);
	});
});

describe('calculateDragHeight', () => {
	it('calculates height within bounds', () => {
		// Dragging up 100px from 200px height
		expect(calculateDragHeight(500, 400, 200, 140, 667)).toBe(300);
	});

	it('clamps to minimum', () => {
		// Trying to drag below minimum
		expect(calculateDragHeight(500, 700, 200, 140, 667)).toBe(140);
	});

	it('clamps to maximum', () => {
		// Trying to drag above maximum
		expect(calculateDragHeight(500, 100, 200, 140, 667)).toBe(600);
	});

	it('handles negative delta (dragging down)', () => {
		// Dragging down 50px from 300px height
		expect(calculateDragHeight(500, 550, 300, 140, 667)).toBe(250);
	});

	it('handles zero delta', () => {
		expect(calculateDragHeight(500, 500, 300, 140, 667)).toBe(300);
	});
});



================================================
FILE: src/lib/drawerGestureUtils.ts
================================================
// Pure utility functions for drawer gesture handling
// All functions are side-effect free and easily testable

import {
	PEEK_HEIGHT,
	VELOCITY_THRESHOLD,
	DISTANCE_THRESHOLD,
	POSITION_THRESHOLD_PERCENT,
	VELOCITY_SAMPLE_COUNT
} from './drawerConfig';

export interface SnapState {
	expanded: boolean;
	height: number;
}

export interface VelocityState {
	samples: number[];
	velocity: number;
	lastY: number;
	lastTime: number;
}

// Determines the snap state based on gesture velocity and distance
export function determineSnapState(
	velocity: number,
	totalDelta: number,
	finalHeight: number,
	expandedHeight: number
): SnapState {
	// Velocity takes priority - flick gestures feel responsive
	if (Math.abs(velocity) > VELOCITY_THRESHOLD) {
		if (velocity > 0) {
			return { expanded: true, height: expandedHeight };
		} else {
			return { expanded: false, height: PEEK_HEIGHT };
		}
	}

	// Then check distance for deliberate drags
	if (totalDelta > DISTANCE_THRESHOLD) {
		return { expanded: true, height: expandedHeight };
	}
	if (totalDelta < -DISTANCE_THRESHOLD) {
		return { expanded: false, height: PEEK_HEIGHT };
	}

	// Small movement - snap to nearest based on current position
	const threshold = PEEK_HEIGHT + (expandedHeight - PEEK_HEIGHT) * POSITION_THRESHOLD_PERCENT;
	if (finalHeight > threshold) {
		return { expanded: true, height: expandedHeight };
	}
	return { expanded: false, height: PEEK_HEIGHT };
}

// Updates velocity tracking state - returns new state without mutation
export function updateVelocity(
	currentY: number,
	currentTime: number,
	state: VelocityState
): VelocityState {
	const timeDelta = currentTime - state.lastTime;
	if (timeDelta <= 0) {
		return { ...state, lastY: currentY, lastTime: currentTime };
	}

	const yDelta = state.lastY - currentY; // positive = moving up
	const instantVelocity = yDelta / timeDelta;

	const samples = [...state.samples, instantVelocity];
	if (samples.length > VELOCITY_SAMPLE_COUNT) {
		samples.shift();
	}

	const velocity = samples.reduce((a, b) => a + b, 0) / samples.length;

	return {
		samples,
		velocity,
		lastY: currentY,
		lastTime: currentTime
	};
}

// Creates initial velocity tracking state
export function createVelocityState(initialY: number, initialTime: number): VelocityState {
	return {
		samples: [],
		velocity: 0,
		lastY: initialY,
		lastTime: initialTime
	};
}

// Resets velocity tracking state (for reuse without allocation)
export function resetVelocityState(): VelocityState {
	return {
		samples: [],
		velocity: 0,
		lastY: 0,
		lastTime: 0
	};
}

// Calculates new drawer height during drag
export function calculateDragHeight(
	startY: number,
	currentY: number,
	initialHeight: number,
	minHeight: number,
	maxHeight: number
): number {
	const deltaY = startY - currentY;
	return Math.max(minHeight, Math.min(maxHeight, initialHeight + deltaY));
}



================================================
FILE: src/lib/gitea.ts
================================================
import axios from 'axios';
import { env } from '$env/dynamic/private';
import { getRandomColor } from '$lib/utils';
import { get } from 'svelte/store';
import { areas } from '$lib/store';

import type { GiteaLabel, GiteaIssue } from '$lib/types';

// Cache structure with TTL
interface IssuesCache {
	timestamp: number;
	data: GiteaIssue[];
	totalCount: number;
}

let issuesCache: IssuesCache | null = null;
const CACHE_DURATION = 10 * 60 * 1000; // 10 minutes in milliseconds

async function syncIssuesFromGitea(): Promise<IssuesCache> {
	// Check if required environment variables are available
	if (!env.GITEA_API_URL || !env.GITEA_API_KEY) {
		console.warn(
			'Gitea API configuration missing (GITEA_API_URL or GITEA_API_KEY). Returning empty cache.'
		);
		return {
			timestamp: Date.now(),
			data: [],
			totalCount: 0
		};
	}

	const headers = {
		Authorization: `token ${env.GITEA_API_KEY}`
	};

	const [issuesResponse, repoResponse] = await Promise.all([
		axios.get(`${env.GITEA_API_URL}/api/v1/repos/teambtcmap/btcmap-data/issues?state=open`, {
			headers
		}),
		axios.get(`${env.GITEA_API_URL}/api/v1/repos/teambtcmap/btcmap-data`, { headers })
	]);

	const giteaIssues = issuesResponse.data.map((issue: GiteaIssue) => ({
		id: issue.id,
		number: issue.number,
		title: issue.title,
		created_at: issue.created_at,
		html_url: issue.html_url,
		labels: issue.labels,
		user: {
			login: issue.user.login,
			avatar_url: issue.user.avatar_url,
			html_url: issue.user.html_url
		},
		comments: issue.comments,
		assignees: issue.assignees
	}));

	return {
		timestamp: Date.now(),
		data: giteaIssues,
		totalCount: repoResponse.data.open_issues_count
	};
}

export async function getIssues(
	labelNames?: string[]
): Promise<{ issues: GiteaIssue[]; totalCount: number }> {
	// Refresh cache if expired or doesn't exist
	if (!issuesCache || Date.now() - issuesCache.timestamp > CACHE_DURATION) {
		try {
			issuesCache = await syncIssuesFromGitea();
		} catch (error) {
			console.error('Failed to sync issues from Gitea:', error);
			throw error;
		}
	}

	// If no labels specified, return all issues
	if (!labelNames || labelNames.length === 0) {
		return {
			issues: issuesCache.data,
			totalCount: issuesCache.totalCount
		};
	}

	// Filter issues by labels
	const filteredIssues = issuesCache.data.filter((issue) => {
		const issueLabels = new Set(issue.labels.map((l) => l.name.toLowerCase()));
		return labelNames.every((labelName) => issueLabels.has(labelName.toLowerCase()));
	});

	return {
		issues: filteredIssues,
		totalCount: filteredIssues.length
	};
}

async function getLabels(): Promise<GiteaLabel[]> {
	const headers = {
		Authorization: `token ${env.GITEA_API_KEY}`
	};

	try {
		const response = await axios.get(
			`${env.GITEA_API_URL}/api/v1/repos/teambtcmap/btcmap-data/labels`,
			{ headers }
		);
		return response.data;
	} catch (error) {
		console.error('Failed to fetch labels:', error);
		return [];
	}
}

async function createLabel(name: string): Promise<number | null> {
	const headers = {
		Authorization: `token ${env.GITEA_API_KEY}`
	};

	try {
		const existingLabels = await getLabels();
		const existingLabel = existingLabels.find((l) => l.name === name);
		if (existingLabel) {
			return existingLabel.id;
		}

		const areaDetails = get(areas).find((area) => area.id === name);
		const areaType = areaDetails?.tags?.type;
		const areaName = areaDetails?.tags?.name || name;

		if (!areaDetails) {
			console.warn(`Area ${name} not found in store. Creating label without area details.`);
		}

		let color = '';
		if (areaType === 'country') {
			color = '4A90E2'; // Blue color for countries
		} else if (areaType === 'community') {
			color = '7ED321'; // Green color for communities
		} else {
			color = getRandomColor().substring(1); // Random color for other types
		}

		const response = await axios.post(
			`${env.GITEA_API_URL}/api/v1/repos/teambtcmap/btcmap-data/labels`,
			{
				name,
				color,
				description: `Auto-generated label for ${areaName}${areaType ? ` (${areaType})` : ''}`
			},
			{ headers }
		);
		return response.data.id;
	} catch (error) {
		console.error(`Failed to create/get label ${name}:`, error);
		throw error;
	}
}

export async function createIssueWithLabels(title: string, body: string, labelNames: string[]) {
	console.debug('createIssueWithLabels - Input:', { title, labelNames });
	const headers = {
		Authorization: `token ${env.GITEA_API_KEY}`
	};

	try {
		console.debug('Attempting to create/get labels...');
		const labelPromises = labelNames.map((name) => createLabel(name));
		const labelIds = await Promise.all(labelPromises);
		console.debug('Label IDs resolved:', labelIds);

		const response = await axios.post(
			`${env.GITEA_API_URL}/api/v1/repos/teambtcmap/btcmap-data/issues`,
			{ title, body, labels: labelIds },
			{ headers }
		);

		// Invalidate cache after creating new issue
		issuesCache = null;

		return response;
	} catch (error) {
		console.error('Failed to create issue:', error);
		throw error;
	}
}



================================================
FILE: src/lib/merchantDrawerHash.test.ts
================================================
import { describe, it, expect, beforeEach, vi } from 'vitest';

// Mock SvelteKit's browser module
vi.mock('$app/environment', () => ({
	browser: true
}));

import { parseMerchantHash, updateMerchantHash } from './merchantDrawerHash';

describe('parseMerchantHash', () => {
	beforeEach(() => {
		// Mock window.location.hash before each test
		delete (window as unknown as { location: unknown }).location;
		(window as unknown as { location: { hash: string } }).location = { hash: '' };
	});

	describe('parsing merchant without map coordinates', () => {
		it('should parse #merchant=123', () => {
			window.location.hash = '#merchant=123';
			const result = parseMerchantHash();
			expect(result).toEqual({
				merchantId: 123,
				drawerView: 'details',
				isOpen: true
			});
		});

		it('should parse #merchant=123&view=boost', () => {
			window.location.hash = '#merchant=123&view=boost';
			const result = parseMerchantHash();
			expect(result).toEqual({
				merchantId: 123,
				drawerView: 'boost',
				isOpen: true
			});
		});
	});

	describe('parsing merchant with map coordinates', () => {
		it('should parse #14/10.24279/-67.58397&merchant=24180', () => {
			window.location.hash = '#14/10.24279/-67.58397&merchant=24180';
			const result = parseMerchantHash();
			expect(result).toEqual({
				merchantId: 24180,
				drawerView: 'details',
				isOpen: true
			});
		});

		it('should parse #14/10.24279/-67.58397&merchant=24180&view=boost', () => {
			window.location.hash = '#14/10.24279/-67.58397&merchant=24180&view=boost';
			const result = parseMerchantHash();
			expect(result).toEqual({
				merchantId: 24180,
				drawerView: 'boost',
				isOpen: true
			});
		});
	});

	describe('parsing empty or invalid hashes', () => {
		it('should return null merchantId for empty hash', () => {
			window.location.hash = '';
			const result = parseMerchantHash();
			expect(result).toEqual({
				merchantId: null,
				drawerView: 'details',
				isOpen: false
			});
		});

		it('should return null merchantId for hash without merchant param', () => {
			window.location.hash = '#14/10.24279/-67.58397';
			const result = parseMerchantHash();
			expect(result).toEqual({
				merchantId: null,
				drawerView: 'details',
				isOpen: false
			});
		});

		it('should return null merchantId for #merchant=invalid', () => {
			window.location.hash = '#merchant=invalid';
			const result = parseMerchantHash();
			expect(result).toEqual({
				merchantId: null,
				drawerView: 'details',
				isOpen: false
			});
		});

		it('should return null merchantId for negative values', () => {
			window.location.hash = '#merchant=-5';
			const result = parseMerchantHash();
			expect(result).toEqual({
				merchantId: null,
				drawerView: 'details',
				isOpen: false
			});
		});

		it('should return null merchantId for zero', () => {
			window.location.hash = '#merchant=0';
			const result = parseMerchantHash();
			expect(result).toEqual({
				merchantId: null,
				drawerView: 'details',
				isOpen: false
			});
		});

		it('should return null merchantId for decimal values', () => {
			window.location.hash = '#merchant=123.45';
			const result = parseMerchantHash();
			expect(result).toEqual({
				merchantId: null,
				drawerView: 'details',
				isOpen: false
			});
		});
	});

	describe('parsing with invalid view param', () => {
		it('should default to "details" for invalid view param', () => {
			window.location.hash = '#merchant=123&view=invalid';
			const result = parseMerchantHash();
			expect(result).toEqual({
				merchantId: 123,
				drawerView: 'details',
				isOpen: true
			});
		});
	});
});

describe('updateMerchantHash', () => {
	beforeEach(() => {
		// Mock window.location
		delete (window as unknown as { location: unknown }).location;
		(window as unknown as { location: { hash: string } }).location = { hash: '' };
	});

	describe('setting merchant hash', () => {
		it('should set merchant hash without map coordinates', () => {
			window.location.hash = '';
			updateMerchantHash(123, 'details');
			expect(window.location.hash).toBe('merchant=123');
		});

		it('should set merchant hash with boost view', () => {
			window.location.hash = '';
			updateMerchantHash(123, 'boost');
			expect(window.location.hash).toBe('merchant=123&view=boost');
		});

		it('should preserve map coordinates when setting merchant', () => {
			window.location.hash = '#14/10.24279/-67.58397';
			updateMerchantHash(24180, 'details');
			expect(window.location.hash).toBe('14/10.24279/-67.58397&merchant=24180');
		});

		it('should preserve map coordinates when setting merchant with boost view', () => {
			window.location.hash = '#14/10.24279/-67.58397';
			updateMerchantHash(24180, 'boost');
			expect(window.location.hash).toBe('14/10.24279/-67.58397&merchant=24180&view=boost');
		});

		it('should update existing merchant hash', () => {
			window.location.hash = '#merchant=123';
			updateMerchantHash(456, 'details');
			expect(window.location.hash).toBe('merchant=456');
		});

		it('should update existing merchant hash with map coordinates', () => {
			window.location.hash = '#14/10.24279/-67.58397&merchant=123';
			updateMerchantHash(456, 'boost');
			expect(window.location.hash).toBe('14/10.24279/-67.58397&merchant=456&view=boost');
		});
	});

	describe('removing merchant hash', () => {
		it('should remove merchant hash when passed null', () => {
			window.location.hash = '#merchant=123';
			updateMerchantHash(null, 'details');
			expect(window.location.hash).toBe('');
		});

		it('should preserve map coordinates when removing merchant', () => {
			window.location.hash = '#14/10.24279/-67.58397&merchant=123';
			updateMerchantHash(null, 'details');
			expect(window.location.hash).toBe('14/10.24279/-67.58397');
		});
	});
});



================================================
FILE: src/lib/merchantDrawerHash.ts
================================================
import { browser } from '$app/environment';

export type DrawerView = 'details' | 'boost';

export interface MerchantHashState {
	merchantId: number | null;
	drawerView: DrawerView;
	isOpen: boolean;
}

export function parseMerchantHash(): MerchantHashState {
	if (!browser) {
		return { merchantId: null, drawerView: 'details', isOpen: false };
	}

	const hash = window.location.hash.substring(1);
	const ampIndex = hash.indexOf('&');

	// Extract the merchant parameters
	// Check if there's a map part (contains '/') before the ampersand
	// If yes: params are after the '&' (e.g., "#14/10.24/-67.58&merchant=123")
	// If no: entire hash is params (e.g., "#merchant=123" or "#merchant=123&view=boost")
	let paramsString: string;
	if (ampIndex !== -1 && hash.substring(0, ampIndex).includes('/')) {
		// Map coordinates present, params are after ampersand
		paramsString = hash.substring(ampIndex + 1);
	} else {
		// No map coordinates, entire hash is params
		paramsString = hash;
	}

	const params = new URLSearchParams(paramsString);
	const merchantParam = params.get('merchant');
	const viewParam = params.get('view');

	// Validate merchant ID: must be a positive integer
	let merchantId: number | null = null;
	if (merchantParam) {
		const parsedId = Number(merchantParam);
		if (!isNaN(parsedId) && parsedId > 0 && Number.isInteger(parsedId)) {
			merchantId = parsedId;
		}
	}

	// Validate view parameter against allowed values
	const validViews: DrawerView[] = ['details', 'boost'];
	const drawerView: DrawerView =
		viewParam && validViews.includes(viewParam as DrawerView)
			? (viewParam as DrawerView)
			: 'details';

	const isOpen = Boolean(merchantId);

	return { merchantId, drawerView, isOpen };
}

export function updateMerchantHash(merchantId: number | null, view: DrawerView = 'details') {
	if (typeof window === 'undefined') return;

	const hash = window.location.hash.substring(1);
	const ampIndex = hash.indexOf('&');

	// Extract map coordinates (if present) - check if it contains '/'
	let mapPart = '';
	if (ampIndex !== -1) {
		// Has ampersand - check if part before it is map coords
		const beforeAmp = hash.substring(0, ampIndex);
		if (beforeAmp.includes('/')) {
			mapPart = beforeAmp;
		}
	} else if (hash.includes('/')) {
		// No ampersand, but hash contains '/' - it's just map coords
		mapPart = hash;
	}

	if (merchantId) {
		const params = new URLSearchParams();
		params.set('merchant', String(merchantId));
		if (view !== 'details') {
			params.set('view', view);
		}

		if (mapPart) {
			window.location.hash = `${mapPart}&${params.toString()}`;
		} else {
			window.location.hash = params.toString();
		}
	} else {
		window.location.hash = mapPart || '';
	}
}



================================================
FILE: src/lib/merchantDrawerLogic.ts
================================================
import { get } from 'svelte/store';
import axios from 'axios';
import { boost } from '$lib/store';
import { errToast } from '$lib/utils';
import { updateMerchantHash } from '$lib/merchantDrawerHash';
import type { Place, Boost } from '$lib/types';
import type { Writable } from 'svelte/store';
import { PLACE_FIELD_SETS, buildFieldsParam } from '$lib/api-fields';

// Memoize verified date calculation - recompute only once per day
let cachedVerifiedDate: number | null = null;
let cachedDay: number | null = null;

export function calcVerifiedDate(): number {
	const today = new Date().getDate();
	if (cachedVerifiedDate !== null && cachedDay === today) {
		return cachedVerifiedDate;
	}

	const verifiedDate = new Date();
	const previousYear = verifiedDate.getFullYear() - 1;
	cachedVerifiedDate = verifiedDate.setFullYear(previousYear);
	cachedDay = today;
	return cachedVerifiedDate;
}

export function isUpToDate(merchant: Place | null, verifiedDate: number): boolean {
	return !!(merchant?.verified_at && Date.parse(merchant.verified_at) > verifiedDate);
}

export function isBoosted(merchant: Place | null): boolean {
	return !!(merchant?.boosted_until && Date.parse(merchant.boosted_until) > Date.now());
}

export function clearBoostState(): void {
	boost.set(undefined);
}

function createBoostObject(merchant: Place) {
	const boostedUntil = isBoosted(merchant) ? merchant.boosted_until || '' : '';
	return {
		id: merchant.id,
		name: merchant.name || '',
		boost: boostedUntil
	};
}

export async function fetchMerchantDetails(
	id: number,
	currentMerchantId: number | null,
	setMerchant: (merchant: Place | null) => void,
	setFetching: (fetching: boolean) => void,
	setLastFetched: (id: number) => void,
	abortSignal?: AbortSignal
): Promise<void> {
	setLastFetched(id);
	setFetching(true);
	setMerchant(null);

	try {
		const response = await axios.get(
			`https://api.btcmap.org/v4/places/${id}?fields=${buildFieldsParam(PLACE_FIELD_SETS.COMPLETE_PLACE)}`,
			{
				timeout: 10000, // 10 second timeout
				signal: abortSignal // Support request cancellation
			}
		);
		if (currentMerchantId === id) {
			setMerchant(response.data);
		}
	} catch (error) {
		// Don't show error if request was cancelled (expected behavior)
		if (axios.isCancel(error)) {
			return;
		}
		console.error('Error fetching merchant details:', error);
		errToast('Error loading merchant details. Please try again.');
	} finally {
		setFetching(false);
	}
}

export function hasCompleteData(place: Place | undefined): place is Place {
	if (!place) return false;
	return place.name !== undefined && place.address !== undefined && place.verified_at !== undefined;
}

export async function handleBoost(
	merchant: Place | null,
	merchantId: number | null,
	setBoostLoading: (loading: boolean) => void
): Promise<void> {
	if (!merchant) return;

	setBoostLoading(true);
	boost.set(createBoostObject(merchant));

	try {
		updateMerchantHash(merchantId, 'boost');
		setBoostLoading(false);
	} catch (error) {
		console.error('Error fetching exchange rate for boost:', error);
		errToast('Failed to load boost information. Please try again.');
		boost.set(undefined);
		setBoostLoading(false);
	}
}

export async function handleBoostComplete(
	merchantId: number | null,
	invalidateAll: () => Promise<void>,
	resetBoostStore?: Writable<number>
): Promise<void> {
	try {
		await invalidateAll();
	} catch (error) {
		console.error('Error invalidating data after boost:', error);
		// Continue with cleanup even if invalidation fails
	}

	clearBoostState();

	if (resetBoostStore) {
		const currentValue = get(resetBoostStore) as number;
		resetBoostStore.set(currentValue + 1);
	}

	if (merchantId) {
		updateMerchantHash(merchantId, 'details');
	}
}

export function handleCloseDrawer(
	setBoostLoading: (loading: boolean) => void,
	additionalCleanup?: () => void
): void {
	clearBoostState();
	setBoostLoading(false);

	if (additionalCleanup) {
		additionalCleanup();
	}

	updateMerchantHash(null);
}

export function handleGoBack(
	merchantId: number | null,
	setBoostLoading: (loading: boolean) => void
): void {
	clearBoostState();
	setBoostLoading(false);

	if (merchantId) {
		updateMerchantHash(merchantId, 'details');
	}
}

export async function ensureBoostData(merchant: Place | null, currentBoost: Boost): Promise<void> {
	if (!merchant) return;

	if (currentBoost === undefined) {
		boost.set(createBoostObject(merchant));
	}
}



================================================
FILE: src/lib/merchantDrawerStore.ts
================================================
import { writable, get } from 'svelte/store';
import { browser } from '$app/environment';
import axios from 'axios';
import { places } from '$lib/store';
import type { DrawerView } from '$lib/merchantDrawerHash';
import { updateMerchantHash, parseMerchantHash } from '$lib/merchantDrawerHash';
import { PLACE_FIELD_SETS, buildFieldsParam } from '$lib/api-fields';
import type { Place } from '$lib/types';

export interface MerchantDrawerState {
	isOpen: boolean;
	merchantId: number | null;
	drawerView: DrawerView;
	merchant: Place | null;
	isLoading: boolean;
	error: string | null;
}

const initialState: MerchantDrawerState = {
	isOpen: false,
	merchantId: null,
	drawerView: 'details',
	merchant: null,
	isLoading: false,
	error: null
};

function createMerchantDrawerStore() {
	const { subscribe, set, update } = writable<MerchantDrawerState>(initialState);

	let abortController: AbortController | null = null;

	function hasCompleteData(place: Place | undefined): place is Place {
		if (!place) return false;
		return (
			place.name !== undefined && place.address !== undefined && place.verified_at !== undefined
		);
	}

	async function fetchMerchantData(id: number): Promise<void> {
		// Cancel any pending request
		if (abortController) {
			abortController.abort();
		}
		abortController = new AbortController();

		try {
			const response = await axios.get(
				`https://api.btcmap.org/v4/places/${id}?fields=${buildFieldsParam(PLACE_FIELD_SETS.COMPLETE_PLACE)}`,
				{
					timeout: 10000,
					signal: abortController.signal
				}
			);

			// Only update if this merchant is still selected
			update((state) => {
				if (state.merchantId === id) {
					return { ...state, merchant: response.data, isLoading: false, error: null };
				}
				return state;
			});
		} catch (error) {
			if (axios.isCancel(error)) return;

			console.error('Error fetching merchant details:', error);
			update((state) => {
				if (state.merchantId === id) {
					return { ...state, isLoading: false, error: 'Failed to load merchant details' };
				}
				return state;
			});
		}
	}

	return {
		subscribe,

		// Open drawer with optimistic UI - show cached data immediately
		open(id: number, view: DrawerView = 'details') {
			// Get cached data from places store
			const cachedPlace = get(places).find((p) => p.id === id);
			const needsFetch = !hasCompleteData(cachedPlace);

			update((state) => ({
				...state,
				isOpen: true,
				merchantId: id,
				drawerView: view,
				merchant: cachedPlace || null,
				isLoading: needsFetch,
				error: null
			}));

			// Update URL hash
			updateMerchantHash(id, view);

			// Fetch fresh data if needed
			if (needsFetch) {
				fetchMerchantData(id);
			}
		},

		// Close drawer and cancel any pending requests
		close() {
			if (abortController) {
				abortController.abort();
				abortController = null;
			}

			update((state) => ({
				...state,
				isOpen: false,
				merchantId: null,
				merchant: null,
				isLoading: false,
				error: null
			}));

			updateMerchantHash(null);
		},

		// Change drawer view (details/boost)
		setView(view: DrawerView) {
			update((state) => {
				if (state.merchantId) {
					updateMerchantHash(state.merchantId, view);
				}
				return { ...state, drawerView: view };
			});
		},

		// Sync state from URL hash (called on hashchange)
		syncFromHash() {
			if (!browser) return;

			const hashState = parseMerchantHash();

			update((currentState) => {
				// Drawer closing
				if (!hashState.isOpen && currentState.isOpen) {
					if (abortController) {
						abortController.abort();
						abortController = null;
					}
					return { ...initialState };
				}

				// Drawer opening or merchant changing
				if (hashState.isOpen && hashState.merchantId !== currentState.merchantId) {
					const cachedPlace = get(places).find((p) => p.id === hashState.merchantId);
					const needsFetch = !hasCompleteData(cachedPlace);

					if (needsFetch && hashState.merchantId) {
						fetchMerchantData(hashState.merchantId);
					}

					return {
						...currentState,
						isOpen: true,
						merchantId: hashState.merchantId,
						drawerView: hashState.drawerView,
						merchant: cachedPlace || null,
						isLoading: needsFetch,
						error: null
					};
				}

				// Just view changing
				if (hashState.drawerView !== currentState.drawerView) {
					return { ...currentState, drawerView: hashState.drawerView };
				}

				return currentState;
			});
		},

		// Update merchant data (e.g., after boost completes)
		updateMerchant(merchant: Place) {
			update((state) => ({ ...state, merchant }));
		},

		// Reset to initial state
		reset() {
			if (abortController) {
				abortController.abort();
				abortController = null;
			}
			set(initialState);
		}
	};
}

export const merchantDrawer = createMerchantDrawerStore();



================================================
FILE: src/lib/merchantListStore.test.ts
================================================
import type { Mock } from 'vitest';
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { get } from 'svelte/store';
import axios from 'axios';
import type { Place } from '$lib/types';

// Mock axios
vi.mock('axios');

// Mock errToast
vi.mock('$lib/utils', () => ({
	errToast: vi.fn(),
	isBoosted: (place: Place) => place.boosted_until && new Date(place.boosted_until) > new Date()
}));

// Mock isBoosted from merchantDrawerLogic
vi.mock('$lib/merchantDrawerLogic', () => ({
	isBoosted: (place: Place) => place.boosted_until && new Date(place.boosted_until) > new Date()
}));

// Import after mocks are set up
import { merchantList } from './merchantListStore';
import { errToast } from '$lib/utils';

// Helper to create mock Place objects
function createMockPlace(overrides: Partial<Place> = {}): Place {
	return {
		id: Math.floor(Math.random() * 10000),
		lat: 0,
		lon: 0,
		name: 'Test Place',
		...overrides
	} as Place;
}

describe('merchantListStore', () => {
	beforeEach(() => {
		vi.clearAllMocks();
		merchantList.reset();
	});

	describe('state toggles', () => {
		it('open() should set isOpen to true', () => {
			merchantList.open();
			const state = get(merchantList);
			expect(state.isOpen).toBe(true);
		});

		it('close() should hide panel but keep data', () => {
			// Set up some state first
			merchantList.open();
			merchantList.setMerchants([createMockPlace()], 0, 0);

			merchantList.close();
			const state = get(merchantList);

			expect(state.isOpen).toBe(false);
			// Data should be preserved (count visible on button)
			expect(state.merchants.length).toBe(1);
			expect(state.totalCount).toBe(1);
		});

		it('reset() should restore initial state and clear all data', () => {
			merchantList.open();
			merchantList.setMerchants([createMockPlace()], 0, 0);

			merchantList.reset();
			const state = get(merchantList);

			expect(state.isOpen).toBe(false);
			expect(state.merchants).toEqual([]);
			expect(state.totalCount).toBe(0);
			expect(state.isLoadingList).toBe(false);
			expect(state.isEnrichingDetails).toBe(false);
		});
	});

	describe('setMerchants', () => {
		it('should limit results to default max items', () => {
			const merchants = Array.from({ length: 100 }, (_, i) =>
				createMockPlace({ id: i, name: `Place ${i}` })
			);

			merchantList.setMerchants(merchants, 0, 0);
			const state = get(merchantList);

			expect(state.merchants.length).toBe(99); // MERCHANT_LIST_MAX_ITEMS
			expect(state.totalCount).toBe(100);
		});

		it('should update totalCount with full array length', () => {
			const merchants = Array.from({ length: 75 }, (_, i) => createMockPlace({ id: i }));

			merchantList.setMerchants(merchants, 0, 0);
			const state = get(merchantList);

			expect(state.totalCount).toBe(75);
		});

		it('should set isLoadingList to false', () => {
			merchantList.setMerchants([createMockPlace()], 0, 0);
			const state = get(merchantList);
			expect(state.isLoadingList).toBe(false);
		});

		it('should respect custom limit parameter', () => {
			const merchants = Array.from({ length: 20 }, (_, i) => createMockPlace({ id: i }));

			merchantList.setMerchants(merchants, 0, 0, 5);
			const state = get(merchantList);

			expect(state.merchants.length).toBe(5);
			expect(state.totalCount).toBe(20);
		});
	});

	describe('merchant sorting', () => {
		it('should place boosted merchants first', () => {
			const futureDate = new Date(Date.now() + 86400000).toISOString(); // Tomorrow
			const boosted = createMockPlace({ id: 1, name: 'Boosted', boosted_until: futureDate });
			const regular = createMockPlace({ id: 2, name: 'Regular' });

			merchantList.setMerchants([regular, boosted], 0, 0);
			const state = get(merchantList);

			expect(state.merchants[0].id).toBe(1); // Boosted first
			expect(state.merchants[1].id).toBe(2);
		});

		it('should sort by distance when center provided', () => {
			const near = createMockPlace({ id: 1, name: 'Near', lat: 0.001, lon: 0.001 });
			const far = createMockPlace({ id: 2, name: 'Far', lat: 1, lon: 1 });

			merchantList.setMerchants([far, near], 0, 0);
			const state = get(merchantList);

			expect(state.merchants[0].id).toBe(1); // Near first
			expect(state.merchants[1].id).toBe(2);
		});

		it('should fallback to alphabetical when no center', () => {
			const placeB = createMockPlace({ id: 1, name: 'Beta' });
			const placeA = createMockPlace({ id: 2, name: 'Alpha' });

			merchantList.setMerchants([placeB, placeA]);
			const state = get(merchantList);

			expect(state.merchants[0].name).toBe('Alpha');
			expect(state.merchants[1].name).toBe('Beta');
		});

		it('should handle merchants without names', () => {
			const withName = createMockPlace({ id: 1, name: 'Has Name' });
			const withoutName = createMockPlace({ id: 2, name: '' });
			const nullName = createMockPlace({ id: 3 });
			delete (nullName as Partial<Place>).name;

			// Should not throw
			merchantList.setMerchants([withName, withoutName, nullName]);
			const state = get(merchantList);
			expect(state.merchants.length).toBe(3);
		});
	});

	describe('fetchAndReplaceList', () => {
		it('should set isLoadingList while fetching', async () => {
			const mockResponse = { data: [] };
			(axios.get as Mock).mockResolvedValueOnce(mockResponse);

			const fetchPromise = merchantList.fetchAndReplaceList({ lat: 0, lon: 0 }, 10);

			// Check loading state immediately
			let state = get(merchantList);
			expect(state.isLoadingList).toBe(true);

			await fetchPromise;

			state = get(merchantList);
			expect(state.isLoadingList).toBe(false);
		});

		it('should populate merchants on success', async () => {
			const mockPlaces = [createMockPlace({ id: 1 }), createMockPlace({ id: 2 })];
			(axios.get as Mock).mockResolvedValueOnce({ data: mockPlaces });

			await merchantList.fetchAndReplaceList({ lat: 0, lon: 0 }, 10);
			const state = get(merchantList);

			expect(state.merchants.length).toBe(2);
			expect(state.totalCount).toBe(2);
		});

		it('should build placeDetailsCache from response', async () => {
			const mockPlaces = [createMockPlace({ id: 123 }), createMockPlace({ id: 456 })];
			(axios.get as Mock).mockResolvedValueOnce({ data: mockPlaces });

			await merchantList.fetchAndReplaceList({ lat: 0, lon: 0 }, 10);
			const state = get(merchantList);

			expect(state.placeDetailsCache.has(123)).toBe(true);
			expect(state.placeDetailsCache.has(456)).toBe(true);
		});

		it('should clear merchants when hideIfExceeds triggered', async () => {
			const mockPlaces = Array.from({ length: 60 }, (_, i) => createMockPlace({ id: i }));
			(axios.get as Mock).mockResolvedValueOnce({ data: mockPlaces });

			await merchantList.fetchAndReplaceList({ lat: 0, lon: 0 }, 10, { hideIfExceeds: 50 });
			const state = get(merchantList);

			expect(state.merchants).toEqual([]);
			expect(state.totalCount).toBe(60);
		});

		it('should store totalCount even when hiding results', async () => {
			const mockPlaces = Array.from({ length: 100 }, (_, i) => createMockPlace({ id: i }));
			(axios.get as Mock).mockResolvedValueOnce({ data: mockPlaces });

			await merchantList.fetchAndReplaceList({ lat: 0, lon: 0 }, 10, { hideIfExceeds: 50 });
			const state = get(merchantList);

			expect(state.totalCount).toBe(100);
		});

		it('should show error toast on failure', async () => {
			const error = new Error('Network error');
			(axios.get as Mock).mockRejectedValueOnce(error);

			await merchantList.fetchAndReplaceList({ lat: 0, lon: 0 }, 10);

			expect(errToast).toHaveBeenCalledWith('Failed to load nearby merchants');
		});

		it('should ignore AbortError (no toast)', async () => {
			const abortError = new Error('Aborted');
			abortError.name = 'AbortError';
			(axios.get as Mock).mockRejectedValueOnce(abortError);

			await merchantList.fetchAndReplaceList({ lat: 0, lon: 0 }, 10);

			expect(errToast).not.toHaveBeenCalled();
		});
	});

	describe('fetchCountOnly', () => {
		it('should request only id field', async () => {
			(axios.get as Mock).mockResolvedValueOnce({ data: [] });

			await merchantList.fetchCountOnly({ lat: 10, lon: 20 }, 5);

			expect(axios.get).toHaveBeenCalledWith(
				expect.stringContaining('fields=id'),
				expect.any(Object)
			);
		});

		it('should set totalCount from response length', async () => {
			const mockIds = [{ id: 1 }, { id: 2 }, { id: 3 }];
			(axios.get as Mock).mockResolvedValueOnce({ data: mockIds });

			await merchantList.fetchCountOnly({ lat: 0, lon: 0 }, 10);
			const state = get(merchantList);

			expect(state.totalCount).toBe(3);
		});

		it('should leave merchants empty', async () => {
			const mockIds = [{ id: 1 }, { id: 2 }];
			(axios.get as Mock).mockResolvedValueOnce({ data: mockIds });

			await merchantList.fetchCountOnly({ lat: 0, lon: 0 }, 10);
			const state = get(merchantList);

			expect(state.merchants).toEqual([]);
		});

		it('should not show error toast on failure', async () => {
			const error = new Error('Network error');
			(axios.get as Mock).mockRejectedValueOnce(error);

			await merchantList.fetchCountOnly({ lat: 0, lon: 0 }, 10);

			expect(errToast).not.toHaveBeenCalled();
		});
	});

	describe('fetchEnrichedDetails', () => {
		it('should merge into existing cache (not replace)', async () => {
			// Set up initial cache
			const initialPlace = createMockPlace({ id: 1 });
			(axios.get as Mock).mockResolvedValueOnce({ data: [initialPlace] });
			await merchantList.fetchAndReplaceList({ lat: 0, lon: 0 }, 10);

			// Fetch enriched details with new place
			const newPlace = createMockPlace({ id: 2 });
			(axios.get as Mock).mockResolvedValueOnce({ data: [newPlace] });
			await merchantList.fetchEnrichedDetails({ lat: 0, lon: 0 }, 10);

			const state = get(merchantList);
			expect(state.placeDetailsCache.has(1)).toBe(true); // Original preserved
			expect(state.placeDetailsCache.has(2)).toBe(true); // New added
		});

		it('should set isEnrichingDetails during fetch', async () => {
			(axios.get as Mock).mockResolvedValueOnce({ data: [] });

			const fetchPromise = merchantList.fetchEnrichedDetails({ lat: 0, lon: 0 }, 10);

			let state = get(merchantList);
			expect(state.isEnrichingDetails).toBe(true);

			await fetchPromise;

			state = get(merchantList);
			expect(state.isEnrichingDetails).toBe(false);
		});

		it('should not affect isLoadingList', async () => {
			(axios.get as Mock).mockResolvedValueOnce({ data: [] });

			const fetchPromise = merchantList.fetchEnrichedDetails({ lat: 0, lon: 0 }, 10);

			const state = get(merchantList);
			expect(state.isLoadingList).toBe(false);

			await fetchPromise;
		});
	});

	describe('request cancellation', () => {
		it('should cancel previous list request when new one starts', async () => {
			let firstAborted = false;
			(axios.get as Mock)
				.mockImplementationOnce(
					(_url: string, config: { signal: AbortSignal }) =>
						new Promise((_, reject) => {
							config.signal.addEventListener('abort', () => {
								firstAborted = true;
								const error = new Error('Aborted');
								error.name = 'AbortError';
								reject(error);
							});
						})
				)
				.mockResolvedValueOnce({ data: [] });

			// Start first request (will hang)
			const first = merchantList.fetchAndReplaceList({ lat: 0, lon: 0 }, 10);

			// Start second request (should abort first)
			const second = merchantList.fetchAndReplaceList({ lat: 1, lon: 1 }, 10);

			await Promise.all([first.catch(() => {}), second]);

			expect(firstAborted).toBe(true);
		});

		it('should NOT cancel details request when list request starts', async () => {
			let detailsAborted = false;
			(axios.get as Mock)
				.mockImplementationOnce(
					(_url: string, config: { signal: AbortSignal }) =>
						new Promise((resolve) => {
							config.signal.addEventListener('abort', () => {
								detailsAborted = true;
							});
							// Resolve after a tick
							setTimeout(() => resolve({ data: [] }), 10);
						})
				)
				.mockResolvedValueOnce({ data: [] });

			// Start details request
			const details = merchantList.fetchEnrichedDetails({ lat: 0, lon: 0 }, 10);

			// Start list request (should NOT abort details)
			const list = merchantList.fetchAndReplaceList({ lat: 1, lon: 1 }, 10);

			await Promise.all([details, list]);

			expect(detailsAborted).toBe(false);
		});

		it('should cancel all requests on reset()', async () => {
			let listAborted = false;
			let detailsAborted = false;

			(axios.get as Mock)
				.mockImplementationOnce(
					(_url: string, config: { signal: AbortSignal }) =>
						new Promise((_, reject) => {
							config.signal.addEventListener('abort', () => {
								listAborted = true;
								const error = new Error('Aborted');
								error.name = 'AbortError';
								reject(error);
							});
						})
				)
				.mockImplementationOnce(
					(_url: string, config: { signal: AbortSignal }) =>
						new Promise((_, reject) => {
							config.signal.addEventListener('abort', () => {
								detailsAborted = true;
								const error = new Error('Aborted');
								error.name = 'AbortError';
								reject(error);
							});
						})
				);

			// Start both requests
			const list = merchantList.fetchAndReplaceList({ lat: 0, lon: 0 }, 10);
			const details = merchantList.fetchEnrichedDetails({ lat: 0, lon: 0 }, 10);

			// Reset should cancel both
			merchantList.reset();

			await Promise.all([list.catch(() => {}), details.catch(() => {})]);

			expect(listAborted).toBe(true);
			expect(detailsAborted).toBe(true);
		});

		it('close() should NOT cancel requests (just hide panel)', async () => {
			let requestAborted = false;

			(axios.get as Mock).mockImplementationOnce(
				(_url: string, config: { signal: AbortSignal }) =>
					new Promise((resolve) => {
						config.signal.addEventListener('abort', () => {
							requestAborted = true;
						});
						// Resolve after a short delay
						setTimeout(() => resolve({ data: [] }), 50);
					})
			);

			// Start a request
			const list = merchantList.fetchAndReplaceList({ lat: 0, lon: 0 }, 10);

			// Close should NOT cancel the request
			merchantList.close();

			await list;

			expect(requestAborted).toBe(false);
		});
	});

	describe('search state', () => {
		it('openSearchMode() should open panel in search mode with optional spinner', () => {
			merchantList.openSearchMode(true);
			const state = get(merchantList);

			expect(state.isSearching).toBe(true);
			expect(state.mode).toBe('search');
			expect(state.isOpen).toBe(true);
		});

		it('openSearchMode() without argument should not show spinner', () => {
			merchantList.openSearchMode();
			const state = get(merchantList);

			expect(state.isSearching).toBe(false);
			expect(state.mode).toBe('search');
			expect(state.isOpen).toBe(true);
		});

		it('openWithSearchResults() should set mode, query, and results', () => {
			const results = [createMockPlace({ id: 1 }), createMockPlace({ id: 2 })];
			merchantList.openWithSearchResults('pizza', results);
			const state = get(merchantList);

			expect(state.mode).toBe('search');
			expect(state.searchQuery).toBe('pizza');
			expect(state.searchResults.length).toBe(2);
			expect(state.isSearching).toBe(false);
			expect(state.isOpen).toBe(true);
		});

		it('openWithSearchResults() should sort boosted merchants first', () => {
			const futureDate = new Date(Date.now() + 86400000).toISOString();
			const boosted = createMockPlace({ id: 1, name: 'Boosted', boosted_until: futureDate });
			const regular = createMockPlace({ id: 2, name: 'Regular' });

			merchantList.openWithSearchResults('test', [regular, boosted]);
			const state = get(merchantList);

			expect(state.searchResults[0].id).toBe(1); // Boosted first
			expect(state.searchResults[1].id).toBe(2);
		});

		it('openWithSearchResults() should calculate category counts from results', () => {
			const results = [
				createMockPlace({ id: 1, icon: 'restaurant' }),
				createMockPlace({ id: 2, icon: 'restaurant' }),
				createMockPlace({ id: 3, icon: 'local_cafe' }),
				createMockPlace({ id: 4, icon: 'local_atm' })
			];

			merchantList.openWithSearchResults('test query', results);
			const state = get(merchantList);

			expect(state.categoryCounts.all).toBe(4);
			expect(state.categoryCounts.restaurants).toBe(2);
			expect(state.categoryCounts.coffee).toBe(1);
			expect(state.categoryCounts.atms).toBe(1);
			expect(state.categoryCounts.shopping).toBe(0);
		});

		it('clearSearchInput() should clear results but keep search mode', () => {
			merchantList.openWithSearchResults('test', [createMockPlace()]);
			merchantList.clearSearchInput();
			const state = get(merchantList);

			expect(state.mode).toBe('search'); // Mode preserved
			expect(state.searchQuery).toBe('');
			expect(state.searchResults).toEqual([]);
			expect(state.isSearching).toBe(false);
		});

		it('exitSearchMode() should switch to nearby mode and clear search state', () => {
			merchantList.openWithSearchResults('test', [createMockPlace()]);
			merchantList.exitSearchMode();
			const state = get(merchantList);

			expect(state.mode).toBe('nearby');
			expect(state.searchQuery).toBe('');
			expect(state.searchResults).toEqual([]);
			expect(state.isSearching).toBe(false);
		});

		it('setMode() should switch to search mode', () => {
			merchantList.setMode('search');
			const state = get(merchantList);

			expect(state.mode).toBe('search');
		});

		it('setMode() should switch to nearby mode without clearing search state', () => {
			// Set up search state first
			merchantList.openWithSearchResults('pizza', [createMockPlace()]);

			merchantList.setMode('nearby');
			const state = get(merchantList);

			// Mode changes but search state is preserved (no side effects)
			expect(state.mode).toBe('nearby');
			expect(state.searchQuery).toBe('pizza');
			expect(state.searchResults.length).toBe(1);
		});
	});

	describe('category filtering', () => {
		// Helper to create places with specific icons for category testing
		function createPlaceWithIcon(icon: string, overrides: Partial<Place> = {}): Place {
			return createMockPlace({ icon, ...overrides });
		}

		describe('setSelectedCategory and resetCategory', () => {
			it('setSelectedCategory() should update selectedCategory in state', () => {
				merchantList.setSelectedCategory('restaurants');
				const state = get(merchantList);
				expect(state.selectedCategory).toBe('restaurants');
			});

			it('setSelectedCategory() should allow setting any valid category', () => {
				const categories = [
					'all',
					'restaurants',
					'shopping',
					'groceries',
					'coffee',
					'atms',
					'hotels',
					'beauty'
				] as const;

				for (const category of categories) {
					merchantList.setSelectedCategory(category);
					const state = get(merchantList);
					expect(state.selectedCategory).toBe(category);
				}
			});

			it('resetCategory() should reset selectedCategory to all', () => {
				merchantList.setSelectedCategory('coffee');
				merchantList.resetCategory();
				const state = get(merchantList);
				expect(state.selectedCategory).toBe('all');
			});
		});

		describe('category state reset on close', () => {
			it('close() should reset category to all', () => {
				merchantList.open();
				merchantList.setSelectedCategory('restaurants');
				merchantList.close();
				const state = get(merchantList);
				expect(state.selectedCategory).toBe('all');
			});

			it('close() should preserve merchants while resetting category', () => {
				const merchants = [createPlaceWithIcon('restaurant', { id: 1 })];
				merchantList.setMerchants(merchants, 0, 0);
				merchantList.setSelectedCategory('restaurants');
				merchantList.close();
				const state = get(merchantList);

				expect(state.selectedCategory).toBe('all');
				expect(state.merchants.length).toBe(1);
			});

			it('close() should reset all search state (mode, query, results, isSearching)', () => {
				// Set up search state
				merchantList.openWithSearchResults('pizza', [
					createPlaceWithIcon('restaurant', { id: 1 }),
					createPlaceWithIcon('restaurant', { id: 2 })
				]);

				// Verify search state is set
				let state = get(merchantList);
				expect(state.mode).toBe('search');
				expect(state.searchQuery).toBe('pizza');
				expect(state.searchResults.length).toBe(2);
				expect(state.isOpen).toBe(true);

				// Close should reset all search state
				merchantList.close();
				state = get(merchantList);

				expect(state.isOpen).toBe(false);
				expect(state.mode).toBe('nearby');
				expect(state.searchQuery).toBe('');
				expect(state.searchResults).toEqual([]);
				expect(state.isSearching).toBe(false);
				expect(state.selectedCategory).toBe('all');
			});
		});

		describe('category state reset on search actions', () => {
			it('openWithSearchResults() should reset category to all', () => {
				merchantList.setSelectedCategory('coffee');
				merchantList.openWithSearchResults('test', [createMockPlace()]);
				const state = get(merchantList);
				expect(state.selectedCategory).toBe('all');
			});

			it('clearSearchInput() should reset category to all', () => {
				merchantList.openSearchMode();
				merchantList.setSelectedCategory('atms');
				merchantList.clearSearchInput();
				const state = get(merchantList);
				expect(state.selectedCategory).toBe('all');
			});

			it('exitSearchMode() should reset category to all', () => {
				merchantList.openSearchMode();
				merchantList.setSelectedCategory('hotels');
				merchantList.exitSearchMode();
				const state = get(merchantList);
				expect(state.selectedCategory).toBe('all');
			});
		});

		describe('category counts', () => {
			it('setMerchants() should calculate category counts', () => {
				const merchants = [
					createPlaceWithIcon('restaurant', { id: 1 }),
					createPlaceWithIcon('restaurant', { id: 2 }),
					createPlaceWithIcon('local_cafe', { id: 3 }),
					createPlaceWithIcon('local_atm', { id: 4 })
				];

				merchantList.setMerchants(merchants, 0, 0);
				const state = get(merchantList);

				expect(state.categoryCounts.all).toBe(4);
				expect(state.categoryCounts.restaurants).toBe(2);
				expect(state.categoryCounts.coffee).toBe(1);
				expect(state.categoryCounts.atms).toBe(1);
				expect(state.categoryCounts.shopping).toBe(0);
			});

			it('setMerchants() should handle merchants without icons', () => {
				const merchants = [
					createPlaceWithIcon('restaurant', { id: 1 }),
					createMockPlace({ id: 2 }), // No icon
					createMockPlace({ id: 3, icon: undefined })
				];

				merchantList.setMerchants(merchants, 0, 0);
				const state = get(merchantList);

				expect(state.categoryCounts.all).toBe(3);
				expect(state.categoryCounts.restaurants).toBe(1);
			});
		});

		describe('category filtering in setMerchants', () => {
			it('should filter merchants by selected category', () => {
				merchantList.setSelectedCategory('restaurants');

				const merchants = [
					createPlaceWithIcon('restaurant', { id: 1, name: 'Restaurant A' }),
					createPlaceWithIcon('local_cafe', { id: 2, name: 'Cafe B' }),
					createPlaceWithIcon('restaurant', { id: 3, name: 'Restaurant C' })
				];

				merchantList.setMerchants(merchants, 0, 0);
				const state = get(merchantList);

				expect(state.merchants.length).toBe(2);
				expect(state.merchants.every((m) => m.icon === 'restaurant')).toBe(true);
				expect(state.totalCount).toBe(2);
			});

			it('should show all merchants when category is all', () => {
				merchantList.setSelectedCategory('all');

				const merchants = [
					createPlaceWithIcon('restaurant', { id: 1 }),
					createPlaceWithIcon('local_cafe', { id: 2 }),
					createPlaceWithIcon('local_atm', { id: 3 })
				];

				merchantList.setMerchants(merchants, 0, 0);
				const state = get(merchantList);

				expect(state.merchants.length).toBe(3);
				expect(state.totalCount).toBe(3);
			});
		});

		describe('auto-reset category when no matches', () => {
			it('should auto-reset to all when selected category has no matches but other merchants exist', () => {
				// First set up with restaurants
				merchantList.setSelectedCategory('restaurants');
				const initialMerchants = [
					createPlaceWithIcon('restaurant', { id: 1 }),
					createPlaceWithIcon('local_cafe', { id: 2 })
				];
				merchantList.setMerchants(initialMerchants, 0, 0);

				// Now update with merchants that have no restaurants
				const newMerchants = [
					createPlaceWithIcon('local_cafe', { id: 3 }),
					createPlaceWithIcon('local_atm', { id: 4 })
				];
				merchantList.setMerchants(newMerchants, 0, 0);

				const state = get(merchantList);

				// Should auto-reset to 'all' since there are no restaurants
				expect(state.selectedCategory).toBe('all');
				expect(state.merchants.length).toBe(2);
				expect(state.categoryCounts.restaurants).toBe(0);
				expect(state.categoryCounts.all).toBe(2);
			});

			it('should NOT auto-reset when selected category still has matches', () => {
				merchantList.setSelectedCategory('restaurants');

				const merchants = [
					createPlaceWithIcon('restaurant', { id: 1 }),
					createPlaceWithIcon('local_cafe', { id: 2 })
				];
				merchantList.setMerchants(merchants, 0, 0);

				const state = get(merchantList);

				expect(state.selectedCategory).toBe('restaurants');
				expect(state.merchants.length).toBe(1);
			});

			it('should NOT auto-reset when no merchants exist at all (empty area)', () => {
				merchantList.setSelectedCategory('restaurants');

				// Simulate panning to empty area
				merchantList.setMerchants([], 0, 0);

				const state = get(merchantList);

				// Should keep restaurants selected - no point resetting when area is empty
				expect(state.selectedCategory).toBe('restaurants');
				expect(state.merchants.length).toBe(0);
				expect(state.categoryCounts.all).toBe(0);
			});

			it('should NOT auto-reset when category is already all', () => {
				merchantList.setSelectedCategory('all');

				const merchants = [createPlaceWithIcon('local_cafe', { id: 1 })];
				merchantList.setMerchants(merchants, 0, 0);

				const state = get(merchantList);

				expect(state.selectedCategory).toBe('all');
			});
		});

		describe('fetchAndReplaceList with categories', () => {
			it('should calculate category counts from API response', async () => {
				const mockPlaces = [
					createPlaceWithIcon('restaurant', { id: 1 }),
					createPlaceWithIcon('restaurant', { id: 2 }),
					createPlaceWithIcon('local_cafe', { id: 3 })
				];
				(axios.get as Mock).mockResolvedValueOnce({ data: mockPlaces });

				await merchantList.fetchAndReplaceList({ lat: 0, lon: 0 }, 10);
				const state = get(merchantList);

				expect(state.categoryCounts.all).toBe(3);
				expect(state.categoryCounts.restaurants).toBe(2);
				expect(state.categoryCounts.coffee).toBe(1);
			});

			it('should apply category filter to API results', async () => {
				merchantList.setSelectedCategory('restaurants');

				const mockPlaces = [
					createPlaceWithIcon('restaurant', { id: 1 }),
					createPlaceWithIcon('local_cafe', { id: 2 }),
					createPlaceWithIcon('restaurant', { id: 3 })
				];
				(axios.get as Mock).mockResolvedValueOnce({ data: mockPlaces });

				await merchantList.fetchAndReplaceList({ lat: 0, lon: 0 }, 10);
				const state = get(merchantList);

				expect(state.merchants.length).toBe(2);
				expect(state.totalCount).toBe(2);
				expect(state.categoryCounts.all).toBe(3); // Full counts preserved
			});

			it('should auto-reset category when API returns no matches for selected category', async () => {
				merchantList.setSelectedCategory('restaurants');

				const mockPlaces = [
					createPlaceWithIcon('local_cafe', { id: 1 }),
					createPlaceWithIcon('local_atm', { id: 2 })
				];
				(axios.get as Mock).mockResolvedValueOnce({ data: mockPlaces });

				await merchantList.fetchAndReplaceList({ lat: 0, lon: 0 }, 10);
				const state = get(merchantList);

				expect(state.selectedCategory).toBe('all');
				expect(state.merchants.length).toBe(2);
			});

			it('should still calculate category counts when hideIfExceeds is triggered', async () => {
				const mockPlaces = Array.from({ length: 60 }, (_, i) =>
					createPlaceWithIcon(i % 2 === 0 ? 'restaurant' : 'local_cafe', { id: i })
				);
				(axios.get as Mock).mockResolvedValueOnce({ data: mockPlaces });

				await merchantList.fetchAndReplaceList({ lat: 0, lon: 0 }, 10, { hideIfExceeds: 50 });
				const state = get(merchantList);

				expect(state.merchants).toEqual([]);
				expect(state.categoryCounts.all).toBe(60);
				expect(state.categoryCounts.restaurants).toBe(30);
				expect(state.categoryCounts.coffee).toBe(30);
			});
		});
	});
});



================================================
FILE: src/lib/merchantListStore.ts
================================================
import { writable, get } from 'svelte/store';
import axios from 'axios';
import type { Place } from '$lib/types';
import { PLACE_FIELD_SETS, buildFieldsParam } from '$lib/api-fields';
import { isBoosted } from '$lib/merchantDrawerLogic';
import { MERCHANT_LIST_MAX_ITEMS } from '$lib/constants';
import { errToast } from '$lib/utils';
import {
	countMerchantsByCategory,
	createEmptyCategoryCounts,
	filterMerchantsByCategory,
	type CategoryCounts,
	type CategoryKey
} from '$lib/categoryMapping';

export type MerchantListMode = 'nearby' | 'search';

export interface MerchantListState {
	isOpen: boolean;
	merchants: Place[];
	totalCount: number;
	// Cache of full Place data by ID, used to show icons/addresses without re-fetching
	placeDetailsCache: Map<number, Place>;
	// True when fetching/replacing the merchant list (shows spinner)
	isLoadingList: boolean;
	// True when fetching enriched details in background (no spinner)
	isEnrichingDetails: boolean;
	// Panel mode: 'nearby' for location-based list, 'search' for search results
	mode: MerchantListMode;
	// Search state
	searchQuery: string;
	searchResults: Place[];
	isSearching: boolean;
	// Category filter
	selectedCategory: CategoryKey;
	categoryCounts: CategoryCounts;
}

const initialState: MerchantListState = {
	isOpen: false,
	merchants: [],
	totalCount: 0,
	placeDetailsCache: new Map(),
	isLoadingList: false,
	isEnrichingDetails: false,
	mode: 'nearby',
	searchQuery: '',
	searchResults: [],
	isSearching: false,
	selectedCategory: 'all',
	categoryCounts: createEmptyCategoryCounts()
};

// Helper function to reset category state
function resetCategoryState<T extends MerchantListState>(state: T): T {
	return { ...state, selectedCategory: 'all' };
}

// Helper to apply category filtering with auto-reset when selected category has no matches
// Returns filtered merchants and the effective category (may be reset to 'all')
function applyCategoryFilter(
	merchants: Place[],
	selectedCategory: CategoryKey,
	categoryCounts: CategoryCounts
): { filtered: Place[]; effectiveCategory: CategoryKey } {
	// Auto-reset if selected category has no matches but other merchants exist
	const shouldReset =
		selectedCategory !== 'all' && categoryCounts.all > 0 && categoryCounts[selectedCategory] === 0;

	const effectiveCategory = shouldReset ? 'all' : selectedCategory;

	const filtered =
		effectiveCategory !== 'all'
			? filterMerchantsByCategory(merchants, effectiveCategory)
			: merchants;

	return { filtered, effectiveCategory };
}

// Equirectangular approximation for local distance sorting
// Uses squared distance (avoids sqrt) since we only need relative ordering
// Cosine adjustment accounts for longitude distortion at different latitudes
function getDistanceSquared(lat1: number, lon1: number, lat2: number, lon2: number): number {
	const dx = (lon2 - lon1) * Math.cos(((lat1 + lat2) / 2) * (Math.PI / 180));
	const dy = lat2 - lat1;
	return dx * dx + dy * dy;
}

// Sort order: boosted merchants first (premium placement), then by distance, then alphabetically
function sortMerchants(merchants: Place[], centerLat?: number, centerLon?: number): Place[] {
	return [...merchants].sort((a, b) => {
		// Boosted first
		if (isBoosted(a) && !isBoosted(b)) return -1;
		if (!isBoosted(a) && isBoosted(b)) return 1;

		// Then by distance (if center provided)
		if (centerLat !== undefined && centerLon !== undefined) {
			const distA = getDistanceSquared(centerLat, centerLon, a.lat, a.lon);
			const distB = getDistanceSquared(centerLat, centerLon, b.lat, b.lon);
			return distA - distB;
		}

		// Fallback to alphabetical
		return (a.name || '').localeCompare(b.name || '');
	});
}

// Filter out invalid API response items missing required id field
function filterValidPlaces<T extends { id?: unknown }>(items: T[]): T[] {
	return items.filter((item): item is T => typeof item?.id === 'number');
}

function createMerchantListStore() {
	const store = writable<MerchantListState>(initialState);
	const { subscribe, set, update } = store;

	// Separate abort controllers so list and detail fetches don't cancel each other
	let listAbortController: AbortController | null = null;
	let detailsAbortController: AbortController | null = null;

	function cancelListRequest() {
		if (listAbortController) {
			listAbortController.abort();
			listAbortController = null;
		}
	}

	function cancelDetailsRequest() {
		if (detailsAbortController) {
			detailsAbortController.abort();
			detailsAbortController = null;
		}
	}

	function cancelAllRequests() {
		cancelListRequest();
		cancelDetailsRequest();
	}

	return {
		subscribe,

		open() {
			update((state) => ({ ...state, isOpen: true }));
		},

		// Hide the panel, reset category filter and search state, but keep merchant data (count visible on button)
		close() {
			update((state) => ({
				...resetCategoryState(state),
				isOpen: false,
				mode: 'nearby',
				searchQuery: '',
				searchResults: [],
				isSearching: false
			}));
		},

		// Set merchants from locally-loaded markers (used at zoom 15-16)
		setMerchants(
			merchants: Place[],
			centerLat?: number,
			centerLon?: number,
			limit: number = MERCHANT_LIST_MAX_ITEMS
		) {
			const categoryCounts = countMerchantsByCategory(merchants);
			const { selectedCategory } = get(store);
			const { filtered, effectiveCategory } = applyCategoryFilter(
				merchants,
				selectedCategory,
				categoryCounts
			);

			const sorted = sortMerchants(filtered, centerLat, centerLon);
			const limited = sorted.slice(0, limit);

			update((state) => ({
				...state,
				merchants: limited,
				totalCount: filtered.length,
				isLoadingList: false,
				categoryCounts,
				selectedCategory: effectiveCategory
			}));
		},

		// Fetch merchants from API and replace the current list
		// Used at high zoom (17+) and low zoom (11-14) where we can't rely on loaded markers
		// hideIfExceeds: if API returns more than this, clear the list (shows "zoom in" message)
		async fetchAndReplaceList(
			center: { lat: number; lon: number },
			radiusKm: number,
			options?: { hideIfExceeds?: number }
		) {
			cancelListRequest();
			listAbortController = new AbortController();

			// Keep previous merchants visible while loading (prevents flicker)
			update((state) => ({ ...state, isLoadingList: true }));

			try {
				const fields = buildFieldsParam(PLACE_FIELD_SETS.LIST_ITEM);
				const response = await axios.get<Place[]>(
					`https://api.btcmap.org/v4/places/search/?lat=${center.lat}&lon=${center.lon}&radius_km=${radiusKm}&fields=${fields}`,
					{ timeout: 10000, signal: listAbortController.signal }
				);

				// Validate response is an array (API may return HTML error page)
				if (!Array.isArray(response.data)) {
					throw new Error('API returned invalid data format');
				}

				// Filter out invalid items missing required id field
				const validPlaces = filterValidPlaces(response.data);

				// Build cache for enriched display (icons, addresses, etc.)
				const placeDetailsCache = new Map<number, Place>();
				validPlaces.forEach((place) => placeDetailsCache.set(place.id, place));

				const categoryCounts = countMerchantsByCategory(validPlaces);

				// Check if we should hide results (too many at low zoom)
				if (options?.hideIfExceeds && validPlaces.length > options.hideIfExceeds) {
					// Too many results - store count but show empty list
					// The panel will display "zoom in" message, button shows count
					update((state) => ({
						...state,
						merchants: [],
						totalCount: validPlaces.length,
						isLoadingList: false,
						categoryCounts
					}));
				} else {
					const { selectedCategory } = get(store);
					const { filtered, effectiveCategory } = applyCategoryFilter(
						validPlaces,
						selectedCategory,
						categoryCounts
					);

					const sorted = sortMerchants(filtered, center.lat, center.lon);
					const limited = sorted.slice(0, MERCHANT_LIST_MAX_ITEMS);
					update((state) => ({
						...state,
						merchants: limited,
						totalCount: filtered.length,
						placeDetailsCache,
						isLoadingList: false,
						categoryCounts,
						selectedCategory: effectiveCategory
					}));
				}
			} catch (error) {
				if (error instanceof Error && error.name !== 'AbortError') {
					console.warn('Failed to fetch merchant list:', error.message);
					errToast('Failed to load nearby merchants');
				}
				update((state) => ({ ...state, isLoadingList: false }));
			}
		},

		// Fetch only IDs to get count (minimal payload for button badge)
		// Used at zoom 11-14 when panel is closed - avoids fetching full data unnecessarily
		async fetchCountOnly(center: { lat: number; lon: number }, radiusKm: number) {
			cancelListRequest();
			listAbortController = new AbortController();

			update((state) => ({ ...state, isLoadingList: true }));

			try {
				const response = await axios.get<{ id: number }[]>(
					`https://api.btcmap.org/v4/places/search/?lat=${center.lat}&lon=${center.lon}&radius_km=${radiusKm}&fields=id`,
					{ timeout: 10000, signal: listAbortController.signal }
				);

				// Validate response is an array (API may return HTML error page)
				if (!Array.isArray(response.data)) {
					throw new Error('API returned invalid data format');
				}

				// Filter out invalid items missing required id field
				const validItems = filterValidPlaces(response.data);

				update((state) => ({
					...state,
					merchants: [],
					totalCount: validItems.length,
					isLoadingList: false
					// Preserve existing categoryCounts since we don't have actual merchant data to recalculate them
				}));
			} catch (error) {
				if (error instanceof Error && error.name !== 'AbortError') {
					console.warn('Failed to fetch merchant count:', error.message);
				}
				update((state) => ({ ...state, isLoadingList: false }));
			}
		},

		// Fetch full Place data to enrich existing list items (doesn't change the list)
		// Used at zoom 15-16 when panel is open - adds icons/addresses to skeleton items
		// Runs silently in background without showing spinner
		async fetchEnrichedDetails(center: { lat: number; lon: number }, radiusKm: number) {
			cancelDetailsRequest();
			detailsAbortController = new AbortController();

			update((state) => ({ ...state, isEnrichingDetails: true }));

			try {
				const fields = buildFieldsParam(PLACE_FIELD_SETS.LIST_ITEM);
				const response = await axios.get<Place[]>(
					`https://api.btcmap.org/v4/places/search/?lat=${center.lat}&lon=${center.lon}&radius_km=${radiusKm}&fields=${fields}`,
					{ timeout: 10000, signal: detailsAbortController.signal }
				);

				// Filter out invalid items and merge into existing cache
				const validPlaces = filterValidPlaces(response.data);
				update((state) => {
					const mergedCache = new Map(state.placeDetailsCache);
					validPlaces.forEach((place) => mergedCache.set(place.id, place));
					return { ...state, placeDetailsCache: mergedCache, isEnrichingDetails: false };
				});
			} catch (error) {
				if (error instanceof Error && error.name !== 'AbortError') {
					console.warn('Failed to fetch enriched details:', error.message);
				}
				update((state) => ({ ...state, isEnrichingDetails: false }));
			}
		},

		// Open panel with search results (sorted with boosted first)
		openWithSearchResults(query: string, results: Place[]) {
			const sortedResults = sortMerchants(results);
			const categoryCounts = countMerchantsByCategory(sortedResults);
			update((state) => ({
				...resetCategoryState(state),
				isOpen: true,
				mode: 'search',
				searchQuery: query,
				searchResults: sortedResults,
				isSearching: false,
				categoryCounts
			}));
		},

		// Open panel in search mode, optionally showing spinner
		// Use openSearchMode() to open panel ready for input (no spinner)
		// Use openSearchMode(true) when a search is in progress (shows spinner)
		openSearchMode(isSearching: boolean = false) {
			update((state) => ({
				...state,
				isSearching,
				mode: 'search',
				isOpen: true
			}));
		},

		// Update the search query (used when binding input to store)
		setSearchQuery(query: string) {
			update((state) => ({ ...state, searchQuery: query }));
		},

		// Clear search input and results, but stay in search mode
		// Use when: user clears the search input (e.g., clicking X button)
		// Markers reset because searchResultIds becomes empty, triggering normal marker reload
		clearSearchInput() {
			update((state) => ({
				...resetCategoryState(state),
				searchQuery: '',
				searchResults: [],
				isSearching: false
			}));
		},

		// Exit search mode and return to nearby mode
		// Use when: user explicitly switches away from search (e.g., clicking "Nearby" tab)
		exitSearchMode() {
			update((state) => ({
				...resetCategoryState(state),
				mode: 'nearby',
				searchQuery: '',
				searchResults: [],
				isSearching: false
			}));
		},

		// Switch between modes (no side effects - just sets mode)
		setMode(mode: MerchantListMode) {
			update((state) => ({ ...state, mode }));
		},

		// Set the selected category filter
		setSelectedCategory(category: CategoryKey) {
			update((state) => ({ ...state, selectedCategory: category }));
		},

		// Reset the selected category to 'all'
		resetCategory() {
			update((state) => resetCategoryState(state));
		},

		reset() {
			cancelAllRequests();
			set(initialState);
		}
	};
}

export const merchantList = createMerchantListStore();



================================================
FILE: src/lib/organizationDisplayNames.ts
================================================
export interface OrganizationDisplayName {
	id: string;
	displayName: string;
}

export const organizationDisplayNames: Record<string, string> = {
	'2140-meetups': '2140 Meetups',
	bitcoin4india: 'Bitcoin4India',
	'bitcoin-4-iranians': 'Bitcoin 4 Iranians',
	'bitcoin-bulgaria': 'Bitcoin Bulgaria',
	'bitcoin-indonesia': 'Bitcoin Indonesia',
	'bitcoin-jamii': 'Bitcoin Jamii',
	'bitcoin-paraguay': 'Bitcoin Paraguay',
	'bit-devs': 'BitDevs',
	'breizh-bitcoin': 'Breizh Bitcoin',
	'decouvre-bitcoin': 'DÃ©couvre Bitcoin',
	dvadsatjeden: 'DvadsaÅ¥jeden',
	'dwadziescia-jeden': 'DwadzieÅ›cia Jeden',
	eenentwintig: 'Eenentwintig',
	einundzwanzig: 'Einundzwanzig',
	enogtyve: 'Enogtyve',
	'go-btc': 'Go BTC',
	jednadvacet: 'Jednadvacet',
	'mi-primer-bitcoin': 'Mi Primer Bitcoin',
	'plan-b-network': 'Plan B Network',
	sst: 'Satoshi Somos Todos',
	'satoshi-spritz': 'Satoshi Spritz',
	uaibit: 'UAIBIT'
};

//Function will return the raw `organization` tag if it is not in the list of known organizations above.`
export const getOrganizationDisplayName = (organizationId: string): string => {
	return organizationDisplayNames[organizationId] || organizationId;
};

export const getAllOrganizations = (): OrganizationDisplayName[] => {
	return Object.entries(organizationDisplayNames).map(([id, displayName]) => ({
		id,
		displayName
	}));
};



================================================
FILE: src/lib/payment.ts
================================================
/**
 * Shared payment utilities for comment and boost flows
 */
import axios from 'axios';
import axiosRetry from 'axios-retry';

/**
 * Create a configured axios instance for payment API calls
 */
export const createPaymentApi = () => {
	const api = axios.create();
	axiosRetry(api, { retries: 3, retryDelay: axiosRetry.exponentialDelay });
	return api;
};

/**
 * Poll invoice status from v4 API
 */
export const pollInvoiceStatus = async (invoiceId: string) => {
	const api = createPaymentApi();
	return api.get(`/api/boost/invoice/status?invoice_id=${invoiceId}`);
};

/**
 * Check if invoice is paid
 */
export const isInvoicePaid = (status: string) => {
	return status === 'paid';
};



================================================
FILE: src/lib/store.ts
================================================
import type { AppIconName } from '$lib/icons/types';
import type { Area, Boost, Event, Issue, OSMTags, Place, Report, Theme, User } from '$lib/types';
import type { Writable } from 'svelte/store';
import { derived, readable, writable } from 'svelte/store';

export const socials = readable({
	x: 'https://x.com/btcmap',
	nostr: 'https://nosta.me/nprofile1qqsra2ey033mkdwl5w8q0jss9ak69zafh82xsuvhwsaauw3trkq2amgax6f75',
	matrix: 'https://matrix.to/#/#btcmap:matrix.org',
	github: 'https://github.com/teambtcmap',
	amboss: 'https://amboss.space/community/edf8d227-9bc7-4cb2-af2a-66c1b455109a'
});

export const apps = readable<{ link: string; type: string; icon: AppIconName; desc: string }[]>([
	{
		link: '/map',
		type: 'Web',
		icon: 'web',
		desc: 'Progressive Web App'
	},
	{
		link: 'https://f-droid.org/en/packages/org.btcmap/',
		type: 'F-Droid',
		icon: 'f-droid',
		desc: 'FOSS App Store'
	},
	{
		link: 'https://github.com/teambtcmap/btcmap-android/releases/latest',
		type: 'APK',
		icon: 'android',
		desc: 'Direct Download'
	},
	{
		link: 'https://apps.apple.com/us/app/bitlocal-btc-friendly-shops/id6447485666',
		type: 'iOS',
		icon: 'ios',
		desc: 'Walled Garden Option'
	}
]);

export const places: Writable<Place[]> = writable([]);
export const placesById = derived(places, ($places) => new Map($places.map((p) => [p.id, p])));
export const placesError = writable('');
export const placesSyncCount = writable(0);

// Progress tracking for places sync
export const placesLoadingStatus = writable<string>(''); // e.g. "Downloading places...", "Processing data..."
export const placesLoadingProgress = writable<number>(0); // 0-100 percentage

export const users: Writable<User[]> = writable([]);
export const userError = writable('');

export const events: Writable<Event[]> = writable([]);
export const eventError = writable('');

export const areas: Writable<Area[]> = writable([]);
export const areaError = writable('');

export const reports: Writable<Report[]> = writable([]);
export const reportError = writable('');

export const syncStatus: Writable<boolean> = writable();

export const mapUpdates = writable(false);

export const selectedMerchant: Writable<Place | null> = writable(null);

const excludedTaggers = [
	{ id: 9451067, note: 'b-jaz bot' },
	{ id: 18545877, note: 'BTC Map account' },
	{ id: 232801, note: 'CENTSOARER' },
	{ id: 19880430, note: 'Qerko bot' },
	{ id: 1778799, note: 'SomeoneElse_Revert - DWG' },
	{ id: 21749653, note: 'Kinso - Steak&Shake Revert' },
	{ id: 242345, note: 'confusedbuffalo bot' }
];

export const excludeLeader = readable(excludedTaggers.map(({ id }) => id));
export const boost: Writable<Boost> = writable();
export const resetBoost = writable(0);
export const boostHash: Writable<string> = writable();
export const lastUpdatedPlaceId: Writable<number | undefined> = writable();

export const showTags: Writable<OSMTags | undefined> = writable();
export const taggingIssues: Writable<Issue[] | undefined> = writable();
export const showMore = writable(false);

export const theme: Writable<Theme> = writable();



================================================
FILE: src/lib/types.ts
================================================
import type { GeoJSON, Polygon, MultiPolygon } from 'geojson';
import type leaflet from 'leaflet';
import type { DomEvent, FeatureGroup, LayerGroup, TileLayer, MaplibreGL } from 'leaflet';
import type { MobileNavIconName } from '$lib/icons/types';

// nominatim.openstreetmap.org API
// https://nominatim.org/release-docs/latest/api/Search

export interface NominatimResponse {
	place_id: number;
	licence: string;
	osm_type: string;
	osm_id: number;
	lat: string;
	lon: string;
	class: string;
	type: string;
	place_rank: number;
	importance: number;
	addresstype?: string;
	name?: string;
	display_name: string;
	boundingbox: [string, string, string, string];
	geojson?: Polygon | MultiPolygon; // Use GeoJSON types here
}

// BACKEND

export type Area = {
	id: string;
	tags: AreaTags;
	created_at: string;
	updated_at: string;
	deleted_at: string;
};

export type AreaTags = {
	type: AreaType;
	name: string;
	description?: string;
	continent: Continents;
	url_alias: string;
	geo_json: GeoJSON;
	['icon:square']: string; // countries don't have this tag yet
	organization?: string;
	language?: string;
	population?: string;
	area_km2?: number;
	['population:date']?: string;
	['population:year']?: number;
	['contact:website']?: string;
	['contact:email']?: string;
	['contact:nostr']?: string;
	['contact:twitter']?: string;
	['contact:meetup']?: string;
	['contact:eventbrite']?: string;
	['contact:telegram']?: string;
	['contact:discord']?: string;
	['contact:youtube']?: string;
	['contact:github']?: string;
	['contact:reddit']?: string;
	['contact:instagram']?: string;
	['contact:whatsapp']?: string;
	['contact:facebook']?: string;
	['contact:linkedin']?: string;
	['contact:rss']?: string;
	['contact:signal']?: string;
	['contact:simplex']?: string;
	['tips:lightning_address']?: string;
	['tips:url']?: string;
	sponsor?: boolean;
	['box:north']?: string;
	['box:east']?: string;
	['box:south']?: string;
	['box:west']?: string;
};

export type AreaType = 'community' | 'country' | 'trash';

export type Community = {
	id: string;
	tags: AreaTags & {
		type: 'community';
	};
	created_at: string;
	updated_at: string;
	deleted_at: string;
};

export type Continents =
	| 'africa'
	| 'asia'
	| 'europe'
	| 'north-america'
	| 'oceania'
	| 'south-america'
	| 'Africa'
	| 'Asia'
	| 'Europe'
	| 'North America'
	| 'Oceania'
	| 'South America';

export interface MerchantComment {
	id: number;
	text: string;
	created_at: string;
}

export interface MerchantPageData {
	id: string;
	name?: string;
	lat: number;
	lon: number;
	comments: MerchantComment[];
	// Additional fields from Element data
	icon?: string;
	address?: string;
	description?: string;
	note?: string;
	hours?: string;
	payment?: PayMerchant;
	boosted?: string;
	verified: string[];
	phone?: string;
	website?: string;
	email?: string;
	twitter?: string;
	instagram?: string;
	facebook?: string;
	thirdParty?: boolean;
	paymentMethod?: string;
	// OSM data for edit links and tag functionality
	osmType: string;
	osmId: number;
	osmTags: OSMTags;
	// Place data for BoostButton and other components
	placeData: Place;
}

export type RpcIssue = {
	element_osm_type: string;
	element_osm_id: number;
	element_name: string;
	issue_code: string;
};

export type IssueType =
	| 'date_format'
	| 'misspelled_tag'
	| 'missing_icon'
	| 'not_verified'
	| 'out_of_date'
	| 'out_of_date_soon';

export type Issue = {
	description: string;
	severity: number;
	type: IssueType;
};

export type IssueIcon =
	| 'fa-calendar-days'
	| 'fa-spell-check'
	| 'fa-icons'
	| 'fa-clipboard-question'
	| 'fa-hourglass-end'
	| 'fa-list-check'
	| 'fa-hourglass-half';

export type RpcGetMostActiveUsersItem = {
	id: number;
	name: string;
	image_url: string;
	tip_address: string;
	edits: number;
	created: number;
	updated: number;
	deleted: number;
};

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export type OSMTags = { [key: string]: any };

export type Event = {
	id: number;
	user_id: number;
	element_id: string;
	type: EventType;
	tags: object;
	created_at: string;
	updated_at: string;
	deleted_at: string;
};

export type EventType = 'create' | 'update' | 'delete';

export type Report = {
	id: number;
	area_id: string;
	date: string;
	tags: ReportTags;
	created_at: string;
	updated_at: string;
	deleted_at: string;
};

export type ReportTags = {
	total_elements: number;
	total_elements_onchain: number;
	total_elements_lightning: number;
	total_elements_lightning_contactless: number;
	total_atms: number;
	up_to_date_elements: number;
	up_to_date_percent: number;
	outdated_elements: number;
	legacy_elements: number;
	avg_verification_date: string;
};

export type Grade = 1 | 2 | 3 | 4 | 5;

export type User = {
	id: number;
	osm_json: {
		id: number;
		display_name: string;
		description: string;
		img: { href: string } | null;
		account_created: string;
	};
	tags: { ['supporter:expires']?: string };
	created_at: string;
	updated_at: string;
	deleted_at: string;
};

// FRONTEND

// leaflet

export type Leaflet = typeof leaflet;

export type DomEventType = typeof DomEvent;

export type MapGroups = { [key: string]: LayerGroup | FeatureGroup.SubGroup };

export type BaseMaps = {
	'OpenFreeMap Liberty': MaplibreGL;
	'OpenFreeMap Dark': MaplibreGL;
	'Carto Positron': MaplibreGL;
	'Carto Dark Matter': MaplibreGL;
	OpenStreetMap: TileLayer;
};

// map

export type Boost = { id: number; name: string; boost: string } | undefined;

// Search types for places search API
export interface SearchItem {
	type: 'element' | 'user' | 'area';
	id: number;
	name: string | null;
	address?: string;
	icon?: string;
}

export type PayMerchant = { type: string; url?: string; username?: string } | undefined;

// leaderboards

export type TaggerLeaderboard = {
	avatar: string;
	tagger: string;
	id: number;
	created: number;
	updated: number;
	deleted: number;
	total: number;
	tip: string;
};

export type ProfileLeaderboard = { id: number; total: number };

export interface LeaderboardArea extends Area {
	report: Report;
	grade: Grade;
}

// tagger

export enum BadgeType {
	Contribution = 'contribution',
	Achievement = 'achievement'
}

export type EarnedBadge = { title: string; icon: string; type: BadgeType };

export enum TipType {
	Address = 'address',
	Url = 'url'
}

// events

export interface ActivityEvent extends Event {
	location: string;
	merchantId: string;
	tagger?: User;
}

// misc

export interface GiteaLabel {
	id: number;
	name: string;
	color: string;
	description?: string;
}

export interface GiteaIssue {
	id: number;
	number: number;
	title: string;
	created_at: string;
	html_url: string;
	labels: GiteaLabel[];
	user: {
		login: string;
		avatar_url: string;
		html_url: string;
	};
	comments: number;
	assignees: {
		login: string;
		avatar_url: string;
		html_url: string;
	}[];
}

export type Tickets = GiteaIssue[] | 'error';

export type Theme = 'light' | 'dark';

export type DonationType = 'On-chain' | 'Lightning';

export type DropdownLink = {
	url: string;
	external?: boolean;
	icon: MobileNavIconName;
	title: string;
};

export type ChartHistory = '7D' | '1M' | '3M' | '6M' | 'YTD' | '1Y' | 'ALL';

export type AreaPageProps = {
	id: string;
	name: string;
	tickets: Tickets;
	issues: RpcIssue[];
};

// V4 API Types
export type Place = {
	id: number;
	lat: number;
	lon: number;
	icon: string;
	comments?: number;
	deleted_at?: string; // Only present when fetching with include_deleted=true
	updated_at?: string; // Only present when fetching with updated_since parameter
	boosted_until?: string; // Only present when location is boosted
	// Standard documented fields
	name?: string;
	address?: string;
	description?: string;
	opening_hours?: string;
	created_at?: string;
	verified_at?: string;
	osm_id?: string;
	osm_url?: string;
	phone?: string;
	website?: string;
	twitter?: string;
	facebook?: string;
	instagram?: string;
	line?: string;
	email?: string;
	// OSM contact fields
	'osm:contact:instagram'?: string;
	'osm:contact:twitter'?: string;
	'osm:contact:facebook'?: string;
	'osm:contact:phone'?: string;
	'osm:contact:website'?: string;
	'osm:contact:email'?: string;
	// Payment methods
	'payment:uri'?: string;
	'payment:pouch'?: string;
	'payment:coinos'?: string;
	// Payment capabilities
	'payment:lightning'?: 'yes';
	'payment:onchain'?: 'yes';
	'payment:lightning_contactless'?: 'yes';
	// Third party app requirement
	required_app_url?: string;
	// OSM payment method fields
	'osm:payment:onchain'?: 'yes';
	'osm:payment:lightning'?: 'yes';
	'osm:payment:lightning_contactless'?: 'yes';
	'osm:payment:bitcoin'?: 'yes';
	'osm:payment:uri'?: string;
	'osm:payment:coinos'?: string;
	'osm:payment:pouch'?: string;
	'osm:payment:lightning:requires_companion_app'?: 'yes';
	'osm:payment:lightning:companion_app_url'?: string;
	// OSM category fields
	'osm:amenity'?: string;
	'osm:category'?: string;
	// OSM tags that might be useful
	'osm:survey:date'?: string;
	'osm:check_date'?: string;
	'osm:check_date:currency:XBT'?: string;
	'osm:note'?: string;
};

// Worker progress tracking
export interface ProgressUpdate {
	percent: number;
	itemsParsed?: number;
	totalItems?: number;
	status: 'downloading' | 'parsing' | 'filtering' | 'complete';
}



================================================
FILE: src/lib/utils.ts
================================================
import { theme, areas } from '$lib/store';
import { areasSync } from '$lib/sync/areas';
import { PLACE_FIELD_SETS } from '$lib/api-fields';
import type { Continents, Grade, IssueIcon, Place } from '$lib/types';
import { toast } from '@zerodevx/svelte-toast';
import type { Chart } from 'chart.js';
import { get } from 'svelte/store';
import rewind from '@mapbox/geojson-rewind';
import { geoContains } from 'd3-geo';
import DOMPurify from 'dompurify';
import { parseISO } from 'date-fns/parseISO';
import { isThisYear } from 'date-fns/isThisYear';
import { isAfter } from 'date-fns/isAfter';
import { subDays } from 'date-fns/subDays';
import { format } from 'date-fns/format';
import { formatDistanceToNow } from 'date-fns/formatDistanceToNow';
import { isToday } from 'date-fns/isToday';

// Converts Material Design icon names to human-readable labels
export const humanizeIconName = (icon: string): string => {
	const specialCases: Record<string, string> = {
		content_cut: 'Barber',
		local_atm: 'ATM'
	};
	if (specialCases[icon]) return specialCases[icon];

	return icon
		.replace(/^local_/, '')
		.replace(/_/g, ' ')
		.replace(/\b\w/g, (c) => c.toUpperCase());
};

// Yields to main thread to prevent UI freezes during heavy operations (browser-only)
export function yieldToMain(): Promise<void> {
	// SSR guard - window not available during server rendering
	if (typeof window === 'undefined') return Promise.resolve();

	return new Promise((resolve) => {
		// Use scheduler.yield() if available (Chrome 115+), otherwise setTimeout
		if (
			'scheduler' in window &&
			'yield' in (window as { scheduler?: { yield?: () => Promise<void> } }).scheduler!
		) {
			(window as { scheduler: { yield: () => Promise<void> } }).scheduler.yield().then(resolve);
		} else {
			setTimeout(resolve, 0);
		}
	});
}

export const errToast = (m: string) => {
	toast.push(m, {
		theme: {
			'--toastBarBackground': '#DF3C3C'
		}
	});
};

export const warningToast = (m: string) => {
	toast.push(m, {
		theme: {
			'--toastBarBackground': '#FACA15'
		},
		duration: 10000
	});
};

export const successToast = (m: string) => {
	toast.push(m, {
		theme: {
			'--toastBarBackground': '#22C55E'
		}
	});
};

export function getRandomColor() {
	const letters = '0123456789ABCDEF';
	let color = '#';
	for (let i = 0; i < 6; i++) {
		color += letters[Math.floor(Math.random() * 16)];
	}
	return color;
}

export const detectTheme = () => {
	if (typeof window === 'undefined') return 'light'; // SSR fallback
	if (
		localStorage.theme === 'dark' ||
		(!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)
	) {
		return 'dark';
	} else {
		return 'light';
	}
};

export const updateChartThemes = (
	charts: Chart<'line' | 'bar', number[] | undefined, string>[]
) => {
	if (get(theme) === 'dark') {
		charts.forEach((chart) => {
			if (chart.options.scales?.x?.grid && chart.options.scales?.y?.grid) {
				chart.options.scales.x.grid.color = 'rgba(255, 255, 255, 0.15)';
				chart.options.scales.y.grid.color = 'rgba(255, 255, 255, 0.15)';
				chart.update();
			}
		});
	} else {
		charts.forEach((chart) => {
			if (chart.options.scales?.x?.grid && chart.options.scales?.y?.grid) {
				chart.options.scales.x.grid.color = 'rgba(0, 0, 0, 0.1)';
				chart.options.scales.y.grid.color = 'rgba(0, 0, 0, 0.1)';
				chart.update();
			}
		});
	}
};

export const formatElementID = (id: string) => {
	const elementIdSplit = id.split(':');
	const elementIdFormatted =
		elementIdSplit[0].charAt(0).toUpperCase() +
		elementIdSplit[0].slice(1, elementIdSplit[0].length) +
		' ' +
		elementIdSplit[1];

	return elementIdFormatted;
};

export const getGrade = (upToDatePercent: number): Grade => {
	switch (true) {
		case upToDatePercent >= 95:
			return 5;
		case upToDatePercent >= 75:
			return 4;
		case upToDatePercent >= 50:
			return 3;
		case upToDatePercent >= 25:
			return 2;
		case upToDatePercent >= 0:
		default:
			return 1;
	}
};

export const getIssueIcon = (issue_code: string): IssueIcon => {
	if (issue_code.startsWith('invalid_tag_value')) {
		return 'fa-calendar-days';
	}
	if (issue_code.startsWith('misspelled_tag_name')) {
		return 'fa-spell-check';
	}
	if (issue_code == 'missing_icon') {
		return 'fa-icons';
	}
	if (issue_code == 'not_verified') {
		return 'fa-clipboard-question';
	}
	if (issue_code == 'outdated') {
		return 'fa-hourglass-end';
	}
	if (issue_code == 'outdated_soon') {
		return 'fa-hourglass-half';
	}
	return 'fa-list-check';
};

export const getIssueHelpLink = (issue_code: string) => {
	if (issue_code == 'outdated' || issue_code == 'outdated_soon' || issue_code == 'not_verified') {
		return 'https://gitea.btcmap.org/teambtcmap/btcmap-general/wiki/Verifying-Existing-Merchants';
	}
	if (issue_code.startsWith('invalid_tag_value')) {
		return 'https://gitea.btcmap.org/teambtcmap/btcmap-general/wiki/Tagging-Merchants#tagging-guidance';
	}
	if (issue_code.startsWith('misspelled_tag_name')) {
		return 'https://gitea.btcmap.org/teambtcmap/btcmap-general/wiki/Tagging-Merchants#tagging-guidance';
	}
	return undefined;
};

export const isEven = (number: number) => {
	return number % 2 === 0;
};

/* eslint-disable @typescript-eslint/no-explicit-any */
export function debounce(func: (e?: any) => void, timeout = 500) {
	let timer: ReturnType<typeof setTimeout>;
	// @ts-expect-error: introducing typecheck, this was failing, so ingoring for now
	const debouncedFn = (...args) => {
		clearTimeout(timer);
		timer = setTimeout(() => {
			// @ts-expect-error: introducing typecheck, this was failing, so ingoring for now
			func.apply(this, args);
		}, timeout);
	};
	// Add cleanup method to cancel pending execution
	debouncedFn.cancel = () => {
		clearTimeout(timer);
	};
	return debouncedFn;
}
/* eslint-enable @typescript-eslint/no-explicit-any */

export const validateContinents = (continent: Continents) =>
	[
		'africa',
		'asia',
		'europe',
		'north-america',
		'oceania',
		'south-america',
		'Africa',
		'Asia',
		'Europe',
		'North America',
		'Oceania',
		'South America'
	].includes(continent);

export const isBoosted = (item: Place | undefined | null) => {
	if (!item) return false;
	return item.boosted_until && Date.parse(item.boosted_until) > Date.now();
};

/**
 * Normalizes social media URLs by ensuring they start with https://
 * If the URL doesn't start with http, prepends the platform's base URL
 */
const normalizeSocialUrl = (url: string, platform: string): string => {
	if (url.startsWith('http')) {
		return url;
	}
	const platformUrls: Record<string, string> = {
		instagram: 'https://instagram.com/',
		twitter: 'https://twitter.com/',
		facebook: 'https://facebook.com/'
	};
	return platformUrls[platform] + url;
};

export async function getAreaIdsByCoordinates(lat: number, long: number): Promise<string[]> {
	console.debug('Checking areas with coordinates:', { lat, long });
	await areasSync(); // Get latest areas
	const allAreas = get(areas);
	console.debug('Total areas to check:', allAreas.length);

	return allAreas
		.filter((area) => {
			if (!area.tags.geo_json) {
				console.warn('Area missing geo_json:', area.id);
				return false;
			}
			const rewoundPoly = rewind(area.tags.geo_json, true);
			const contains = geoContains(rewoundPoly, [long, lat]);
			if (contains) {
				console.debug('Found matching area:', area.id);
			}
			return contains;
		})
		.map((area) => area.id);
}

export const formatOpeningHours = (str: string): string => {
	const html = str
		.split(/;\s*/)
		.map((part) => `<span>${part.trim()}</span>`)
		.join('');

	return DOMPurify.sanitize(html, { ALLOWED_TAGS: ['span'] });
};

const RECENT_DATE_THRESHOLD_DAYS = 30;

const isValidDate = (date: Date): boolean => !Number.isNaN(date.getTime());

const parseDateSafely = (isoString: string): Date | null => {
	try {
		const date = parseISO(isoString);
		return isValidDate(date) ? date : null;
	} catch {
		return null;
	}
};

const isRecentDate = (date: Date, thresholdDays: number = RECENT_DATE_THRESHOLD_DAYS): boolean => {
	return isAfter(date, subDays(new Date(), thresholdDays));
};

export const formatVerifiedHuman = (isoDateString?: string): string => {
	if (!isoDateString) return '';

	const parsedDate = parseDateSafely(isoDateString);
	if (!parsedDate) return isoDateString;

	// Today â†’ "Today"
	if (isToday(parsedDate)) {
		return 'Today';
	}

	// Recent dates (â‰¤30 days) â†’ "3 days ago"
	if (isRecentDate(parsedDate)) {
		return formatDistanceToNow(parsedDate, { addSuffix: true });
	}

	// Same year â†’ "15 October"
	if (isThisYear(parsedDate)) {
		return format(parsedDate, 'd MMMM');
	}

	// Different year â†’ "15 October 2023"
	return format(parsedDate, 'd MMMM yyyy');
};

// Cache for enhanced place data to avoid repeated API calls
const enhancedPlacesCache = new Map<string, Place>();

/**
 * Fetches enhanced place data (name, address, etc.) for a specific place ID
 * Uses caching to avoid repeated API calls for the same place
 */
export async function fetchEnhancedPlace(placeId: string): Promise<Place | null> {
	// Check cache first
	if (enhancedPlacesCache.has(placeId)) {
		return enhancedPlacesCache.get(placeId)!;
	}

	try {
		const response = await fetch(
			`https://api.btcmap.org/v4/places/${placeId}?fields=${PLACE_FIELD_SETS.COMPLETE_PLACE.join(',')}`
		);

		if (!response.ok) {
			console.warn(`Failed to fetch enhanced data for place ${placeId}:`, response.status);
			return null;
		}

		const basePlace: Place = await response.json();
		const enhancedPlace: Place = { ...basePlace };

		// Map osm:contact fields to official fields as fallback
		if (!enhancedPlace.instagram && enhancedPlace['osm:contact:instagram']) {
			enhancedPlace.instagram = normalizeSocialUrl(
				enhancedPlace['osm:contact:instagram'],
				'instagram'
			);
		}
		if (!enhancedPlace.twitter && enhancedPlace['osm:contact:twitter']) {
			enhancedPlace.twitter = normalizeSocialUrl(enhancedPlace['osm:contact:twitter'], 'twitter');
		}
		if (!enhancedPlace.facebook && enhancedPlace['osm:contact:facebook']) {
			enhancedPlace.facebook = normalizeSocialUrl(
				enhancedPlace['osm:contact:facebook'],
				'facebook'
			);
		}

		// v4 Places API provides all necessary contact information through osm:contact:* fields
		// No additional API calls needed

		// Cache the result
		enhancedPlacesCache.set(placeId, enhancedPlace);

		return enhancedPlace;
	} catch (error) {
		console.error(`Error fetching enhanced place data for ${placeId}:`, error);
		return null;
	}
}



================================================
FILE: src/lib/icons/IconApps.svelte
================================================
<script lang="ts">
	import type { AppIconName } from './types';
	import android from './apps/android.svg?raw';
	import fdroid from './apps/f-droid.svg?raw';
	import ios from './apps/ios.svg?raw';
	import play from './apps/play.svg?raw';
	import web from './apps/web.svg?raw';

	const icons: Record<AppIconName, string> = {
		android,
		'f-droid': fdroid,
		ios,
		play,
		web
	};

	export let icon: AppIconName;
	export let w = '24';
	export let h = '24';
	let className: string | undefined = undefined;
	export { className as class };
</script>

<span
	class={className}
	style="display: block; width: {w}px; height: {h}px;"
	role="img"
	aria-hidden="true"
>
	<!-- eslint-disable-next-line svelte/no-at-html-tags - SVG from trusted local files -->
	{@html icons[icon]}
</span>

<style>
	span :global(svg) {
		width: 100%;
		height: 100%;
	}
</style>



================================================
FILE: src/lib/icons/IconMobileNav.svelte
================================================
<script lang="ts">
	import type { MobileNavIconName } from './types';
	import activity from './mobile-nav/activity.svg?raw';
	import add from './mobile-nav/add.svg?raw';
	import api from './mobile-nav/api.svg?raw';
	import apps from './mobile-nav/apps.svg?raw';
	import areasHighlight from './mobile-nav/areas-highlight.svg?raw';
	import areas from './mobile-nav/areas.svg?raw';
	import bars from './mobile-nav/bars.svg?raw';
	import close from './mobile-nav/close.svg?raw';
	import communities from './mobile-nav/communities.svg?raw';
	import contributeHighlight from './mobile-nav/contribute-highlight.svg?raw';
	import contribute from './mobile-nav/contribute.svg?raw';
	import countries from './mobile-nav/countries.svg?raw';
	import dash from './mobile-nav/dash.svg?raw';
	import directory from './mobile-nav/directory.svg?raw';
	import general from './mobile-nav/general.svg?raw';
	import issue from './mobile-nav/issue.svg?raw';
	import leader from './mobile-nav/leader.svg?raw';
	import mapHighlight from './mobile-nav/map-highlight.svg?raw';
	import map from './mobile-nav/map.svg?raw';
	import statsHighlight from './mobile-nav/stats-highlight.svg?raw';
	import stats from './mobile-nav/stats.svg?raw';
	import support from './mobile-nav/support.svg?raw';
	import ticket from './mobile-nav/ticket.svg?raw';
	import verify from './mobile-nav/verify.svg?raw';
	import wikiHighlight from './mobile-nav/wiki-highlight.svg?raw';
	import wiki from './mobile-nav/wiki.svg?raw';

	const icons: Record<MobileNavIconName, string> = {
		activity,
		add,
		api,
		apps,
		'areas-highlight': areasHighlight,
		areas,
		bars,
		close,
		communities,
		'contribute-highlight': contributeHighlight,
		contribute,
		countries,
		dash,
		directory,
		general,
		issue,
		leader,
		'map-highlight': mapHighlight,
		map,
		'stats-highlight': statsHighlight,
		stats,
		support,
		ticket,
		verify,
		'wiki-highlight': wikiHighlight,
		wiki
	};

	export let icon: MobileNavIconName;
	export let w = '24';
	export let h = '24';
	let className: string | undefined = undefined;
	export { className as class };
</script>

<span
	class={className}
	style="display: block; width: {w}px; height: {h}px;"
	role="img"
	aria-hidden="true"
>
	<!-- eslint-disable-next-line svelte/no-at-html-tags - SVG from trusted local files -->
	{@html icons[icon]}
</span>

<style>
	span :global(svg) {
		width: 100%;
		height: 100%;
	}
</style>



================================================
FILE: src/lib/icons/IconSocials.svelte
================================================
<script lang="ts">
	import type { SocialIconName } from './types';
	import amboss from './socials/amboss.svg?raw';
	import discord from './socials/discord.svg?raw';
	import email from './socials/email.svg?raw';
	import facebook from './socials/facebook.svg?raw';
	import github from './socials/github.svg?raw';
	import instagram from './socials/instagram.svg?raw';
	import linkedin from './socials/linkedin.svg?raw';
	import matrix from './socials/matrix.svg?raw';
	import nostr from './socials/nostr.svg?raw';
	import reddit from './socials/reddit.svg?raw';
	import signal from './socials/signal.svg?raw';
	import telegram from './socials/telegram.svg?raw';
	import website from './socials/website.svg?raw';
	import whatsapp from './socials/whatsapp.svg?raw';
	import x from './socials/x.svg?raw';
	import youtube from './socials/youtube.svg?raw';

	const icons: Record<SocialIconName, string> = {
		amboss,
		discord,
		email,
		facebook,
		github,
		instagram,
		linkedin,
		matrix,
		nostr,
		reddit,
		signal,
		telegram,
		website,
		whatsapp,
		x,
		youtube
	};

	export let icon: SocialIconName;
	export let w = '24';
	export let h = '24';
	let className: string | undefined = undefined;
	export { className as class };
</script>

<span
	class={className}
	style="display: block; width: {w}px; height: {h}px;"
	role="img"
	aria-hidden="true"
>
	<!-- eslint-disable-next-line svelte/no-at-html-tags - SVG from trusted local files -->
	{@html icons[icon]}
</span>

<style>
	span :global(svg) {
		width: 100%;
		height: 100%;
	}
</style>



================================================
FILE: src/lib/icons/types.ts
================================================
export type SocialIconName =
	| 'amboss'
	| 'discord'
	| 'email'
	| 'facebook'
	| 'github'
	| 'instagram'
	| 'linkedin'
	| 'matrix'
	| 'nostr'
	| 'reddit'
	| 'signal'
	| 'telegram'
	| 'website'
	| 'whatsapp'
	| 'x'
	| 'youtube';

export type AppIconName = 'android' | 'f-droid' | 'ios' | 'play' | 'web';

export type MobileNavIconName =
	| 'activity'
	| 'add'
	| 'api'
	| 'apps'
	| 'areas-highlight'
	| 'areas'
	| 'bars'
	| 'close'
	| 'communities'
	| 'contribute-highlight'
	| 'contribute'
	| 'countries'
	| 'dash'
	| 'directory'
	| 'general'
	| 'issue'
	| 'leader'
	| 'map-highlight'
	| 'map'
	| 'stats-highlight'
	| 'stats'
	| 'support'
	| 'ticket'
	| 'verify'
	| 'wiki-highlight'
	| 'wiki';



================================================
FILE: src/lib/map/imports.ts
================================================
// Dynamic imports for browser-only map dependencies
// These packages access window/document and must be loaded client-side only
export async function loadMapDependencies() {
	// Leaflet must load first - it sets window.L
	const [leaflet, DomEvent] = await Promise.all([
		import('leaflet'),
		import('leaflet/src/dom/DomEvent')
	]);

	// Plugins depend on window.L - load after leaflet
	// Most imports are for side effects only (setting up window.L plugins)
	const [_maplibreGL, _maplibreLeaflet, locateControlModule, _markerCluster, _subgroup] =
		await Promise.all([
			import('maplibre-gl'),
			import('@maplibre/maplibre-gl-leaflet'),
			import('leaflet.locatecontrol'),
			import('leaflet.markercluster'),
			import('leaflet.featuregroup.subgroup')
		]);

	const { LocateControl } = locateControlModule;

	return { leaflet, DomEvent, LocateControl };
}



================================================
FILE: src/lib/map/markers.ts
================================================
import type { LatLngBounds, Marker } from 'leaflet';
import type { FeatureGroup } from 'leaflet';

export type LoadedMarkers = Record<string, Marker>;

// Clear selection styling from a marker
export const clearMarkerSelection = (loadedMarkers: LoadedMarkers, markerId: number): void => {
	const marker = loadedMarkers[markerId.toString()];
	if (!marker) return;

	const markerIcon = marker.getElement();
	if (markerIcon) {
		markerIcon.classList.remove('selected-marker', 'selected-marker-boosted');
	}
};

// Add selection styling to a marker
export const highlightMarker = (loadedMarkers: LoadedMarkers, markerId: number): void => {
	const marker = loadedMarkers[markerId.toString()];
	if (!marker) return;

	const markerIcon = marker.getElement();
	if (markerIcon) {
		const isBoosted = markerIcon.classList.contains('boosted-icon');
		markerIcon.classList.add(isBoosted ? 'selected-marker-boosted' : 'selected-marker');
	}
};

export type CleanupMarkersOptions = {
	loadedMarkers: LoadedMarkers;
	upToDateLayer: FeatureGroup.SubGroup;
	boostedLayer: FeatureGroup;
	boostedLayerMarkerIds: Set<string>;
	bounds: LatLngBounds;
};

// Remove markers that are no longer in viewport
export const cleanupOutOfBoundsMarkers = ({
	loadedMarkers,
	upToDateLayer,
	boostedLayer,
	boostedLayerMarkerIds,
	bounds
}: CleanupMarkersOptions): string[] => {
	const markersToRemove: string[] = [];

	Object.entries(loadedMarkers).forEach(([placeId, marker]) => {
		const markerLatLng = marker.getLatLng();
		if (!bounds.contains(markerLatLng)) {
			if (boostedLayerMarkerIds.has(placeId)) {
				boostedLayer.removeLayer(marker);
				boostedLayerMarkerIds.delete(placeId);
			} else {
				upToDateLayer.removeLayer(marker);
			}
			markersToRemove.push(placeId);
		}
	});

	markersToRemove.forEach((placeId) => {
		delete loadedMarkers[placeId];
	});

	if (markersToRemove.length > 0) {
		console.info(`Cleaned up ${markersToRemove.length} out-of-bounds markers`);
	}

	return markersToRemove;
};



================================================
FILE: src/lib/map/setup.ts
================================================
import type { Map, LatLng, DivIcon } from 'leaflet';

import { replaceState } from '$app/navigation';
import axios from 'axios';
import axiosRetry from 'axios-retry';

import Icon from '$components/Icon.svelte';
import { trackEvent } from '$lib/analytics';
import { PLACE_FIELD_SETS, buildFieldsParam } from '$lib/api-fields';
import { selectedMerchant } from '$lib/store';
import type { DomEventType, Leaflet, Place } from '$lib/types';
import { detectTheme, errToast, humanizeIconName } from '$lib/utils';

axiosRetry(axios, { retries: 3, retryDelay: axiosRetry.exponentialDelay });

export const updateMapHash = (zoom: number, center: LatLng): void => {
	// Preserve any existing query parameters (like &merchant=123)
	const currentHash = window.location.hash.substring(1);
	const ampIndex = currentHash.indexOf('&');
	const existingParams = ampIndex !== -1 ? currentHash.substring(ampIndex) : '';

	const newHash = `#${zoom}/${center.lat.toFixed(5)}/${center.lng.toFixed(5)}${existingParams}`;
	// Use SvelteKit's replaceState to preserve current pathname while updating hash
	const url = window.location.pathname + newHash;
	// eslint-disable-next-line svelte/no-navigation-without-resolve
	replaceState(url, {});
};

export const layers = (leaflet: Leaflet, map: Map) => {
	const theme = detectTheme();

	const osm = leaflet.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
		noWrap: true,
		maxZoom: 19
	});

	const openFreeMapLiberty = window.L.maplibreGL({
		style: 'https://tiles.openfreemap.org/styles/liberty'
	});

	const openFreeMapDark = window.L.maplibreGL({
		style: 'https://static.btcmap.org/map-styles/dark.json'
	});

	const cartoPositron = window.L.maplibreGL({
		style: 'https://basemaps.cartocdn.com/gl/positron-gl-style/style.json'
	});

	const cartoDarkMatter = window.L.maplibreGL({
		style: 'https://basemaps.cartocdn.com/gl/dark-matter-gl-style/style.json'
	});

	let activeLayer;
	if (theme === 'dark') {
		cartoDarkMatter.addTo(map);
		activeLayer = cartoDarkMatter;
	} else {
		openFreeMapLiberty.addTo(map);
		activeLayer = openFreeMapLiberty;
	}

	const baseMaps = {
		'OpenFreeMap Liberty': openFreeMapLiberty,
		'OpenFreeMap Dark': openFreeMapDark,
		'Carto Positron': cartoPositron,
		'Carto Dark Matter': cartoDarkMatter,
		OpenStreetMap: osm
	};

	return { baseMaps, activeLayer };
};

export const attribution = (L: Leaflet, map: Map) => {
	// Use Leaflet's default attribution control
	L.control.attribution({ position: 'bottomleft', prefix: false }).addTo(map);
};

export const support = () => {
	// Add "Support BTC Map" link to right attribution
	const supportAttribution: HTMLDivElement | null = document.querySelector(
		'.leaflet-bottom.leaflet-right > .leaflet-control-attribution'
	);

	if (!supportAttribution) return;

	supportAttribution.innerHTML =
		'<a href="/support-us" title="Support with sats">Support</a> BTC Map';
};

export const scaleBars = (L: Leaflet, map: Map) => {
	// Use Leaflet's default scale control
	L.control.scale({ position: 'bottomleft' }).addTo(map);
};

export const changeDefaultIcons = (
	_layers: boolean,
	L: Leaflet,
	mapElement: HTMLDivElement,
	DomEvent: DomEventType
) => {
	// Add analytics tracking to zoom controls (keep Leaflet's default +/- text)
	const zoomIn: HTMLAnchorElement | null = document.querySelector('.leaflet-control-zoom-in');
	if (zoomIn) {
		zoomIn.addEventListener('click', () => {
			trackEvent('zoom_in_click');
		});
	}

	const zoomOut: HTMLAnchorElement | null = document.querySelector('.leaflet-control-zoom-out');
	if (zoomOut) {
		zoomOut.addEventListener('click', () => {
			trackEvent('zoom_out_click');
		});
	}

	// Add fullscreen button (custom control, not native to Leaflet)
	const leafletBar: HTMLDivElement | null = document.querySelector('.leaflet-bar');
	const fullscreenButton = L.DomUtil.create('a');
	fullscreenButton.classList.add('leaflet-control-full-screen');
	fullscreenButton.title = 'Full screen';
	fullscreenButton.role = 'button';
	fullscreenButton.ariaLabel = 'Full screen';
	fullscreenButton.ariaDisabled = 'false';
	fullscreenButton.innerHTML = `<img src='/icons/expand.svg' alt='fullscreen' class='inline' style='width: 16px; height: 16px;'/>`;
	fullscreenButton.onclick = function toggleFullscreen() {
		trackEvent('fullscreen_click');
		if (!document.fullscreenElement) {
			mapElement.requestFullscreen().catch((err) => {
				errToast(`Error attempting to enable fullscreen mode: ${err.message} (${err.name})`);
			});
		} else {
			document.exitFullscreen();
		}
	};

	leafletBar?.append(fullscreenButton);

	if (DomEvent) {
		DomEvent.disableClickPropagation(fullscreenButton);
	}
};

export const geolocate = (
	_L: Leaflet,
	map: Map,
	LocateControl: typeof import('leaflet.locatecontrol').LocateControl
) => {
	// Use plugin defaults, just add analytics tracking
	new LocateControl({ position: 'topleft' }).addTo(map);

	const locateButton: HTMLAnchorElement | null = document.querySelector(
		'.leaflet-bar-part.leaflet-bar-part-single'
	);
	if (locateButton) {
		// Replace default arrow icon with custom crosshairs icon
		locateButton.innerHTML = `<img src='/icons/locate.svg' alt='locate' style='width: 16px; height: 16px;'/>`;

		locateButton.addEventListener('click', () => {
			trackEvent('locate_click');
		});
	}
};

export const homeMarkerButtons = (
	L: Leaflet,
	map: Map,
	DomEvent: DomEventType,
	mainMap?: boolean
) => {
	const addControlDiv = L.DomUtil.create('div');

	const customControls = L.Control.extend({
		options: {
			position: 'topleft'
		},
		onAdd: () => {
			addControlDiv.classList.add('leaflet-control-site-links', 'leaflet-bar', 'leaflet-control');

			// Home button
			const addHomeButton = L.DomUtil.create('a');
			addHomeButton.href = '/';
			addHomeButton.title = 'Go to home page';
			addHomeButton.role = 'button';
			addHomeButton.ariaLabel = 'Go to home page';
			addHomeButton.innerHTML = `<img src='/icons/home.svg' alt='home' style='width: 16px; height: 16px;'/>`;
			addHomeButton.onclick = () => {
				trackEvent('home_button_click');
			};
			addControlDiv.append(addHomeButton);

			if (mainMap) {
				// Add location button
				const addLocationButton = L.DomUtil.create('a');
				addLocationButton.href = '/add-location';
				addLocationButton.title = 'Add location';
				addLocationButton.role = 'button';
				addLocationButton.ariaLabel = 'Add location';
				addLocationButton.innerHTML = `<img src='/icons/marker.svg' alt='marker' style='width: 16px; height: 16px;'/>`;
				addLocationButton.onclick = () => {
					trackEvent('add_location_click');
				};
				addControlDiv.append(addLocationButton);

				// Community map button
				const communityMapButton = L.DomUtil.create('a');
				communityMapButton.href = '/communities/map';
				communityMapButton.title = 'Community map';
				communityMapButton.role = 'button';
				communityMapButton.ariaLabel = 'Community map';
				communityMapButton.innerHTML = `<img src='/icons/group.svg' alt='group' style='width: 16px; height: 16px;'/>`;
				communityMapButton.onclick = () => {
					trackEvent('community_map_click');
				};
				addControlDiv.append(communityMapButton);
			} else {
				// Merchant map button (for community map page)
				const merchantMapButton = L.DomUtil.create('a');
				merchantMapButton.href = '/map';
				merchantMapButton.title = 'Merchant map';
				merchantMapButton.role = 'button';
				merchantMapButton.ariaLabel = 'Merchant map';
				merchantMapButton.innerHTML = `<img src='/icons/shopping.svg' alt='shopping' style='width: 16px; height: 16px;'/>`;
				addControlDiv.append(merchantMapButton);
			}

			return addControlDiv;
		}
	});

	map.addControl(new customControls());
	DomEvent.disableClickPropagation(addControlDiv);
};

export const dataRefresh = (L: Leaflet, map: Map, DomEvent: DomEventType) => {
	const dataRefreshButton = L.DomUtil.create('a');

	const customDataRefreshButton = L.Control.extend({
		options: {
			position: 'topleft'
		},
		onAdd: () => {
			const dataRefreshDiv = L.DomUtil.create('div');
			dataRefreshDiv.classList.add('leaflet-bar', 'leaflet-control', 'data-refresh-div');
			dataRefreshDiv.style.display = 'none';

			dataRefreshButton.classList.add('leaflet-control-data-refresh');
			dataRefreshButton.title = 'Data refresh available';
			dataRefreshButton.role = 'button';
			dataRefreshButton.ariaLabel = 'Data refresh available';
			dataRefreshButton.ariaDisabled = 'false';
			dataRefreshButton.innerHTML = `<img src='/icons/refresh.svg' alt='refresh' style='width: 16px; height: 16px;'/>`;
			dataRefreshButton.onclick = () => {
				trackEvent('data_refresh_click');
				location.reload();
			};

			dataRefreshDiv.append(dataRefreshButton);

			return dataRefreshDiv;
		}
	});

	map.addControl(new customDataRefreshButton());
	DomEvent.disableClickPropagation(dataRefreshButton);
};

export const calcVerifiedDate = () => {
	const verifiedDate = new Date();
	const previousYear = verifiedDate.getFullYear() - 1;
	return verifiedDate.setFullYear(previousYear);
};

export const generateIcon = (L: Leaflet, icon: string, boosted: boolean, commentsCount: number) => {
	const className = boosted ? 'animate-wiggle' : '';
	const iconTmp = icon !== 'question_mark' ? icon : 'currency_bitcoin';

	const iconContainer = document.createElement('div');
	iconContainer.className = 'icon-container relative flex items-center justify-center';

	const iconElement = document.createElement('div');
	new Icon({
		target: iconElement,
		props: {
			w: '20',
			h: '20',
			class: `${className} mt-[5.75px] text-white`,
			icon: iconTmp,
			type: 'material'
		}
	});
	iconContainer.appendChild(iconElement);

	if (commentsCount > 0) {
		const commentsCountSpan = document.createElement('span');
		commentsCountSpan.textContent = `${commentsCount}`;
		commentsCountSpan.className =
			'absolute top-1 right-1 transform translate-x-1/2 -translate-y-1/2 ' +
			'bg-green-600 text-white text-[10px] font-bold ' +
			'rounded-full w-4 h-4 flex items-center justify-center';
		iconContainer.appendChild(commentsCountSpan);
	}

	// Accessible label for screen readers
	const accessibleLabel = document.createElement('span');
	accessibleLabel.className = 'sr-only';
	accessibleLabel.textContent = humanizeIconName(icon);
	iconContainer.appendChild(accessibleLabel);

	return L.divIcon({
		className: boosted ? 'boosted-icon' : 'div-icon',
		iconSize: [32, 43],
		iconAnchor: [16, 43],
		popupAnchor: [0, -43],
		html: iconContainer
	});
};

export const verifiedArr = (place: Place) => {
	const verified = [];

	if (place['osm:survey:date'] && Date.parse(place['osm:survey:date'])) {
		verified.push(place['osm:survey:date']);
	}

	if (place['osm:check_date'] && Date.parse(place['osm:check_date'])) {
		verified.push(place['osm:check_date']);
	}

	if (place['osm:check_date:currency:XBT'] && Date.parse(place['osm:check_date:currency:XBT'])) {
		verified.push(place['osm:check_date:currency:XBT']);
	}

	if (verified.length > 1) {
		verified.sort((a, b) => Date.parse(b) - Date.parse(a));
	}

	return verified;
};

export const generateMarker = ({
	lat,
	long,
	icon,
	placeId,
	// element,
	// payment,
	leaflet: L,
	onMarkerClick
	// verifiedDate,
	// verify,
	// boosted
	// issues
}: {
	lat: number;
	long: number;
	icon: DivIcon;
	placeId: number | string;
	leaflet: Leaflet;
	onMarkerClick?: (placeId: number | string) => void;
	// verifiedDate: number;
	verify: boolean;
	boosted?: boolean;
	// issues?: Issue[];
}) => {
	const marker = L.marker([lat, long], { icon });

	marker.on('click', async () => {
		if (onMarkerClick) {
			onMarkerClick(placeId);
		} else {
			// Fallback to old store-based behavior
			try {
				const response = await axios.get(
					`https://api.btcmap.org/v4/places/${placeId}?fields=${buildFieldsParam(PLACE_FIELD_SETS.COMPLETE_PLACE)}`
				);
				const placeDetails = response.data;
				selectedMerchant.set(placeDetails);
			} catch (error) {
				console.error('Error fetching place details:', error);
				errToast('Error loading merchant details. Please try again.');
			}
		}
	});

	return marker;
};



================================================
FILE: src/lib/map/viewport.test.ts
================================================
import { describe, expect, it } from 'vitest';
import {
	calculateRadiusKm,
	getZoomBehavior,
	getBufferedBounds,
	getVisiblePlaces
} from './viewport';
import type { Place } from '$lib/types';

describe('getZoomBehavior', () => {
	it('returns "none" for zoom levels below 11', () => {
		expect(getZoomBehavior(1)).toBe('none');
		expect(getZoomBehavior(5)).toBe('none');
		expect(getZoomBehavior(10)).toBe('none');
	});

	it('returns "api-with-limit" for zoom levels 11-14', () => {
		expect(getZoomBehavior(11)).toBe('api-with-limit');
		expect(getZoomBehavior(12)).toBe('api-with-limit');
		expect(getZoomBehavior(14)).toBe('api-with-limit');
	});

	it('returns "local-markers" for zoom levels 15+', () => {
		expect(getZoomBehavior(15)).toBe('local-markers');
		expect(getZoomBehavior(16)).toBe('local-markers');
		expect(getZoomBehavior(17)).toBe('local-markers');
		expect(getZoomBehavior(18)).toBe('local-markers');
		expect(getZoomBehavior(20)).toBe('local-markers');
	});
});

describe('calculateRadiusKm', () => {
	// Mock LatLngBounds object
	const createMockBounds = (
		centerLat: number,
		centerLng: number,
		northEastLat: number,
		northEastLng: number
	) => ({
		getCenter: () => ({ lat: centerLat, lng: centerLng }),
		getNorthEast: () => ({ lat: northEastLat, lng: northEastLng })
	});

	it('calculates radius for a small area', () => {
		// Small area around a point (approx 1km span)
		const bounds = createMockBounds(51.5, -0.1, 51.505, -0.095);
		const radius = calculateRadiusKm(bounds as Parameters<typeof calculateRadiusKm>[0]);

		// Should be a small radius (less than 1km)
		expect(radius).toBeGreaterThan(0);
		expect(radius).toBeLessThan(2);
	});

	it('calculates radius for a larger area', () => {
		// Larger area (approx 10km span)
		const bounds = createMockBounds(51.5, -0.1, 51.55, -0.05);
		const radius = calculateRadiusKm(bounds as Parameters<typeof calculateRadiusKm>[0]);

		// Should be a larger radius
		expect(radius).toBeGreaterThan(3);
		expect(radius).toBeLessThan(10);
	});

	it('includes 10% buffer in the calculation', () => {
		// The function multiplies by 1.1 for a buffer
		const bounds = createMockBounds(0, 0, 1, 1);
		const radius = calculateRadiusKm(bounds as Parameters<typeof calculateRadiusKm>[0]);

		// Without buffer would be ~157km, with 10% buffer should be ~173km
		expect(radius).toBeGreaterThan(170);
		expect(radius).toBeLessThan(180);
	});

	it('handles equator coordinates', () => {
		const bounds = createMockBounds(0, 0, 0.01, 0.01);
		const radius = calculateRadiusKm(bounds as Parameters<typeof calculateRadiusKm>[0]);

		// Should return a positive radius
		expect(radius).toBeGreaterThan(0);
	});

	it('handles high latitude coordinates', () => {
		// Near the poles (high latitude)
		const bounds = createMockBounds(70, 10, 70.01, 10.01);
		const radius = calculateRadiusKm(bounds as Parameters<typeof calculateRadiusKm>[0]);

		// Should still return a positive radius
		expect(radius).toBeGreaterThan(0);
	});
});

describe('getBufferedBounds', () => {
	// Mock leaflet with latLngBounds factory
	const createMockLeaflet = () => ({
		latLngBounds: (coords: [[number, number], [number, number]]) => ({
			_southWest: { lat: coords[0][0], lng: coords[0][1] },
			_northEast: { lat: coords[1][0], lng: coords[1][1] },
			getSouth: () => coords[0][0],
			getWest: () => coords[0][1],
			getNorth: () => coords[1][0],
			getEast: () => coords[1][1],
			contains: (point: [number, number]) => {
				const [lat, lng] = point;
				return (
					lat >= coords[0][0] && lat <= coords[1][0] && lng >= coords[0][1] && lng <= coords[1][1]
				);
			}
		})
	});

	const createMockBounds = (south: number, west: number, north: number, east: number) => ({
		getSouth: () => south,
		getWest: () => west,
		getNorth: () => north,
		getEast: () => east
	});

	it('expands bounds by buffer percentage', () => {
		const leaflet = createMockLeaflet();
		const bounds = createMockBounds(10, 20, 12, 22); // 2x2 degree box

		const buffered = getBufferedBounds(
			leaflet as unknown as Parameters<typeof getBufferedBounds>[0],
			bounds as unknown as Parameters<typeof getBufferedBounds>[1],
			0.2 // 20% buffer
		);

		// Original span is 2 degrees, 20% buffer = 0.4 degrees on each side
		expect(buffered.getSouth()).toBe(9.6); // 10 - 0.4
		expect(buffered.getNorth()).toBe(12.4); // 12 + 0.4
		expect(buffered.getWest()).toBe(19.6); // 20 - 0.4
		expect(buffered.getEast()).toBe(22.4); // 22 + 0.4
	});

	it('handles zero buffer', () => {
		const leaflet = createMockLeaflet();
		const bounds = createMockBounds(10, 20, 12, 22);

		const buffered = getBufferedBounds(
			leaflet as unknown as Parameters<typeof getBufferedBounds>[0],
			bounds as unknown as Parameters<typeof getBufferedBounds>[1],
			0
		);

		expect(buffered.getSouth()).toBe(10);
		expect(buffered.getNorth()).toBe(12);
	});
});

describe('getVisiblePlaces', () => {
	const createMockLeaflet = () => ({
		latLngBounds: (coords: [[number, number], [number, number]]) => ({
			contains: (point: [number, number]) => {
				const [lat, lng] = point;
				return (
					lat >= coords[0][0] && lat <= coords[1][0] && lng >= coords[0][1] && lng <= coords[1][1]
				);
			}
		})
	});

	const createMockBounds = (south: number, west: number, north: number, east: number) => ({
		getSouth: () => south,
		getWest: () => west,
		getNorth: () => north,
		getEast: () => east
	});

	const createMockPlace = (id: number, lat: number, lon: number): Place =>
		({
			id,
			lat,
			lon
		}) as Place;

	it('filters places within bounds', () => {
		const leaflet = createMockLeaflet();
		const bounds = createMockBounds(10, 20, 12, 22);
		const places = [
			createMockPlace(1, 11, 21), // inside
			createMockPlace(2, 15, 25), // outside
			createMockPlace(3, 10.5, 20.5) // inside
		];

		const visible = getVisiblePlaces(
			leaflet as unknown as Parameters<typeof getVisiblePlaces>[0],
			places,
			bounds as unknown as Parameters<typeof getVisiblePlaces>[2],
			0 // no buffer for simplicity
		);

		expect(visible).toHaveLength(2);
		expect(visible.map((p) => p.id)).toEqual([1, 3]);
	});

	it('returns empty array for empty places', () => {
		const leaflet = createMockLeaflet();
		const bounds = createMockBounds(10, 20, 12, 22);

		const visible = getVisiblePlaces(
			leaflet as unknown as Parameters<typeof getVisiblePlaces>[0],
			[],
			bounds as unknown as Parameters<typeof getVisiblePlaces>[2],
			0
		);

		expect(visible).toHaveLength(0);
	});

	it('applies buffer to include places slightly outside viewport', () => {
		const leaflet = createMockLeaflet();
		const bounds = createMockBounds(10, 20, 12, 22); // 2x2 degree box
		const places = [
			createMockPlace(1, 11, 21), // inside original
			createMockPlace(2, 9.8, 21) // outside original, inside with 20% buffer (0.4 deg)
		];

		const visible = getVisiblePlaces(
			leaflet as unknown as Parameters<typeof getVisiblePlaces>[0],
			places,
			bounds as unknown as Parameters<typeof getVisiblePlaces>[2],
			0.2 // 20% buffer
		);

		expect(visible).toHaveLength(2);
	});
});



================================================
FILE: src/lib/map/viewport.ts
================================================
import { MERCHANT_LIST_MIN_ZOOM, MERCHANT_LIST_LOW_ZOOM } from '$lib/constants';
import type { Leaflet, Place } from '$lib/types';
import type { LatLngBounds } from 'leaflet';

export type ZoomBehavior = 'none' | 'api-with-limit' | 'local-markers';

// Determines which fetch strategy to use based on current zoom level
// See constants.ts for zoom behavior documentation
export function getZoomBehavior(zoom: number): ZoomBehavior {
	if (zoom >= MERCHANT_LIST_MIN_ZOOM) return 'local-markers'; // Zoom 15+
	if (zoom >= MERCHANT_LIST_LOW_ZOOM) return 'api-with-limit'; // Zoom 11-14
	return 'none'; // Below zoom 11
}

// Calculate radius from map center to corner (Haversine formula)
export const calculateRadiusKm = (bounds: LatLngBounds): number => {
	const center = bounds.getCenter();
	const corner = bounds.getNorthEast();

	const R = 6371; // Earth radius in km
	const dLat = ((corner.lat - center.lat) * Math.PI) / 180;
	const dLon = ((corner.lng - center.lng) * Math.PI) / 180;
	const a =
		Math.sin(dLat / 2) * Math.sin(dLat / 2) +
		Math.cos((center.lat * Math.PI) / 180) *
			Math.cos((corner.lat * Math.PI) / 180) *
			Math.sin(dLon / 2) *
			Math.sin(dLon / 2);
	const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
	return R * c * 1.1; // Add 10% buffer
};

// Get expanded bounds with buffer for preloading
export const getBufferedBounds = (
	leaflet: Leaflet,
	bounds: LatLngBounds,
	bufferPercent: number
): LatLngBounds => {
	const latDiff = bounds.getNorth() - bounds.getSouth();
	const lngDiff = bounds.getEast() - bounds.getWest();
	const latBuffer = latDiff * bufferPercent;
	const lngBuffer = lngDiff * bufferPercent;

	return leaflet.latLngBounds([
		[bounds.getSouth() - latBuffer, bounds.getWest() - lngBuffer],
		[bounds.getNorth() + latBuffer, bounds.getEast() + lngBuffer]
	]);
};

// Get places visible in current viewport with buffer
export const getVisiblePlaces = (
	leaflet: Leaflet,
	places: Place[],
	bounds: LatLngBounds,
	bufferPercent: number
): Place[] => {
	if (!bounds) return [];

	const bufferedBounds = getBufferedBounds(leaflet, bounds, bufferPercent);
	return places.filter((place) => bufferedBounds.contains([place.lat, place.lon]));
};



================================================
FILE: src/lib/sync/areas.ts
================================================
import { areaError, areas } from '$lib/store';
import { serverCache } from '$lib/cache';
import type { Area } from '$lib/types';
import { createSyncFunction } from './createSyncFactory';

const CACHE_DURATION = 5 * 60 * 1000; // 5 minutes

export const areasSync = createSyncFunction<Area>({
	name: 'areas',
	storageKey: 'areas_v4',
	apiEndpoint: 'areas',
	limit: 500,
	store: areas,
	errorStore: areaError,
	filterDeleted: (area) => !area.deleted_at && area.tags?.type !== 'trash',
	legacyTables: ['areas', 'areas_v2', 'areas_v3'],
	serverCache: {
		get: () => serverCache.getAreas(),
		set: (data) => serverCache.setAreas(data),
		getLastSync: () => serverCache.getLastSync()
	},
	cacheDuration: CACHE_DURATION
});



================================================
FILE: src/lib/sync/batchSync.ts
================================================
// Utility for coordinating multiple sync operations
// Runs all syncs in parallel and provides aggregated error logging

export async function batchSync(syncFunctions: Array<() => Promise<void>>): Promise<void> {
	const results = await Promise.allSettled(syncFunctions.map((fn) => fn()));

	const failures = results.filter((r): r is PromiseRejectedResult => r.status === 'rejected');

	if (failures.length > 0) {
		console.error(
			`${failures.length}/${results.length} sync operations failed:`,
			failures.map((f) => f.reason)
		);
	}
}



================================================
FILE: src/lib/sync/clearTables.ts
================================================
import localforage from 'localforage';

export const clearTables = (tables: string[]) => {
	for (const table of tables) {
		localforage
			.getItem(table)
			.then(function (value) {
				if (value) {
					localforage
						.removeItem(table)
						.then(function () {
							console.info('Key is cleared!');
						})
						.catch(function (err) {
							console.error(err);
						});
				}
			})
			.catch(function (err) {
				console.error(err);
			});
	}
};



================================================
FILE: src/lib/sync/createSyncFactory.ts
================================================
import type { Writable } from 'svelte/store';
import axios from 'axios';
import axiosRetry from 'axios-retry';
import localforage from 'localforage';
import { clearTables } from '$lib/sync/clearTables';

axiosRetry(axios, { retries: 3, retryDelay: axiosRetry.exponentialDelay });

// Base interface for syncable entities
interface SyncableEntity {
	id: string | number;
	updated_at: string;
	deleted_at?: string | null;
}

// Configuration for creating a sync function
export interface SyncConfig<T extends SyncableEntity> {
	name: string;
	storageKey: string;
	apiEndpoint: string;
	limit: number;
	store: Writable<T[]>;
	errorStore: Writable<string>;
	filterDeleted: (item: T) => boolean;
	legacyTables?: string[];
	// Server-side cache (optional, only areas uses this)
	serverCache?: {
		get: () => T[];
		set: (data: T[]) => void;
		getLastSync: () => Date | null;
	};
	cacheDuration?: number;
}

// Factory function that creates a sync function with its own state
export function createSyncFunction<T extends SyncableEntity>(
	config: SyncConfig<T>
): () => Promise<void> {
	// Each sync function maintains its own concurrency flag
	let syncInProgress = false;

	return async () => {
		if (syncInProgress) {
			console.info(`${config.name} sync already in progress, skipping concurrent invocation`);
			return;
		}

		syncInProgress = true;

		try {
			const isServerSide = typeof window === 'undefined';

			// Server-side cache handling (only for areas)
			if (isServerSide && config.serverCache && config.cacheDuration) {
				const cachedData = config.serverCache.get();
				const lastSync = config.serverCache.getLastSync();

				if (cachedData.length && lastSync) {
					// Use cache if still fresh
					if (Date.now() - lastSync.getTime() < config.cacheDuration) {
						config.store.set(cachedData);
						return;
					}

					// Do incremental update from expired cache
					const updatedData = await incrementalSync(
						cachedData,
						config.apiEndpoint,
						config.limit,
						config.filterDeleted
					);
					config.store.set(updatedData);
					config.serverCache.set(updatedData);
					return;
				}
			}

			// Client-side: clear legacy storage tables
			if (!isServerSide && config.legacyTables?.length) {
				clearTables(config.legacyTables);
			}

			// Try to get cached data from local storage (client-side only)
			let cachedData: T[] | null = null;
			if (!isServerSide) {
				try {
					cachedData = await localforage.getItem(config.storageKey);
				} catch (err) {
					console.error(`Could not load ${config.name} locally:`, err);
					config.errorStore.set(
						`Could not load ${config.name} locally, please try again or contact BTC Map.`
					);
				}
			}

			let resultData: T[];

			if (!cachedData) {
				// Initial sync - fetch all data from API
				resultData = await initialSync(
					config.apiEndpoint,
					config.limit,
					config.filterDeleted,
					config.errorStore,
					config.name
				);
			} else {
				// Incremental sync - update from cached data
				try {
					resultData = await incrementalSync(
						cachedData,
						config.apiEndpoint,
						config.limit,
						config.filterDeleted
					);
				} catch (err) {
					// On error, fall back to cached data
					console.error(`Could not update ${config.name} from API:`, err);
					config.store.set(cachedData);
					return;
				}
			}

			// Save to stores
			if (resultData.length) {
				config.store.set(resultData);

				// Save to local storage (client-side)
				if (!isServerSide) {
					try {
						await localforage.setItem(config.storageKey, resultData);
					} catch (err) {
						console.error(`Could not store ${config.name} locally:`, err);
					}
				}

				// Save to server cache if configured
				if (isServerSide && config.serverCache) {
					config.serverCache.set(resultData);
				}
			}
		} catch (err) {
			console.error(`${config.name} sync failed:`, err);
			config.errorStore.set(`Could not sync ${config.name}, please try again or contact BTC Map.`);
		} finally {
			syncInProgress = false;
		}
	};
}

// Initial sync - fetch all data from the beginning
async function initialSync<T extends SyncableEntity>(
	apiEndpoint: string,
	limit: number,
	filterDeleted: (item: T) => boolean,
	errorStore: Writable<string>,
	name: string
): Promise<T[]> {
	let updatedSince = '2022-01-01T00:00:00.000Z';
	let responseCount: number;
	const allData: T[] = [];
	const seenIds = new Set<string | number>();

	do {
		try {
			const response = await axios.get<T[]>(
				`https://api.btcmap.org/v2/${apiEndpoint}?updated_since=${updatedSince}&limit=${limit}`
			);

			const newItems = response.data;
			if (!newItems.length) break;

			updatedSince = newItems[newItems.length - 1].updated_at;
			responseCount = newItems.length;

			// Add new items, avoiding duplicates
			for (const item of newItems) {
				if (!seenIds.has(item.id)) {
					seenIds.add(item.id);
					allData.push(item);
				} else {
					// Update existing item
					const idx = allData.findIndex((d) => d.id === item.id);
					if (idx !== -1) {
						allData[idx] = item;
					}
				}
			}
		} catch (error) {
			errorStore.set(`Could not load ${name} from API, please try again or contact BTC Map.`);
			console.error(error);
			break;
		}
	} while (responseCount === limit);

	// Filter out deleted items
	return allData.filter(filterDeleted);
}

// Incremental sync - update from existing cached data
async function incrementalSync<T extends SyncableEntity>(
	cachedData: T[],
	apiEndpoint: string,
	limit: number,
	filterDeleted: (item: T) => boolean
): Promise<T[]> {
	// Sort cache to find most recent updated_at
	const cacheSorted = [...cachedData];
	cacheSorted.sort((a, b) => Date.parse(b.updated_at) - Date.parse(a.updated_at));

	let updatedSince = cacheSorted[0]?.updated_at || '2022-01-01T00:00:00.000Z';
	let responseCount: number;

	// Use Map for O(1) lookups instead of array operations
	const dataMap = new Map(cachedData.map((item) => [item.id, item]));

	do {
		const response = await axios.get<T[]>(
			`https://api.btcmap.org/v2/${apiEndpoint}?updated_since=${updatedSince}&limit=${limit}`
		);

		const newItems = response.data;
		if (!newItems.length) break;

		updatedSince = newItems[newItems.length - 1].updated_at;
		responseCount = newItems.length;

		// Update or add items
		for (const item of newItems) {
			if (filterDeleted(item)) {
				dataMap.set(item.id, item);
			} else {
				// Item was deleted, remove from cache
				dataMap.delete(item.id);
			}
		}
	} while (responseCount === limit);

	return Array.from(dataMap.values());
}



================================================
FILE: src/lib/sync/events.ts
================================================
import { eventError, events } from '$lib/store';
import type { Event } from '$lib/types';
import { createSyncFunction } from './createSyncFactory';

export const eventsSync = createSyncFunction<Event>({
	name: 'events',
	storageKey: 'events_v4',
	apiEndpoint: 'events',
	limit: 50000,
	store: events,
	errorStore: eventError,
	filterDeleted: (event) => !event.deleted_at,
	legacyTables: ['events', 'events_v2', 'events_v3']
});



================================================
FILE: src/lib/sync/places.ts
================================================
import {
	placesError,
	places,
	placesSyncCount,
	mapUpdates,
	placesLoadingStatus,
	placesLoadingProgress
} from '$lib/store';
import { clearTables } from '$lib/sync/clearTables';
import type { Place } from '$lib/types';
import { PLACE_FIELD_SETS, buildFieldsParam } from '$lib/api-fields';
import axios, { type AxiosProgressEvent } from 'axios';
import axiosRetry from 'axios-retry';
import localforage from 'localforage';
import { get } from 'svelte/store';
import { parseJSON, filterPlaces } from '$lib/workers/sync-worker-manager';
import { yieldToMain } from '$lib/utils';

axiosRetry(axios, { retries: 3, retryDelay: axiosRetry.exponentialDelay });

// Concurrency protection to prevent multiple simultaneous syncs
let syncInProgress = false;

// Maximum age for cached sync timestamp (in days)
const MAX_CACHE_AGE_DAYS = 90;

// Progress range constants for clear progress mapping
const PROGRESS_RANGES = {
	DOWNLOAD_START: 10,
	DOWNLOAD_END: 50,
	PARSE_START: 50,
	PARSE_END: 80,
	CACHE_LOAD: 60,
	UPDATE_CHECK: 70,
	UPDATE_CHECK_NO_CACHE: 85,
	MERGE_START: 80,
	MERGE_START_NO_CACHE: 90,
	FINALIZE: 95,
	COMPLETE: 100
} as const;

// Helper function to get date 2 weeks ago (fallback)
const getTwoWeeksAgoDate = (): string => {
	const twoWeeksAgo = new Date();
	twoWeeksAgo.setDate(twoWeeksAgo.getDate() - 14);
	return twoWeeksAgo.toISOString();
};

// Helper function to validate sync dates (not in future, not older than MAX_CACHE_AGE_DAYS)
const isValidSyncDate = (dateStr: string): boolean => {
	const date = new Date(dateStr);
	const now = new Date();
	const maxAgeDate = new Date();
	maxAgeDate.setDate(maxAgeDate.getDate() - MAX_CACHE_AGE_DAYS);
	return date <= now && date >= maxAgeDate;
};

// Helper function to get static file's last modified date
const getStaticFileDate = async (): Promise<string> => {
	try {
		// Use HEAD request to get headers without downloading the full file
		const headResponse = await axios.head('https://cdn.static.btcmap.org/api/v4/places.json');
		const lastModified = headResponse.headers['last-modified'];

		if (lastModified) {
			const staticDateStr = new Date(lastModified).toISOString();

			if (isValidSyncDate(staticDateStr)) {
				console.info(`Using static file date for updates: ${staticDateStr}`);
				return staticDateStr;
			} else {
				console.warn(`Static file date invalid (${staticDateStr}), using fallback`);
			}
		}
	} catch (error) {
		console.warn('Failed to get static file date, using fallback:', error);
	}

	// Fallback to 2 weeks ago
	return getTwoWeeksAgoDate();
};

export const elementsSync = async () => {
	// Prevent concurrent syncs - if already running, skip this invocation
	if (syncInProgress) {
		console.info('Sync already in progress, skipping concurrent invocation');
		return;
	}

	syncInProgress = true;

	try {
		// clear old migration tables if present (not places_v4 which is current)
		clearTables(['elements', 'elements_v2', 'elements_v3']);

		// Initialize progress to 1 to show loader immediately
		placesLoadingProgress.set(1);
		placesLoadingStatus.set('Initializing...');

		// get places and sync timestamp from local storage
		const cachedPlaces = await localforage.getItem<Place[]>('places_v4');
		const cachedSyncedAt = await localforage.getItem<string>('places_v4_synced_at');

		await Promise.resolve(cachedPlaces)
			.then(async function (cachedPlaces) {
				// add to sync count to only show data refresh after initial load
				const count = get(placesSyncCount);
				placesSyncCount.set(count + 1);

				let placesData: Place[] = [];

				// Step 1: Get base data from static CDN if no cache exists
				if (!cachedPlaces) {
					try {
						placesLoadingStatus.set('Downloading places data...');
						placesLoadingProgress.set(PROGRESS_RANGES.DOWNLOAD_START);

						// Fetch as text to parse in worker
						const staticResponse = await axios.get(
							'https://cdn.static.btcmap.org/api/v4/places.json',
							{
								responseType: 'text',
								onDownloadProgress: (progressEvent: AxiosProgressEvent) => {
									if (progressEvent.total) {
										const downloadPercent = (progressEvent.loaded / progressEvent.total) * 100;
										// Map 0-100% download to DOWNLOAD_START-DOWNLOAD_END range
										const downloadRange =
											PROGRESS_RANGES.DOWNLOAD_END - PROGRESS_RANGES.DOWNLOAD_START;
										const scaledProgress =
											PROGRESS_RANGES.DOWNLOAD_START + (downloadPercent / 100) * downloadRange;
										placesLoadingProgress.set(Math.round(scaledProgress));

										const loadedMB = (progressEvent.loaded / (1024 * 1024)).toFixed(1);
										const totalMB = (progressEvent.total / (1024 * 1024)).toFixed(1);
										placesLoadingStatus.set(`Downloading ${loadedMB} MB / ${totalMB} MB...`);
									}
								}
							}
						);

						placesLoadingStatus.set('Processing places data...');
						placesLoadingProgress.set(PROGRESS_RANGES.PARSE_START);

						// Parse JSON in worker thread to avoid blocking main thread
						placesData = await parseJSON<Place[]>(staticResponse.data, 'places', (progress) => {
							// Map 0-100% parsing to PARSE_START-PARSE_END range
							const parseRange = PROGRESS_RANGES.PARSE_END - PROGRESS_RANGES.PARSE_START;
							const scaledProgress =
								PROGRESS_RANGES.PARSE_START + (progress.percent / 100) * parseRange;
							placesLoadingProgress.set(Math.round(scaledProgress));

							if (progress.itemsParsed) {
								placesLoadingStatus.set(
									`Processing ${progress.itemsParsed.toLocaleString()} places...`
								);
							}
						});

						// Validate parsed data
						if (!Array.isArray(placesData) || placesData.length === 0) {
							console.error('CDN data parsing failed:', {
								isArray: Array.isArray(placesData),
								length: placesData?.length
							});
							throw new Error('CDN data parsing returned invalid format');
						}

						console.info(`Successfully parsed ${placesData.length} places from CDN`);

						placesLoadingProgress.set(PROGRESS_RANGES.PARSE_END);
					} catch (error) {
						placesError.set(
							'Could not load places from static CDN, please try again or contact BTC Map.'
						);
						placesLoadingStatus.set('');
						placesLoadingProgress.set(0);
						console.error(error);
						return;
					}
				} else {
					// Use cached data as base
					placesData = [...cachedPlaces];
					placesLoadingStatus.set('Loading from cache...');
					placesLoadingProgress.set(PROGRESS_RANGES.CACHE_LOAD);
				}

				// Step 2: Get recent updates from API
				// Prefer cached sync timestamp if available and valid (not in future, not older than
				// MAX_CACHE_AGE_DAYS); otherwise use static file date
				placesLoadingStatus.set('Checking for updates...');
				placesLoadingProgress.set(
					cachedPlaces ? PROGRESS_RANGES.UPDATE_CHECK : PROGRESS_RANGES.UPDATE_CHECK_NO_CACHE
				);

				// Validate cachedSyncedAt before using
				let validCachedSyncedAt: string | null = null;
				if (cachedSyncedAt) {
					if (isValidSyncDate(cachedSyncedAt)) {
						validCachedSyncedAt = cachedSyncedAt;
					} else {
						console.warn(`Cached sync date invalid (${cachedSyncedAt}), ignoring`);
					}
				}

				const useCachedSyncTimestamp = cachedPlaces && validCachedSyncedAt;
				if (useCachedSyncTimestamp) {
					console.info(`Using cached sync timestamp for updates: ${validCachedSyncedAt}`);
				}
				const updatesSince = useCachedSyncTimestamp
					? validCachedSyncedAt
					: await getStaticFileDate();

				let apiSucceeded = false;

				try {
					const apiResponse = await axios.get<Place[]>(
						`https://api.btcmap.org/v4/places?fields=${buildFieldsParam(PLACE_FIELD_SETS.MAP_SYNC)}&updated_since=${updatesSince}&include_deleted=true`
					);

					const recentUpdates = apiResponse.data;

					// Validate response is actually an array
					if (!Array.isArray(recentUpdates)) {
						console.error('API returned invalid data format:', typeof recentUpdates, recentUpdates);
						throw new Error('API returned invalid data format');
					}

					console.info(`Fetched ${recentUpdates.length} updates from API since ${updatesSince}`);

					if (recentUpdates.length > 0) {
						placesLoadingStatus.set('Merging updates...');
						placesLoadingProgress.set(
							cachedPlaces ? PROGRESS_RANGES.MERGE_START : PROGRESS_RANGES.MERGE_START_NO_CACHE
						);

						// Use worker to filter and merge updates to avoid blocking main thread
						const updatedPlaceIds = recentUpdates.map((place) => place.id);
						placesData = await filterPlaces(placesData, updatedPlaceIds, recentUpdates);

						// Show refresh indicator if we got updates and had cached data
						if (cachedPlaces) {
							mapUpdates.set(true);
						}
					}

					apiSucceeded = true;
				} catch (error) {
					// If API fails, continue with existing data (either cached or CDN)
					// Don't return early - let execution continue to Step 3 to finalize and complete progress
					const errorMsg = cachedPlaces
						? 'Could not update places from API, using cached data.'
						: 'Could not fetch recent updates. Showing baseline data from CDN.';
					placesError.set(errorMsg);
					console.error(error);
				}

				// Step 3: Save to local storage and update store
				placesLoadingStatus.set('Finalizing...');
				placesLoadingProgress.set(PROGRESS_RANGES.FINALIZE);

				if (placesData.length > 0) {
					localforage
						.setItem('places_v4', placesData)
						.then(async function () {
							// Only save sync timestamp if API succeeded, to avoid creating gaps
							// where updates between old and new timestamp are permanently missed
							if (apiSucceeded) {
								await localforage.setItem('places_v4_synced_at', new Date().toISOString());
							}

							// Yield to main thread before updating store to prevent UI freeze
							await yieldToMain();
							// set response to store
							places.set(placesData);
							placesLoadingStatus.set('Complete!');
							placesLoadingProgress.set(PROGRESS_RANGES.COMPLETE);

							// Keep progress at 100% - don't reset to avoid confusing loading states
							// The map component will handle hiding the indicator when elementsLoaded = true
						})
						.catch(async function (err) {
							// Yield to main thread before updating store to prevent UI freeze
							await yieldToMain();
							places.set(placesData);
							placesError.set(
								'Could not store places locally, please try again or contact BTC Map.'
							);
							placesLoadingStatus.set('');
							placesLoadingProgress.set(0);
							console.error(err);
						});
				}
			})
			.catch(async function (err) {
				placesError.set('Could not load places locally, please try again or contact BTC Map.');
				console.error(err);

				// Fallback: try to load from static CDN
				const count = get(placesSyncCount);
				placesSyncCount.set(count + 1);

				try {
					// Fetch as text to parse in worker
					const staticResponse = await axios.get(
						'https://cdn.static.btcmap.org/api/v4/places.json',
						{
							responseType: 'text'
						}
					);

					// Parse JSON in worker thread
					const parsedPlaces = await parseJSON<Place[]>(staticResponse.data, 'places');

					// Validate fallback CDN data
					if (!Array.isArray(parsedPlaces) || parsedPlaces.length === 0) {
						throw new Error('Fallback CDN data invalid');
					}

					if (parsedPlaces.length > 0) {
						// Yield to main thread before updating store to prevent UI freeze
						await yieldToMain();
						places.set(parsedPlaces);
					}
				} catch (error) {
					placesError.set(
						'Could not load places from static CDN, please try again or contact BTC Map.'
					);
					console.error(error);
				}
			});
	} finally {
		syncInProgress = false;
	}
};

export const updateSinglePlace = async (placeId: string | number): Promise<Place | null> => {
	try {
		// Fetch the updated place from the API
		const response = await axios.get<Place>(
			`https://api.btcmap.org/v4/places/${placeId}?fields=${buildFieldsParam(PLACE_FIELD_SETS.COMPLETE_PLACE)}`
		);
		const updatedPlace = response.data;

		// Get current places from localforage
		const cachedPlaces = await localforage.getItem<Place[]>('places_v4');

		if (!cachedPlaces) {
			console.warn('No cached places found, cannot update single place');
			return null;
		}

		// Find and update the place in the array
		const placeIndex = cachedPlaces.findIndex((p) => p.id === updatedPlace.id);

		let updatedPlaces: Place[];
		if (placeIndex !== -1) {
			// Update existing place
			updatedPlaces = [...cachedPlaces];
			updatedPlaces[placeIndex] = updatedPlace;
		} else {
			// Place not found in cache, add it
			updatedPlaces = [...cachedPlaces, updatedPlace];
		}

		// Save to localforage
		await localforage.setItem('places_v4', updatedPlaces);

		// Yield to main thread before updating store to prevent UI freeze
		await yieldToMain();

		// Update the store
		places.set(updatedPlaces);

		console.info(`Successfully updated place ${placeId} in localforage and store`);
		return updatedPlace;
	} catch (error) {
		console.error(`Failed to update single place ${placeId}:`, error);
		return null;
	}
};



================================================
FILE: src/lib/sync/reports.ts
================================================
import { reportError, reports } from '$lib/store';
import type { Report } from '$lib/types';
import { createSyncFunction } from './createSyncFactory';

export const reportsSync = createSyncFunction<Report>({
	name: 'reports',
	storageKey: 'reports_v6',
	apiEndpoint: 'reports',
	limit: 10000,
	store: reports,
	errorStore: reportError,
	filterDeleted: (report) => !report.deleted_at,
	legacyTables: ['reports', 'reports_v2', 'reports_v3', 'reports_v4', 'reports_v5']
});



================================================
FILE: src/lib/sync/users.ts
================================================
import { userError, users } from '$lib/store';
import type { User } from '$lib/types';
import { createSyncFunction } from './createSyncFactory';

export const usersSync = createSyncFunction<User>({
	name: 'users',
	storageKey: 'users_v5',
	apiEndpoint: 'users',
	limit: 7500,
	store: users,
	errorStore: userError,
	filterDeleted: (user) => !user.deleted_at,
	legacyTables: ['users', 'users_v2', 'users_v3', 'users_v4']
});



================================================
FILE: src/lib/workers/map-worker.ts
================================================
import type { Place } from '../types';

export interface ProcessPlacesPayload {
	places: Place[];
	batchSize: number;
}

export interface GenerateIconsPayload {
	places: Place[];
}

export interface BatchReadyPayload {
	batch: ProcessedPlace[];
	batchIndex: number;
	totalBatches: number;
	progress: number;
}

export interface PlacesProcessedPayload {
	totalProcessed: number;
}

export interface ErrorPayload {
	error: string;
}

export interface WorkerMessage {
	type: 'PROCESS_PLACES' | 'GENERATE_ICONS';
	payload: ProcessPlacesPayload | GenerateIconsPayload;
	id: string;
}

export interface WorkerResponse {
	type: 'PLACES_PROCESSED' | 'ICONS_GENERATED' | 'BATCH_READY' | 'ERROR';
	payload: PlacesProcessedPayload | BatchReadyPayload | ErrorPayload | unknown[];
	id: string;
}

export interface ProcessedPlace extends Place {
	iconData: {
		className: string;
		iconTmp: string;
		commentsCount: number;
		boosted: boolean;
	};
}

// Worker message handler
self.onmessage = (event: MessageEvent<WorkerMessage>) => {
	const { type, payload, id } = event.data;

	try {
		switch (type) {
			case 'PROCESS_PLACES': {
				const processPayload = payload as ProcessPlacesPayload;
				processPlacesInBatches(processPayload.places, processPayload.batchSize, id);
				break;
			}
			case 'GENERATE_ICONS': {
				const iconPayload = payload as GenerateIconsPayload;
				generateIconData(iconPayload.places, id);
				break;
			}
			default:
				throw new Error(`Unknown message type: ${type}`);
		}
	} catch (error) {
		self.postMessage({
			type: 'ERROR',
			payload: { error: error instanceof Error ? error.message : String(error) } as ErrorPayload,
			id
		} as WorkerResponse);
	}
};

// Utility function to yield control back to the event loop
// Uses MessageChannel for reliable yielding without setTimeout delays
function yieldToEventLoop(): Promise<void> {
	// Use MessageChannel for immediate, reliable yielding
	return new Promise((resolve) => {
		const channel = new MessageChannel();
		channel.port2.onmessage = () => resolve();
		channel.port1.postMessage(null);
	});
}

// Extract common icon data calculation logic
function calculateIconData(place: Place) {
	const isBoosted = place.boosted_until ? Date.parse(place.boosted_until) > Date.now() : false;

	return {
		className: isBoosted ? 'animate-wiggle' : '',
		iconTmp: place.icon !== 'question_mark' ? place.icon : 'currency_bitcoin',
		commentsCount: place.comments || 0,
		boosted: isBoosted
	};
}

// Process places in batches to avoid blocking
async function processPlacesInBatches(places: Place[], batchSize: number = 50, requestId: string) {
	const totalBatches = Math.ceil(places.length / batchSize);

	for (let i = 0; i < totalBatches; i++) {
		const start = i * batchSize;
		const end = Math.min(start + batchSize, places.length);
		const batch = places.slice(start, end);

		// Process batch
		const processedBatch: ProcessedPlace[] = batch.map((place) => ({
			...place,
			iconData: calculateIconData(place)
		}));

		// Send batch back to main thread
		self.postMessage({
			type: 'BATCH_READY',
			payload: {
				batch: processedBatch,
				batchIndex: i,
				totalBatches,
				progress: ((i + 1) / totalBatches) * 100
			},
			id: requestId
		} as WorkerResponse);

		// Yield control to prevent worker blocking - use proper scheduler
		await yieldToEventLoop();
	}

	// Signal completion
	self.postMessage({
		type: 'PLACES_PROCESSED',
		payload: { totalProcessed: places.length } as PlacesProcessedPayload,
		id: requestId
	} as WorkerResponse);
}

function generateIconData(places: Place[], requestId: string) {
	// Pre-calculate icon data without DOM manipulation
	const iconData = places.map((place) => ({
		id: place.id,
		iconData: calculateIconData(place)
	}));

	self.postMessage({
		type: 'ICONS_GENERATED',
		payload: iconData,
		id: requestId
	} as WorkerResponse);
}



================================================
FILE: src/lib/workers/sync-worker-manager.ts
================================================
import type { WorkerMessage, WorkerResponse } from './sync-worker';
import type { Place, Area, User, Event, Report, ProgressUpdate } from '../types';

let worker: Worker | null = null;
let workerInitialized = false;
let workerSupported: boolean | null = null;
let messageId = 0;

const pendingRequests = new Map<
	string,
	{
		resolve: (value: unknown) => void;
		reject: (error: unknown) => void;
		onProgress?: (progress: ProgressUpdate) => void;
	}
>();

function isWorkerSupported(): boolean {
	if (workerSupported !== null) {
		return workerSupported;
	}

	workerSupported =
		typeof Worker !== 'undefined' && typeof window !== 'undefined' && 'Worker' in window;

	return workerSupported;
}

function handleWorkerMessage(response: WorkerResponse) {
	const request = pendingRequests.get(response.id);
	if (!request) return;

	switch (response.type) {
		case 'PROGRESS':
			// Don't resolve/reject, just call progress callback
			if (request.onProgress) {
				request.onProgress(response.payload as ProgressUpdate);
			}
			break;

		case 'PARSED':
		case 'FILTERED':
		case 'MERGED':
			request.resolve(response.payload);
			pendingRequests.delete(response.id);
			break;

		case 'ERROR': {
			const errorPayload = response.payload as { error: string };
			request.reject(new Error(errorPayload.error));
			pendingRequests.delete(response.id);
			break;
		}
	}
}

async function initWorker(): Promise<boolean> {
	if (workerInitialized) {
		return worker !== null;
	}

	workerInitialized = true;

	if (!isWorkerSupported()) {
		console.warn('Web Workers not supported, falling back to synchronous processing');
		return false;
	}

	try {
		worker = new Worker(new URL('./sync-worker.ts', import.meta.url), {
			type: 'module'
		});

		worker.onmessage = (event: MessageEvent<WorkerResponse>) => {
			handleWorkerMessage(event.data);
		};

		worker.onerror = (error) => {
			console.error('Sync worker error:', error);
			// Reject all pending requests to prevent memory leaks
			pendingRequests.forEach(({ reject }) => {
				reject(new Error('Worker encountered an error'));
			});
			pendingRequests.clear();
		};

		return true;
	} catch (error) {
		console.warn('Failed to initialize sync worker:', error);
		worker = null;
		return false;
	}
}

function generateMessageId(): string {
	return `sync_msg_${++messageId}_${Date.now()}`;
}

async function sendWorkerMessage<T>(
	messageType: WorkerMessage['type'],
	payload: WorkerMessage['payload'],
	onProgress?: (progress: ProgressUpdate) => void
): Promise<T> {
	const workerReady = await initWorker();

	if (!workerReady || !worker) {
		// Fallback to synchronous processing
		throw new Error('Web Worker not supported');
	}

	const id = generateMessageId();

	return new Promise<T>((resolve, reject) => {
		if (!worker) {
			reject(new Error('Worker became unavailable'));
			return;
		}

		pendingRequests.set(id, {
			resolve: resolve as (value: unknown) => void,
			reject,
			onProgress
		});

		const message: WorkerMessage = {
			type: messageType,
			payload,
			id
		};

		worker.postMessage(message);
	});
}

export async function parseJSON<T>(
	json: string,
	type: 'places' | 'areas' | 'users' | 'events' | 'reports',
	onProgress?: (progress: ProgressUpdate) => void
): Promise<T> {
	try {
		return await sendWorkerMessage<T>('PARSE_JSON', { json, type }, onProgress);
	} catch (error) {
		// Fallback to synchronous parsing
		console.warn('Worker parsing failed, using synchronous fallback:', error);
		return JSON.parse(json);
	}
}

export async function filterPlaces(
	places: Place[],
	updatedPlaceIds: number[],
	recentUpdates: Place[]
): Promise<Place[]> {
	try {
		return await sendWorkerMessage<Place[]>('FILTER_PLACES', {
			places,
			updatedPlaceIds,
			recentUpdates
		});
	} catch (error) {
		// Fallback to synchronous filtering
		console.warn('Worker filtering failed, using synchronous fallback:', error);
		const updatedIds = new Set(updatedPlaceIds);
		const filtered = places.filter((place) => !updatedIds.has(place.id));
		const merged = [...filtered];
		recentUpdates.forEach((place) => {
			if (!place.deleted_at) {
				merged.push(place);
			}
		});
		return merged;
	}
}

export async function filterDeleted<T extends Place | Area | User | Event | Report>(
	items: T[],
	type: 'places' | 'areas' | 'users' | 'events' | 'reports'
): Promise<T[]> {
	try {
		return await sendWorkerMessage<T[]>('FILTER_DELETED', { items, type });
	} catch (error) {
		// Fallback to synchronous filtering
		console.warn('Worker filtering failed, using synchronous fallback:', error);
		return items.filter((item) => !item.deleted_at);
	}
}

export async function mergeUpdates<T extends Area | User | Event | Report>(
	cached: T[],
	updates: T[],
	type: 'areas' | 'users' | 'events' | 'reports'
): Promise<T[]> {
	try {
		return await sendWorkerMessage<T[]>('MERGE_UPDATES', { cached, updates, type });
	} catch (error) {
		// Fallback to synchronous merging
		// Type-safe: T is constrained to Area | User | Event | Report, all have id and deleted_at
		console.warn('Worker merging failed, using synchronous fallback:', error);
		const updatesMap = new Map(updates.map((item) => [item.id, item]));
		const filtered = cached.filter((item) => !updatesMap.has(item.id));
		const merged = [...filtered];
		updates.forEach((item) => {
			if (!item.deleted_at) {
				merged.push(item);
			}
		});
		return merged;
	}
}

export function terminate() {
	if (worker) {
		worker.terminate();
		worker = null;
	}
	pendingRequests.clear();
	workerInitialized = false;
}



================================================
FILE: src/lib/workers/sync-worker.ts
================================================
import type { Place, Area, User, Event, Report, ProgressUpdate } from '../types';

// Type constraint to ensure items have required properties
type ItemWithId = Area | User | Event | Report;

// Type guard to validate runtime types
function hasRequiredProperties(item: unknown): item is ItemWithId {
	return (
		typeof item === 'object' &&
		item !== null &&
		'id' in item &&
		'deleted_at' in item &&
		(typeof (item as ItemWithId).id === 'string' || typeof (item as ItemWithId).id === 'number') &&
		(typeof (item as ItemWithId).deleted_at === 'string' ||
			(item as ItemWithId).deleted_at === null)
	);
}

export interface ParseJSONPayload {
	json: string;
	type: 'places' | 'areas' | 'users' | 'events' | 'reports';
}

export interface FilterPlacesPayload {
	places: Place[];
	updatedPlaceIds: number[];
	recentUpdates: Place[];
}

export interface FilterDeletedPayload {
	items: (Place | Area | User | Event | Report)[];
	type: 'places' | 'areas' | 'users' | 'events' | 'reports';
}

export interface MergeUpdatesPayload {
	cached: ItemWithId[];
	updates: ItemWithId[];
	type: 'areas' | 'users' | 'events' | 'reports';
}

export interface WorkerMessage {
	type: 'PARSE_JSON' | 'FILTER_PLACES' | 'FILTER_DELETED' | 'MERGE_UPDATES';
	payload: ParseJSONPayload | FilterPlacesPayload | FilterDeletedPayload | MergeUpdatesPayload;
	id: string;
}

export interface WorkerResponse {
	type: 'PARSED' | 'FILTERED' | 'MERGED' | 'ERROR' | 'PROGRESS';
	payload: unknown;
	id: string;
}

function serializeError(error: unknown): string {
	if (error instanceof Error) {
		return error.message;
	}
	if (typeof error === 'string') {
		return error;
	}
	if (typeof error === 'object' && error !== null) {
		try {
			return JSON.stringify(error);
		} catch {
			return String(error);
		}
	}
	return String(error);
}

self.onmessage = (event: MessageEvent<WorkerMessage>) => {
	const { type, payload, id } = event.data;

	try {
		switch (type) {
			case 'PARSE_JSON': {
				const parsePayload = payload as ParseJSONPayload;

				// Send initial progress
				self.postMessage({
					type: 'PROGRESS',
					payload: {
						percent: 0,
						status: 'parsing'
					} as ProgressUpdate,
					id
				} as WorkerResponse);

				// Parse JSON with progress tracking
				const startTime = performance.now();
				const parsed = JSON.parse(parsePayload.json);
				const parseTime = performance.now() - startTime;

				// Send progress update after parsing
				const itemCount = Array.isArray(parsed) ? parsed.length : 0;
				self.postMessage({
					type: 'PROGRESS',
					payload: {
						percent: 100,
						itemsParsed: itemCount,
						totalItems: itemCount,
						status: 'complete'
					} as ProgressUpdate,
					id
				} as WorkerResponse);

				console.info(`Worker parsed ${itemCount} items in ${parseTime.toFixed(2)}ms`);

				self.postMessage({
					type: 'PARSED',
					payload: parsed,
					id
				} as WorkerResponse);
				break;
			}

			case 'FILTER_PLACES': {
				const filterPayload = payload as FilterPlacesPayload;

				// Send progress update
				self.postMessage({
					type: 'PROGRESS',
					payload: {
						percent: 50,
						status: 'filtering'
					} as ProgressUpdate,
					id
				} as WorkerResponse);

				const updatedIds = new Set(filterPayload.updatedPlaceIds);

				// Filter out places that will be updated
				const filtered = filterPayload.places.filter((place) => !updatedIds.has(place.id));

				// Add non-deleted updates
				const merged = [...filtered];
				filterPayload.recentUpdates.forEach((place) => {
					if (!place.deleted_at) {
						merged.push(place);
					}
				});

				// Deduplicate by ID (keep last occurrence to preserve most recent data)
				const seenIds = new Set<number>();
				const deduplicated: Place[] = [];
				for (let i = merged.length - 1; i >= 0; i--) {
					const place = merged[i];
					if (!seenIds.has(place.id)) {
						seenIds.add(place.id);
						deduplicated.push(place);
					}
				}
				deduplicated.reverse();

				self.postMessage({
					type: 'PROGRESS',
					payload: {
						percent: 100,
						itemsParsed: deduplicated.length,
						totalItems: deduplicated.length,
						status: 'complete'
					} as ProgressUpdate,
					id
				} as WorkerResponse);

				self.postMessage({
					type: 'FILTERED',
					payload: deduplicated,
					id
				} as WorkerResponse);
				break;
			}

			case 'FILTER_DELETED': {
				const filterPayload = payload as FilterDeletedPayload;
				let filtered: unknown[];

				switch (filterPayload.type) {
					case 'areas':
						filtered = (filterPayload.items as Area[]).filter(
							(area) => !area.deleted_at && area.tags?.type !== 'trash'
						);
						break;
					case 'places':
						filtered = (filterPayload.items as Place[]).filter((place) => !place.deleted_at);
						break;
					case 'users':
						filtered = (filterPayload.items as User[]).filter((user) => !user.deleted_at);
						break;
					case 'events':
						filtered = (filterPayload.items as Event[]).filter((event) => !event.deleted_at);
						break;
					case 'reports':
						filtered = (filterPayload.items as Report[]).filter((report) => !report.deleted_at);
						break;
					default:
						filtered = filterPayload.items;
				}

				self.postMessage({
					type: 'FILTERED',
					payload: filtered,
					id
				} as WorkerResponse);
				break;
			}

			case 'MERGE_UPDATES': {
				const mergePayload = payload as MergeUpdatesPayload;

				// Type-safe mapping: handle both string and number IDs
				const updatesMap = new Map<string | number, ItemWithId>();
				mergePayload.updates.forEach((item) => {
					if (hasRequiredProperties(item)) {
						updatesMap.set(item.id, item);
					}
				});

				// Filter out items that have updates
				const filtered = mergePayload.cached.filter((item) => {
					if (!hasRequiredProperties(item)) return false;
					return !updatesMap.has(item.id);
				});

				// Add non-deleted updates
				const merged = [...filtered];
				mergePayload.updates.forEach((item) => {
					if (hasRequiredProperties(item) && !item.deleted_at) {
						merged.push(item);
					}
				});

				self.postMessage({
					type: 'MERGED',
					payload: merged,
					id
				} as WorkerResponse);
				break;
			}

			default:
				throw new Error(`Unknown message type: ${type}`);
		}
	} catch (error) {
		self.postMessage({
			type: 'ERROR',
			payload: { error: serializeError(error) },
			id
		} as WorkerResponse);
	}
};



================================================
FILE: src/lib/workers/worker-manager.ts
================================================
import type {
	WorkerMessage,
	WorkerResponse,
	ProcessedPlace,
	BatchReadyPayload,
	PlacesProcessedPayload,
	ErrorPayload
} from './map-worker';
import type { Place } from '../types';

// Worker state - using module-level variables instead of class properties
let worker: Worker | null = null;
let workerInitialized = false;
let workerSupported: boolean | null = null;
let messageId = 0;
const pendingRequests = new Map<
	string,
	{
		resolve: (value: unknown) => void;
		reject: (error: unknown) => void;
		onProgress?: (progress: number, batch?: ProcessedPlace[]) => void;
	}
>();

// Feature detection for Web Workers
function isWorkerSupported(): boolean {
	if (workerSupported !== null) {
		return workerSupported;
	}

	workerSupported =
		typeof Worker !== 'undefined' && typeof window !== 'undefined' && 'Worker' in window;

	return workerSupported;
}

// Handle worker messages
function handleWorkerMessage(response: WorkerResponse) {
	const request = pendingRequests.get(response.id);
	if (!request) return;

	switch (response.type) {
		case 'BATCH_READY': {
			const batchPayload = response.payload as BatchReadyPayload;
			// Call progress callback with batch data
			if (request.onProgress) {
				request.onProgress(batchPayload.progress, batchPayload.batch);
			}
			break;
		}

		case 'PLACES_PROCESSED': {
			const processedPayload = response.payload as PlacesProcessedPayload;
			request.resolve(processedPayload);
			pendingRequests.delete(response.id);
			break;
		}

		case 'ICONS_GENERATED': {
			const iconsPayload = response.payload as unknown[];
			request.resolve(iconsPayload);
			pendingRequests.delete(response.id);
			break;
		}

		case 'ERROR': {
			const errorPayload = response.payload as ErrorPayload;
			request.reject(new Error(errorPayload.error));
			pendingRequests.delete(response.id);
			break;
		}
	}
}

// Initialize worker lazily
async function initWorker(): Promise<boolean> {
	if (workerInitialized) {
		return worker !== null;
	}

	workerInitialized = true;

	if (!isWorkerSupported()) {
		console.warn('Web Workers not supported, falling back to synchronous processing');
		return false;
	}

	try {
		worker = new Worker(new URL('./map-worker.ts', import.meta.url), {
			type: 'module'
		});

		worker.onmessage = (event: MessageEvent<WorkerResponse>) => {
			handleWorkerMessage(event.data);
		};

		worker.onerror = (error) => {
			console.error('Map worker error:', error);
			// Don't terminate on error, let individual operations handle fallback
		};

		return true;
	} catch (error) {
		console.warn('Failed to initialize web worker:', error);
		worker = null;
		return false;
	}
}

// Generate unique message ID
function generateMessageId(): string {
	return `msg_${++messageId}_${Date.now()}`;
}

/**
 * Generic function to send messages to worker and handle responses
 */
async function sendWorkerMessage<T>(
	messageType: WorkerMessage['type'],
	payload: WorkerMessage['payload'],
	onProgress?: (progress: number, batch?: ProcessedPlace[]) => void
): Promise<T> {
	// Lazy initialization
	const workerReady = await initWorker();

	if (!workerReady || !worker) {
		throw new Error('Web Worker not supported or failed to initialize');
	}

	const id = generateMessageId();

	return new Promise<T>((resolve, reject) => {
		// Double-check worker is still available
		if (!worker) {
			reject(new Error('Worker became unavailable'));
			return;
		}

		pendingRequests.set(id, {
			resolve: resolve as (value: unknown) => void,
			reject,
			onProgress
		});

		const message: WorkerMessage = {
			type: messageType,
			payload,
			id
		};

		worker.postMessage(message);
	});
}

/**
 * Process places in batches using web worker
 */
export async function processPlaces(
	places: Place[],
	batchSize: number = 50,
	onProgress?: (progress: number, batch?: ProcessedPlace[]) => void
): Promise<PlacesProcessedPayload> {
	return sendWorkerMessage<PlacesProcessedPayload>(
		'PROCESS_PLACES',
		{ places, batchSize },
		onProgress
	);
}

/**
 * Generate icon data for places
 */
export async function generateIconData(places: Place[]): Promise<unknown[]> {
	return sendWorkerMessage<unknown[]>('GENERATE_ICONS', { places });
}

/**
 * Check if web workers are supported without initializing
 */
export function isSupported(): boolean {
	return isWorkerSupported();
}

/**
 * Terminate the worker and cleanup
 */
export function terminate() {
	if (worker) {
		worker.terminate();
		worker = null;
	}
	pendingRequests.clear();
	workerInitialized = false;
}



================================================
FILE: src/routes/+error.svelte
================================================
<script lang="ts">
	import { page } from '$app/stores';
	import Icon from '$components/Icon.svelte';
	import { onMount } from 'svelte';
	import { resolve } from '$app/paths';

	onMount(() => {
		if ($page.status === 500 && !navigator.onLine) {
			location.reload();
		}
	});
</script>

<svelte:head>
	<title>BTC Map - Error</title>
	<meta property="og:image" content="https://btcmap.org/images/og/home.png" />
	<meta property="twitter:title" content="BTC Map" />
	<meta property="twitter:image" content="https://btcmap.org/images/og/home.png" />
</svelte:head>

<div class="bg-teal dark:bg-dark">
	<div class="relative mx-auto w-10/12 xl:w-[1200px]">
		<header>
			<a href={resolve('/')}>
				<img src="/images/logo.svg" alt="logo" class="mx-auto w-32 py-5" />
			</a>
		</header>

		<div class="space-y-10 py-10 text-center">
			<a
				href={resolve('/')}
				class="text-xl font-semibold text-link transition-colors hover:text-hover"
				><Icon type="fa" icon="house" w="16" h="16" class="mr-2 inline" /> Home</a
			>
			<h1 class="text-4xl md:text-5xl dark:text-white">{$page.status}: {$page.error?.message}</h1>
			<h2 class="text-xl font-semibold text-primary dark:text-white">
				Please try again or contact BTC Map.
			</h2>
		</div>
	</div>
</div>



================================================
FILE: src/routes/+layout.svelte
================================================
<script lang="ts">
	import { dev } from '$app/environment';
	import { syncStatus } from '$lib/store';
	import { elementsSync } from '$lib/sync/places';
	import Header from '$components/layout/Header.svelte';
	import { SvelteToast } from '@zerodevx/svelte-toast';
	import axios from 'axios';
	import 'leaflet.locatecontrol/dist/L.Control.Locate.min.css';
	import 'leaflet.markercluster/dist/MarkerCluster.Default.css';
	import 'leaflet.markercluster/dist/MarkerCluster.css';
	import 'leaflet/dist/leaflet.css';
	import localforage from 'localforage';
	import { onDestroy, onMount } from 'svelte';
	import 'tippy.js/dist/tippy.css';
	import '../app.css';
	import Footer from '$components/layout/Footer.svelte';

	axios.defaults.timeout = 600000;

	const options = {
		reversed: true,
		intro: { y: 192 },
		pausable: true
	};

	let dataSyncInterval: ReturnType<typeof setInterval>;

	onMount(async () => {
		localforage.config({
			name: 'BTC Map',
			description: 'The Times 03/Jan/2009 Chancellor on brink of second bailout for banks'
		});

		const dataSync = async () => {
			$syncStatus = true;

			// Load places (map is primary use case)
			// Other syncs (events, users, areas, reports) are lazy-loaded by pages that need them
			await elementsSync();

			$syncStatus = false;
		};

		dataSync();
		dataSyncInterval = setInterval(dataSync, 600000);
	});

	onDestroy(() => {
		clearInterval(dataSyncInterval);
	});

	export let data;
</script>

<svelte:head>
	<meta
		name="lightning"
		content="lnurlp:LNURL1DP68GURN8GHJ7CM0WFJJUCN5VDKKZUPWDAEXWTMVDE6HYMRS9ARKXVN4W5EQPSYZ34"
	/>
	<meta property="alby:image" content="/images/logo.svg" />
	<meta property="alby:name" content="BTC Map" />
	<!-- Umami Analytics - privacy-focused, no cookies, production only -->
	{#if !dev}
		<script
			defer
			src="https://umami.btcmap.org/script.js"
			data-website-id="01d98748-38ef-4cda-b7d9-6eaece0f74bd"
		></script>
	{/if}
</svelte:head>

{#if !['/', '/map', '/communities/map', '/communities', '/countries'].includes(data.pathname)}
	<div class="bg-teal dark:bg-dark">
		<Header />
		<div class="mx-auto w-10/12 xl:w-[1200px]">
			<slot />
			<Footer />
		</div>
	</div>
{:else}
	<slot />
{/if}

<SvelteToast {options} />

<style>
	:root {
		--toastContainerTop: auto;
		--toastContainerRight: auto;
		--toastContainerBottom: 8rem;
		--toastContainerLeft: calc(50vw - 8rem);
	}
</style>



================================================
FILE: src/routes/+layout.ts
================================================
import type { LayoutLoad } from './$types';

export const load: LayoutLoad = ({ url }) => {
	return {
		pathname: url.pathname
	};
};



================================================
FILE: src/routes/+page.svelte
================================================
<script lang="ts">
	import Footer from '$components/layout/Footer.svelte';
	import Header from '$components/layout/Header.svelte';
	import HeaderPlaceholder from '$components/layout/HeaderPlaceholder.svelte';
	import IconApps from '$lib/icons/IconApps.svelte';
	import { apps, theme } from '$lib/store';
	import { detectTheme } from '$lib/utils';
	import { resolve } from '$app/paths';
</script>

<svelte:head>
	<title>BTC Map</title>
	<meta property="og:image" content="https://btcmap.org/images/og/home.png" />
	<meta property="twitter:title" content="BTC Map" />
	<meta property="twitter:image" content="https://btcmap.org/images/og/home.png" />
</svelte:head>

<div class="street-map bg-teal dark:bg-dark">
	<img
		src="/images/street-map.svg"
		alt="roads"
		class="absolute top-0 right-0 xl:hidden dark:opacity-10"
	/>
	<Header />
	<div class="relative mx-auto w-10/12 xl:w-[1200px]">
		<section id="hero" class="items-center justify-between pt-10 pb-20 xl:flex xl:pt-0">
			<div class="mx-auto w-full xl:mx-0 xl:w-[500px]">
				{#if typeof window !== 'undefined'}
					<h1
						class="{detectTheme() === 'dark' || $theme === 'dark'
							? 'text-white'
							: 'gradient'} text-center text-4xl !leading-tight font-semibold md:text-5xl xl:text-left"
					>
						Find places to spend sats wherever you are.
					</h1>
				{:else}
					<HeaderPlaceholder />
				{/if}
				<div class="my-8 flex flex-wrap justify-center gap-4">
					<a
						href={resolve('/map')}
						class="rounded-full bg-link px-7 py-3.5 text-lg font-semibold text-white transition-colors hover:bg-hover"
						>Open Map</a
					>
					<a
						href={resolve('/add-location')}
						class="rounded-full bg-link px-7 py-3.5 text-lg font-semibold text-white transition-colors hover:bg-hover"
						>Add Location</a
					>
				</div>
				<div
					class="my-8 flex flex-wrap justify-center rounded-2xl bg-white/30 py-6 dark:bg-white/[0.15]"
				>
					{#each $apps as app (app.link)}
						<div
							class="mx-2 my-2 space-y-1 text-center font-semibold text-body md:my-0 dark:text-white"
						>
							<p>{app.type}</p>
							<!-- eslint-disable svelte/no-navigation-without-resolve -->
							<a
								href={app.link}
								target={app.type === 'Web' ? null : '_blank'}
								rel={app.type === 'Web' ? null : 'noreferrer'}
								aria-label={app.type === 'Web' ? 'Open web app' : `Download for ${app.type}`}
								class="block rounded-full bg-link p-3 text-white transition-colors hover:bg-hover"
							>
								<!-- eslint-enable svelte/no-navigation-without-resolve -->
								<IconApps
									w="32"
									h="32"
									class={app.icon === 'play' ? 'pl-0.5' : ''}
									icon={app.icon}
								/>
							</a>
						</div>
					{/each}
				</div>
				<h2 class="text-center text-xl font-semibold text-primary xl:text-left dark:text-white">
					We use
					<a
						href="https://www.openstreetmap.org/about"
						target="_blank"
						rel="noreferrer"
						class="text-link transition-colors hover:text-hover">OpenStreetMap</a
					>
					to tag places that accept bitcoin and we display those merchants in our beautiful apps.
					<br /><br />
					Our apps and the underlying data are free and open source.
					<br /><br />
					#SPEDN âœŠ
				</h2>
			</div>
			{#if typeof window !== 'undefined'}
				<a href={resolve('/map')}>
					<img
						src={detectTheme() === 'dark' || $theme === 'dark'
							? '/images/hero-mobile-example-dark.webp'
							: '/images/hero-mobile-example.webp'}
						alt="mobile example"
						class="mx-auto mt-10 w-80 drop-shadow-2xl xl:mx-0 xl:mt-0"
					/>
				</a>
			{/if}
		</section>

		<Footer />
	</div>
</div>

{#if typeof window !== 'undefined'}
	{#if detectTheme() === 'dark' || $theme === 'dark'}
		<style>
			@media (min-width: 1280px) {
				.street-map {
					background-image: url(/images/street-map-dark.svg);
				}
			}
		</style>
	{:else}
		<style>
			@media (min-width: 1280px) {
				.street-map {
					background-image: url(/images/street-map.svg);
				}
			}
		</style>
	{/if}
{/if}

<style>
	@media (min-width: 1280px) {
		.street-map {
			background-position: right;
			background-repeat: no-repeat;
			background-size: 65%;
		}
	}
</style>



================================================
FILE: src/routes/about-us/+page.svelte
================================================
<script lang="ts">
	import AboutCommunity from './components/AboutCommunity.svelte';
	import AboutContributor from './components/AboutContributor.svelte';
	import AboutCore from './components/AboutCore.svelte';
	import AboutIntegration from './components/AboutIntegration.svelte';
	import AboutMerchant from './components/AboutMerchant.svelte';
	import AboutPlus from './components/AboutPlus.svelte';
	import AboutTagger from './components/AboutTagger.svelte';
	import {
		areaError,
		areas,
		placesError,
		places,
		eventError,
		events,
		excludeLeader,
		userError,
		users
	} from '$lib/store';
	import { areasSync } from '$lib/sync/areas';
	import { eventsSync } from '$lib/sync/events';
	import { reportsSync } from '$lib/sync/reports';
	import { usersSync } from '$lib/sync/users';
	import { batchSync } from '$lib/sync/batchSync';
	import { resolve } from '$app/paths';
	import type { SocialIconName } from '$lib/icons/types';
	import type { Area, Place } from '$lib/types';
	import { errToast, formatElementID } from '$lib/utils';
	import { onMount } from 'svelte';

	onMount(() => {
		batchSync([eventsSync, usersSync, areasSync, reportsSync]);
	});

	// alert for all errors
	$: {
		if ($placesError) errToast($placesError);
		if ($userError) errToast($userError);
		if ($eventError) errToast($eventError);
		if ($areaError) errToast($areaError);
	}

	let dataInitalized = false;

	let merchants: Place[] = [];
	let communities: Area[] = [];

	const fetchMerchantName = async (placeId: number): Promise<string> => {
		try {
			const response = await fetch(`https://api.btcmap.org/v4/places/${placeId}?fields=name`);
			if (!response.ok) throw new Error('API call failed');
			const data = await response.json();
			return data.name || formatElementID(`node:${placeId}`);
		} catch {
			return formatElementID(`node:${placeId}`);
		}
	};

	const initializeData = async () => {
		const boostedMerchants = $places
			.filter((place: Place) => place.boosted_until)
			.sort(
				(a: Place, b: Place) =>
					Date.parse(b.boosted_until || '0') - Date.parse(a.boosted_until || '0')
			)
			.slice(0, 6);

		// Fetch names for merchants
		const merchantPromises = boostedMerchants.map(async (merchant: Place) => {
			const name = await fetchMerchantName(merchant.id);
			return { ...merchant, name };
		});

		try {
			merchants = await Promise.all(merchantPromises);
		} catch (error) {
			console.error('Error fetching merchant names:', error);
			// Fallback: use merchants without names
			merchants = boostedMerchants;
		}

		populateLeaderboard();

		communities = $areas.filter((area) => featuredCommunities.includes(area.id));
	};

	// Initialize data when all stores are loaded
	$: if (
		$places?.length &&
		$users?.length &&
		$events?.length &&
		$areas?.length &&
		!dataInitalized
	) {
		initializeData();
		dataInitalized = true;
	}

	let supertaggers: { id: number; username: string; avatar: string; total: number }[] = [];

	const populateLeaderboard = () => {
		$users.forEach((user) => {
			if ($excludeLeader.includes(user.id)) {
				return;
			}

			let userEvents = $events.filter((event) => event['user_id'] == user.id);

			if (userEvents.length) {
				let id = user.id;
				let username = user['osm_json'].display_name;
				let avatar = user['osm_json'].img
					? user['osm_json'].img.href
					: '/images/satoshi-nakamoto.png';

				supertaggers.push({
					id,
					username,
					avatar,
					total: id === 17221642 ? userEvents.length + 120 : userEvents.length
				});
			}
		});

		supertaggers.sort((a, b) => b.total - a.total);
		supertaggers = supertaggers.slice(0, 6);
	};

	const featuredCommunities = [
		'bitcoin-island-philippines',
		'btc-curacao',
		'bitcoin-beach',
		'bitcoin-ekasi',
		'einundzwanzig-deutschland',
		'free-madeira'
	];

	const communityIntegrations = [
		{ name: 'Coinos', icon: 'coinos', url: 'https://coinos.io/' },
		{ name: 'Wallet of Satoshi', icon: 'wos', url: 'https://www.walletofsatoshi.com/' },
		{ name: 'Pouch', icon: 'pouch', url: 'https://pouch.ph/' },
		{ name: 'Bolt Card', icon: 'bolt', url: 'https://www.boltcard.org/' },
		{ name: 'Galoy', icon: 'galoy', url: 'https://galoy.io/' },
		{ name: 'Satimoto', icon: 'satimoto', url: 'https://satimoto.com/' },
		{
			name: 'Bitcoin Dashboard',
			icon: 'dashboard',
			url: 'https://bitcoin-primodata.streamlit.app/'
		},
		{ name: 'BitLocal', icon: 'bitlocal', url: 'https://www.bitlocal.app/' },
		{ name: 'Nostr Bot', icon: 'nostr-bot', url: 'https://github.com/BcnBitcoinOnly/btcmap-bot' },
		{ name: 'Fedi', icon: 'fedi', url: 'https://www.fedi.xyz/' },
		{ name: 'Osmo', icon: 'osmo', url: 'https://www.osmowallet.com/' },
		{ name: 'Bitcoin Rocks!', icon: 'bitcoin-rocks', url: 'https://bitcoin.rocks/' },
		{ name: 'lipa', icon: 'lipa', url: 'https://lipa.swiss/' },
		{ name: 'Spirit of Satoshi', icon: 'spirit', url: 'https://www.spiritofsatoshi.ai/' },
		{ name: 'Blockstream', icon: 'blockstream', url: 'https://blockstream.com/local/' },
		{ name: 'Satlantis', icon: 'satlantis', url: 'https://www.satlantis.io/' },
		{ name: 'Aqua Wallet', icon: 'aqua', url: 'https://aquawallet.io/' },
		{ name: 'Adopting Bitcoin', icon: 'adopting', url: 'https://www.adoptingbitcoin.org/' }
	];

	const projectIntegrations = [
		{ name: 'OpenStreetMap', icon: 'osm', url: 'https://www.openstreetmap.org/' },
		{ name: 'LNbits', icon: 'lnbits', url: 'https://lnbits.com/' },
		{ name: 'GitHub', icon: 'gh', url: 'https://github.com/' },
		{ name: 'Voltage', icon: 'voltage', url: 'https://voltage.cloud/' },
		{ name: 'Leaflet', icon: 'leaflet', url: 'https://leafletjs.com/' },
		{ name: 'Chart.js', icon: 'chartjs', url: 'https://www.chartjs.org/' }
	];

	const contributors = [
		{
			name: 'salvanakamoto',
			title: 'iOS Developer',
			url: 'https://github.com/salvatoto',
			file: 'jpg'
		},
		{
			name: 'saunter',
			title: 'Community Leader',
			url: 'https://twitter.com/StackingSaunter',
			file: 'jpg'
		},
		{
			name: 'Rogzy',
			title: 'Community Leader',
			url: 'https://twitter.com/DecouvreBitcoin',
			file: 'jpg'
		},
		{
			name: 'HolgerHatGarKeineNode',
			title: 'Community Coder',
			url: 'https://github.com/HolgerHatGarKeineNode',
			file: 'jpeg'
		},
		{
			name: '3j2009',
			title: 'Designer',
			url: 'https://github.com/3j2009',
			file: 'jpeg'
		},
		{
			name: 'Liam',
			title: 'Animator',
			url: 'https://twitter.com/LiamCyDennis',
			file: 'jpg'
		},
		{
			name: 'Andrej',
			title: 'Icon Designer',
			url: 'https://nostr.com/npub1cak3t8wa5zaxe99mfrzqzt8h2hp0lvalk8agj3qmthkmrs3zvlaqyt964v',
			file: 'png'
		}
	];

	const coreTeam: {
		name: string;
		title: string;
		avatar: string;
		socials: { url: string; name: SocialIconName }[];
	}[] = [
		{
			name: 'Igor',
			title: 'Backend & Android',
			avatar: 'igor',
			socials: [
				{ url: 'https://bubelov.com/', name: 'website' },
				{ url: 'https://github.com/bubelov', name: 'github' }
			]
		},
		{
			name: 'Nathan Day',
			title: 'Project Manager',
			avatar: 'nathan',
			socials: [
				{ url: 'https://twitter.com/nathan_day', name: 'x' },
				{ url: 'https://github.com/dadofsambonzuki', name: 'github' }
			]
		},
		{
			name: 'secondl1ght',
			title: 'Web Developer',
			avatar: 'secondl1ght',
			socials: [
				{ url: 'https://secondl1ght.site', name: 'website' },
				{ url: 'https://twitter.com/secondl1ght', name: 'x' },
				{ url: 'https://github.com/secondl1ght', name: 'github' }
			]
		},
		{
			name: 'Karnage',
			title: 'Lead Designer',
			avatar: 'karnage',
			socials: [
				{ url: 'https://twitter.com/KarnageBitcoin', name: 'x' },
				{ url: 'https://github.com/cogentgene', name: 'github' }
			]
		}
	];
</script>

<svelte:head>
	<title>BTC Map - About</title>
	<meta property="og:image" content="https://btcmap.org/images/og/home.png" />
	<meta property="twitter:title" content="BTC Map - About" />
	<meta property="twitter:image" content="https://btcmap.org/images/og/home.png" />
</svelte:head>

<main class="mt-10 mb-20 space-y-20 text-primary md:space-y-40 dark:text-white">
	<div class="space-y-5 text-center text-xl">
		<h1 class="text-4xl !leading-tight font-semibold md:text-5xl">About Us</h1>
		<p class="mx-auto md:w-[600px]">
			BTC Map is a free and open source project powered by volunteer bitcoiners and bitcoin-friendly
			merchants around the world.
		</p>
	</div>

	<section class="w-full justify-center space-y-10 lg:flex lg:space-y-0 lg:space-x-10">
		<div class="lg:w-[475px]">
			<h2 class="mb-5 text-3xl font-semibold">Merchants</h2>

			<div class="space-y-5">
				<p>
					Merchants are at the heart of BTC Map. These businesses are front-running the paradigm
					change and positioning themselves for continued success. Any merchant who accepts bitcoin
					can be listed on BTC Map.
				</p>
				<p>
					<strong>Accept bitcoin?</strong>
					<a
						href={resolve('/add-location')}
						class="font-semibold text-link transition-colors hover:text-hover"
						>Get listed on BTC Map</a
					>!
				</p>
			</div>
		</div>

		<div class="flex grid-cols-3 flex-wrap justify-center gap-5 lg:grid">
			{#if merchants.length}
				{#each merchants as merchant (merchant.id)}
					<AboutMerchant id={merchant.id.toString()} icon={merchant.icon} tooltip={merchant.name} />
				{/each}
			{:else}
				{#each Array(6) as _, index (index)}
					<span class="h-24 w-24 animate-pulse rounded-full bg-link/50" />
				{/each}
			{/if}
		</div>
	</section>

	<section class="w-full space-y-10 rounded-xl bg-[#164E63] p-5 text-center text-white md:p-10">
		<h2 class="text-3xl font-semibold">Shadowy Supertaggers</h2>

		<p class="mx-auto lg:w-[650px]">
			Shadowy Supertaggers are people who power this project. They are volunteers who selflessly
			take the time to update business locations with new information. Without them, BTC Map would
			not be sustainable!
		</p>

		<div class="space-y-5">
			<p class="font-semibold uppercase">Our top supertaggers</p>

			<div class="flex flex-wrap justify-center gap-5">
				{#if supertaggers.length}
					{#each supertaggers.map((t) => ({ ...t, total: undefined })) as tagger (tagger.id)}
						<AboutTagger {tagger} />
					{/each}
				{:else}
					{#each Array(6) as _, index (index)}
						<span class="h-24 w-24 animate-pulse rounded-full bg-link/50" />
					{/each}
				{/if}
			</div>

			<a
				href={resolve('/leaderboard')}
				class="inline-block font-semibold underline underline-offset-4 hover:no-underline"
				>View leaderboard</a
			>
		</div>
	</section>

	<section class="w-full justify-center space-y-10 lg:flex lg:space-y-0 lg:space-x-10">
		<div class="lg:w-[475px]">
			<h2 class="mb-5 text-3xl font-semibold">Communities</h2>

			<div class="space-y-5">
				<p>Bitcoin communities help drive global adoption by onboarding new users locally!</p>
				<p>
					<strong>Donâ€™t see your community?</strong>
					<a
						href={resolve('/communities/add')}
						class="font-semibold text-link transition-colors hover:text-hover">Add it to BTC Map</a
					>.
				</p>
			</div>
		</div>

		<div>
			<div class="flex grid-cols-3 flex-wrap justify-center gap-5 lg:grid">
				{#if communities.length}
					{#each communities as community (community.id)}
						<AboutCommunity {community} />
					{/each}
				{:else}
					{#each Array(6) as _, index (index)}
						<span class="h-24 w-24 animate-pulse rounded-full bg-link/50" />
					{/each}
				{/if}
			</div>

			<div class="mt-5 flex justify-center">
				<a
					href={resolve('/communities')}
					class="font-semibold text-link transition-colors hover:text-hover">See all communities</a
				>
			</div>
		</div>
	</section>

	<section
		class="w-full space-y-10 rounded-xl bg-[#F1F7FC] p-5 text-center md:p-10 dark:bg-white/[0.15]"
	>
		<h2 class="text-3xl font-semibold">Integrations</h2>

		<p class="font-semibold uppercase">
			Community integrations <span class="block text-sm font-normal normal-case"
				>Projects using BTC Map</span
			>
		</p>

		<div class="flex flex-wrap justify-center gap-10">
			{#each communityIntegrations as integration (integration.url)}
				<AboutIntegration {integration} />
			{/each}
			<AboutPlus />
		</div>

		<p class="font-semibold uppercase">
			Project integrations <span class="block text-sm font-normal normal-case"
				>BTC Map uses these projects</span
			>
		</p>

		<div class="flex flex-wrap justify-center gap-10">
			{#each projectIntegrations as integration (integration.url)}
				<AboutIntegration {integration} />
			{/each}
			<AboutPlus />
		</div>

		<p>
			If you are interested in integrating with us please <a
				href="mailto:hello@btcmap.org"
				class="font-semibold text-link transition-colors hover:text-hover">reach out</a
			>!
		</p>
	</section>

	<section class="w-full justify-center space-y-10 lg:flex lg:space-y-0 lg:space-x-10">
		<div class="lg:w-[475px]">
			<h2 class="mb-5 text-3xl font-semibold">Contributors</h2>

			<p>
				Anybody can contribute to BTC Map in many different ways. If you would like to get involved
				please don't hesitate and come join the fun!
			</p>
		</div>

		<div class="flex grid-cols-3 flex-wrap justify-center gap-5 lg:grid">
			{#each contributors as contributor (contributor.url)}
				<AboutContributor {contributor} />
			{/each}
		</div>
	</section>

	<section
		class="w-full justify-center space-y-10 rounded-xl bg-[#EBEFF2] p-5 md:p-10 lg:flex lg:space-y-0 lg:space-x-10 dark:bg-white/[0.15]"
	>
		<div class="lg:w-[475px]">
			<h2 class="mb-10 text-3xl font-semibold">Core Team</h2>

			<div class="space-y-10">
				<p>
					<strong>Igor</strong> is a long time bitcoiner, mapper, and digital nomad living abroad. He
					created BTC Map as an Android application and the project has since gained worldwide momentum
					from there. He now also maintains all of the backend infrastructure for the project.
				</p>
				<p>
					<strong>Nathan</strong> is a tech entrepreneur turned pleb-at-large. He brought the core team
					together to accelerate app development. Having built, sold, invested in and advised tech businesses
					over the years he is now focused on bitcoin, building BTCMap.org, gamertron.net and delivering
					bitcoin education for kids.
				</p>
				<p>
					A self-taught Web Developer, <strong>secondl1ght</strong> dove head first down the bitcoin rabbit
					hole and left his fiat career to focus on bitcoin development full-time. He created and maintains
					the BTC Map web application, as well as an encrypted messaging app called Cipherchat, and works
					on lightning network tools at Amboss Technologies.
				</p>
				<p>
					<strong>Karnage</strong> is the lead designer on the web app and created the BTC Map brand.
					He has contributed to many high profile bitcoin open source projects. His mission is to help
					startup founders succeed and creates products to achieve this goal. Pixel-perfect product design
					every time. Get it shipped.
				</p>
			</div>
		</div>

		<div class="flex grid-cols-2 flex-wrap items-center justify-center gap-10 lg:grid">
			{#each coreTeam as member (member.name)}
				<AboutCore {member} />
			{/each}
		</div>
	</section>
</main>



================================================
FILE: src/routes/about-us/components/AboutCommunity.svelte
================================================
<script lang="ts">
	import type { Area } from '$lib/types';
	import tippy from 'tippy.js';
	import { resolve } from '$app/paths';

	export let community: Area;

	let communityTooltip: HTMLAnchorElement;

	$: communityTooltip &&
		tippy([communityTooltip], {
			content: community.tags.name
		});
</script>

<a bind:this={communityTooltip} href={resolve(`/community/${community.id}`)}>
	<img
		src={`https://btcmap.org/.netlify/images?url=${community.tags['icon:square']}&fit=cover&w=256&h=256`}
		alt="avatar"
		class="h-24 w-24 rounded-full object-cover"
		on:error={function () {
			this.src = '/images/bitcoin.svg';
		}}
	/>
</a>



================================================
FILE: src/routes/about-us/components/AboutContributor.svelte
================================================
<script lang="ts">
	export let contributor: { url: string; name: string; file: string; title: string };
</script>

<!-- eslint-disable svelte/no-navigation-without-resolve -->
<a
	href={contributor.url}
	target="_blank"
	rel="noreferrer"
	class="space-y-2 text-center transition-colors hover:text-link"
>
	<!-- eslint-enable svelte/no-navigation-without-resolve -->
	<img
		src="/images/contributors/{contributor.name}.{contributor.file}"
		alt="avatar"
		class="mx-auto h-24 w-24 rounded-full object-cover"
		on:error={function () {
			this.src = '/images/satoshi-nakamoto.png';
		}}
	/>

	<div>
		<p class="font-semibold">{contributor.name}</p>
		<p>{contributor.title}</p>
	</div>
</a>



================================================
FILE: src/routes/about-us/components/AboutCore.svelte
================================================
<script lang="ts">
	import type { SocialIconName } from '$lib/icons/types';
	import IconSocials from '$lib/icons/IconSocials.svelte';

	export let member: {
		avatar: string;
		name: string;
		title: string;
		socials: { url: string; name: SocialIconName }[];
	};
</script>

<div class="space-y-2 text-center">
	<img
		src="/images/team/{member.avatar}.jpg"
		alt="avatar"
		class="mx-auto h-28 w-28 rounded-full object-cover"
		on:error={function () {
			this.src = '/images/satoshi-nakamoto.png';
		}}
	/>

	<div>
		<p class="font-semibold">{member.name}</p>
		<p>{member.title}</p>
	</div>

	<div class="flex justify-center space-x-2">
		{#each member.socials as social (social.url)}
			<!-- eslint-disable svelte/no-navigation-without-resolve -->
			<a
				href={social.url}
				target="_blank"
				rel="noreferrer"
				class="inline-block rounded-full bg-[#AFBBC9] p-2 text-white transition-opacity hover:opacity-80"
			>
				<!-- eslint-enable svelte/no-navigation-without-resolve -->
				<IconSocials w="16" h="16" icon={social.name} />
			</a>
		{/each}
	</div>
</div>



================================================
FILE: src/routes/about-us/components/AboutIntegration.svelte
================================================
<script lang="ts">
	export let integration: { url: string; icon: string; name: string };
</script>

<div class="space-y-2">
	<!-- eslint-disable svelte/no-navigation-without-resolve -->
	<a
		href={integration.url}
		target="_blank"
		rel="noreferrer"
		class="space-y-2 transition-colors hover:text-link"
	>
		<!-- eslint-enable svelte/no-navigation-without-resolve -->
		<img
			src="/images/integrations/{integration.icon}{integration.icon === 'voltage' ||
			integration.icon === 'adopting'
				? '.png'
				: '.jpg'}"
			alt="logo"
			class="mx-auto h-24 w-24 rounded-full object-cover"
			on:error={function () {
				this.src = '/images/bitcoin.svg';
			}}
		/>

		<p class="text-center font-semibold">{integration.name}</p>
	</a>
	{#if integration.name === 'OpenStreetMap'}
		<a
			href="https://wiki.osmfoundation.org/wiki/Corporate_Members#Supporter_Corporate_Members"
			target="_blank"
			rel="noreferrer"
			class="mx-auto block w-32 rounded-full bg-link py-1 text-xs font-semibold text-white transition-colors hover:bg-hover"
		>
			Supporter
		</a>
	{/if}
</div>



================================================
FILE: src/routes/about-us/components/AboutMerchant.svelte
================================================
<script lang="ts">
	import Icon from '$components/Icon.svelte';
	import tippy from 'tippy.js';
	import { resolve } from '$app/paths';

	export let id: string;
	export let icon: string;
	export let tooltip: string | undefined;

	let merchantTooltip: HTMLAnchorElement;

	$: merchantTooltip &&
		tooltip &&
		tooltip.length &&
		tippy([merchantTooltip], {
			content: tooltip
		});
</script>

<a
	bind:this={merchantTooltip}
	href={resolve(`/merchant/${id}`)}
	class="flex h-24 w-24 items-center justify-center rounded-full bg-bitcoin hover:animate-wiggle"
>
	<Icon
		w="40"
		h="40"
		class="text-white"
		icon={icon !== 'question_mark' ? icon : 'currency_bitcoin'}
		type="material"
	/>
</a>



================================================
FILE: src/routes/about-us/components/AboutPlus.svelte
================================================
<script lang="ts">
	import Icon from '$components/Icon.svelte';
</script>

<div class="space-y-2">
	<div class="mx-auto flex h-24 w-24 items-center justify-center rounded-full bg-link">
		<Icon type="fa" icon="circle-plus" w="40" h="40" class="text-white" />
	</div>

	<p class="text-center font-semibold">More!</p>
</div>



================================================
FILE: src/routes/about-us/components/AboutTagger.svelte
================================================
<script lang="ts">
	import tippy from 'tippy.js';
	import { resolve } from '$app/paths';

	export let tagger: { id: number; avatar: string; username: string };

	let taggerTooltip: HTMLAnchorElement;

	$: taggerTooltip &&
		tippy([taggerTooltip], {
			content: tagger.username
		});
</script>

<a bind:this={taggerTooltip} href={resolve(`/tagger/${tagger.id}`)}>
	<img
		src={tagger.avatar}
		alt="avatar"
		class="h-24 w-24 rounded-full bg-black object-cover"
		on:error={function () {
			this.src = '/images/satoshi-nakamoto.png';
		}}
	/>
</a>



================================================
FILE: src/routes/activity/+page.svelte
================================================
<script lang="ts">
	import HeaderPlaceholder from '$components/layout/HeaderPlaceholder.svelte';
	import LatestTagger from '$components/LatestTagger.svelte';
	import TaggerSkeleton from '$components/TaggerSkeleton.svelte';
	import TopButton from '$components/TopButton.svelte';
	import { placesError, eventError, events, syncStatus, theme, userError, users } from '$lib/store';
	import { eventsSync } from '$lib/sync/events';
	import { usersSync } from '$lib/sync/users';
	import { batchSync } from '$lib/sync/batchSync';
	import type { ActivityEvent, Event, User } from '$lib/types';
	import { detectTheme, errToast, formatElementID } from '$lib/utils';
	import { onMount } from 'svelte';

	onMount(() => {
		batchSync([eventsSync, usersSync]);
	});

	// alert for user errors
	$: $userError && errToast($userError);
	// alert for event errors
	$: $eventError && errToast($eventError);
	// alert for element errors
	$: $placesError && errToast($placesError);

	let elementsLoading: boolean;
	let supertaggers: ActivityEvent[];

	const findUser = (tagger: Event) => {
		let foundUser = $users.find((user) => user.id == tagger['user_id']);
		if (foundUser) {
			return foundUser;
		} else {
			return undefined;
		}
	};

	const fetchMerchantName = async (elementId: string): Promise<string> => {
		try {
			const response = await fetch(`https://api.btcmap.org/v2/elements/${elementId}`);
			if (!response.ok) throw new Error('API call failed');
			const data = await response.json();
			return data.osm_json?.tags?.name || formatElementID(elementId);
		} catch {
			return formatElementID(elementId);
		}
	};

	const supertaggerSync = async (status: boolean, users: User[], events: Event[]) => {
		if (events.length && users.length && !status) {
			let recentEvents = events
				.sort((a, b) => Date.parse(b['created_at']) - Date.parse(a['created_at']))
				.slice(0, 50);

			elementsLoading = true;
			supertaggers = [];

			// Fetch merchant names concurrently
			const supertaggerPromises = recentEvents.map(async (event) => {
				const location = await fetchMerchantName(event['element_id']);
				const tagger = findUser(event);

				return {
					...event,
					location,
					merchantId: event['element_id'],
					tagger
				};
			});

			try {
				supertaggers = await Promise.all(supertaggerPromises);
			} catch (error) {
				console.error('Error fetching merchant names:', error);
				// Fallback: create entries with element IDs only
				supertaggers = recentEvents.map((event) => ({
					...event,
					location: formatElementID(event['element_id']),
					merchantId: event['element_id'],
					tagger: findUser(event)
				}));
			}

			elementsLoading = false;
		}
	};

	$: supertaggerSync($syncStatus, $users, $events);

	$: latestTaggers = supertaggers && supertaggers.length && !elementsLoading ? true : false;
</script>

<svelte:head>
	<title>BTC Map - Activity</title>
	<meta property="og:image" content="https://btcmap.org/images/og/activity.png" />
	<meta property="twitter:title" content="BTC Map - Activity" />
	<meta property="twitter:image" content="https://btcmap.org/images/og/activity.png" />
</svelte:head>

<main class="mt-10 mb-20 space-y-10">
	{#if typeof window !== 'undefined'}
		<h1
			class="{detectTheme() === 'dark' || $theme === 'dark'
				? 'text-white'
				: 'gradient'} text-center text-4xl !leading-tight font-semibold text-primary md:text-5xl lg:text-left dark:text-white"
		>
			Activity
		</h1>
	{:else}
		<HeaderPlaceholder />
	{/if}

	<h2
		class="w-full text-center text-xl font-semibold text-primary lg:w-[675px] lg:text-left dark:text-white"
	>
		Shadowy Supertaggers donâ€™t sleep. They are up all night, tagging away. The world we want is a
		tag away.
	</h2>

	<p class="text-center text-xl text-primary lg:text-left dark:text-white">
		You too can be a shadowy supertagging legend! What are you waiting for? <a
			href="https://gitea.btcmap.org/teambtcmap/btcmap-general/wiki/Tagging-Merchants#shadowy-supertaggers-"
			class="text-link transition-colors hover:text-hover">Get tagginâ€™!</a
		>
	</p>

	<section id="taggers">
		<div class="w-full rounded-3xl border border-gray-300 dark:border-white/95 dark:bg-white/10">
			<h3
				class="border-b border-gray-300 p-5 text-center text-2xl font-semibold text-primary lg:text-left dark:border-white/95 dark:text-white"
			>
				Latest Supertaggers
			</h3>

			<div class="space-y-5">
				{#if latestTaggers}
					{#each supertaggers as tagger (tagger['created_at'])}
						<LatestTagger
							location={tagger.location}
							action={tagger.type}
							user={tagger.tagger}
							time={tagger['created_at']}
							latest={tagger === supertaggers[0] ? true : false}
							merchantId={tagger.merchantId}
						/>
					{/each}
				{:else}
					{#each Array(50) as _, index (index)}
						<TaggerSkeleton />
					{/each}
				{/if}
			</div>
		</div>
		<p class="text-center text-sm text-body lg:text-left dark:text-white">
			*Data updated every 10 minutes
		</p>
		<div class="mt-10 flex justify-center">
			<TopButton />
		</div>
	</section>
</main>



================================================
FILE: src/routes/add-location/+page.svelte
================================================
<script lang="ts">
	import { browser } from '$app/environment';
	import FormSuccess from '$components/FormSuccess.svelte';
	import HeaderPlaceholder from '$components/layout/HeaderPlaceholder.svelte';
	import Icon from '$components/Icon.svelte';
	import InfoTooltip from '$components/InfoTooltip.svelte';
	import MapLoadingEmbed from '$components/MapLoadingEmbed.svelte';
	import PrimaryButton from '$components/PrimaryButton.svelte';
	import { loadMapDependencies } from '$lib/map/imports';
	import { attribution, changeDefaultIcons, geolocate } from '$lib/map/setup';
	import { theme } from '$lib/store';
	import { detectTheme, errToast } from '$lib/utils';

	import axios from 'axios';

	import type { Map, MaplibreGL, Marker } from 'leaflet';
	import { onDestroy, onMount, tick } from 'svelte';
	import DOMPurify from 'dompurify';

	let captchaContent = '';
	let isCaptchaLoading = true;
	let captchaSecret: string;
	let captchaInput: HTMLInputElement;
	let honeyInput: HTMLInputElement;

	const fetchCaptcha = () => {
		isCaptchaLoading = true;
		axios
			.get('/captcha')
			.then(function (response) {
				captchaSecret = response.data.captchaSecret;
				captchaContent = DOMPurify.sanitize(response.data.captcha);
			})
			.catch(function (error) {
				errToast('Could not fetch captcha, please try again or contact BTC Map.');
				console.error(error);
			})
			.finally(() => {
				isCaptchaLoading = false;
			});
	};

	function resetForm() {
		submitted = false;
		submitting = false;
		methods = [];
		selected = false;
		noLocationSelected = false;
		noMethodSelected = false;
		lat = undefined;
		long = undefined;
		source = undefined;
		sourceOther = undefined;

		// Wait for the DOM to update with the form back in place
		tick().then(async () => {
			// Clear form fields
			if (name) name.value = '';
			if (address) address.value = '';
			if (category) category.value = '';
			if (website) website.value = '';
			if (phone) phone.value = '';
			if (hours) hours.value = '';
			if (notes) notes.value = '';
			if (contact) contact.value = '';
			if (captchaInput) captchaInput.value = '';
			if (onchain) onchain.checked = false;
			if (lightning) lightning.checked = false;
			if (nfc) nfc.checked = false;

			// Refresh captcha
			fetchCaptcha();

			// Reinitialize the map
			await initializeMap();
		});
	}

	/**
	 * Initialize the map with all required settings and controls
	 */
	async function initializeMap() {
		const deps = await loadMapDependencies();
		const leaflet = deps.leaflet;
		const DomEvent = deps.DomEvent;
		const LocateControl = deps.LocateControl;

		// Create map instance
		if (map) map.remove(); // Clean up any existing map
		map = leaflet.map(mapElement, { attributionControl: false, maxZoom: 19 }).setView([0, 0], 2);

		// Create map styles
		openFreeMapLiberty = window.L.maplibreGL({
			style: 'https://tiles.openfreemap.org/styles/liberty'
		});

		openFreeMapDark = window.L.maplibreGL({
			style: 'https://static.btcmap.org/map-styles/dark.json'
		});

		// Apply appropriate theme
		const currentTheme = $theme || detectTheme();

		if (currentTheme === 'dark') {
			openFreeMapDark.addTo(map);
		} else {
			openFreeMapLiberty.addTo(map);
		}

		// Add marker on click
		let marker: Marker;
		map.on('click', (e) => {
			if (captchaSecret) {
				lat = e.latlng.lat;
				long = e.latlng.lng;

				if (marker) {
					map.removeLayer(marker);
				}

				marker = leaflet.marker([lat, long]).addTo(map);
				selected = true;
			}
		});

		// Add map controls and settings
		try {
			geolocate(leaflet, map, LocateControl);
		} catch (e) {
			console.error('Error adding locate control:', e);
		}

		changeDefaultIcons(false, leaflet, mapElement, DomEvent);
		attribution(leaflet, map);

		// Force a resize to ensure proper rendering
		map.invalidateSize();

		mapLoaded = true;
		return leaflet; // Return leaflet for any additional setup
	}

	let name: HTMLInputElement;
	let address: HTMLInputElement;
	let lat: number | undefined = undefined;
	let long: number | undefined = undefined;
	let selected = false;
	let category: HTMLInputElement;
	let methods: ('onchain' | 'lightning' | 'nfc')[] = [];
	let onchain: HTMLInputElement;
	let lightning: HTMLInputElement;
	let nfc: HTMLInputElement;
	let website: HTMLInputElement;
	let phone: HTMLInputElement;
	let hours: HTMLInputElement;
	let notes: HTMLTextAreaElement;
	let contact: HTMLInputElement;
	let source: 'Business Owner' | 'Customer' | 'Other' | undefined = undefined;
	let sourceOther: string | undefined = undefined;
	let sourceOtherElement: HTMLTextAreaElement;
	let noLocationSelected = false;
	let noMethodSelected = false;
	let submitted = false;
	let submitting = false;
	let submissionIssueNumber: number;

	const handleCheckboxClick = () => {
		noMethodSelected = false;
	};

	$: latFixed = lat && lat.toFixed(5);
	$: longFixed = long && long.toFixed(5);

	const submitForm = (event: SubmitEvent) => {
		event.preventDefault();
		if (!selected) {
			noLocationSelected = true;
			errToast('Please select a location...');
		} else if (!onchain.checked && !lightning.checked && !nfc.checked) {
			noMethodSelected = true;
			errToast('Please select at least one payment method...');
		} else {
			submitting = true;
			if (onchain.checked) {
				methods.push('onchain');
			}
			if (lightning.checked) {
				methods.push('lightning');
			}
			if (nfc.checked) {
				methods.push('nfc');
			}

			axios
				.post('/add-location/endpoint', {
					captchaSecret,
					captchaTest: captchaInput.value,
					honey: honeyInput.value,
					name: name.value,
					address: address.value,
					lat: lat ? lat.toString() : '',
					long: long ? long.toString() : '',
					osm: lat && long ? `https://www.openstreetmap.org/edit#map=21/${lat}/${long}` : '',
					category: category.value,
					methods: methods.toString(),
					website: website.value,
					phone: phone.value,
					hours: hours.value,
					notes: notes.value,
					source,
					sourceOther: sourceOther ? sourceOther : '',
					contact: contact.value
				})
				.then(function (response) {
					submissionIssueNumber = response.data.number;
					submitted = true;
				})
				.catch(function (error) {
					methods = [];
					if (error.response.data.message.includes('Captcha')) {
						errToast(error.response.data.message);
					} else {
						errToast('Form submission failed, please try again or contact BTC Map.');
					}
					console.error(error);
					submitting = false;
				});
		}
	};

	// location picker map
	let mapElement: HTMLDivElement;
	let map: Map;
	let mapLoaded = false;

	let openFreeMapLiberty: MaplibreGL;
	let openFreeMapDark: MaplibreGL;

	onMount(async () => {
		if (browser) {
			// fetch and add captcha
			fetchCaptcha();

			// Initialize the map
			await initializeMap();
		}
	});

	onDestroy(async () => {
		if (map) {
			console.info('Unloading Leaflet map.');
			map.remove();
		}
	});

	const toggleTheme = () => {
		if ($theme === 'dark') {
			openFreeMapLiberty.remove();
			openFreeMapDark.addTo(map);
		} else {
			openFreeMapDark.remove();
			openFreeMapLiberty.addTo(map);
		}
	};

	$: $theme !== undefined && mapLoaded === true && toggleTheme();
</script>

<svelte:head>
	<title>BTC Map - Add Location</title>
	<meta property="og:image" content="https://btcmap.org/images/og/add.png" />
	<meta property="twitter:title" content="BTC Map - Add Location" />
	<meta property="twitter:image" content="https://btcmap.org/images/og/add.png" />
</svelte:head>

{#if !submitted}
	{#if typeof window !== 'undefined'}
		<h1
			class="{detectTheme() === 'dark' || $theme === 'dark'
				? 'text-white'
				: 'gradient'} mt-10 text-center text-4xl font-semibold md:text-5xl"
		>
			Accept bitcoin? Get found.
		</h1>
	{:else}
		<HeaderPlaceholder />
	{/if}

	<p class="mt-10 text-center text-lg font-semibold text-primary md:text-xl dark:text-white">
		If you're a business owner, please read our <a
			href="https://gitea.btcmap.org/teambtcmap/btcmap-general/wiki/Merchant-Best-Practices"
			target="_blank"
			rel="noreferrer"
			class="text-link transition-colors hover:text-hover">Merchant Best Practices</a
		> guide.
	</p>

	<div class="mt-16 pb-20 md:pb-32 lg:flex lg:justify-between lg:gap-10">
		<section id="form" class="mx-auto w-full lg:w-1/2 lg:border-r lg:border-input lg:pr-10">
			<div class="mx-auto max-w-xl">
				<h2
					class="mb-5 text-center text-3xl font-semibold text-primary md:text-left dark:text-white"
				>
					Done-for-you
				</h2>

				<p class="mb-10 w-full text-justify text-primary dark:text-white">
					Fill out the following form and one of our volunteer community members will add your
					location to the map. <InfoTooltip
						tooltip="All additions are completed on a volunteer basis and so we can't guarantee when your location will be added."
					/>
				</p>

				<form on:submit={submitForm} class="w-full space-y-5 text-primary dark:text-white">
					<div>
						<label for="name" class="mb-2 block font-semibold">Merchant Name</label>
						<input
							disabled={!captchaSecret || !mapLoaded}
							type="text"
							name="name"
							id="name"
							placeholder="Satoshi's Comics"
							required
							class="w-full rounded-2xl border-2 border-input p-3 transition-all focus:outline-link disabled:cursor-not-allowed disabled:bg-gray-100 disabled:text-gray-500 dark:bg-white/[0.15] dark:disabled:bg-gray-700 dark:disabled:text-gray-400"
							bind:this={name}
						/>
					</div>

					<div>
						<label for="location-picker" class="mb-2 block font-semibold">Select Location</label>
						{#if selected}
							<span class="font-semibold text-green-500">Location selected!</span>
						{:else if noLocationSelected}
							<span class="font-semibold text-error">Please select a location...</span>
						{/if}
						<div class="relative mb-2">
							<div
								bind:this={mapElement}
								class="z-10 h-[300px] !cursor-crosshair rounded-2xl border-2 border-input !bg-teal md:h-[400px] dark:!bg-dark"
							/>
							{#if !mapLoaded}
								<MapLoadingEmbed style="h-[300px] md:h-[400px] border-2 border-input rounded-2xl" />
							{/if}
						</div>
						<div class="flex space-x-2">
							<!-- 	eslint-disable svelte/no-reactive-reassign -->
							<input
								required
								disabled
								bind:value={latFixed}
								readonly
								type="number"
								name="lat"
								placeholder="Latitude"
								class="w-full rounded-2xl border-2 border-input p-3 focus:outline-link disabled:cursor-not-allowed disabled:bg-gray-100 disabled:text-gray-500 dark:disabled:bg-gray-700 dark:disabled:text-gray-400"
							/>
							<input
								required
								disabled
								bind:value={longFixed}
								readonly
								type="number"
								name="long"
								placeholder="Longitude"
								class="w-full rounded-2xl border-2 border-input p-3 focus:outline-link disabled:cursor-not-allowed disabled:bg-gray-100 disabled:text-gray-500 dark:disabled:bg-gray-700 dark:disabled:text-gray-400"
							/>
							<!-- 	eslint-enable svelte/no-reactive-reassign -->
						</div>
					</div>

					<div>
						<label for="address" class="mb-2 block font-semibold"
							>Address (Optional) <InfoTooltip
								tooltip="All locations are required to have a physical
										presence. Optionally enter an address here if that makes sense where the merchant is located. Services without locations are not map-able."
							/></label
						>
						<input
							disabled={!captchaSecret || !mapLoaded}
							type="text"
							name="address"
							id="address"
							placeholder="2100 Freedom Drive..."
							class="w-full rounded-2xl border-2 border-input p-3 transition-all focus:outline-link disabled:cursor-not-allowed disabled:bg-gray-100 disabled:text-gray-500 dark:bg-white/[0.15] dark:disabled:bg-gray-700 dark:disabled:text-gray-400"
							bind:this={address}
						/>
					</div>

					<div>
						<label for="category" class="mb-2 block font-semibold">Category</label>
						<input
							disabled={!captchaSecret || !mapLoaded}
							type="text"
							name="category"
							id="category"
							placeholder="Restaurant etc."
							class="w-full rounded-2xl border-2 border-input p-3 transition-all focus:outline-link disabled:cursor-not-allowed disabled:bg-gray-100 disabled:text-gray-500 dark:bg-white/[0.15] dark:disabled:bg-gray-700 dark:disabled:text-gray-400"
							bind:this={category}
						/>
					</div>

					<fieldset>
						<legend class="mb-2 block font-semibold">Select accepted payment methods</legend>
						{#if noMethodSelected}
							<span class="font-semibold text-error">Please fix this...</span>
						{/if}
						<div class="space-y-4">
							<div>
								<input
									class="h-4 w-4 accent-link"
									disabled={!captchaSecret || !mapLoaded}
									type="checkbox"
									name="onchain"
									id="onchain"
									bind:this={onchain}
									on:click={handleCheckboxClick}
								/>
								<label for="onchain" class="ml-1 cursor-pointer">
									{#if typeof window !== 'undefined'}
										<img
											src={detectTheme() === 'dark' || $theme === 'dark'
												? '/icons/btc-highlight-dark.svg'
												: '/icons/btc-primary.svg'}
											alt="onchain"
											class="inline"
										/>
									{/if}
									On-chain
								</label>
							</div>
							<div>
								<input
									class="h-4 w-4 accent-link"
									disabled={!captchaSecret || !mapLoaded}
									type="checkbox"
									name="lightning"
									id="lightning"
									bind:this={lightning}
									on:click={handleCheckboxClick}
								/>
								<label for="lightning" class="ml-1 cursor-pointer">
									{#if typeof window !== 'undefined'}
										<img
											src={detectTheme() === 'dark' || $theme === 'dark'
												? '/icons/ln-highlight-dark.svg'
												: '/icons/ln-primary.svg'}
											alt="lightning"
											class="inline"
										/>
									{/if}
									Lightning
								</label>
							</div>
							<div>
								<input
									class="h-4 w-4 accent-link"
									disabled={!captchaSecret || !mapLoaded}
									type="checkbox"
									name="nfc"
									id="nfc"
									bind:this={nfc}
									on:click={handleCheckboxClick}
								/>
								<label for="nfc" class="ml-1 cursor-pointer">
									{#if typeof window !== 'undefined'}
										<img
											src={detectTheme() === 'dark' || $theme === 'dark'
												? '/icons/nfc-highlight-dark.svg'
												: '/icons/nfc-primary.svg'}
											alt="nfc"
											class="inline"
										/>
									{/if}
									Lightning Contactless
								</label>
							</div>
						</div>
					</fieldset>

					<div>
						<label for="website" class="mb-2 block font-semibold"
							>Website <span class="font-normal">(optional)</span></label
						>
						<input
							disabled={!captchaSecret || !mapLoaded}
							type="url"
							name="website"
							placeholder="https://bitcoin.org"
							class="w-full rounded-2xl border-2 border-input p-3 transition-all focus:outline-link disabled:cursor-not-allowed disabled:bg-gray-100 disabled:text-gray-500 dark:bg-white/[0.15] dark:disabled:bg-gray-700 dark:disabled:text-gray-400"
							bind:this={website}
						/>
					</div>

					<div>
						<label for="phone" class="mb-2 block font-semibold"
							>Phone <span class="font-normal">(optional)</span></label
						>
						<input
							disabled={!captchaSecret || !mapLoaded}
							type="tel"
							name="phone"
							placeholder="Number"
							class="w-full rounded-2xl border-2 border-input p-3 transition-all focus:outline-link disabled:cursor-not-allowed disabled:bg-gray-100 disabled:text-gray-500 dark:bg-white/[0.15] dark:disabled:bg-gray-700 dark:disabled:text-gray-400"
							bind:this={phone}
						/>
					</div>

					<div>
						<label for="hours" class="mb-2 block font-semibold"
							>Opening Hours <span class="font-normal">(optional)</span></label
						>
						<input
							disabled={!captchaSecret || !mapLoaded}
							type="text"
							name="hours"
							placeholder="Mo-Fr 08:30-20:00"
							class="w-full rounded-2xl border-2 border-input p-3 transition-all focus:outline-link disabled:cursor-not-allowed disabled:bg-gray-100 disabled:text-gray-500 dark:bg-white/[0.15] dark:disabled:bg-gray-700 dark:disabled:text-gray-400"
							bind:this={hours}
						/>
					</div>

					<div>
						<label for="notes" class="mb-2 block font-semibold"
							>Notes <span class="font-normal">(optional)</span></label
						>
						<textarea
							disabled={!captchaSecret || !mapLoaded}
							name="notes"
							placeholder="Please add further details here like additional merchant details, contacts, socials, etc."
							rows="3"
							class="w-full rounded-2xl border-2 border-input p-3 transition-all focus:outline-link disabled:cursor-not-allowed disabled:bg-gray-100 disabled:text-gray-500 dark:bg-white/[0.15] dark:disabled:bg-gray-700 dark:disabled:text-gray-400"
							bind:this={notes}
						/>
					</div>

					<div>
						<label for="source" class="mb-2 block font-semibold">Data Source</label>
						<select
							id="source"
							disabled={!captchaSecret || !mapLoaded}
							name="source"
							required
							class="w-full rounded-2xl border-2 border-input bg-white px-2 py-3 transition-all focus:outline-link disabled:cursor-not-allowed disabled:bg-gray-100 disabled:text-gray-500 dark:bg-white/[0.15] dark:disabled:bg-gray-700 dark:disabled:text-gray-400"
							bind:value={source}
							on:change={async () => {
								if (source === 'Other') {
									await tick();
									sourceOtherElement.focus();
								}
							}}
						>
							<option value="">Please select an option</option>
							<option value="Business Owner">I am the business owner</option>
							<option value="Customer">I visited as a customer</option>
							<option value="Other">Other method</option>
						</select>
						{#if source === 'Other'}
							<p class="my-2 text-justify text-sm">
								How did you verify this information? Please provide as much detail as possible.
							</p>
							<textarea
								disabled={!captchaSecret || !mapLoaded}
								required
								name="source-other"
								placeholder="Local knowledge, online etc."
								class="w-full rounded-2xl border-2 border-input p-3 transition-all focus:outline-link disabled:cursor-not-allowed disabled:bg-gray-100 disabled:text-gray-500 dark:bg-white/[0.15] dark:disabled:bg-gray-700 dark:disabled:text-gray-400"
								bind:value={sourceOther}
								bind:this={sourceOtherElement}
							/>
						{/if}
					</div>

					<div>
						<label for="contact" class="mb-2 block font-semibold">Public Contact</label>
						<p class="mb-2 text-justify text-sm">
							If we have any follow-up questions we will contact you in order to add this location
							successfully. To speed up the process please check your spam folder in case it ends up
							there.
						</p>
						<input
							disabled={!captchaSecret || !mapLoaded}
							required
							type="email"
							name="contact"
							placeholder="hello@btcmap.org"
							class="w-full rounded-2xl border-2 border-input p-3 transition-all focus:outline-link disabled:cursor-not-allowed disabled:bg-gray-100 disabled:text-gray-500 dark:bg-white/[0.15] dark:disabled:bg-gray-700 dark:disabled:text-gray-400"
							bind:this={contact}
						/>
					</div>

					<div>
						<div class="mb-2 flex items-center space-x-2">
							<label for="captcha" class="font-semibold"
								>Bot protection <span class="font-normal">(case-sensitive)</span></label
							>
							{#if captchaSecret}
								<button type="button" on:click={fetchCaptcha}>
									<Icon type="fa" icon="arrows-rotate" w="16" h="16" />
								</button>
							{/if}
						</div>
						<div class="space-y-2">
							<div class="flex items-center justify-center rounded-2xl border-2 border-input py-1">
								{#if isCaptchaLoading}
									<div class="h-[100px] w-[275px] animate-pulse bg-link/50" />
								{:else}
									<!-- eslint-disable-next-line svelte/no-at-html-tags - we even sanitize the captcha content above -->
									{@html captchaContent}
								{/if}
							</div>
							<input
								disabled={!captchaSecret || !mapLoaded}
								required
								type="text"
								name="captcha"
								placeholder="Please enter the captcha text."
								class="w-full rounded-2xl border-2 border-input p-3 transition-all focus:outline-link disabled:cursor-not-allowed disabled:bg-gray-100 disabled:text-gray-500 dark:bg-white/[0.15] dark:disabled:bg-gray-700 dark:disabled:text-gray-400"
								bind:this={captchaInput}
							/>
						</div>
					</div>

					<input
						type="text"
						name="honey"
						placeholder="A nice pot of honey."
						class="hidden"
						bind:this={honeyInput}
					/>

					<PrimaryButton
						loading={submitting}
						disabled={submitting || !captchaSecret || !mapLoaded}
						style="w-full py-3 rounded-xl"
					>
						Submit Location
					</PrimaryButton>
				</form>
			</div>
		</section>

		<section
			id="supertagger"
			class="mx-auto mt-14 w-full border-t border-input pt-14 lg:mt-0 lg:w-1/2 lg:border-t-0 lg:pt-0 lg:pl-10"
		>
			<div class="lg:flex lg:justify-start">
				<div class="mx-auto max-w-xl text-primary dark:text-white">
					<h2 class="mb-5 text-center text-3xl font-semibold md:text-left">Shadowy Supertagger?</h2>
					<p class="mb-10 w-full text-justify md:text-left">
						Contribute changes directly to OSM - like a ğŸ˜ boss. Who needs forms anyway.
					</p>
					<img
						src="/images/supertagger.svg"
						alt="shadowy supertagger"
						class="mx-auto mb-10 h-[220px] w-[220px]"
					/>
					<PrimaryButton
						style="w-full py-3 rounded-xl"
						link="https://gitea.btcmap.org/teambtcmap/btcmap-general/wiki/Tagging-Merchants#shadowy-supertaggers-"
						external={true}
					>
						See Wiki for instructions
					</PrimaryButton>
				</div>
			</div>
		</section>
	</div>
{:else}
	<FormSuccess
		type="Location"
		text="We'll review your information and add it ASAP."
		issue={submissionIssueNumber}
		on:click={resetForm}
	/>
{/if}



================================================
FILE: src/routes/add-location/endpoint/+server.ts
================================================
import { env } from '$env/dynamic/private';
import { error } from '@sveltejs/kit';
import axios from 'axios';
import axiosRetry from 'axios-retry';
import crypto from 'crypto';
import type { RequestHandler } from './$types';
import { getAreaIdsByCoordinates } from '$lib/utils';
import { get } from 'svelte/store';
import { areas } from '$lib/store';
import { createIssueWithLabels } from '$lib/gitea';

import type { CipherKey, BinaryLike } from 'crypto';

axiosRetry(axios, { retries: 3, retryDelay: axiosRetry.exponentialDelay });

const used: string[] = [];

export const POST: RequestHandler = async ({ request }) => {
	const {
		captchaSecret,
		captchaTest,
		honey,
		name,
		address,
		lat,
		long,
		osm,
		category,
		methods,
		website,
		phone,
		hours,
		notes,
		source,
		sourceOther,
		contact
	} = await request.json();

	// if honey field has value return
	if (honey) {
		error(418);
	}

	// verify that captcha is correct
	if (!env.SERVER_CRYPTO_KEY || !env.SERVER_INIT_VECTOR) {
		error(503, 'Service unavailable');
	}
	const initVector = Buffer.from(env.SERVER_INIT_VECTOR, 'hex');
	const serverKey = Buffer.from(env.SERVER_CRYPTO_KEY, 'hex');

	const algorithm = 'aes-256-cbc' as string;
	const key = serverKey as unknown as CipherKey;
	const iv = initVector as unknown as BinaryLike;
	const decrypt = crypto.createDecipheriv(algorithm, key, iv);

	let secret = decrypt.update(captchaSecret, 'hex', 'utf8');
	secret += decrypt.final('utf8');

	if (captchaTest !== secret) {
		error(400, 'Captcha test failed, please try again or contact BTC Map.');
	}

	if (used.includes(captchaSecret)) {
		error(400, 'Captcha has already been used, please try another.');
	} else {
		used.push(captchaSecret);
	}

	const standardLabels = ['location-submission'];

	// Create filtered list of matched areas for reuse
	const associatedAreaIds = lat && long ? await getAreaIdsByCoordinates(lat, long) : [];
	const areasData = get(areas);
	const filteredAreas = associatedAreaIds
		.map((id) => areasData.find((a) => a.id === id))
		.filter(Boolean);

	const areaLabels = filteredAreas
		.map((area) => area?.tags?.url_alias || area?.id)
		.filter((label): label is string => Boolean(label));
	const labels = [...standardLabels, ...areaLabels];

	const body = `Merchant name: ${name}
Address: ${address}
Lat: ${lat}
Long: ${long}
Associated areas: ${filteredAreas.map((area) => `${area?.tags.name} (${area?.tags?.url_alias || area?.id})`).join(', ')}
OSM: ${osm}
Category: ${category}
Payment methods: ${methods}
Website: ${website}
Phone: ${phone}
Opening hours: ${hours}
Notes: ${notes}
Data Source: ${source}
Details (if applicable): ${sourceOther}
Contact: ${contact}
Created at: ${new Date(Date.now()).toISOString()}

If you are a new contributor please read our Tagging Instructions [here](https://gitea.btcmap.org/teambtcmap/btcmap-general/wiki/Tagging-Merchants).`;

	const response = await createIssueWithLabels(name, body, labels);
	const gitea = response.data;

	return new Response(JSON.stringify(gitea));
};



================================================
FILE: src/routes/api/boost/invoice/generate/+server.ts
================================================
import { error } from '@sveltejs/kit';
import axios from 'axios';
import axiosRetry from 'axios-retry';
import type { RequestHandler } from './$types';

axiosRetry(axios, { retries: 3, retryDelay: axiosRetry.exponentialDelay });

interface BoostInvoiceRequest {
	place_id: number;
	days: number;
}

// generate and return invoice
export const POST: RequestHandler = async ({ request }) => {
	const data: BoostInvoiceRequest = await request.json();
	const { place_id, days } = data;

	if (!place_id || !days) {
		error(400, 'Missing required parameters: place_id, days');
	}

	if (days <= 0) {
		error(400, 'Invalid days parameter: must be a positive integer (30, 90, or 365)');
	}

	const invoice = await axios
		.post('https://api.btcmap.org/v4/place-boosts', {
			place_id: place_id.toString(),
			days: days
		})
		.then(function (response) {
			return response.data;
		})
		.catch(function (err) {
			console.error(err);
			error(400, 'Could not generate boost invoice, please try again or contact BTC Map.');
		});

	return new Response(JSON.stringify(invoice));
};



================================================
FILE: src/routes/api/boost/invoice/status/+server.ts
================================================
import { error } from '@sveltejs/kit';
import axios from 'axios';
import type { RequestHandler } from './$types';

// check the status of an invoice
export const GET: RequestHandler = async ({ url }) => {
	const invoiceId = url.searchParams.get('invoice_id');

	if (!invoiceId) {
		error(400, 'Missing required parameter: invoice_id');
	}

	const status = await axios
		.get(`https://api.btcmap.org/v4/invoices/${invoiceId}`)
		.then(function (response) {
			return response.data;
		})
		.catch(function (err) {
			console.error(err);
			error(400, 'Could not check invoice status, please try again or contact BTC Map.');
		});

	return new Response(JSON.stringify(status));
};



================================================
FILE: src/routes/api/boost/post/+server.ts
================================================
import { error, json } from '@sveltejs/kit';
import axios from 'axios';
import axiosRetry from 'axios-retry';
import type { RequestHandler } from './$types';

axiosRetry(axios, { retries: 3, retryDelay: axiosRetry.exponentialDelay });

const used: string[] = [];

export const POST: RequestHandler = async ({ request }) => {
	const { invoice_id } = await request.json();

	// check that invoice_id is provided
	if (!invoice_id) {
		error(400, 'Missing required parameter: invoice_id');
	}

	// verify that the invoice has been paid
	if (used.includes(invoice_id)) {
		error(418, 'Invoice already processed');
	}

	const invoiceStatus = await axios
		.get(`https://api.btcmap.org/v4/invoices/${invoice_id}`)
		.then(function (response) {
			return response.data;
		})
		.catch(function (err) {
			console.error(err);
			error(400, 'Could not verify invoice status, please try again or contact BTC Map.');
		});

	if (invoiceStatus.status !== 'paid') {
		error(400, 'Invoice not paid');
	}

	used.push(invoice_id);

	return json({ status: 200 });
};



================================================
FILE: src/routes/api/comment/invoice/generate/+server.ts
================================================
import { error } from '@sveltejs/kit';
import axios from 'axios';
import axiosRetry from 'axios-retry';
import type { RequestHandler } from './$types';

axiosRetry(axios, { retries: 3, retryDelay: axiosRetry.exponentialDelay });

export const POST: RequestHandler = async ({ request }) => {
	const data = await request.json();
	const { place_id, comment } = data;

	if (!place_id || !comment) {
		error(400, 'Missing required parameters: place_id and comment');
	}

	const response = await axios
		.post('https://api.btcmap.org/v4/place-comments', {
			place_id,
			comment
		})
		.then(function (response) {
			return response.data;
		})
		.catch(function (err) {
			console.error(err);
			error(400, 'Could not process comment request, please try again or contact BTC Map.');
		});

	return new Response(JSON.stringify(response));
};



================================================
FILE: src/routes/api/search/places/+server.ts
================================================
import { error } from '@sveltejs/kit';
import axios from 'axios';
import axiosRetry from 'axios-retry';
import type { RequestHandler } from './$types';

axiosRetry(axios, { retries: 3, retryDelay: axiosRetry.exponentialDelay });

export const GET: RequestHandler = async ({ url }) => {
	const query = url.searchParams.get('name');

	if (!query || query.trim().length === 0) {
		error(400, 'Missing required parameter: name');
	}

	try {
		const response = await axios.get(
			`https://api.btcmap.org/v4/places/search/?name=${encodeURIComponent(query)}`
		);

		return new Response(JSON.stringify(response.data), {
			headers: { 'Content-Type': 'application/json' }
		});
	} catch (err) {
		console.error('Search API error:', err);
		error(500, 'Search temporarily unavailable');
	}
};



================================================
FILE: src/routes/apps/+page.svelte
================================================
<script lang="ts">
	import type { AppIconName } from '$lib/icons/types';
	import AppCard from './components/AppCard.svelte';
	import HeaderPlaceholder from '$components/layout/HeaderPlaceholder.svelte';
	import { apps, theme } from '$lib/store';
	import { detectTheme } from '$lib/utils';

	const communityApps: { link: string; type: string; icon: AppIconName; desc: string }[] = [
		{
			link: 'https://apps.apple.com/us/app/bitlocal-btc-friendly-shops/id6447485666',
			type: 'BitLocal',
			icon: 'ios',
			desc: 'iOS'
		}
	];
</script>

<svelte:head>
	<title>BTC Map - Apps</title>
	<meta property="og:image" content="https://btcmap.org/images/og/apps.png" />
	<meta property="twitter:title" content="BTC Map - Apps" />
	<meta property="twitter:image" content="https://btcmap.org/images/og/apps.png" />
</svelte:head>

<main class="my-10 space-y-10 text-center md:my-20">
	{#if typeof window !== 'undefined'}
		<h1
			class="{detectTheme() === 'dark' || $theme === 'dark'
				? 'text-white'
				: 'gradient'} text-4xl !leading-tight font-semibold text-primary md:text-5xl dark:text-white"
		>
			Find merchants on any platform.
		</h1>
	{:else}
		<HeaderPlaceholder />
	{/if}

	<h2 class="mx-auto w-full text-xl font-semibold text-primary lg:w-[800px] dark:text-white">
		We have you covered on whatever device and OS you choose.
	</h2>

	<h3 class="text-2xl font-semibold text-primary md:text-left dark:text-white">Official</h3>
	<section id="official-apps" class="grid gap-10 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4">
		{#each $apps as app (app.link)}
			<AppCard image={app.icon} text={app.type} desc={app.desc} link={app.link} />
		{/each}
	</section>
	<p class="text-center font-normal dark:text-white">
		Note: There is no Google Play option due to their excessive KYC requirements for developers.
	</p>

	<h3 class="text-2xl font-semibold text-primary md:text-left dark:text-white">Community</h3>
	<section id="community-apps" class="grid gap-10 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4">
		{#each communityApps as app (app.link)}
			<AppCard image={app.icon} text={app.type} desc={app.desc} link={app.link} />
		{/each}
	</section>
</main>



================================================
FILE: src/routes/apps/components/AppCard.svelte
================================================
<script lang="ts">
	import type { AppIconName } from '$lib/icons/types';
	import IconApps from '$lib/icons/IconApps.svelte';

	export let image: AppIconName;
	export let text: string;
	export let desc: string;
	export let link: string;
</script>

<div>
	{#if link}
		<!-- eslint-disable svelte/no-navigation-without-resolve -->
		<a
			href={link}
			target={text === 'Web' ? null : '_blank'}
			rel={text === 'Web' ? null : 'noreferrer'}
			class="text-2xl font-semibold text-link transition-colors hover:text-hover"
		>
			<!-- eslint-enable svelte/no-navigation-without-resolve -->
			<div
				class="mb-5 flex h-60 items-center justify-center rounded-2xl bg-offwhite dark:bg-white/[0.15]"
			>
				<IconApps w="112" h="112" icon={image} />
			</div>
			<p>{text}</p>
			<p class="text-xl font-normal">{desc}</p>
		</a>
	{:else}
		<div
			class="mb-5 flex h-60 items-center justify-center rounded-2xl bg-offwhite text-link opacity-50 dark:bg-white/[0.15]"
		>
			<i class="{image} h-28 w-28" />
		</div>
		<p class="text-2xl font-semibold text-link opacity-50">{text}</p>
		<p class="text-xl text-link opacity-50">Soon!</p>
	{/if}
</div>



================================================
FILE: src/routes/badges/+page.svelte
================================================
<script lang="ts">
	import BadgeCard from './components/BadgeCard.svelte';
	import HeaderPlaceholder from '$components/layout/HeaderPlaceholder.svelte';
	import { theme } from '$lib/store';
	import { BadgeType } from '$lib/types';
	import { detectTheme } from '$lib/utils';

	let achievements = [
		{
			title: 'Geyser Tournament',
			desc: 'Participate in the 2023 Supertagger Event',
			icon: 'geyser'
		},
		{
			title: 'Top Tagger',
			desc: '#1 on the leaderboard',
			icon: 'top-tagger'
		},
		{
			title: 'Podium',
			desc: 'In the top 3 on the leaderboard',
			icon: 'podium'
		},
		{
			title: 'High Rank',
			desc: 'In the top 10 on the leaderboard',
			icon: 'high-rank'
		},
		{
			title: 'OG Supertagger',
			desc: 'Contribute to BTC Map within the first 3 months',
			icon: 'og-supertagger'
		},
		{
			title: 'Lightning Junkie',
			desc: 'Add a tip button to your profile',
			icon: 'lightning-junkie'
		},
		{
			title: 'Hello World',
			desc: 'Add an avatar to your profile',
			icon: 'hello-world'
		},
		{
			title: 'Demolition Specialist',
			desc: 'The majority of your contributions are deletions',
			icon: 'demolition-specialist'
		},
		{
			title: 'Update Maxi',
			desc: 'The majority of your contributions are updates',
			icon: 'update-maxi'
		},
		{
			title: 'Creator',
			desc: 'The majority of your contributions are creations',
			icon: 'creator'
		},
		{
			title: 'Supporter',
			desc: 'Make an annual donation to BTC Map',
			icon: 'supporter'
		}
	];

	let contributions = [
		{
			title: 'Hyperbitcoinisation',
			desc: '21M',
			icon: 'hyperbitcoinisation'
		},
		{
			title: 'Pizza Time',
			desc: '10K',
			icon: 'pizza-time'
		},
		{
			title: 'Godly',
			desc: '7777',
			icon: 'godly'
		},
		{
			title: 'Shadow',
			desc: '5000',
			icon: 'shadow'
		},
		{
			title: 'Whitepaper',
			desc: '3110',
			icon: 'whitepaper'
		},
		{
			title: 'Winston',
			desc: '1984',
			icon: 'winston'
		},
		{
			title: 'Whale',
			desc: '1000',
			icon: 'whale'
		},
		{
			title: 'Infinity',
			desc: '821',
			icon: 'infinity'
		},
		{
			title: 'Legend',
			desc: '500',
			icon: 'legend'
		},
		{
			title: 'Chancellor',
			desc: '301',
			icon: 'chancellor'
		},
		{
			title: 'SHA',
			desc: '256',
			icon: 'sha'
		},
		{
			title: 'No Bailouts',
			desc: '210',
			icon: 'no-bailouts'
		},
		{
			title: 'Supertagger',
			desc: '100',
			icon: 'supertagger'
		},
		{
			title: 'ATH',
			desc: '69',
			icon: 'ath'
		},
		{
			title: 'Longest Chain',
			desc: '51',
			icon: 'longest-chain'
		},
		{
			title: 'Satoshi',
			desc: '21',
			icon: 'satoshi'
		},
		{
			title: 'Heartbeat',
			desc: '10',
			icon: 'heartbeat'
		},
		{
			title: 'Segwit',
			desc: '4',
			icon: 'segwit'
		},
		{
			title: 'Whole Tagger',
			desc: '1',
			icon: 'whole-tagger'
		}
	];
</script>

<svelte:head>
	<title>BTC Map - Badges</title>
	<meta property="og:image" content="https://btcmap.org/images/og/badges.png" />
	<meta property="twitter:title" content="BTC Map - Badges" />
	<meta property="twitter:image" content="https://btcmap.org/images/og/badges.png" />
</svelte:head>

<main class="my-10 text-center md:my-20">
	{#if typeof window !== 'undefined'}
		<h1
			class="{detectTheme() === 'dark' || $theme === 'dark'
				? 'text-white'
				: 'gradient'} mb-8 text-4xl !leading-tight font-semibold md:text-5xl"
		>
			Badges
		</h1>
	{:else}
		<HeaderPlaceholder />
	{/if}

	<p class="mx-auto w-full text-lg text-primary lg:w-[700px] dark:text-white">
		You can earn badges for your BTC Map contributions that will be displayed on your profile. Have
		a badge idea? Let us know!
	</p>

	<section id="achievements" class="mt-16 mb-20 space-y-8">
		<h2 class="text-center text-3xl font-semibold text-primary dark:text-white">Achievements</h2>

		<div class="grid gap-5 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4">
			{#each achievements.reverse() as achievement (achievement.title)}
				<BadgeCard
					icon={achievement.icon}
					title={achievement.title}
					desc={achievement.desc}
					type={BadgeType.Achievement}
				/>
			{/each}
		</div>
	</section>

	<section id="contributions" class="space-y-8">
		<h2 class="text-center text-3xl font-semibold text-primary dark:text-white">Contributions</h2>

		<div class="grid gap-5 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4">
			{#each contributions.reverse() as contribution (contribution.title)}
				<BadgeCard
					icon={contribution.icon}
					title={contribution.title}
					desc={contribution.desc}
					type={BadgeType.Contribution}
				/>
			{/each}
		</div>
	</section>
</main>



================================================
FILE: src/routes/badges/components/BadgeCard.svelte
================================================
<script lang="ts">
	import type { BadgeType } from '$lib/types';

	export let icon: string;
	export let title: string;
	export let desc: string;
	export let type: BadgeType;
</script>

<div
	id={icon}
	class="relative space-y-4 rounded-3xl bg-white p-5 text-center drop-shadow-xl transition-all hover:drop-shadow-2xl md:p-10 dark:bg-white/[0.15]"
>
	{#if type === 'contribution'}
		<div
			class="absolute top-5 -right-2 w-20 rounded-full bg-white py-2 font-semibold text-link shadow-lg dark:bg-white/[0.15]"
		>
			+{desc}
		</div>
	{/if}

	<img src="/icons/badges/{icon}.svg" alt={title} class="mx-auto h-28 w-28" />

	<p class="text-xl font-semibold text-primary dark:text-white">{title}</p>

	{#if type === 'achievement'}
		<p class="text-body dark:text-white">{desc}</p>
	{/if}
</div>



================================================
FILE: src/routes/captcha/+server.ts
================================================
import { env } from '$env/dynamic/private';
import { error, json } from '@sveltejs/kit';
import crypto from 'crypto';
import svgCaptcha from 'svg-captcha';
import type { CipherKey, BinaryLike } from 'crypto';

// generate and return captcha
export function GET() {
	if (!env.SERVER_CRYPTO_KEY || !env.SERVER_INIT_VECTOR) {
		error(503, 'Captcha service unavailable');
	}

	const initVector = Buffer.from(env.SERVER_INIT_VECTOR, 'hex');
	const serverKey = Buffer.from(env.SERVER_CRYPTO_KEY, 'hex');

	svgCaptcha.options.width = 275;
	svgCaptcha.options.height = 100;
	svgCaptcha.options.fontSize = 100;

	const captcha = svgCaptcha.create({ size: 7, noise: 2, color: true });

	if (!captcha.data) {
		error(400, 'Could not generate captcha, please try again or contact BTC Map.');
	}

	const algorithm = 'aes-256-cbc' as string;
	const key = serverKey as unknown as CipherKey;
	const iv = initVector as unknown as BinaryLike;
	const encrypt = crypto.createCipheriv(algorithm, key, iv);

	let secret = encrypt.update(captcha.text, 'utf8', 'hex');
	secret += encrypt.final('hex');

	return json({ captcha: captcha.data, captchaSecret: secret });
}



================================================
FILE: src/routes/comment/invoice/generate/+server.ts
================================================
import { error } from '@sveltejs/kit';
import axios from 'axios';
import axiosRetry from 'axios-retry';
import type { RequestHandler } from './$types';

axiosRetry(axios, { retries: 3, retryDelay: axiosRetry.exponentialDelay });

export const POST: RequestHandler = async ({ request }) => {
	const data = await request.json();
	const { place_id, comment } = data;

	if (!place_id || !comment) {
		error(400, 'Missing required parameters: place_id and comment');
	}

	const response = await axios
		.post('https://api.btcmap.org/v4/place-comments', {
			place_id,
			comment
		})
		.then(function (response) {
			return response.data;
		})
		.catch(function (err) {
			console.error(err);
			error(400, 'Could not process comment request, please try again or contact BTC Map.');
		});

	return new Response(JSON.stringify(response));
};



================================================
FILE: src/routes/communities/+page.server.ts
================================================
import { redirect } from '@sveltejs/kit';
import type { PageServerLoad } from './$types';

export const load: PageServerLoad = async () => {
	// Redirect to default Africa section
	throw redirect(302, '/communities/africa');
};



================================================
FILE: src/routes/communities/+page.svelte
================================================
<!-- This page redirects to /communities/africa via server load -->



================================================
FILE: src/routes/communities/[section]/+page.svelte
================================================
<script lang="ts">
	import { browser } from '$app/environment';
	import { goto } from '$app/navigation';

	import CommunitySection from './components/CommunitySection.svelte';
	import HeaderPlaceholder from '$components/layout/HeaderPlaceholder.svelte';
	import PrimaryButton from '$components/PrimaryButton.svelte';
	import { areaError, areas, reportError, syncStatus, theme } from '$lib/store';
	import { areasSync } from '$lib/sync/areas';
	import { detectTheme, errToast } from '$lib/utils';
	import { getOrganizationDisplayName } from '$lib/organizationDisplayNames';
	import type { Community } from '$lib/types';
	import Chart from 'chart.js/auto';
	import { onMount } from 'svelte';
	import type { PageData } from './$types';
	import { resolve } from '$app/paths';

	export let data: PageData;

	// alert for area errors
	$: $areaError && errToast($areaError);

	// alert for report errors
	$: $reportError && errToast($reportError);

	let chartRendered = false;
	let initialRenderComplete = false;

	$: communities =
		$areas && $areas.length
			? ($areas
					.filter(
						(area): area is Community =>
							area.tags.type === 'community' &&
							!!area.tags.geo_json &&
							!!area.tags.name &&
							!!area.tags['icon:square'] &&
							!!area.tags.continent
					)
					.sort((a, b) => {
						const nameA = a.tags.name.toUpperCase(); // ignore upper and lowercase
						const nameB = b.tags.name.toUpperCase(); // ignore upper and lowercase
						if (nameA < nameB) {
							return -1;
						}
						if (nameA > nameB) {
							return 1;
						}
						// names must be equal
						return 0;
					}) as Community[])
			: undefined;

	const hasOrganization = (community: Community, orgName: string) => {
		if (!community.tags.organization) return false;
		const orgs = community.tags.organization.split(',').map((o: string) => o.trim());
		return orgs.includes(orgName);
	};

	$: africa =
		communities && communities.filter((community) => community.tags.continent === 'africa');
	$: asia = communities && communities.filter((community) => community.tags.continent === 'asia');
	$: europe =
		communities && communities.filter((community) => community.tags.continent === 'europe');
	$: northAmerica =
		communities && communities.filter((community) => community.tags.continent === 'north-america');
	$: oceania =
		communities && communities.filter((community) => community.tags.continent === 'oceania');
	$: southAmerica =
		communities && communities.filter((community) => community.tags.continent === 'south-america');

	// Get unique organizations from community data
	$: uniqueOrganizations = communities
		? Array.from(
				new Set(
					communities
						.filter((community) => community.tags.organization)
						.flatMap((community) =>
							community.tags.organization!.split(',').map((org) => org.trim())
						)
				)
			).sort()
		: [];

	// Generate organization sections dynamically
	$: organizationSections = uniqueOrganizations.map((orgId) => ({
		id: orgId,
		displayName: getOrganizationDisplayName(orgId),
		communities: communities?.filter((community) => hasOrganization(community, orgId)) || []
	}));

	// Validate organization sections and redirect if invalid
	$: if (data.isOrganization && organizationSections.length > 0) {
		const isValidOrganization = organizationSections.some((org) => org.id === data.section);
		if (!isValidOrganization) {
			// eslint-disable-next-line svelte/no-navigation-without-resolve
			goto('/communities/africa', { replaceState: true });
		}
	}

	let continentChartCanvas: HTMLCanvasElement;
	let continentChart: Chart<'doughnut', number[], string>;

	const populateChart = () => {
		if (
			africa &&
			africa.length &&
			asia &&
			asia.length &&
			europe &&
			europe.length &&
			northAmerica &&
			northAmerica.length &&
			oceania &&
			oceania.length &&
			southAmerica &&
			southAmerica.length
		) {
			continentChart = new Chart(continentChartCanvas, {
				type: 'doughnut',
				data: {
					labels: ['Africa', 'Asia', 'Europe', 'North America', 'Oceania', 'South America'],
					datasets: [
						{
							label: 'Communities by Continent',
							data: [
								africa.length,
								asia.length,
								europe.length,
								northAmerica.length,
								oceania.length,
								southAmerica.length
							],
							backgroundColor: [
								'rgba(247, 147, 26, 1)',
								'rgba(11, 144, 114, 1)',
								'rgba(247, 147, 26, 0.7)',
								'rgba(11, 144, 114, 0.7)',
								'rgba(247, 147, 26, 0.35)',
								'rgba(11, 144, 114, 0.35)'
							],
							hoverOffset: 4
						}
					]
				},
				options: {
					maintainAspectRatio: false,
					plugins: {
						legend: {
							labels: {
								font: {
									weight: 600
								}
							}
						},
						title: {
							display: true,
							text: `${communities?.length || 0} Total`,
							font: { size: 18 }
						}
					}
				}
			});

			chartRendered = true;
		}
	};

	const chartSync = (status: boolean) => {
		if (!status) {
			if (chartRendered) {
				continentChart.data.datasets[0].data = [
					africa?.length || 0,
					asia?.length || 0,
					europe?.length || 0,
					northAmerica?.length || 0,
					oceania?.length || 0,
					southAmerica?.length || 0
				];
				continentChart.update();
			} else {
				populateChart();
			}
		}
	};

	$: $areas &&
		$areas.length &&
		communities &&
		communities.length &&
		initialRenderComplete &&
		chartSync($syncStatus);

	// Generate sections dynamically
	$: sections = [
		'--Continents--',
		'africa',
		'asia',
		'europe',
		'north-america',
		'oceania',
		'south-america',
		'--Organizations--',
		...organizationSections.map((org) => org.id)
	];

	$: communitySections = [
		{
			section: 'africa',
			communities: africa
		},
		{
			section: 'asia',
			communities: asia
		},
		{
			section: 'europe',
			communities: europe
		},
		{
			section: 'north-america',
			communities: northAmerica
		},
		{
			section: 'oceania',
			communities: oceania
		},
		{
			section: 'south-america',
			communities: southAmerica
		},
		...organizationSections.map((org) => ({
			section: org.id,
			communities: org.communities
		}))
	];

	// Map continent tag values to display names
	const continentDisplayNames: Record<string, string> = {
		africa: 'Africa',
		asia: 'Asia',
		europe: 'Europe',
		'north-america': 'North America',
		oceania: 'Oceania',
		'south-america': 'South America'
	};

	// Handle section changes via dropdown
	const handleSectionChange = (newSection: string) => {
		// eslint-disable-next-line svelte/no-navigation-without-resolve
		goto(`/communities/${newSection}`, { replaceState: false });
	};

	onMount(() => {
		areasSync();

		if (browser) {
			continentChartCanvas.getContext('2d');
			initialRenderComplete = true;
		}
	});
</script>

<svelte:head>
	<title>BTC Map - Communities</title>
	<meta property="og:image" content="https://btcmap.org/images/og/communities.png" />
	<meta property="twitter:title" content="BTC Map - Communities" />
	<meta property="twitter:image" content="https://btcmap.org/images/og/communities.png" />
</svelte:head>

<main class="my-10 space-y-10 text-center md:my-20">
	{#if typeof window !== 'undefined'}
		<h1
			class="{detectTheme() === 'dark' || $theme === 'dark'
				? 'text-white'
				: 'gradient'} text-4xl !leading-tight font-semibold md:text-5xl"
		>
			Join the bitcoin map community.
		</h1>
	{:else}
		<HeaderPlaceholder />
	{/if}

	<h2 class="mx-auto w-full text-xl font-semibold text-primary lg:w-[800px] dark:text-white">
		Take ownership of your local bitcoin mapping data and help drive adoption. Bitcoin communities
		are the spark that ignites the movement. Join your friends, onboard businesses and have fun!
	</h2>

	<div>
		<PrimaryButton
			style="md:w-[200px] mx-auto py-3 rounded-xl mb-5"
			link="/communities/leaderboard"
		>
			Leaderboard
		</PrimaryButton>

		<div class="flex flex-col items-center justify-center gap-5 md:flex-row">
			<PrimaryButton style="md:w-[200px] py-3 rounded-xl w-full" link="/communities/add">
				Add community
			</PrimaryButton>
			<PrimaryButton style="md:w-[200px] py-3 rounded-xl w-full" link="/communities/map">
				View community map
			</PrimaryButton>
		</div>
	</div>

	<div class="relative">
		{#if !initialRenderComplete || !communities}
			<div class="absolute top-0 left-0 flex h-full w-full flex-col justify-between">
				<div class="flex flex-wrap justify-center">
					{#each Array(6) as _, i (i)}
						<div class="m-2 w-[94px] animate-pulse rounded-sm bg-link/50 py-2" />
					{/each}
				</div>
				<div
					class="mx-auto h-[225px] w-[225px] animate-pulse rounded-full bg-link/50 md:h-[300px] md:w-[300px]"
				/>
			</div>
		{/if}
		<canvas bind:this={continentChartCanvas} width="100%" height="350" />
	</div>

	<div>
		<div class="mb-5 justify-between md:flex">
			{#if data.section}
				<h2 class="mb-2 text-3xl font-semibold text-primary md:mb-0 md:text-left dark:text-white">
					<a href={resolve(`/communities/${data.section}`)}>
						{organizationSections.find((org) => org.id === data.section)?.displayName ||
							continentDisplayNames[data.section] ||
							data.section}
					</a>
				</h2>

				<select
					class="w-full rounded-2xl border-2 border-input bg-white px-2 py-3 text-primary transition-all focus:outline-link md:w-auto dark:bg-white/[0.15] dark:text-white"
					bind:value={data.section}
					on:change={(e) => {
						// @ts-expect-error e.target is the select element
						const newSection = e.target?.value;
						if (newSection) {
							handleSectionChange(newSection);
						}
					}}
				>
					{#each sections as option (option)}
						<option disabled={option.startsWith('--')} value={option}>
							{option.startsWith('--')
								? option
								: organizationSections.find((org) => org.id === option)?.displayName ||
									continentDisplayNames[option] ||
									option}
						</option>
					{/each}
				</select>
			{/if}
		</div>

		{#each communitySections as item (item.section)}
			{#if data.section === item.section}
				<CommunitySection communities={item.communities} />
			{/if}
		{/each}
	</div>
</main>

{#if typeof window !== 'undefined'}
	{#if detectTheme() === 'dark' || $theme === 'dark'}
		<style>
			select option {
				--tw-bg-opacity: 1;
				background-color: rgb(55 65 81 / var(--tw-bg-opacity));
			}
		</style>
	{/if}
{/if}



================================================
FILE: src/routes/communities/[section]/+page.ts
================================================
import type { PageLoad } from './$types';

export const load: PageLoad = async ({ params }) => {
	const { section } = params;

	// Define valid continent sections
	const validContinents = ['africa', 'asia', 'europe', 'north-america', 'oceania', 'south-america'];

	// For now, we'll accept any section that's not a continent as a potential organization
	// The actual validation will happen client-side once organization data is loaded
	// This allows for dynamic organization sections

	// If section is not a valid continent, we'll pass it through
	// and let the client-side handle organization validation
	if (!validContinents.includes(section)) {
		// This could be an organization section - validate client-side
		return {
			section,
			isOrganization: true
		};
	}

	return {
		section,
		isOrganization: false
	};
};



================================================
FILE: src/routes/communities/[section]/components/CommunityCard.svelte
================================================
<script lang="ts">
	import Socials from '$components/Socials.svelte';
	import SponsorBadge from '$components/SponsorBadge.svelte';
	import Tip from '$components/Tip.svelte';
	import OrgBadge from '$components/OrgBadge.svelte';
	import type { AreaTags } from '$lib/types';
	import { TipType } from '$lib/types';
	import { getOrganizationDisplayName } from '$lib/organizationDisplayNames';
	import { resolve } from '$app/paths';

	export let id: string;
	export let tags: AreaTags;

	$: image = tags['icon:square'] && tags['icon:square'];
	$: website = tags['contact:website'] && tags['contact:website'];
	$: email = tags['contact:email'] && tags['contact:email'];
	$: nostr = tags['contact:nostr'] && tags['contact:nostr'];
	$: twitter = tags['contact:twitter'] && tags['contact:twitter'];
	$: meetup = tags['contact:meetup'] && tags['contact:meetup'];
	$: eventbrite = tags['contact:eventbrite'] && tags['contact:eventbrite'];
	$: telegram = tags['contact:telegram'] && tags['contact:telegram'];
	$: discord = tags['contact:discord'] && tags['contact:discord'];
	$: youtube = tags['contact:youtube'] && tags['contact:youtube'];
	$: github = tags['contact:github'] && tags['contact:github'];
	$: reddit = tags['contact:reddit'] && tags['contact:reddit'];
	$: instagram = tags['contact:instagram'] && tags['contact:instagram'];
	$: whatsapp = tags['contact:whatsapp'] && tags['contact:whatsapp'];
	$: facebook = tags['contact:facebook'] && tags['contact:facebook'];
	$: linkedin = tags['contact:linkedin'] && tags['contact:linkedin'];
	$: rss = tags['contact:rss'] && tags['contact:rss'];
	$: signal = tags['contact:signal'] && tags['contact:signal'];
	$: simplex = tags['contact:simplex'] && tags['contact:simplex'];
	$: tip =
		(tags['tips:lightning_address'] && {
			destination: tags['tips:lightning_address'],
			type: TipType.Address
		}) ||
		(tags['tips:url'] && { destination: tags['tips:url'], type: TipType.Url });
</script>

<div
	class="rounded-3xl border border-gray-300 shadow transition-shadow hover:shadow-2xl dark:border-white/95 dark:bg-white/10"
>
	<div class="my-4 space-y-2 p-4">
		<a
			href={resolve(`/community/${id}`)}
			class="space-y-2 text-link transition-colors hover:text-hover"
		>
			<img
				loading="lazy"
				src={image
					? `https://btcmap.org/.netlify/images?url=${image}&fit=cover&w=256&h=256`
					: '/images/bitcoin.svg'}
				alt={tags.name}
				class="mx-auto h-20 w-20 rounded-full object-cover"
				on:error={function () {
					this.src = '/images/bitcoin.svg';
				}}
			/>

			<span class="block text-center text-lg font-semibold">{tags.name}</span>
		</a>
		{#if tags.organization}
			<OrgBadge org={getOrganizationDisplayName(tags.organization)} />
		{/if}
		{#if tags.sponsor}
			<SponsorBadge />
		{/if}
		{#if tip}
			<Tip destination={tip.destination} type={tip.type} class="mx-auto block" />
		{/if}
	</div>

	<Socials
		{website}
		{email}
		{nostr}
		{twitter}
		{meetup}
		{eventbrite}
		{telegram}
		{discord}
		{youtube}
		{github}
		{reddit}
		{instagram}
		{whatsapp}
		{facebook}
		{linkedin}
		{rss}
		{signal}
		{simplex}
		style="border-t border-t-gray-200 p-4 w-full dark:border-t-white/95"
	/>
</div>



================================================
FILE: src/routes/communities/[section]/components/CommunitySection.svelte
================================================
<script lang="ts">
	export let communities: Area[] | undefined;

	import CommunityCard from './CommunityCard.svelte';
	import CommunitySkeleton from './CommunitySkeleton.svelte';
	import type { Area } from '$lib/types';
</script>

<section>
	<div class="grid gap-10 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4">
		{#if communities && communities.length}
			{#each communities as community (community.id)}
				<CommunityCard id={community.id} tags={community.tags} />
			{/each}
		{:else}
			{#each Array(4) as _, index (index)}
				<CommunitySkeleton />
			{/each}
		{/if}
	</div>
</section>



================================================
FILE: src/routes/communities/[section]/components/CommunitySkeleton.svelte
================================================
<div
	class="animate-pulse rounded-3xl border border-link/50 shadow transition-shadow hover:shadow-2xl"
>
	<div class="my-4 space-y-2 p-4">
		<!-- avatar placeholder -->
		<div class="mx-auto h-20 w-20 animate-pulse rounded-full bg-link/50" />

		<!-- name placeholder -->
		<div class="mx-auto h-[28px] w-[200px] animate-pulse rounded-xl bg-link/50" />
	</div>

	<!-- socials placeholder -->
	<div
		class="flex w-full animate-pulse items-center justify-center space-x-2 border-t border-t-link/50 p-4"
	>
		<div class="h-[40px] w-[40px] animate-pulse rounded-full bg-link/50" />
		<div class="h-[40px] w-[40px] animate-pulse rounded-full bg-link/50" />
		<div class="h-[40px] w-[40px] animate-pulse rounded-full bg-link/50" />
	</div>
</div>



================================================
FILE: src/routes/communities/add/+page.svelte
================================================
<script lang="ts">
	import { browser } from '$app/environment';
	import Breadcrumbs from '$components/Breadcrumbs.svelte';
	import FormSuccess from '$components/FormSuccess.svelte';
	import HeaderPlaceholder from '$components/layout/HeaderPlaceholder.svelte';
	import Icon from '$components/Icon.svelte';
	import InfoTooltip from '$components/InfoTooltip.svelte';
	import PrimaryButton from '$components/PrimaryButton.svelte';
	import { theme } from '$lib/store';
	import type { NominatimResponse } from '$lib/types';
	import { detectTheme, errToast, successToast, warningToast } from '$lib/utils';
	import axios from 'axios';
	import { onMount } from 'svelte';
	import DOMPurify from 'dompurify';

	const routes = [
		{ name: 'Communities', url: '/communities' },
		{ name: 'Add', url: '/communities/add' }
	];

	let captchaContent = '';
	let isCaptchaLoading = true;
	let captchaSecret: string;
	let captchaValue: string = '';
	let honeyInput: HTMLInputElement;

	const fetchCaptcha = () => {
		isCaptchaLoading = true;
		axios
			.get('/captcha')
			.then(function (response) {
				captchaSecret = response.data.captchaSecret;
				captchaContent = DOMPurify.sanitize(response.data.captcha);
			})
			.catch(function (error) {
				errToast('Could not fetch captcha, please try again or contact BTC Map.');
				console.error(error);
			})
			.finally(() => {
				isCaptchaLoading = false;
			});
	};

	let location: string | undefined;
	let name: string;
	let icon: string;
	let lightning: string;
	let socialLinks: string;
	let contact: string;
	let notes: string;

	let selected = false;
	let noLocationSelected = false;
	let submitted = false;
	let submitting = false;
	let submissionIssueNumber: number;

	let searchQuery: string;
	let searchResults: NominatimResponse[] = [];
	let searchLoading = false;

	const searchLocation = () => {
		searchLoading = true;
		searchResults = [];
		location = undefined;
		selected = false;

		axios
			.get<NominatimResponse[]>(
				`https://nominatim.openstreetmap.org/search?q=${searchQuery}&format=json&polygon_geojson=1&email=hello@btcmap.org`
			)
			.then(function (response) {
				searchResults = response.data.filter(
					(area) => area.geojson?.type === 'Polygon' || area.geojson?.type === 'MultiPolygon'
				);
				if (!searchResults.length) {
					warningToast('No locations found, please adjust query.');
				}
				searchLoading = false;
			})
			.catch(function (error) {
				errToast('Could not search for locations, please try again or contact BTC Map.');
				searchLoading = false;
				console.error(error);
			});
	};

	let selectedLat: number;
	let selectedLon: number;

	const setLocation = (area: { display_name: string; lat: string; lon: string }) => {
		location = area.display_name;
		selectedLat = parseFloat(area.lat);
		selectedLon = parseFloat(area.lon);
		selected = true;
		successToast('Location selected!');
	};

	const submitForm = (event: SubmitEvent) => {
		event.preventDefault();
		if (!selected) {
			noLocationSelected = true;
			errToast('Please select a location...');
		} else {
			submitting = true;

			axios
				.post('/communities/add/endpoint', {
					captchaSecret,
					captchaTest: captchaValue,
					honey: honeyInput,
					location,
					name,
					icon: icon ? icon : '',
					lightning: lightning ? lightning : '',
					socialLinks: socialLinks ? socialLinks : '',
					contact,
					notes: notes ? notes : '',
					lat: selectedLat,
					long: selectedLon
				})
				.then(function (response) {
					submissionIssueNumber = response.data.number;
					submitted = true;
				})
				.catch(function (error) {
					if (error.response.data.message.includes('Captcha')) {
						errToast(error.response.data.message);
					} else {
						errToast('Form submission failed, please try again or contact BTC Map.');
					}

					console.error(error);
					submitting = false;
				});
		}
	};

	const formReset = () => {
		// Reset state variables
		selected = false;
		noLocationSelected = false;
		submitted = false;
		submitting = false;
		searchQuery = '';
		searchResults = [];
		searchLoading = false;

		// Clear form fields
		location = undefined;
		name = '';
		icon = '';
		lightning = '';
		socialLinks = '';
		contact = '';
		notes = '';
		captchaValue = ''; // Reset the value directly

		// Refresh captcha
		fetchCaptcha();
	};

	onMount(async () => {
		if (browser) {
			// fetch and add captcha
			fetchCaptcha();
		}
	});
</script>

<svelte:head>
	<title>BTC Map - Add Community</title>
	<meta property="og:image" content="https://btcmap.org/images/og/add-community.png" />
	<meta property="twitter:title" content="BTC Map - Add Community" />
	<meta property="twitter:image" content="https://btcmap.org/images/og/add-community.png" />
</svelte:head>

<Breadcrumbs {routes} />
{#if !submitted}
	{#if typeof window !== 'undefined'}
		<h1
			class="{detectTheme() === 'dark' || $theme === 'dark'
				? 'text-white'
				: 'gradient'} mt-10 text-center text-4xl font-semibold md:text-5xl"
		>
			Make an impact locally!
		</h1>
	{:else}
		<HeaderPlaceholder />
	{/if}

	<section id="add-community" class="mx-auto mt-16 w-full pb-20 md:w-[600px] md:pb-32">
		<h2 class="mb-5 text-center text-3xl font-semibold text-primary dark:text-white">
			Add Community
		</h2>

		<p class="mb-5 w-full text-center text-primary dark:text-white">
			Please fill out this form to submit a community application. This is a great way to grow
			bitcoin adoption in your area, have some fun, and maybe even make some friends along the way. <InfoTooltip
				tooltip="NOTE: BTC Map is a free and open source project run by volunteers. Each community application is manually reviewed to ensure quality. It may take a few weeks to have your community added."
			/>
		</p>

		<div class="mb-10 w-full text-primary dark:text-white">
			<p class="font-semibold">Criteria</p>
			<ul class="ml-5 list-disc">
				<li>bitcoin-only</li>
				<li>must be a geographical area not a single point</li>
				<li>be willing to take ownership of your local mapping data</li>
				<li>try to onboard new businesses in your area</li>
			</ul>
		</div>

		<form on:submit={submitForm} class="w-full space-y-5 text-primary dark:text-white">
			<div class="space-y-2">
				<label for="location-picker" class="block font-semibold">Select Location</label>
				<p class="text-sm">Search for an area and select an option from the results.</p>

				{#if selected}
					<span class="font-semibold text-green-500">Location selected!</span>
				{:else if noLocationSelected}
					<span class="font-semibold text-error">Please select a location...</span>
				{/if}

				<div class="space-y-2 md:flex md:space-y-0 md:space-x-2">
					<input
						on:keydown={(e) => {
							if (e.key === 'Enter') {
								searchLocation();
							}
						}}
						disabled={!captchaSecret}
						type="text"
						name="location"
						placeholder="El Zonte, El Salvador"
						required
						class="w-full rounded-2xl border-2 border-input p-3 transition-all focus:outline-link dark:bg-white/[0.15]"
						bind:value={searchQuery}
					/>
					<PrimaryButton
						type="button"
						on:click={searchLocation}
						loading={searchLoading}
						disabled={!captchaSecret || searchLoading || !searchQuery}
						style="{!searchQuery
							? 'opacity-50 hover:bg-link'
							: ''} w-full md:w-[210px] py-3 rounded-xl"
					>
						Search ğŸ”
					</PrimaryButton>
				</div>

				{#if searchResults && searchResults.length}
					<div
						class="{!location
							? 'bg-white dark:bg-dark'
							: ''} max-h-[300px] overflow-auto border-2 border-input"
					>
						{#if !location}
							{#each searchResults as area, index (area.display_name)}
								<button
									on:click={() => setLocation(area)}
									class="{index !== searchResults.length - 1
										? 'border-b'
										: ''} block p-3 whitespace-nowrap hover:bg-link/50">{area.display_name}</button
								>
							{/each}
						{:else}
							<p class="p-3 font-semibold whitespace-nowrap">{location}</p>
						{/if}
					</div>
				{/if}
			</div>

			<div>
				<label for="name" class="mb-2 block font-semibold">Community Name</label>
				<input
					disabled={!captchaSecret}
					type="text"
					name="name"
					placeholder="Bitcoin Island Philippines"
					required
					class="w-full rounded-2xl border-2 border-input p-3 transition-all focus:outline-link dark:bg-white/[0.15]"
					bind:value={name}
				/>
			</div>

			<div>
				<label for="icon" class="mb-2 block font-semibold"
					>Icon URL <span class="font-normal">(optional)</span></label
				>
				<p class="mb-2 text-sm">
					We will use the avatar from your social link or the country's flag your community is
					located in if an icon is not provided.
				</p>
				<input
					disabled={!captchaSecret}
					type="url"
					name="icon"
					placeholder="https://static.btcmap.org/images/communities/iom.svg"
					class="w-full rounded-2xl border-2 border-input p-3 transition-all focus:outline-link dark:bg-white/[0.15]"
					bind:value={icon}
				/>
			</div>

			<div>
				<label for="lightning" class="mb-2 block font-semibold"
					>Lightning Tips <span class="font-normal">(optional)</span></label
				>
				<p class="mb-2 text-sm">
					If you want the ability to receive sats you can add either a <a
						href="https://lightningaddress.com/"
						target="_blank"
						rel="noreferrer"
						class="text-link transition-colors hover:text-hover">Lightning Address</a
					>
					or
					<a
						href="https://github.com/fiatjaf/lnurl-rfc#lnurl-documents"
						target="_blank"
						rel="noreferrer"
						class="text-link transition-colors hover:text-hover">LNURL-pay</a
					> string.
				</p>
				<input
					disabled={!captchaSecret}
					type="text"
					name="lightning"
					placeholder="btcmap@zbd.gg"
					class="w-full rounded-2xl border-2 border-input p-3 transition-all focus:outline-link dark:bg-white/[0.15]"
					bind:value={lightning}
				/>
			</div>

			<div>
				<label for="socials" class="mb-2 block font-semibold">Social Links</label>
				<p class="mb-2 text-sm">
					You need to provide at least one method for people to join your community.
				</p>

				<textarea
					required
					disabled={!captchaSecret}
					name="socials"
					placeholder="Website, Nostr, Telegram, Meetup etc."
					rows="3"
					class="w-full rounded-2xl border-2 border-input p-3 transition-all focus:outline-link dark:bg-white/[0.15]"
					bind:value={socialLinks}
				/>
			</div>

			<div>
				<label for="icon" class="mb-2 block font-semibold">Public Contact</label>
				<p class="mb-2 text-sm">
					A way to get in touch with the community leader if we have any questions.
				</p>
				<input
					required
					disabled={!captchaSecret}
					type="text"
					name="contact"
					placeholder="e.g. hello@btcmap.org"
					class="w-full rounded-2xl border-2 border-input p-3 transition-all focus:outline-link dark:bg-white/[0.15]"
					bind:value={contact}
				/>
			</div>

			<div>
				<label for="notes" class="mb-2 block font-semibold"
					>Notes <span class="font-normal">(optional)</span></label
				>
				<p class="mb-2 text-sm">
					Is this community part of an organization? Would you like to be associated with a specific
					language? Etc.
				</p>

				<textarea
					disabled={!captchaSecret}
					name="notes"
					placeholder="German speaking - part of Einundzwanzig."
					rows="2"
					class="w-full rounded-2xl border-2 border-input p-3 transition-all focus:outline-link dark:bg-white/[0.15]"
					bind:value={notes}
				/>
			</div>

			<div>
				<div class="mb-2 flex items-center space-x-2">
					<label for="captcha" class="font-semibold"
						>Bot protection <span class="font-normal">(case-sensitive)</span></label
					>
					{#if captchaSecret}
						<button type="button" on:click={fetchCaptcha}>
							<Icon type="fa" icon="arrows-rotate" w="16" h="16" />
						</button>
					{/if}
				</div>
				<div class="space-y-2">
					<div class="flex items-center justify-center rounded-2xl border-2 border-input py-1">
						{#if isCaptchaLoading}
							<div class="h-[100px] w-[275px] animate-pulse bg-link/50" />
						{:else}
							<!-- eslint-disable-next-line svelte/no-at-html-tags - we even sanitize the captcha content above -->
							{@html captchaContent}
						{/if}
					</div>
					<input
						disabled={!captchaSecret}
						required
						type="text"
						name="captcha"
						placeholder="Please enter the captcha text."
						class="w-full rounded-2xl border-2 border-input p-3 transition-all focus:outline-link dark:bg-white/[0.15]"
						bind:value={captchaValue}
					/>
				</div>
			</div>

			<input
				type="text"
				name="honey"
				placeholder="A nice pot of honey."
				class="hidden"
				bind:value={honeyInput}
			/>

			<PrimaryButton
				loading={submitting}
				disabled={submitting || !captchaSecret}
				style="w-full py-3 rounded-xl"
			>
				Submit Community
			</PrimaryButton>
		</form>
	</section>
{:else}
	<FormSuccess
		type="Community"
		text="Thanks for your initiative to create a bitcoin community. Weâ€™ll review your information
	and reach out if we need any more details."
		issue={submissionIssueNumber}
		buttonWidth="w-60"
		on:click={formReset}
	/>
{/if}



================================================
FILE: src/routes/communities/add/endpoint/+server.ts
================================================
import { env } from '$env/dynamic/private';
import { error } from '@sveltejs/kit';
import crypto from 'crypto';
import type { RequestHandler } from './$types';
import type { CipherKey, BinaryLike } from 'crypto';
import { getAreaIdsByCoordinates } from '$lib/utils';
import { createIssueWithLabels } from '$lib/gitea';
import { get } from 'svelte/store';
import { areas } from '$lib/store';

const used: string[] = [];

export const POST: RequestHandler = async ({ request }) => {
	const {
		captchaSecret,
		captchaTest,
		honey,
		location,
		name,
		icon,
		lightning,
		socialLinks,
		contact,
		notes,
		lat,
		long
	} = await request.json();

	// if honey field has value return
	if (honey) {
		error(418);
	}

	// verify that captcha is correct
	if (!env.SERVER_CRYPTO_KEY || !env.SERVER_INIT_VECTOR) {
		error(503, 'Service unavailable');
	}
	const initVector = Buffer.from(env.SERVER_INIT_VECTOR, 'hex');
	const serverKey = Buffer.from(env.SERVER_CRYPTO_KEY, 'hex');

	const algorithm = 'aes-256-cbc' as string;
	const key = serverKey as unknown as CipherKey;
	const iv = initVector as unknown as BinaryLike;
	const decrypt = crypto.createDecipheriv(algorithm, key, iv);

	let secret = decrypt.update(captchaSecret, 'hex', 'utf8');
	secret += decrypt.final('utf8');

	if (captchaTest !== secret) {
		error(400, 'Captcha test failed, please try again or contact BTC Map.');
	}

	if (used.includes(captchaSecret)) {
		error(400, 'Captcha has already been used, please try another.');
	} else {
		used.push(captchaSecret);
	}

	const standardLabels = ['community-submission'];

	// Create filtered list of matched areas (i.e. countries or larger communities) for reuse
	const associatedAreaIds = lat && long ? await getAreaIdsByCoordinates(lat, long) : [];
	const areasData = get(areas);
	const filteredAreas = associatedAreaIds
		.map((id) => areasData.find((a) => a.id === id))
		.filter(Boolean);

	const areaLabels = filteredAreas
		.map((area) => area?.tags?.url_alias || area?.id)
		.filter((label): label is string => Boolean(label)); // Filter out undefined values
	const labels = [...standardLabels, ...areaLabels];

	const body = `Community name: ${name}
Location: ${location}
Associated areas: ${filteredAreas.map((area) => `${area?.tags.name} (${area?.tags?.url_alias || area?.id})`).join(', ')}
GeoJSON: https://geojson.codingarena.top/?search=${encodeURIComponent(location)}
Icon URL: ${icon}
Lightning: ${lightning}
Social links: ${socialLinks}
Community leader contact: ${contact}
Notes: ${notes}
Created at: ${new Date(Date.now()).toISOString()}`;

	const response = await createIssueWithLabels(name, body, labels);
	const gitea = response.data;

	return new Response(JSON.stringify(gitea));
};



================================================
FILE: src/routes/communities/leaderboard/+page.svelte
================================================
<script lang="ts">
	import { onMount } from 'svelte';
	import AreaLeaderboard from '$components/leaderboard/AreaLeaderboard.svelte';
	import Breadcrumbs from '$components/Breadcrumbs.svelte';
	import HeaderPlaceholder from '$components/layout/HeaderPlaceholder.svelte';
	import PrimaryButton from '$components/PrimaryButton.svelte';
	import { areasSync } from '$lib/sync/areas';
	import { reportsSync } from '$lib/sync/reports';
	import { batchSync } from '$lib/sync/batchSync';
	import { theme } from '$lib/store';
	import { detectTheme } from '$lib/utils';

	const routes = [
		{ name: 'Communities', url: '/communities' },
		{ name: 'Leaderboard', url: '/communities/leaderboard' }
	];

	onMount(() => {
		batchSync([areasSync, reportsSync]);
	});
</script>

<svelte:head>
	<title>BTC Map - Communities Leaderboard</title>
	<meta property="og:image" content="https://btcmap.org/images/og/top-communities.png" />
	<meta property="twitter:title" content="BTC Map - Communities Leaderboard" />
	<meta property="twitter:image" content="https://btcmap.org/images/og/top-communities.png" />
</svelte:head>

<Breadcrumbs {routes} />

<main class="my-10 space-y-10">
	{#if typeof window !== 'undefined'}
		<h1
			class="{detectTheme() === 'dark' || $theme === 'dark'
				? 'text-white'
				: 'gradient'} text-center text-4xl !leading-tight font-semibold md:text-5xl"
		>
			Top Communities
		</h1>
	{:else}
		<HeaderPlaceholder />
	{/if}

	<h2
		class="mx-auto w-full text-center text-xl font-semibold text-primary lg:w-[800px] dark:text-white"
	>
		Bitcoin mapping communities maintain their local datasets and strive to have the most accurate
		information. They also help onboard new merchants in their area!
	</h2>

	<div>
		<PrimaryButton style="w-full md:w-[200px] mx-auto py-3 rounded-xl mb-5" link="/communities">
			Directory
		</PrimaryButton>

		<div class="flex flex-col items-center justify-center gap-5 md:flex-row">
			<PrimaryButton style="w-full md:w-[200px] py-3 rounded-xl" link="/communities/add">
				Add community
			</PrimaryButton>
			<PrimaryButton style="w-full md:w-[200px] py-3 rounded-xl" link="/communities/map">
				View community map
			</PrimaryButton>
		</div>
	</div>

	<AreaLeaderboard type="community" />
</main>



================================================
FILE: src/routes/communities/map/+page.svelte
================================================
<script lang="ts">
	import { browser } from '$app/environment';
	import { page } from '$app/stores';
	import MapLoadingMain from '$components/MapLoadingMain.svelte';
	import Socials from '$components/Socials.svelte';
	import { loadMapDependencies } from '$lib/map/imports';
	import {
		attribution,
		changeDefaultIcons,
		geolocate,
		homeMarkerButtons,
		layers,
		scaleBars,
		support,
		updateMapHash
	} from '$lib/map/setup';
	import { areaError, areas, reportError, reports } from '$lib/store';
	import { areasSync } from '$lib/sync/areas';
	import { reportsSync } from '$lib/sync/reports';
	import { batchSync } from '$lib/sync/batchSync';
	import type { Leaflet, Theme } from '$lib/types';
	import { detectTheme, errToast } from '$lib/utils';
	import rewind from '@mapbox/geojson-rewind';
	import { geoArea } from 'd3-geo';
	import type { Map } from 'leaflet';
	import { onDestroy, onMount } from 'svelte';
	import { resolve } from '$app/paths';

	let mapLoading = 0;

	let leaflet: Leaflet;
	let DomEvent: typeof import('leaflet/src/dom/DomEvent');
	let theme: Theme;

	let mapElement: HTMLDivElement;
	let map: Map;
	let mapLoaded = false;
	let communitiesLoaded = false;

	// allow to view map centered on a community
	const communityQuery = $page.url.searchParams.get('community');

	// allow to view map with only certain language communities
	const language = $page.url.searchParams.get('language');

	// allow to view map with only certain org communities
	const organization = $page.url.searchParams.get('organization');

	// alert for area errors
	$: $areaError && errToast($areaError);

	// alert for report errors
	$: $reportError && errToast($reportError);

	const initializeCommunities = () => {
		if (communitiesLoaded) return;

		const communitySelected = $areas.find((area) => area.id === communityQuery);

		// filter communities
		const communitiesFiltered = $areas.filter(
			(area) =>
				area.tags.type === 'community' &&
				area.tags.geo_json &&
				area.tags.name &&
				area.tags['icon:square'] &&
				area.tags.continent &&
				Object.keys(area.tags).find((key) => key.includes('contact')) &&
				$reports.find((report) => report.area_id === area.id) &&
				(language ? area.tags.language === language : true) &&
				(organization ? area.tags.organization === organization : true)
		);

		// sort communities by largest to smallest
		const communities = communitiesFiltered
			.map((community) => {
				rewind(community.tags.geo_json, true);
				return { ...community, area: geoArea(community.tags.geo_json) };
			})
			.sort((a, b) => b.area - a.area);

		// add communities to map
		communities.forEach((community) => {
			const popupContainer = leaflet.DomUtil.create('div');

			popupContainer.innerHTML = `
				<div class='text-center space-y-2'>
					<img loading='lazy' src=${`https://btcmap.org/.netlify/images?url=${community.tags['icon:square']}&fit=cover&w=256&h=256`} alt='avatar' class='w-24 h-24 rounded-full mx-auto' title='Community icon' onerror="this.src='/images/bitcoin.svg'" />

					<span class='text-primary dark:text-white font-semibold text-xl' title='Community name'>${
						community.tags.name
					}</span>

					${
						community.tags.organization
							? `<span
						class="mx-auto whitespace-nowrap w-fit block rounded-full bg-[#10B981] px-3.5 py-1 text-xs font-semibold uppercase text-white" title='Organization'
					>
					${community.tags.organization}
					</span>`
							: ''
					}

					${
						community.tags.sponsor
							? `<span class="block gradient-bg w-32 mx-auto py-1 text-xs text-white font-semibold rounded-full" title='Supporter'>
						BTC Map Sponsor
					</span>`
							: ''
					}

					<div id='socials'>
					</div>

					<a href="${resolve(`/community/${community.id}`)}" class='block bg-link hover:bg-hover !text-white text-center font-semibold py-3 rounded-xl transition-colors' title='Community page'>View Community</a>
				</div>

				${
					theme === 'dark'
						? `
							<style>
								.leaflet-popup-content-wrapper, .leaflet-popup-tip {
									background-color: #06171C;
									border: 1px solid #e5e7eb
							}

								.leaflet-popup-close-button {
									font-size: 24px !important;
									top: 4px !important;
									right: 4px !important;
							}
							</style>`
						: ''
				}`;

			const socials = popupContainer.querySelector('#socials');
			if (socials) {
				new Socials({
					target: socials,
					props: {
						website: community.tags['contact:website'],
						email: community.tags['contact:email'],
						nostr: community.tags['contact:nostr'],
						twitter: community.tags['contact:twitter'],
						meetup: community.tags['contact:meetup'],
						eventbrite: community.tags['contact:eventbrite'],
						telegram: community.tags['contact:telegram'],
						discord: community.tags['contact:discord'],
						youtube: community.tags['contact:youtube'],
						github: community.tags['contact:github'],
						reddit: community.tags['contact:reddit'],
						instagram: community.tags['contact:instagram'],
						whatsapp: community.tags['contact:whatsapp'],
						facebook: community.tags['contact:facebook'],
						linkedin: community.tags['contact:linkedin'],
						rss: community.tags['contact:rss'],
						signal: community.tags['contact:signal'],
						simplex: community.tags['contact:simplex']
					}
				});
			}

			try {
				let communityLayer = leaflet
					.geoJSON(community.tags.geo_json, {
						style: { color: '#000000', fillColor: '#F7931A', fillOpacity: 0.5 }
					})
					.bindPopup(popupContainer, { minWidth: 300 });

				communityLayer.on('click', () => communityLayer.bringToBack());

				communityLayer.addTo(map);
			} catch (error) {
				console.error(error, community);
			}
		});

		// set view to community if in url params
		if (communityQuery && communitySelected) {
			try {
				map.fitBounds(leaflet.geoJSON(communitySelected.tags.geo_json).getBounds());
			} catch (error) {
				map.setView([0, 0], 3);
				errToast(
					'Could not set map view to provided coordinates, please try again or contact BTC Map.'
				);
				console.error(error);
			}
		}

		mapLoading = 100;

		communitiesLoaded = true;
	};

	$: $areas &&
		$areas.length &&
		$reports &&
		$reports.length &&
		mapLoaded &&
		!communitiesLoaded &&
		initializeCommunities();

	onMount(async () => {
		batchSync([areasSync, reportsSync]);

		if (browser) {
			theme = detectTheme();

			const deps = await loadMapDependencies();
			leaflet = deps.leaflet;
			DomEvent = deps.DomEvent;
			const LocateControl = deps.LocateControl;

			// add map and tiles
			map = leaflet.map(mapElement);

			// use url hash if present
			if (location.hash) {
				try {
					const coords = location.hash.split('/');
					map.setView([Number(coords[1]), Number(coords[2])], Number(coords[0].slice(1)));
				} catch (error) {
					map.setView([0, 0], 3);
					errToast(
						'Could not set map view to provided coordinates, please try again or contact BTC Map.'
					);
					console.error(error);
				}
			} else {
				map.setView([0, 0], 3);
			}

			// add tiles and basemaps
			const { baseMaps } = layers(leaflet, map);

			map.on('moveend', () => {
				if (!communityQuery) {
					const zoom = map.getZoom();
					const mapCenter = map.getCenter();
					updateMapHash(zoom, mapCenter);
				}
			});

			// add support attribution
			support();

			// add OSM attribution
			attribution(leaflet, map);

			// add scale
			scaleBars(leaflet, map);

			// add locate button to map
			geolocate(leaflet, map, LocateControl);

			// add home and marker buttons to map
			homeMarkerButtons(leaflet, map, DomEvent);

			leaflet.control.layers(baseMaps).addTo(map);

			// change default icons
			changeDefaultIcons(true, leaflet, mapElement, DomEvent);

			// final map setup
			mapLoading = 40;

			mapLoaded = true;
		}
	});

	onDestroy(async () => {
		if (map) {
			console.info('Unloading Leaflet map.');
			map.remove();
		}
	});
</script>

<svelte:head>
	<title>BTC Map - Community Map</title>
	<meta property="og:image" content="https://btcmap.org/images/og/communities.png" />
	<meta property="twitter:title" content="BTC Map - Community Map" />
	<meta property="twitter:image" content="https://btcmap.org/images/og/communities.png" />
</svelte:head>

<main>
	<h1 class="hidden">Community Map</h1>

	<MapLoadingMain progress={mapLoading} />

	<div bind:this={mapElement} class="absolute h-[100%] w-full !bg-teal dark:!bg-dark" />
</main>



================================================
FILE: src/routes/community/[area]/+page.server.ts
================================================
import { redirect } from '@sveltejs/kit';
import type { PageServerLoad } from './$types';

export const load: PageServerLoad = async ({ params }) => {
	const { area } = params;
	// Redirect to default merchants section
	throw redirect(302, `/community/${area}/merchants`);
};



================================================
FILE: src/routes/community/[area]/[section]/+page.server.ts
================================================
import { error, redirect } from '@sveltejs/kit';
import axios from 'axios';
import axiosRetry from 'axios-retry';
import type { PageServerLoad } from './$types';
import { getIssues } from '$lib/gitea';

axiosRetry(axios, { retries: 3, retryDelay: axiosRetry.exponentialDelay });

export const load: PageServerLoad = async ({ params }) => {
	const { area, section } = params;

	// Validate section parameter
	const validSections = ['merchants', 'stats', 'activity', 'maintain'];
	if (!validSections.includes(section)) {
		throw redirect(302, `/community/${area}/merchants`);
	}
	try {
		const areaResponse = await axios.get(`https://api.btcmap.org/v2/areas/${area}`);
		const fetchedArea = areaResponse.data;

		const { issues: tickets } = await getIssues([fetchedArea.tags.url_alias]).catch(() => ({
			issues: 'error'
		}));

		const issuesResponse = await fetch('https://api.btcmap.org/rpc', {
			method: 'POST',
			headers: {
				'Content-Type': 'application/json'
			},
			body: JSON.stringify({
				jsonrpc: '2.0',
				id: 1,
				method: 'get_element_issues',
				params: {
					area_id: fetchedArea.tags['btcmap:id'],
					limit: 10_000,
					offset: 0
				}
			})
		});

		const issues = await issuesResponse.json();

		return {
			id: fetchedArea.id,
			name: fetchedArea.tags.name,
			tickets: tickets,
			issues: issues.result.requested_issues
		};
	} catch (err) {
		console.error(err);
		throw error(404, 'Community Not Found');
	}
};



================================================
FILE: src/routes/community/[area]/[section]/+page.svelte
================================================
<script lang="ts">
	import AreaPage from '$components/area/AreaPage.svelte';
	import Breadcrumbs from '$components/Breadcrumbs.svelte';
	import type { AreaPageProps } from '$lib/types';
	import type { PageData } from './$types';

	export let data: PageData & AreaPageProps;

	const { name, id } = data;

	const routes = [
		{ name: 'Communities', url: '/communities' },
		{ name, url: `/community/${id}` }
	];
</script>

<svelte:head>
	<title>{name ? name + ' - ' : ''}BTC Map Community</title>
	<meta property="og:image" content="https://btcmap.org/images/og/communities.png" />
	<meta property="twitter:title" content="{name ? name + ' - ' : ''}BTC Map Community" />
	<meta property="twitter:image" content="https://btcmap.org/images/og/communities.png" />
</svelte:head>

<Breadcrumbs {routes} />
<AreaPage type="community" {data} />



================================================
FILE: src/routes/countries/+page.server.ts
================================================
import { redirect } from '@sveltejs/kit';
import type { PageServerLoad } from './$types';

export const load: PageServerLoad = async () => {
	// Redirect to default Africa section
	throw redirect(302, '/countries/africa');
};



================================================
FILE: src/routes/countries/+page.svelte
================================================
<!-- This page redirects to /countries/africa via server load -->



================================================
FILE: src/routes/countries/[section]/+page.svelte
================================================
<script lang="ts">
	import { goto } from '$app/navigation';
	import CountrySection from './components/CountrySection.svelte';
	import HeaderPlaceholder from '$components/layout/HeaderPlaceholder.svelte';
	import PrimaryButton from '$components/PrimaryButton.svelte';
	import { areaError, areas, theme } from '$lib/store';
	import { areasSync } from '$lib/sync/areas';
	import { detectTheme, errToast, validateContinents } from '$lib/utils';
	import type { PageData } from './$types';
	import { resolve } from '$app/paths';
	import { onMount } from 'svelte';

	export let data: PageData;

	onMount(() => {
		areasSync();
	});

	// alert for area errors
	$: $areaError && errToast($areaError);

	$: countries =
		$areas && $areas.length
			? $areas
					.filter(
						(area) =>
							area.tags.type === 'country' &&
							area.id.length === 2 &&
							area.tags.geo_json &&
							area.tags.name &&
							area.tags.continent &&
							validateContinents(area.tags.continent)
					)
					.sort((a, b) => {
						const nameA = a.tags.name.toUpperCase(); // ignore upper and lowercase
						const nameB = b.tags.name.toUpperCase(); // ignore upper and lowercase
						if (nameA < nameB) {
							return -1;
						}
						if (nameA > nameB) {
							return 1;
						}
						// names must be equal
						return 0;
					})
			: undefined;

	$: africa = countries && countries.filter((country) => country.tags.continent === 'Africa');
	$: asia = countries && countries.filter((country) => country.tags.continent === 'Asia');
	$: europe = countries && countries.filter((country) => country.tags.continent === 'Europe');
	$: northAmerica =
		countries && countries.filter((country) => country.tags.continent === 'North America');
	$: oceania = countries && countries.filter((country) => country.tags.continent === 'Oceania');
	$: southAmerica =
		countries && countries.filter((country) => country.tags.continent === 'South America');

	const sections = ['africa', 'asia', 'europe', 'north-america', 'oceania', 'south-america'];
	$: countrySections = [
		{
			section: 'Africa',
			countries: africa
		},
		{
			section: 'Asia',
			countries: asia
		},
		{
			section: 'Europe',
			countries: europe
		},
		{
			section: 'North America',
			countries: northAmerica
		},
		{
			section: 'Oceania',
			countries: oceania
		},
		{
			section: 'South America',
			countries: southAmerica
		}
	];

	// Map continent tag values to display names
	const continentDisplayNames: Record<string, string> = {
		africa: 'Africa',
		asia: 'Asia',
		europe: 'Europe',
		'north-america': 'North America',
		oceania: 'Oceania',
		'south-america': 'South America'
	};

	// Handle dropdown change
	function handleSectionChange(event: Event) {
		const target = event.target as HTMLSelectElement;
		const newSection = target.value;
		// eslint-disable-next-line svelte/no-navigation-without-resolve
		goto(`/countries/${newSection}`);
	}

	// Section is now validated in the load function
</script>

<svelte:head>
	<title>BTC Map - Countries</title>
	<meta property="og:image" content="https://btcmap.org/images/og/countries.png" />
	<meta property="twitter:title" content="BTC Map - Countries" />
	<meta property="twitter:image" content="https://btcmap.org/images/og/countries.png" />
</svelte:head>

<main class="my-10 space-y-10 text-center md:my-20">
	{#if typeof window !== 'undefined'}
		<h1
			class="{detectTheme() === 'dark' || $theme === 'dark'
				? 'text-white'
				: 'gradient'} text-4xl !leading-tight font-semibold md:text-5xl"
		>
			Bitcoin adoption by countries.
		</h1>
	{:else}
		<HeaderPlaceholder />
	{/if}

	<h2 class="mx-auto w-full text-xl font-semibold text-primary lg:w-[800px] dark:text-white">
		Your country? Your map!
	</h2>

	<PrimaryButton style="md:w-[200px] mx-auto py-3 rounded-xl" link="/countries/leaderboard">
		View leaderboard
	</PrimaryButton>

	<div>
		<div class="mb-5 justify-between md:flex">
			{#if data.section}
				<h2 class="mb-2 text-3xl font-semibold text-primary md:mb-0 md:text-left dark:text-white">
					<a href={resolve(`/countries/${data.section}`)}
						>{continentDisplayNames[data.section] || data.section}</a
					>
				</h2>

				<select
					class="w-full rounded-2xl border-2 border-input bg-white px-2 py-3 text-primary transition-all focus:outline-link md:w-auto dark:bg-white/[0.15] dark:text-white"
					value={data.section}
					on:change={handleSectionChange}
				>
					{#each sections as option (option)}
						<option value={option}>{continentDisplayNames[option] || option}</option>
					{/each}
				</select>
			{/if}
		</div>

		{#each countrySections as item (item.section)}
			{#if continentDisplayNames[data.section] === item.section}
				<CountrySection countries={item.countries} />
			{/if}
		{/each}
	</div>
</main>

{#if typeof window !== 'undefined'}
	{#if detectTheme() === 'dark' || $theme === 'dark'}
		<style>
			select option {
				--tw-bg-opacity: 1;
				background-color: rgb(55 65 81 / var(--tw-bg-opacity));
			}
		</style>
	{/if}
{/if}



================================================
FILE: src/routes/countries/[section]/+page.ts
================================================
import { redirect } from '@sveltejs/kit';
import type { PageLoad } from './$types';

export const load: PageLoad = ({ params }) => {
	const { section } = params;
	const validSections = ['africa', 'asia', 'europe', 'north-america', 'oceania', 'south-america'];

	// If invalid section, redirect to Africa
	if (!validSections.includes(section)) {
		throw redirect(302, '/countries/africa');
	}

	return {
		section
	};
};



================================================
FILE: src/routes/countries/[section]/components/CountryCard.svelte
================================================
<script lang="ts">
	import { resolve } from '$app/paths';
	export let id: string;
	export let name: string;
</script>

<div
	class="rounded-3xl border border-gray-300 shadow transition-shadow hover:shadow-2xl dark:border-white/95 dark:bg-white/10"
>
	<div class="my-4 space-y-2 p-4">
		<a
			href={resolve(`/country/${id}`)}
			class="space-y-2 text-link transition-colors hover:text-hover"
		>
			<img
				src={`https://static.btcmap.org/images/countries/${id}.svg`}
				alt={name}
				class="mx-auto h-20 w-20 rounded-full object-cover"
				on:error={function () {
					this.src = '/images/bitcoin.svg';
				}}
			/>

			<span class="block text-center text-lg font-semibold">{name}</span>
		</a>
	</div>
</div>



================================================
FILE: src/routes/countries/[section]/components/CountrySection.svelte
================================================
<script lang="ts">
	export let countries: Area[] | undefined;

	import CountryCard from './CountryCard.svelte';
	import CountrySkeleton from './CountrySkeleton.svelte';
	import type { Area } from '$lib/types';
</script>

<section>
	<div class="grid gap-10 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4">
		{#if countries && countries.length}
			{#each countries as country (country.id)}
				<CountryCard id={country.id} name={country.tags.name} />
			{/each}
		{:else}
			{#each Array(4) as _, index (index)}
				<CountrySkeleton />
			{/each}
		{/if}
	</div>
</section>



================================================
FILE: src/routes/countries/[section]/components/CountrySkeleton.svelte
================================================
<div
	class="animate-pulse rounded-3xl border border-link/50 shadow transition-shadow hover:shadow-2xl"
>
	<div class="my-4 space-y-2 p-4">
		<!-- avatar placeholder -->
		<div class="mx-auto h-20 w-20 animate-pulse rounded-full bg-link/50" />

		<!-- name placeholder -->
		<div class="mx-auto h-[28px] w-[200px] animate-pulse rounded-xl bg-link/50" />
	</div>
</div>



================================================
FILE: src/routes/countries/leaderboard/+page.svelte
================================================
<script lang="ts">
	import { onMount } from 'svelte';
	import AreaLeaderboard from '$components/leaderboard/AreaLeaderboard.svelte';
	import Breadcrumbs from '$components/Breadcrumbs.svelte';
	import HeaderPlaceholder from '$components/layout/HeaderPlaceholder.svelte';
	import PrimaryButton from '$components/PrimaryButton.svelte';
	import { areasSync } from '$lib/sync/areas';
	import { reportsSync } from '$lib/sync/reports';
	import { batchSync } from '$lib/sync/batchSync';
	import { theme } from '$lib/store';
	import { detectTheme } from '$lib/utils';

	const routes = [
		{ name: 'Countries', url: '/countries' },
		{ name: 'Leaderboard', url: '/countries/leaderboard' }
	];

	onMount(() => {
		batchSync([areasSync, reportsSync]);
	});
</script>

<svelte:head>
	<title>BTC Map - Countries Leaderboard</title>
	<meta property="og:image" content="https://btcmap.org/images/og/top-countries.png" />
	<meta property="twitter:title" content="BTC Map - Countries Leaderboard" />
	<meta property="twitter:image" content="https://btcmap.org/images/og/top-countries.png" />
</svelte:head>

<Breadcrumbs {routes} />

<main class="my-10 space-y-10">
	{#if typeof window !== 'undefined'}
		<h1
			class="{detectTheme() === 'dark' || $theme === 'dark'
				? 'text-white'
				: 'gradient'} text-center text-4xl !leading-tight font-semibold md:text-5xl"
		>
			Top Countries
		</h1>
	{:else}
		<HeaderPlaceholder />
	{/if}

	<h2
		class="mx-auto w-full text-center text-xl font-semibold text-primary lg:w-[800px] dark:text-white"
	>
		Insights into bitcoin adoption worldwide!
	</h2>

	<PrimaryButton style="md:w-[200px] mx-auto py-3 rounded-xl" link="/countries">
		View directory
	</PrimaryButton>

	<AreaLeaderboard type="country" />
</main>



================================================
FILE: src/routes/country/[area]/+page.server.ts
================================================
import { redirect } from '@sveltejs/kit';
import type { PageServerLoad } from './$types';

export const load: PageServerLoad = async ({ params }) => {
	const { area } = params;
	// Redirect to default merchants section
	throw redirect(302, `/country/${area}/merchants`);
};



================================================
FILE: src/routes/country/[area]/[section]/+page.server.ts
================================================
import { error, redirect } from '@sveltejs/kit';
import axios from 'axios';
import axiosRetry from 'axios-retry';
import type { PageServerLoad } from './$types';
import { getIssues } from '$lib/gitea';

axiosRetry(axios, { retries: 3, retryDelay: axiosRetry.exponentialDelay });

export const load: PageServerLoad = async ({ params }) => {
	const { area, section } = params;

	// Validate section parameter - default to merchants if not provided
	const validSections = ['merchants', 'stats', 'activity', 'maintain'];
	const currentSection = section || 'merchants';

	if (!validSections.includes(currentSection)) {
		throw redirect(302, `/country/${area}/merchants`);
	}
	try {
		const areaResponse = await axios.get(`https://api.btcmap.org/v2/areas/${area}`);
		const fetchedArea = areaResponse.data;

		const { issues: tickets } = await getIssues([fetchedArea.tags.url_alias]).catch(() => ({
			issues: 'error'
		}));

		const issuesResponse = await fetch('https://api.btcmap.org/rpc', {
			method: 'POST',
			headers: {
				'Content-Type': 'application/json'
			},
			body: JSON.stringify({
				jsonrpc: '2.0',
				id: 1,
				method: 'get_element_issues',
				params: {
					area_id: fetchedArea.tags['btcmap:id'],
					limit: 10_000,
					offset: 0
				}
			})
		});

		const issues = await issuesResponse.json();

		return {
			id: fetchedArea.id,
			name: fetchedArea.tags.name,
			tickets: tickets,
			issues: issues.result.requested_issues
		};
	} catch (err) {
		console.error(err);
		throw error(404, 'Country Not Found');
	}
};



================================================
FILE: src/routes/country/[area]/[section]/+page.svelte
================================================
<script lang="ts">
	import AreaPage from '$components/area/AreaPage.svelte';
	import Breadcrumbs from '$components/Breadcrumbs.svelte';
	import type { AreaPageProps } from '$lib/types';
	import type { PageData } from './$types';

	export let data: PageData & AreaPageProps;

	const { name, id } = data;

	const routes = [
		{ name: 'Countries', url: '/countries' },
		{ name, url: `/country/${id}` }
	];
</script>

<svelte:head>
	<title>{name ? name + ' - ' : ''}BTC Map Country</title>
	<meta property="og:image" content="https://btcmap.org/images/og/countries.png" />
	<meta property="twitter:title" content="{name ? name + ' - ' : ''}BTC Map Country" />
	<meta property="twitter:image" content="https://btcmap.org/images/og/countries.png" />
</svelte:head>

<Breadcrumbs {routes} />
<AreaPage type="country" {data} />



================================================
FILE: src/routes/dashboard/+page.server.ts
================================================
import type { PageServerLoad } from './$types';
import { error } from '@sveltejs/kit';

interface DashboardData {
	total_merchants: number;
	total_merchants_chart: Array<ChartEntry>;
	verified_merchants_1y: number;
	verified_merchants_1y_chart: Array<ChartEntry>;
	total_exchanges: number;
	verified_exchanges_1y: number;
}

interface ChartEntry {
	date: string;
	value: number;
}

export const load: PageServerLoad = async ({ fetch }) => {
	const response = await fetch('https://api.btcmap.org/v4/dashboard');

	if (!response.ok) {
		throw error(response.status, 'Failed to fetch dashboard data');
	}

	const areaDashboard: DashboardData = await response.json();

	return { areaDashboard };
};



================================================
FILE: src/routes/dashboard/+page.svelte
================================================
<script lang="ts">
	import { browser } from '$app/environment';
	import DashboardStat from './components/DashboardStat.svelte';
	import HeaderPlaceholder from '$components/layout/HeaderPlaceholder.svelte';
	import { theme } from '$lib/store';
	import type { ChartHistory } from '$lib/types';
	import { detectTheme, updateChartThemes } from '$lib/utils';
	import Chart from 'chart.js/auto';
	import { format } from 'date-fns/format';
	import { startOfYear } from 'date-fns/startOfYear';
	import { subDays } from 'date-fns/subDays';
	import { subMonths } from 'date-fns/subMonths';
	import { subYears } from 'date-fns/subYears';
	import { onMount } from 'svelte';

	export let data;

	let areaDashboard = data.areaDashboard;

	const chartHistory: ChartHistory[] = ['7D', '1M', '3M', '6M', 'YTD', '1Y', 'ALL'];
	let chartHistorySelected: ChartHistory = '3M';

	let totalChartCanvas: HTMLCanvasElement;
	let totalChart: Chart<'line', number[], string>;

	let upToDateChartCanvas: HTMLCanvasElement;
	let upToDateChart: Chart<'line', number[], string>;

	const populateCharts = () => {
		const theme = detectTheme();
		const cutoffDate = getChartHistoryDate();

		const filterData = (data: ChartDataItem[] = []) =>
			data.filter((item) => new Date(item.date) >= cutoffDate);

		upToDateChart = new Chart(upToDateChartCanvas, {
			type: 'line',
			data: {
				labels: filterData(areaDashboard?.verified_merchants_1y_chart || []).map((item) =>
					format(new Date(item.date), 'yyyy-MM-dd')
				),
				datasets: [
					{
						label: 'Recently Verified Merchants',
						data: filterData(areaDashboard?.verified_merchants_1y_chart || []).map(
							(item) => item.value
						),
						fill: {
							target: 'origin',
							above: 'rgba(11, 144, 114, 0.2)'
						},
						borderColor: 'rgb(11, 144, 114)',
						tension: 0.1,
						pointStyle: false
					}
				]
			},
			options: {
				animation: false,
				maintainAspectRatio: false,
				plugins: {
					legend: {
						labels: {
							font: {
								weight: 600
							}
						}
					}
				},
				scales: {
					x: {
						ticks: {
							maxTicksLimit: 5,
							font: {
								weight: 600
							}
						},
						grid: {
							color: theme === 'dark' ? 'rgba(255, 255, 255, 0.15)' : 'rgba(0, 0, 0, 0.1)'
						}
					},
					y: {
						ticks: {
							font: {
								weight: 600
							}
						},
						grid: {
							color: theme === 'dark' ? 'rgba(255, 255, 255, 0.15)' : 'rgba(0, 0, 0, 0.1)'
						}
					}
				},
				interaction: {
					intersect: false
				}
			}
		});

		totalChart = new Chart(totalChartCanvas, {
			type: 'line',
			data: {
				labels: filterData(areaDashboard?.total_merchants_chart || []).map((item) =>
					format(new Date(item.date), 'yyyy-MM-dd')
				),
				datasets: [
					{
						label: 'Total Merchants',
						data: filterData(areaDashboard?.total_merchants_chart || []).map((item) => item.value),
						fill: {
							target: 'origin',
							above: 'rgba(0, 153, 175, 0.2)'
						},
						borderColor: 'rgb(0, 153, 175)',
						tension: 0.1,
						pointStyle: false
					}
				]
			},
			options: {
				animation: false,
				maintainAspectRatio: false,
				plugins: {
					legend: {
						labels: {
							font: {
								weight: 600
							}
						}
					}
				},
				scales: {
					x: {
						ticks: {
							maxTicksLimit: 5,
							font: {
								weight: 600
							}
						},
						grid: {
							color: theme === 'dark' ? 'rgba(255, 255, 255, 0.15)' : 'rgba(0, 0, 0, 0.1)'
						}
					},
					y: {
						ticks: {
							font: {
								weight: 600
							}
						},
						grid: {
							color: theme === 'dark' ? 'rgba(255, 255, 255, 0.15)' : 'rgba(0, 0, 0, 0.1)'
						}
					}
				},
				interaction: {
					intersect: false
				}
			}
		});
	};

	$: $theme !== undefined && updateChartThemes([upToDateChart, totalChart]);

	onMount(async () => {
		if (browser) {
			upToDateChartCanvas.getContext('2d');
			totalChartCanvas.getContext('2d');
			populateCharts();
		}
	});

	interface ChartDataItem {
		date: string;
		value: number;
	}

	const getChartHistoryDate = () => {
		const today = new Date();
		switch (chartHistorySelected) {
			case '7D':
				return subDays(today, 7);
			case '1M':
				return subMonths(today, 1);
			case '3M':
				return subMonths(today, 3);
			case '6M':
				return subMonths(today, 6);
			case 'YTD':
				return startOfYear(today);
			case '1Y':
				return subYears(today, 1);
			case 'ALL':
				return new Date(0);
		}
	};

	$: {
		if (chartHistorySelected && upToDateChart && totalChart) {
			const cutoffDate = getChartHistoryDate();

			const filterData = (data: ChartDataItem[] = []) =>
				data.filter((item) => new Date(item.date) >= cutoffDate);

			const updateChart = (chart: Chart<'line', number[], string>, data: ChartDataItem[]) => {
				const filtered = filterData(data);
				chart.data.labels = filtered.map((item) => format(new Date(item.date), 'yyyy-MM-dd'));
				chart.data.datasets[0].data = filtered.map((item) => item.value);
				chart.update();
			};

			updateChart(upToDateChart, areaDashboard?.verified_merchants_1y_chart || []);
			updateChart(totalChart, areaDashboard?.total_merchants_chart || []);
		}
	}

	$: {
		areaDashboard = data.areaDashboard;
	}
</script>

<svelte:head>
	<title>BTC Map - Dashboard</title>
	<meta property="og:image" content="https://btcmap.org/images/og/dash.png" />
	<meta property="twitter:title" content="BTC Map - Dashboard" />
	<meta property="twitter:image" content="https://btcmap.org/images/og/dash.png" />
</svelte:head>

<main class="mt-10 mb-20 space-y-10">
	{#if typeof window !== 'undefined'}
		<h1
			class="{detectTheme() === 'dark' || $theme === 'dark'
				? 'text-white'
				: 'gradient'} text-center text-4xl !leading-tight font-semibold md:text-left md:text-5xl"
		>
			Dashboard
		</h1>
	{:else}
		<HeaderPlaceholder />
	{/if}

	<section id="merchant-stats">
		<div
			class="grid rounded-3xl border border-gray-300 md:grid-cols-2 xl:grid-cols-2 dark:border-white/95 dark:bg-white/10"
		>
			<DashboardStat
				title="Total Merchants"
				stat={areaDashboard?.total_merchants}
				border="border-b md:border-b-0 border-gray-300"
				loading={false}
			/>
			<DashboardStat
				title="Recently Verified"
				stat={areaDashboard?.verified_merchants_1y}
				loading={false}
			/>
		</div>
	</section>

	<section id="exchange-stats">
		<div
			class="grid rounded-3xl border border-gray-300 md:grid-cols-2 xl:grid-cols-2 dark:border-white/95 dark:bg-white/10"
		>
			<DashboardStat
				title="Total Exchanges"
				stat={areaDashboard?.total_exchanges}
				border="border-b md:border-b-0 border-gray-300"
				loading={false}
			/>
			<DashboardStat
				title="Recently Verified"
				stat={areaDashboard?.verified_exchanges_1y}
				loading={false}
			/>
		</div>
	</section>

	<section id="charts" class="space-y-10">
		<div
			class="flex flex-wrap justify-end gap-3 font-semibold text-primary md:gap-5 dark:text-white"
		>
			{#each chartHistory as history (history)}
				<button
					class={chartHistorySelected === history
						? 'underline decoration-primary decoration-4 underline-offset-8 dark:decoration-white'
						: ''}
					on:click={() => (chartHistorySelected = history)}
				>
					{history}
				</button>
			{/each}
		</div>

		<div>
			<div class="relative">
				<canvas bind:this={totalChartCanvas} width="100%" height="400" />
			</div>
			<p class="mt-1 text-center text-sm text-body dark:text-white">
				*Merchants accepting any bitcoin method.
			</p>
		</div>

		<div>
			<div class="relative">
				<canvas bind:this={upToDateChartCanvas} width="100%" height="400" />
			</div>
			<p class="mt-1 text-center text-sm text-body dark:text-white">
				*Merchants with a <em>survey:date</em>, <em>check_date</em>, or
				<em>check_date:currency:XBT</em> tag less than one year old.
			</p>
		</div>
	</section>

	<p class="text-center text-sm text-body md:text-left dark:text-white">
		*More information on bitcoin mapping tags can be found <a
			href="https://gitea.btcmap.org/teambtcmap/btcmap-general/wiki/Tagging-Merchants#tagging-guidance"
			target="_blank"
			rel="noreferrer"
			class="text-link transition-colors hover:text-hover">here</a
		>.
	</p>
</main>



================================================
FILE: src/routes/dashboard/components/DashboardStat.svelte
================================================
<script lang="ts">
	import LoadingSpinner from '$components/LoadingSpinner.svelte';

	export let title: string;
	export let stat: number | undefined;
	export let percent: undefined | string = undefined;
	export let change: undefined | string = undefined;
	export let border: undefined | string = undefined;
	export let loading: boolean;
</script>

<div class="space-y-5 p-5 {border}">
	<h3 class="text-center text-xl text-primary md:h-[56px] md:text-left dark:text-white">
		{title}
		{#if loading}
			<LoadingSpinner color="text-link" style="inline" />
		{/if}
	</h3>
	<div class="flex justify-center md:justify-start">
		{#if stat !== undefined}
			<span class="text-5xl font-semibold text-primary dark:text-white">
				{stat.toLocaleString()}{title === 'Up-To-Date Percent' ? '%' : ''}
			</span>
			{#if percent}
				<span
					class="{percent === '+0'
						? 'text-primary dark:text-white'
						: percent.startsWith('+')
							? 'text-statPositive'
							: 'text-statNegative'} ml-1 text-lg font-semibold"
					>{percent === '+0' ? percent.slice(1) : percent}%</span
				>
			{:else if change}
				<span
					class="{change === '+0'
						? 'text-primary dark:text-white'
						: change.startsWith('+')
							? 'text-statPositive'
							: 'text-statNegative'} ml-1 text-lg font-semibold">{change}</span
				>
			{/if}
		{:else}
			<!-- loading skeleton -->
			<span class="h-[48px] w-[150px] animate-pulse rounded-xl bg-link/50" />
		{/if}
	</div>
</div>



================================================
FILE: src/routes/leaderboard/+page.server.ts
================================================
import type { PageServerLoad } from './$types';

const ALL_TIME_START = '2021-09-01';

const PERIOD_OPTIONS = ['3-months', '6-months', '12-months', 'all-time'] as const;

type PeriodKey = (typeof PERIOD_OPTIONS)[number];

type PeriodPreset =
	| {
			kind: 'relative';
			days: number;
	  }
	| {
			kind: 'fixed';
			startDate: string;
	  };

const PERIOD_PRESETS: Record<PeriodKey, PeriodPreset> = {
	'3-months': { kind: 'relative', days: 91 },
	'6-months': { kind: 'relative', days: 182 },
	'12-months': { kind: 'relative', days: 365 },
	'all-time': { kind: 'fixed', startDate: ALL_TIME_START }
};

const buildPeriodRange = (period: PeriodKey) => {
	const preset = PERIOD_PRESETS[period];
	const today = new Date();
	const period_end = today.toISOString().split('T')[0];
	if (preset.kind === 'fixed') {
		return { period_start: preset.startDate, period_end };
	}
	const startDate = new Date(today);
	startDate.setDate(startDate.getDate() - preset.days);
	return { period_start: startDate.toISOString().split('T')[0], period_end };
};

const DEFAULT_PERIOD: PeriodKey = '12-months';

const resolvePeriod = (maybePeriod: string | null): PeriodKey => {
	return PERIOD_OPTIONS.includes(maybePeriod as PeriodKey)
		? (maybePeriod as PeriodKey)
		: DEFAULT_PERIOD;
};

export const load: PageServerLoad = async ({ url }) => {
	const resolvedPeriod = resolvePeriod(url.searchParams.get('period'));
	const range = buildPeriodRange(resolvedPeriod);

	try {
		const response = await fetch('https://api.btcmap.org/rpc', {
			method: 'POST',
			headers: {
				'Content-Type': 'application/json'
			},
			body: JSON.stringify({
				jsonrpc: '2.0',
				id: 1,
				method: 'get_most_active_users',
				params: {
					...range,
					limit: 100
				}
			})
		});

		const data = await response.json();

		if (data.error) {
			const errorMessage = data.error.message || 'RPC Error';
			const errorDetails = data.error.data ? `: ${JSON.stringify(data.error.data)}` : '';
			return {
				error: errorMessage + errorDetails,
				rpcResult: null,
				period: resolvedPeriod,
				periodOptions: PERIOD_OPTIONS
			};
		}
		return {
			rpcResult: data.result,
			period: resolvedPeriod,
			periodOptions: PERIOD_OPTIONS
		};
	} catch (err) {
		return {
			error: err instanceof Error ? err.message : 'Failed to load leaderboard',
			rpcResult: null,
			period: resolvedPeriod,
			periodOptions: PERIOD_OPTIONS
		};
	}
};



================================================
FILE: src/routes/leaderboard/+page.svelte
================================================
<script lang="ts">
	import { goto } from '$app/navigation';
	import Icon from '$components/Icon.svelte';
	import LeaderboardPagination from '$components/leaderboard/LeaderboardPagination.svelte';
	import LeaderboardSearch from '$components/leaderboard/LeaderboardSearch.svelte';
	import SortHeaderButton from '$components/leaderboard/SortHeaderButton.svelte';
	import TaggerLeaderboardDesktopTable from '$components/leaderboard/TaggerLeaderboardDesktopTable.svelte';
	import TaggerLeaderboardMobileCard from '$components/leaderboard/TaggerLeaderboardMobileCard.svelte';
	import PrimaryButton from '$components/PrimaryButton.svelte';
	import LoadingSpinner from '$components/LoadingSpinner.svelte';
	import {
		createSvelteTable,
		getCoreRowModel,
		getFilteredRowModel,
		getPaginationRowModel,
		getSortedRowModel,
		type ColumnDef,
		type FilterFn,
		type OnChangeFn,
		type PaginationState,
		type SortingState,
		type TableOptions
	} from '@tanstack/svelte-table';
	import { rankItem } from '@tanstack/match-sorter-utils';
	import { page } from '$app/stores';
	import { writable, get } from 'svelte/store';
	import { excludeLeader, theme } from '$lib/store';
	import type { RpcGetMostActiveUsersItem, TaggerLeaderboard } from '$lib/types';
	import { debounce, detectTheme } from '$lib/utils';

	type TaggerRow = TaggerLeaderboard & {
		position: number;
		tipDestination?: string;
	};

	type PeriodOption = '3-months' | '6-months' | '12-months' | 'all-time';
	const DEFAULT_PERIOD: PeriodOption = '12-months';
	const DEFAULT_PERIOD_OPTIONS: PeriodOption[] = ['3-months', '6-months', '12-months', 'all-time'];
	const periodLabels: Record<PeriodOption, string> = {
		'3-months': 'Last 3 months',
		'6-months': 'Last 6 months',
		'12-months': 'Last 12 months',
		'all-time': 'All Time'
	};

	export let data;

	const pageSizes = [10, 20, 30, 40, 50];
	let loading = true;
	let periodLoading = false;
	let errorMessage: string | null = data?.error ?? null;
	let leaderboardRows: TaggerRow[] = [];
	let totalTaggers = 0;

	const validatePeriodOption = (value: unknown): value is PeriodOption => {
		return typeof value === 'string' && DEFAULT_PERIOD_OPTIONS.includes(value as PeriodOption);
	};

	let periodOptions: PeriodOption[] = [...DEFAULT_PERIOD_OPTIONS];
	let selectedPeriod: PeriodOption = DEFAULT_PERIOD;
	let lastResolvedPeriod: PeriodOption = DEFAULT_PERIOD;

	$: {
		const incoming = Array.isArray(data?.periodOptions)
			? data?.periodOptions
			: DEFAULT_PERIOD_OPTIONS;
		periodOptions = Array.from(
			new Set(incoming.filter((option) => validatePeriodOption(option)))
		) as PeriodOption[];
		if (!periodOptions.length) {
			periodOptions = [...DEFAULT_PERIOD_OPTIONS];
		}
	}

	$: {
		const periodFromData = validatePeriodOption(data?.period)
			? (data.period as PeriodOption)
			: DEFAULT_PERIOD;
		const validPeriod = periodOptions.includes(periodFromData) ? periodFromData : DEFAULT_PERIOD;
		if (validPeriod !== lastResolvedPeriod) {
			lastResolvedPeriod = validPeriod;
			selectedPeriod = validPeriod;
		}
	}

	const extractLightningDestination = (tip?: string): string | undefined => {
		if (!tip) return undefined;
		const trimmed = tip.trim();
		if (!trimmed) return undefined;
		const lightningMatch = trimmed.match(/lightning:[^\s)]+/i);
		if (lightningMatch) {
			return lightningMatch[0].replace(/^lightning:/i, '');
		}
		return trimmed.replace(/^lightning:/i, '');
	};

	const normalizeUsers = (
		users: RpcGetMostActiveUsersItem[],
		excluded: Set<number>
	): TaggerRow[] => {
		return users
			.filter((user) => !excluded.has(user.id))
			.map((user) => {
				const avatar = user.image_url || '/images/satoshi-nakamoto.png';
				const totalEdits = user.edits;
				return {
					avatar,
					tagger: user.name,
					id: user.id,
					created: user.created,
					updated: user.updated,
					deleted: user.deleted,
					total: totalEdits,
					tip: user.tip_address,
					tipDestination: extractLightningDestination(user.tip_address)
				};
			})
			.sort((a, b) => {
				if (b.total !== a.total) return b.total - a.total;
				if (b.updated !== a.updated) return b.updated - a.updated;
				return a.tagger.localeCompare(b.tagger);
			})
			.map((item, index) => ({ ...item, position: index + 1 }));
	};

	$: {
		if (data?.rpcResult?.users?.length) {
			const excluded = new Set(get(excludeLeader));
			leaderboardRows = normalizeUsers(data.rpcResult.users, excluded);
			totalTaggers = leaderboardRows.length;
			loading = false;
			periodLoading = false;
			errorMessage = null;
		} else if (data?.error) {
			leaderboardRows = [];
			totalTaggers = 0;
			loading = false;
			periodLoading = false;
			errorMessage = data.error;
		} else {
			leaderboardRows = [];
			totalTaggers = 0;
		}
	}

	const fuzzyFilter: FilterFn<TaggerRow> = (row, columnId, value, addMeta) => {
		const itemRank = rankItem(row.getValue(columnId), value);
		addMeta?.({ itemRank });
		return itemRank.passed;
	};

	const columns: ColumnDef<TaggerRow>[] = [
		{
			id: 'position',
			header: 'Position',
			accessorFn: (row) => row.position,
			enableSorting: true,
			enableGlobalFilter: false,
			sortingFn: (a, b) => a.original.position - b.original.position
		},
		{
			id: 'name',
			header: 'Name',
			accessorFn: (row) => row.tagger,
			enableSorting: true,
			filterFn: fuzzyFilter,
			enableGlobalFilter: true
		},
		{
			id: 'total',
			header: 'Total',
			accessorFn: (row) => row.total,
			enableSorting: true,
			enableGlobalFilter: false
		},
		{
			id: 'created',
			header: 'Created',
			accessorFn: (row) => row.created,
			enableSorting: true,
			enableGlobalFilter: false
		},
		{
			id: 'updated',
			header: 'Updated',
			accessorFn: (row) => row.updated,
			enableSorting: true,
			enableGlobalFilter: false
		},
		{
			id: 'deleted',
			header: 'Deleted',
			accessorFn: (row) => row.deleted,
			enableSorting: true,
			enableGlobalFilter: false
		},
		{
			id: 'tip',
			header: 'Tip',
			accessorFn: (row) => row.tipDestination ?? '',
			enableSorting: false,
			enableGlobalFilter: false
		}
	];

	let sorting: SortingState = [{ id: 'total', desc: true }];
	let pagination: PaginationState = {
		pageIndex: 0,
		pageSize: pageSizes[0]
	};

	const setSorting: OnChangeFn<SortingState> = (updater) => {
		sorting = updater instanceof Function ? updater(sorting) : updater;
		options.update((old) => ({
			...old,
			state: {
				...old.state,
				sorting
			}
		}));
	};

	const setPagination: OnChangeFn<PaginationState> = (updater) => {
		pagination = updater instanceof Function ? updater(pagination) : updater;
		options.update((old) => ({
			...old,
			state: {
				...old.state,
				pagination
			}
		}));
	};

	const options = writable<TableOptions<TaggerRow>>({
		data: leaderboardRows,
		columns,
		state: {
			sorting,
			pagination
		},
		onSortingChange: setSorting,
		onPaginationChange: setPagination,
		globalFilterFn: fuzzyFilter,
		getCoreRowModel: getCoreRowModel(),
		getSortedRowModel: getSortedRowModel(),
		getPaginationRowModel: getPaginationRowModel(),
		getFilteredRowModel: getFilteredRowModel()
	});

	const table = createSvelteTable(options);

	$: options.update((current) => ({
		...current,
		data: leaderboardRows
	}));

	const handleKeyUp = (e: KeyboardEvent) => {
		$table?.setGlobalFilter(String((e.target as HTMLInputElement)?.value));
	};

	const searchDebounce = debounce((e) => handleKeyUp(e));

	const handlePeriodChange = async (event: Event) => {
		const nextValue = (event.target as HTMLSelectElement).value as PeriodOption;
		const search = new URLSearchParams($page.url.searchParams);
		if (nextValue === DEFAULT_PERIOD) {
			search.delete('period');
		} else {
			search.set('period', nextValue);
		}
		const nextSearch = search.toString();
		const nextUrl = nextSearch ? `/leaderboard?${nextSearch}` : '/leaderboard';
		selectedPeriod = nextValue;
		periodLoading = true;

		// eslint-disable-next-line svelte/no-navigation-without-resolve
		await goto(nextUrl, {
			replaceState: true,
			noScroll: true
		});
	};
</script>

<svelte:head>
	<title>BTC Map - Tagger Leaderboard</title>
	<meta property="og:image" content="https://btcmap.org/images/og/leader.png" />
	<meta property="twitter:title" content="BTC Map - Tagger Leaderboard" />
	<meta property="twitter:image" content="https://btcmap.org/images/og/leader.png" />
</svelte:head>

<main class="mt-10 mb-20">
	<div class="mb-10 flex justify-center">
		<div id="hero" class="flex h-[324px] w-full items-end justify-center">
			<img src="/images/supertagger-king.svg" alt="ultimate supertagger" />
		</div>
	</div>

	<div class="mx-auto w-12/12 space-y-10 xl:w-[1200px]">
		<h1
			class="{detectTheme() === 'dark' || $theme === 'dark'
				? 'text-white'
				: 'gradient'} text-center text-4xl !leading-tight font-semibold md:text-5xl"
		>
			Tagger Leaderboard
		</h1>

		<PrimaryButton
			style="w-[207px] mx-auto py-3 rounded-xl"
			link="https://gitea.btcmap.org/teambtcmap/btcmap-general/wiki/Tagging-Merchants#shadowy-supertaggers-"
			external
		>
			Join Them
		</PrimaryButton>

		<section id="leaderboard" aria-labelledby="leaderboard-title">
			<div
				class="w-full rounded-3xl border border-gray-300 bg-white dark:border-white/95 dark:bg-white/10"
			>
				<header>
					<h2
						id="leaderboard-title"
						class="border-b border-gray-300 p-5 text-center text-lg font-semibold text-primary md:text-left dark:border-white/95 dark:text-white"
					>
						Tagger Leaderboard
						{#if !loading && !errorMessage && totalTaggers}
							({totalTaggers})
						{/if}
					</h2>
				</header>

				{#if loading}
					<div class="p-5">
						<div
							class="flex h-[572px] w-full animate-pulse items-center justify-center rounded-3xl border border-link/50"
							role="status"
							aria-live="polite"
						>
							<span class="sr-only">Loading leaderboard data</span>
							<Icon type="fa" icon="table" w="96" h="96" class="animate-pulse text-link/50" />
						</div>
					</div>
				{:else if periodLoading}
					<div class="p-5">
						<div
							class="flex h-[572px] w-full items-center justify-center rounded-3xl border border-link/50"
							role="status"
							aria-live="polite"
						>
							<div class="flex flex-col items-center gap-4">
								<LoadingSpinner color="text-link" size="h-12 w-12" />
								<p class="text-lg font-medium text-primary dark:text-white">
									Loading {periodLabels[selectedPeriod].toLowerCase()} data...
								</p>
							</div>
						</div>
					</div>
				{:else if errorMessage}
					<p class="w-full p-5 text-center text-primary dark:text-white">
						Failed to load leaderboard: {errorMessage}
					</p>
				{:else if !leaderboardRows.length}
					<p class="w-full p-5 text-center text-primary dark:text-white">No data available</p>
				{:else}
					<div class="p-5">
						<div
							class="mb-6 flex flex-col gap-4 px-4 py-3 md:flex-row md:items-center md:justify-between"
						>
							<div class="flex-1">
								<LeaderboardSearch
									table={$table}
									globalFilter={$table.getState().globalFilter}
									on:globalFilterChange={(e) => $table?.setGlobalFilter(e.detail)}
									{searchDebounce}
								/>
							</div>
							<label
								class="flex flex-col gap-2 text-sm font-medium text-primary md:flex-row md:items-center md:gap-3 dark:text-white"
							>
								<span>Period</span>
								<select
									class="w-full rounded-2xl border-2 border-input bg-white px-2 py-3 text-primary transition-all focus:outline-link md:w-auto dark:bg-white/[0.15] dark:text-white"
									value={selectedPeriod}
									on:change={handlePeriodChange}
									aria-label="Select leaderboard period"
								>
									{#each periodOptions as option (option)}
										<option value={option}>{periodLabels[option]}</option>
									{/each}
								</select>
							</label>
						</div>

						{#if $table.getFilteredRowModel().rows.length === 0}
							<p class="w-full p-5 text-center text-primary dark:text-white">No results found.</p>
						{:else}
							<div class="block lg:hidden">
								<div
									class="border-b border-gray-300 bg-primary/5 dark:border-white/95 dark:bg-white/5"
								>
									<div class="grid grid-cols-4 gap-3 px-4 py-3 text-center text-xs">
										<SortHeaderButton
											column={$table?.getColumn('position')}
											label="Position"
											ariaLabel="Sort by position"
										/>
										<SortHeaderButton
											column={$table?.getColumn('total')}
											label="Total"
											ariaLabel="Sort by total edits"
										/>
										<SortHeaderButton
											column={$table?.getColumn('created')}
											label="Created"
											ariaLabel="Sort by created edits"
										/>
										<SortHeaderButton
											column={$table?.getColumn('updated')}
											label="Updated"
											ariaLabel="Sort by updated edits"
										/>
									</div>
								</div>

								<TaggerLeaderboardMobileCard table={$table} />
							</div>

							<TaggerLeaderboardDesktopTable table={$table} />
							<LeaderboardPagination table={$table} {pageSizes} />
						{/if}
					</div>
				{/if}
			</div>
		</section>
	</div>
</main>

{#if typeof window !== 'undefined'}
	{#if detectTheme() === 'dark' || $theme === 'dark'}
		<style>
			select option {
				--tw-bg-opacity: 1;
				background-color: rgb(55 65 81 / var(--tw-bg-opacity));
			}
		</style>
	{/if}
{/if}

<style>
	#hero {
		background-image: url('/images/confetti.png');
		background-repeat: no-repeat;
		background-position: center;
	}
</style>



================================================
FILE: src/routes/leaderboard/components/LeaderboardItem.svelte
================================================
<script lang="ts">
	export let position: number;
	export let avatar: string;
	export let tagger: string;
	export let id: number;
	export let created: number;
	export let updated: number;
	export let deleted: number;
	export let tip: string;

	import Tip from '$components/Tip.svelte';
	import { resolve } from '$app/paths';

	$: stats = [
		{ stat: created, title: 'C' },
		{ stat: updated, title: 'U' },
		{ stat: deleted, title: 'D' }
	];

	$: regexMatch = tip && tip.match('(lightning:[^)]+)');
	$: lightning = regexMatch && regexMatch[0].slice(10);
</script>

<div
	class="grid-cols-6 space-y-5 border-t border-b border-gray-300 py-5 text-center text-lg font-semibold lg:grid lg:space-y-0 lg:border-none lg:py-0 dark:border-white/95"
>
	<span
		class="my-auto text-link {position > 3
			? 'underline'
			: ''} decoration-4 underline-offset-4 lg:no-underline"
	>
		{#if position === 1}
			<span class="text-2xl">ğŸ¥‡</span>
		{:else if position === 2}
			<span class="text-2xl">ğŸ¥ˆ</span>
		{:else if position === 3}
			<span class="text-2xl">ğŸ¥‰</span>
		{:else}
			{position}
		{/if}
	</span>

	<div class="flex flex-col items-center gap-2 lg:flex-row">
		<img
			src={avatar}
			alt="avatar"
			class="h-20 w-20 rounded-full object-cover lg:h-14 lg:w-14"
			on:error={function () {
				this.src = '/images/satoshi-nakamoto.png';
			}}
		/>

		<a
			href={resolve(`/tagger/${id}`)}
			class="text-link hover:text-hover lg:text-left {tagger.match('([^ ]{16})')
				? 'break-all'
				: ''} transition-colors">{tagger}</a
		>
	</div>

	{#each stats as stat (stat.title)}
		<span class="mx-5 inline-block text-link lg:mx-0 lg:!my-auto">
			<span
				class="mr-1 inline-block h-3 w-3 rounded-full {stat.title === 'C'
					? 'bg-created'
					: stat.title === 'U'
						? 'bg-link'
						: 'bg-deleted'} lg:hidden"
			/>{stat.stat}
		</span>
	{/each}

	{#if lightning}
		<Tip destination={lightning} class="mx-auto block lg:!my-auto lg:h-[30px]" />
	{/if}
</div>



================================================
FILE: src/routes/leaderboard/components/LeaderboardSkeleton.svelte
================================================
<div
	class="animate-pulse grid-cols-6 space-y-5 border-t border-b border-link/50 py-5 text-center lg:grid lg:space-y-0 lg:border-none lg:py-0"
>
	<!-- position placeholder -->
	<span class="mx-auto my-auto block h-5 w-5 animate-pulse rounded-full bg-link/50 lg:inline" />

	<!-- avatar and username placeholder -->
	<div class="items-center space-y-2 lg:flex lg:space-y-0 lg:space-x-2">
		<!-- avatar -->
		<span
			class="mx-auto block h-20 w-20 animate-pulse rounded-full bg-link/50 lg:mx-0 lg:inline lg:h-14 lg:w-14"
		/>

		<!-- username -->
		<span
			class="mx-auto block h-[30px] w-[150px] animate-pulse rounded-xl bg-link/50 lg:mx-0 lg:inline lg:w-[75px] xl:w-[100px]"
		/>
	</div>

	<!-- stats placeholders -->
	<span
		class="mx-5 inline-block h-3 w-3 animate-pulse rounded-full bg-link/50 lg:mx-auto lg:!my-auto lg:h-5 lg:w-5"
	/>
	<span
		class="mx-5 inline-block h-3 w-3 animate-pulse rounded-full bg-link/50 lg:mx-auto lg:!my-auto lg:h-5 lg:w-5"
	/>
	<span
		class="mx-5 inline-block h-3 w-3 animate-pulse rounded-full bg-link/50 lg:mx-auto lg:!my-auto lg:h-5 lg:w-5"
	/>

	<!-- tip button placeholder -->
	<div
		class="mx-auto h-[38px] w-full animate-pulse rounded-lg bg-link/50 md:h-[30px] md:w-20 lg:!my-auto"
	/>
</div>



================================================
FILE: src/routes/license/+page.svelte
================================================
<script lang="ts">
</script>

<svelte:head>
	<title>BTC Map - License</title>
	<meta property="og:image" content="https://btcmap.org/images/og/home.png" />
	<meta property="twitter:title" content="BTC Map - License" />
	<meta property="twitter:image" content="https://btcmap.org/images/og/home.png" />
</svelte:head>

<main class="mt-10 mb-20 space-y-5 text-body dark:text-white">
	<p class="text-center font-semibold text-primary dark:text-white">
		BTC Map - Easily find places to spend sats anywhere on the planet.
		<br />
		Copyright &#169; 2022-{new Date().getFullYear()} BTC Map
		<br />
		<a
			href="mailto:hello@btcmap.org"
			class="font-normal text-link transition-colors hover:text-hover">hello@btcmap.org</a
		>
	</p>
	<p>
		This program is free software: you can redistribute it and/or modify it under the terms of the
		GNU Affero General Public License as published by the Free Software Foundation, either version 3
		of the License, or (at your option) any later version.
	</p>
	<p>
		This program is distributed in the hope that it will be useful, but <strong
			>WITHOUT ANY WARRANTY</strong
		>; without even the implied warranty of
		<strong>MERCHANTABILITY</strong> or <strong>FITNESS FOR A PARTICULAR PURPOSE</strong>. See the
		GNU Affero General Public License for more details.
	</p>

	<h1
		class="text-center text-4xl !leading-tight font-semibold text-primary md:text-5xl dark:text-white"
	>
		GNU AFFERO GENERAL PUBLIC LICENSE
		<span class="block text-base">Version 3, 19 November 2007</span>
	</h1>

	<p>
		Copyright (C) 2007 Free Software Foundation, Inc. <a
			href="https://fsf.org/"
			class="text-link transition-colors hover:text-hover">https://fsf.org/</a
		>
		Everyone is permitted to copy and distribute verbatim copies of this license document, but changing
		it is not allowed.
	</p>

	<h2 class="text-center text-3xl font-semibold text-primary dark:text-white">Preamble</h2>

	<p>
		The GNU Affero General Public License is a free, copyleft license for software and other kinds
		of works, specifically designed to ensure cooperation with the community in the case of network
		server software.
	</p>
	<p>
		The licenses for most software and other practical works are designed to take away your freedom
		to share and change the works. By contrast, our General Public Licenses are intended to
		guarantee your freedom to share and change all versions of a program--to make sure it remains
		free software for all its users.
	</p>
	<p>
		When we speak of free software, we are referring to freedom, not price. Our General Public
		Licenses are designed to make sure that you have the freedom to distribute copies of free
		software (and charge for them if you wish), that you receive source code or can get it if you
		want it, that you can change the software or use pieces of it in new free programs, and that you
		know you can do these things.
	</p>
	<p>
		Developers that use our General Public Licenses protect your rights with two steps: (1) assert
		copyright on the software, and (2) offer you this License which gives you legal permission to
		copy, distribute and/or modify the software.
	</p>
	<p>
		A secondary benefit of defending all users' freedom is that improvements made in alternate
		versions of the program, if they receive widespread use, become available for other developers
		to incorporate. Many developers of free software are heartened and encouraged by the resulting
		cooperation. However, in the case of software used on network servers, this result may fail to
		come about. The GNU General Public License permits making a modified version and letting the
		public access it on a server without ever releasing its source code to the public.
	</p>
	<p>
		The GNU Affero General Public License is designed specifically to ensure that, in such cases,
		the modified source code becomes available to the community. It requires the operator of a
		network server to provide the source code of the modified version running there to the users of
		that server. Therefore, public use of a modified version, on a publicly accessible server, gives
		the public access to the source code of the modified version.
	</p>
	<p>
		An older license, called the Affero General Public License and published by Affero, was designed
		to accomplish similar goals. This is a different license, not a version of the Affero GPL, but
		Affero has released a new version of the Affero GPL which permits relicensing under this
		license.
	</p>
	<p>The precise terms and conditions for copying, distribution and modification follow.</p>

	<h2 class="text-center text-3xl font-semibold text-primary dark:text-white">
		TERMS AND CONDITIONS
	</h2>

	<h3 class="text-2xl font-semibold text-primary dark:text-white">0. Definitions.</h3>

	<p>
		<strong>"This License"</strong> refers to version 3 of the GNU Affero General Public License.
	</p>
	<p>
		<strong>"Copyright"</strong> also means copyright-like laws that apply to other kinds of works, such
		as semiconductor masks.
	</p>
	<p>
		<strong>"The Program"</strong> refers to any copyrightable work licensed under this License.
		Each licensee is addressed as <strong>"you"</strong>. <strong>"Licensees"</strong> and
		<strong>"recipients"</strong> may be individuals or organizations.
	</p>
	<p>
		To <strong>"modify"</strong> a work means to copy from or adapt all or part of the work in a
		fashion requiring copyright permission, other than the making of an exact copy. The resulting
		work is called a <strong>"modified version"</strong> of the earlier work or a work
		<strong>"based on"</strong> the earlier work.
	</p>
	<p>
		A <strong>"covered work"</strong> means either the unmodified Program or a work based on the Program.
	</p>
	<p>
		To <strong>"propagate"</strong> a work means to do anything with it that, without permission, would
		make you directly or secondarily liable for infringement under applicable copyright law, except executing
		it on a computer or modifying a private copy. Propagation includes copying, distribution (with or
		without modification), making available to the public, and in some countries other activities as well.
	</p>
	<p>
		To <strong>"convey"</strong> a work means any kind of propagation that enables other parties to make
		or receive copies. Mere interaction with a user through a computer network, with no transfer of a
		copy, is not conveying.
	</p>
	<p>
		An interactive user interface displays <strong>"Appropriate Legal Notices"</strong>
		to the extent that it includes a convenient and prominently visible feature that (1) displays an appropriate
		copyright notice, and (2) tells the user that there is no warranty for the work (except to the extent
		that warranties are provided), that licensees may convey the work under this License, and how to view
		a copy of this License. If the interface presents a list of user commands or options, such as a menu,
		a prominent item in the list meets this criterion.
	</p>

	<h3 class="text-2xl font-semibold text-primary dark:text-white">1. Source Code.</h3>

	<p>
		The <strong>"source code"</strong> for a work means the preferred form of the work for making
		modifications to it. <strong>"Object code"</strong> means any non-source form of a work.
	</p>
	<p>
		A <strong>"Standard Interface"</strong> means an interface that either is an official standard defined
		by a recognized standards body, or, in the case of interfaces specified for a particular programming
		language, one that is widely used among developers working in that language.
	</p>
	<p>
		The <strong>"System Libraries"</strong> of an executable work include anything, other than the
		work as a whole, that (a) is included in the normal form of packaging a Major Component, but
		which is not part of that Major Component, and (b) serves only to enable use of the work with
		that Major Component, or to implement a Standard Interface for which an implementation is
		available to the public in source code form. A
		<strong>"Major Component"</strong>, in this context, means a major essential component (kernel,
		window system, and so on) of the specific operating system (if any) on which the executable work
		runs, or a compiler used to produce the work, or an object code interpreter used to run it.
	</p>
	<p>
		The <strong>"Corresponding Source"</strong> for a work in object code form means all the source code
		needed to generate, install, and (for an executable work) run the object code and to modify the work,
		including scripts to control those activities. However, it does not include the work's System Libraries,
		or general-purpose tools or generally available free programs which are used unmodified in performing
		those activities but which are not part of the work. For example, Corresponding Source includes interface
		definition files associated with source files for the work, and the source code for shared libraries
		and dynamically linked subprograms that the work is specifically designed to require, such as by intimate
		data communication or control flow between those subprograms and other parts of the work.
	</p>
	<p>
		The Corresponding Source need not include anything that users can regenerate automatically from
		other parts of the Corresponding Source.
	</p>
	<p>The Corresponding Source for a work in source code form is that same work.</p>

	<h3 class="text-2xl font-semibold text-primary dark:text-white">2. Basic Permissions.</h3>

	<p>
		All rights granted under this License are granted for the term of copyright on the Program, and
		are irrevocable provided the stated conditions are met. This License explicitly affirms your
		unlimited permission to run the unmodified Program. The output from running a covered work is
		covered by this License only if the output, given its content, constitutes a covered work. This
		License acknowledges your rights of fair use or other equivalent, as provided by copyright law.
	</p>
	<p>
		You may make, run and propagate covered works that you do not convey, without conditions so long
		as your license otherwise remains in force. You may convey covered works to others for the sole
		purpose of having them make modifications exclusively for you, or provide you with facilities
		for running those works, provided that you comply with the terms of this License in conveying
		all material for which you do not control copyright. Those thus making or running the covered
		works for you must do so exclusively on your behalf, under your direction and control, on terms
		that prohibit them from making any copies of your copyrighted material outside their
		relationship with you.
	</p>
	<p>
		Conveying under any other circumstances is permitted solely under the conditions stated below.
		Sublicensing is not allowed; section 10 makes it unnecessary.
	</p>

	<h3 class="text-2xl font-semibold text-primary dark:text-white">
		3. Protecting Users' Legal Rights From Anti-Circumvention Law.
	</h3>

	<p>
		No covered work shall be deemed part of an effective technological measure under any applicable
		law fulfilling obligations under article 11 of the WIPO copyright treaty adopted on 20 December
		1996, or similar laws prohibiting or restricting circumvention of such measures.
	</p>
	<p>
		When you convey a covered work, you waive any legal power to forbid circumvention of
		technological measures to the extent such circumvention is effected by exercising rights under
		this License with respect to the covered work, and you disclaim any intention to limit operation
		or modification of the work as a means of enforcing, against the work's users, your or third
		parties' legal rights to forbid circumvention of technological measures.
	</p>

	<h3 class="text-2xl font-semibold text-primary dark:text-white">4. Conveying Verbatim Copies.</h3>

	<p>
		You may convey verbatim copies of the Program's source code as you receive it, in any medium,
		provided that you conspicuously and appropriately publish on each copy an appropriate copyright
		notice; keep intact all notices stating that this License and any non-permissive terms added in
		accord with section 7 apply to the code; keep intact all notices of the absence of any warranty;
		and give all recipients a copy of this License along with the Program.
	</p>
	<p>
		You may charge any price or no price for each copy that you convey, and you may offer support or
		warranty protection for a fee.
	</p>

	<h3 class="text-2xl font-semibold text-primary dark:text-white">
		5. Conveying Modified Source Versions.
	</h3>

	<p>
		You may convey a work based on the Program, or the modifications to produce it from the Program,
		in the form of source code under the terms of section 4, provided that you also meet all of
		these conditions:
	</p>
	<ul class="ml-5 space-y-5">
		<li>
			a) The work must carry prominent notices stating that you modified it, and giving a relevant
			date.
		</li>
		<li>
			b) The work must carry prominent notices stating that it is released under this License and
			any conditions added under section 7. This requirement modifies the requirement in section 4
			to
			<strong>"keep intact all notices"</strong>.
		</li>
		<li>
			c) You must license the entire work, as a whole, under this License to anyone who comes into
			possession of a copy. This License will therefore apply, along with any applicable section 7
			additional terms, to the whole of the work, and all its parts, regardless of how they are
			packaged. This License gives no permission to license the work in any other way, but it does
			not invalidate such permission if you have separately received it.
		</li>
		<li>
			d) If the work has interactive user interfaces, each must display Appropriate Legal Notices;
			however, if the Program has interactive interfaces that do not display Appropriate Legal
			Notices, your work need not make them do so.
		</li>
	</ul>
	<p>
		A compilation of a covered work with other separate and independent works, which are not by
		their nature extensions of the covered work, and which are not combined with it such as to form
		a larger program, in or on a volume of a storage or distribution medium, is called an
		<strong>"aggregate"</strong> if the compilation and its resulting copyright are not used to limit
		the access or legal rights of the compilation's users beyond what the individual works permit. Inclusion
		of a covered work in an aggregate does not cause this License to apply to the other parts of the aggregate.
	</p>

	<h3 class="text-2xl font-semibold text-primary dark:text-white">
		6. Conveying Non-Source Forms.
	</h3>

	<p>
		You may convey a covered work in object code form under the terms of sections 4 and 5, provided
		that you also convey the machine-readable Corresponding Source under the terms of this License,
		in one of these ways:
	</p>
	<ul class="ml-5 space-y-5">
		<li>
			a) Convey the object code in, or embodied in, a physical product (including a physical
			distribution medium), accompanied by the Corresponding Source fixed on a durable physical
			medium customarily used for software interchange.
		</li>
		<li>
			b) Convey the object code in, or embodied in, a physical product (including a physical
			distribution medium), accompanied by a written offer, valid for at least three years and valid
			for as long as you offer spare parts or customer support for that product model, to give
			anyone who possesses the object code either (1) a copy of the Corresponding Source for all the
			software in the product that is covered by this License, on a durable physical medium
			customarily used for software interchange, for a price no more than your reasonable cost of
			physically performing this conveying of source, or (2) access to copy the Corresponding Source
			from a network server at no charge.
		</li>
		<li>
			c) Convey individual copies of the object code with a copy of the written offer to provide the
			Corresponding Source. This alternative is allowed only occasionally and noncommercially, and
			only if you received the object code with such an offer, in accord with subsection 6b.
		</li>
		<li>
			d) Convey the object code by offering access from a designated place (gratis or for a charge),
			and offer equivalent access to the Corresponding Source in the same way through the same place
			at no further charge. You need not require recipients to copy the Corresponding Source along
			with the object code. If the place to copy the object code is a network server, the
			Corresponding Source may be on a different server (operated by you or a third party) that
			supports equivalent copying facilities, provided you maintain clear directions next to the
			object code saying where to find the Corresponding Source. Regardless of what server hosts the
			Corresponding Source, you remain obligated to ensure that it is available for as long as
			needed to satisfy these requirements.
		</li>
		<li>
			e) Convey the object code using peer-to-peer transmission, provided you inform other peers
			where the object code and Corresponding Source of the work are being offered to the general
			public at no charge under subsection 6d.
		</li>
	</ul>
	<p>
		A separable portion of the object code, whose source code is excluded from the Corresponding
		Source as a System Library, need not be included in conveying the object code work.
	</p>
	<p>
		A <strong>"User Product"</strong> is either (1) a <strong>"consumer product"</strong>, which
		means any tangible personal property which is normally used for personal, family, or household
		purposes, or (2) anything designed or sold for incorporation into a dwelling. In determining
		whether a product is a consumer product, doubtful cases shall be resolved in favor of coverage.
		For a particular product received by a particular user,
		<strong>"normally used"</strong> refers to a typical or common use of that class of product, regardless
		of the status of the particular user or of the way in which the particular user actually uses, or
		expects or is expected to use, the product. A product is a consumer product regardless of whether
		the product has substantial commercial, industrial or non-consumer uses, unless such uses represent
		the only significant mode of use of the product.
	</p>
	<p>
		<strong>"Installation Information"</strong> for a User Product means any methods, procedures, authorization
		keys, or other information required to install and execute modified versions of a covered work in
		that User Product from a modified version of its Corresponding Source. The information must suffice
		to ensure that the continued functioning of the modified object code is in no case prevented or interfered
		with solely because modification has been made.
	</p>
	<p>
		If you convey an object code work under this section in, or with, or specifically for use in, a
		User Product, and the conveying occurs as part of a transaction in which the right of possession
		and use of the User Product is transferred to the recipient in perpetuity or for a fixed term
		(regardless of how the transaction is characterized), the Corresponding Source conveyed under
		this section must be accompanied by the Installation Information. But this requirement does not
		apply if neither you nor any third party retains the ability to install modified object code on
		the User Product (for example, the work has been installed in ROM).
	</p>
	<p>
		The requirement to provide Installation Information does not include a requirement to continue
		to provide support service, warranty, or updates for a work that has been modified or installed
		by the recipient, or for the User Product in which it has been modified or installed. Access to
		a network may be denied when the modification itself materially and adversely affects the
		operation of the network or violates the rules and protocols for communication across the
		network.
	</p>
	<p>
		Corresponding Source conveyed, and Installation Information provided, in accord with this
		section must be in a format that is publicly documented (and with an implementation available to
		the public in source code form), and must require no special password or key for unpacking,
		reading or copying.
	</p>

	<h3 class="text-2xl font-semibold text-primary dark:text-white">7. Additional Terms.</h3>

	<p>
		<strong>"Additional permissions"</strong> are terms that supplement the terms of this License by making
		exceptions from one or more of its conditions. Additional permissions that are applicable to the entire
		Program shall be treated as though they were included in this License, to the extent that they are
		valid under applicable law. If additional permissions apply only to part of the Program, that part
		may be used separately under those permissions, but the entire Program remains governed by this License
		without regard to the additional permissions.
	</p>
	<p>
		When you convey a copy of a covered work, you may at your option remove any additional
		permissions from that copy, or from any part of it. (Additional permissions may be written to
		require their own removal in certain cases when you modify the work.) You may place additional
		permissions on material, added by you to a covered work, for which you have or can give
		appropriate copyright permission.
	</p>
	<p>
		Notwithstanding any other provision of this License, for material you add to a covered work, you
		may (if authorized by the copyright holders of that material) supplement the terms of this
		License with terms:
	</p>
	<ul class="ml-5 space-y-5">
		<li>
			a) Disclaiming warranty or limiting liability differently from the terms of sections 15 and 16
			of this License; or
		</li>

		<li>
			b) Requiring preservation of specified reasonable legal notices or author attributions in that
			material or in the Appropriate Legal Notices displayed by works containing it; or
		</li>

		<li>
			c) Prohibiting misrepresentation of the origin of that material, or requiring that modified
			versions of such material be marked in reasonable ways as different from the original version;
			or
		</li>

		<li>
			d) Limiting the use for publicity purposes of names of licensors or authors of the material;
			or
		</li>

		<li>
			e) Declining to grant rights under trademark law for use of some trade names, trademarks, or
			service marks; or
		</li>

		<li>
			f) Requiring indemnification of licensors and authors of that material by anyone who conveys
			the material (or modified versions of it) with contractual assumptions of liability to the
			recipient, for any liability that these contractual assumptions directly impose on those
			licensors and authors.
		</li>
	</ul>
	<p>
		All other non-permissive additional terms are considered <strong>"further restrictions"</strong> within
		the meaning of section 10. If the Program as you received it, or any part of it, contains a notice
		stating that it is governed by this License along with a term that is a further restriction, you may
		remove that term. If a license document contains a further restriction but permits relicensing or
		conveying under this License, you may add to a covered work material governed by the terms of that
		license document, provided that the further restriction does not survive such relicensing or conveying.
	</p>
	<p>
		If you add terms to a covered work in accord with this section, you must place, in the relevant
		source files, a statement of the additional terms that apply to those files, or a notice
		indicating where to find the applicable terms.
	</p>
	<p>
		Additional terms, permissive or non-permissive, may be stated in the form of a separately
		written license, or stated as exceptions; the above requirements apply either way.
	</p>

	<h3 class="text-2xl font-semibold text-primary dark:text-white">8. Termination.</h3>

	<p>
		You may not propagate or modify a covered work except as expressly provided under this License.
		Any attempt otherwise to propagate or modify it is void, and will automatically terminate your
		rights under this License (including any patent licenses granted under the third paragraph of
		section 11).
	</p>
	<p>
		However, if you cease all violation of this License, then your license from a particular
		copyright holder is reinstated (a) provisionally, unless and until the copyright holder
		explicitly and finally terminates your license, and (b) permanently, if the copyright holder
		fails to notify you of the violation by some reasonable means prior to 60 days after the
		cessation.
	</p>
	<p>
		Moreover, your license from a particular copyright holder is reinstated permanently if the
		copyright holder notifies you of the violation by some reasonable means, this is the first time
		you have received notice of violation of this License (for any work) from that copyright holder,
		and you cure the violation prior to 30 days after your receipt of the notice.
	</p>
	<p>
		Termination of your rights under this section does not terminate the licenses of parties who
		have received copies or rights from you under this License. If your rights have been terminated
		and not permanently reinstated, you do not qualify to receive new licenses for the same material
		under section 10.
	</p>

	<h3 class="text-2xl font-semibold text-primary dark:text-white">
		9. Acceptance Not Required for Having Copies.
	</h3>

	<p>
		You are not required to accept this License in order to receive or run a copy of the Program.
		Ancillary propagation of a covered work occurring solely as a consequence of using peer-to-peer
		transmission to receive a copy likewise does not require acceptance. However, nothing other than
		this License grants you permission to propagate or modify any covered work. These actions
		infringe copyright if you do not accept this License. Therefore, by modifying or propagating a
		covered work, you indicate your acceptance of this License to do so.
	</p>

	<h3 class="text-2xl font-semibold text-primary dark:text-white">
		10. Automatic Licensing of Downstream Recipients.
	</h3>

	<p>
		Each time you convey a covered work, the recipient automatically receives a license from the
		original licensors, to run, modify and propagate that work, subject to this License. You are not
		responsible for enforcing compliance by third parties with this License.
	</p>
	<p>
		An <strong>"entity transaction"</strong> is a transaction transferring control of an organization,
		or substantially all assets of one, or subdividing an organization, or merging organizations. If propagation
		of a covered work results from an entity transaction, each party to that transaction who receives
		a copy of the work also receives whatever licenses to the work the party's predecessor in interest
		had or could give under the previous paragraph, plus a right to possession of the Corresponding Source
		of the work from the predecessor in interest, if the predecessor has it or can get it with reasonable
		efforts.
	</p>
	<p>
		You may not impose any further restrictions on the exercise of the rights granted or affirmed
		under this License. For example, you may not impose a license fee, royalty, or other charge for
		exercise of rights granted under this License, and you may not initiate litigation (including a
		cross-claim or counterclaim in a lawsuit) alleging that any patent claim is infringed by making,
		using, selling, offering for sale, or importing the Program or any portion of it.
	</p>

	<h3 class="text-2xl font-semibold text-primary dark:text-white">11. Patents.</h3>

	<p>
		A <strong>"contributor"</strong> is a copyright holder who authorizes use under this License of
		the Program or a work on which the Program is based. The work thus licensed is called the
		contributor's <strong>"contributor version"</strong>.
	</p>
	<p>
		A contributor's <strong>"essential patent claims"</strong> are all patent claims owned or
		controlled by the contributor, whether already acquired or hereafter acquired, that would be
		infringed by some manner, permitted by this License, of making, using, or selling its
		contributor version, but do not include claims that would be infringed only as a consequence of
		further modification of the contributor version. For purposes of this definition,
		<strong>"control"</strong> includes the right to grant patent sublicenses in a manner consistent with
		the requirements of this License.
	</p>
	<p>
		Each contributor grants you a non-exclusive, worldwide, royalty-free patent license under the
		contributor's essential patent claims, to make, use, sell, offer for sale, import and otherwise
		run, modify and propagate the contents of its contributor version.
	</p>
	<p>
		In the following three paragraphs, a <strong>"patent license"</strong> is any express agreement
		or commitment, however denominated, not to enforce a patent (such as an express permission to
		practice a patent or covenant not to sue for patent infringement). To
		<strong>"grant"</strong> such a patent license to a party means to make such an agreement or commitment
		not to enforce a patent against the party.
	</p>
	<p>
		If you convey a covered work, knowingly relying on a patent license, and the Corresponding
		Source of the work is not available for anyone to copy, free of charge and under the terms of
		this License, through a publicly available network server or other readily accessible means,
		then you must either (1) cause the Corresponding Source to be so available, or (2) arrange to
		deprive yourself of the benefit of the patent license for this particular work, or (3) arrange,
		in a manner consistent with the requirements of this License, to extend the patent license to
		downstream recipients. <strong>"Knowingly relying"</strong> means you have actual knowledge that,
		but for the patent license, your conveying the covered work in a country, or your recipient's use
		of the covered work in a country, would infringe one or more identifiable patents in that country
		that you have reason to believe are valid.
	</p>
	<p>
		If, pursuant to or in connection with a single transaction or arrangement, you convey, or
		propagate by procuring conveyance of, a covered work, and grant a patent license to some of the
		parties receiving the covered work authorizing them to use, propagate, modify or convey a
		specific copy of the covered work, then the patent license you grant is automatically extended
		to all recipients of the covered work and works based on it.
	</p>
	<p>
		A patent license is <strong>"discriminatory"</strong> if it does not include within the scope of its
		coverage, prohibits the exercise of, or is conditioned on the non-exercise of one or more of the rights
		that are specifically granted under this License. You may not convey a covered work if you are a party
		to an arrangement with a third party that is in the business of distributing software, under which
		you make payment to the third party based on the extent of your activity of conveying the work, and
		under which the third party grants, to any of the parties who would receive the covered work from
		you, a discriminatory patent license (a) in connection with copies of the covered work conveyed by
		you (or copies made from those copies), or (b) primarily for and in connection with specific products
		or compilations that contain the covered work, unless you entered into that arrangement, or that patent
		license was granted, prior to 28 March 2007.
	</p>
	<p>
		Nothing in this License shall be construed as excluding or limiting any implied license or other
		defenses to infringement that may otherwise be available to you under applicable patent law.
	</p>

	<h3 class="text-2xl font-semibold text-primary dark:text-white">
		12. No Surrender of Others' Freedom.
	</h3>

	<p>
		If conditions are imposed on you (whether by court order, agreement or otherwise) that
		contradict the conditions of this License, they do not excuse you from the conditions of this
		License. If you cannot convey a covered work so as to satisfy simultaneously your obligations
		under this License and any other pertinent obligations, then as a consequence you may not convey
		it at all. For example, if you agree to terms that obligate you to collect a royalty for further
		conveying from those to whom you convey the Program, the only way you could satisfy both those
		terms and this License would be to refrain entirely from conveying the Program.
	</p>

	<h3 class="text-2xl font-semibold text-primary dark:text-white">
		13. Remote Network Interaction; Use with the GNU General Public License.
	</h3>

	<p>
		Notwithstanding any other provision of this License, if you modify the Program, your modified
		version must prominently offer all users interacting with it remotely through a computer network
		(if your version supports such interaction) an opportunity to receive the Corresponding Source
		of your version by providing access to the Corresponding Source from a network server at no
		charge, through some standard or customary means of facilitating copying of software. This
		Corresponding Source shall include the Corresponding Source for any work covered by version 3 of
		the GNU General Public License that is incorporated pursuant to the following paragraph.
	</p>
	<p>
		Notwithstanding any other provision of this License, you have permission to link or combine any
		covered work with a work licensed under version 3 of the GNU General Public License into a
		single combined work, and to convey the resulting work. The terms of this License will continue
		to apply to the part which is the covered work, but the work with which it is combined will
		remain governed by version 3 of the GNU General Public License.
	</p>

	<h3 class="text-2xl font-semibold text-primary dark:text-white">
		14. Revised Versions of this License.
	</h3>

	<p>
		The Free Software Foundation may publish revised and/or new versions of the GNU Affero General
		Public License from time to time. Such new versions will be similar in spirit to the present
		version, but may differ in detail to address new problems or concerns.
	</p>
	<p>
		Each version is given a distinguishing version number. If the Program specifies that a certain
		numbered version of the GNU Affero General Public License <strong>"or any later version"</strong
		> applies to it, you have the option of following the terms and conditions either of that numbered
		version or of any later version published by the Free Software Foundation. If the Program does not
		specify a version number of the GNU Affero General Public License, you may choose any version ever
		published by the Free Software Foundation.
	</p>
	<p>
		If the Program specifies that a proxy can decide which future versions of the GNU Affero General
		Public License can be used, that proxy's public statement of acceptance of a version permanently
		authorizes you to choose that version for the Program.
	</p>
	<p>
		Later license versions may give you additional or different permissions. However, no additional
		obligations are imposed on any author or copyright holder as a result of your choosing to follow
		a later version.
	</p>

	<h3 class="text-2xl font-semibold text-primary dark:text-white">15. Disclaimer of Warranty.</h3>

	<p class="font-semibold">
		THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN
		OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS
		IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
		THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK
		AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE
		DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
	</p>

	<h3 class="text-2xl font-semibold text-primary dark:text-white">16. Limitation of Liability.</h3>

	<p class="font-semibold">
		IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL ANY COPYRIGHT HOLDER,
		OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU
		FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF
		THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
		RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO
		OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
		POSSIBILITY OF SUCH DAMAGES.
	</p>

	<h3 class="text-2xl font-semibold text-primary dark:text-white">
		17. Interpretation of Sections 15 and 16.
	</h3>

	<p>
		If the disclaimer of warranty and limitation of liability provided above cannot be given local
		legal effect according to their terms, reviewing courts shall apply local law that most closely
		approximates an absolute waiver of all civil liability in connection with the Program, unless a
		warranty or assumption of liability accompanies a copy of the Program in return for a fee.
	</p>

	<h2 class="text-center text-3xl font-semibold text-primary dark:text-white">
		END OF TERMS AND CONDITIONS
	</h2>
</main>



================================================
FILE: src/routes/map/+layout.server.ts
================================================
import { redirect } from '@sveltejs/kit';
import type { LayoutServerLoad } from './$types';

export const load: LayoutServerLoad = ({ url }) => {
	// redirect to communities map if params match
	const community = url.searchParams.get('community');
	const organization = url.searchParams.get('organization');
	const language = url.searchParams.get('language');
	const communitiesOnly = url.searchParams.has('communitiesOnly');

	switch (true) {
		case Boolean(community):
			redirect(301, `/communities/map?community=${community}`);
			break;

		case Boolean(organization):
			redirect(301, `/communities/map?organization=${organization}`);
			break;

		case Boolean(language):
			redirect(301, `/communities/map?language=${language}`);
			break;

		case communitiesOnly:
			url.searchParams.delete('communitiesOnly');
			redirect(301, '/communities/map');
			break;
	}
};



================================================
FILE: src/routes/map/+page.svelte
================================================
<script lang="ts">
	import { browser } from '$app/environment';
	import { page } from '$app/stores';
	import Icon from '$components/Icon.svelte';
	import LoadingSpinner from '$components/LoadingSpinner.svelte';
	import MapLoadingMain from '$components/MapLoadingMain.svelte';
	import TileLoadingIndicator from './components/TileLoadingIndicator.svelte';
	import MerchantDrawerHash from './components/MerchantDrawerHash.svelte';
	import MerchantListPanel from './components/MerchantListPanel.svelte';
	import { merchantDrawer } from '$lib/merchantDrawerStore';
	import type { MerchantListMode } from '$lib/merchantListStore';
	import { merchantList } from '$lib/merchantListStore';
	import type { CategoryKey } from '$lib/categoryMapping';
	import { placeMatchesCategory } from '$lib/categoryMapping';
	import { trackEvent } from '$lib/analytics';
	import {
		BREAKPOINTS,
		MERCHANT_LIST_WIDTH,
		MERCHANT_DRAWER_WIDTH,
		MAP_FIT_BOUNDS_PADDING,
		CLUSTERING_DISABLED_ZOOM,
		BOOSTED_CLUSTERING_MAX_ZOOM,
		MERCHANT_LIST_LOW_ZOOM,
		MERCHANT_LIST_MAX_ITEMS,
		NEARBY_RADIUS_MULTIPLIER,
		MAX_LOADED_MARKERS,
		VIEWPORT_BATCH_SIZE,
		VIEWPORT_BUFFER_PERCENT,
		MAP_DEBOUNCE_DELAY,
		MARKER_CLICK_THROTTLE,
		DEFAULT_MAP_LAT,
		DEFAULT_MAP_LNG,
		DEFAULT_MAP_ZOOM
	} from '$lib/constants';
	import {
		calculateRadiusKm,
		getBufferedBounds,
		getVisiblePlaces,
		getZoomBehavior
	} from '$lib/map/viewport';
	import {
		clearMarkerSelection,
		highlightMarker,
		cleanupOutOfBoundsMarkers,
		type LoadedMarkers
	} from '$lib/map/markers';
	import {
		processPlaces,
		isSupported as isWorkerSupported,
		terminate as terminateWorker
	} from '$lib/workers/worker-manager';
	import type { ProcessedPlace } from '$lib/workers/map-worker';
	import { loadMapDependencies } from '$lib/map/imports';
	import {
		attribution,
		changeDefaultIcons,
		dataRefresh,
		generateIcon,
		generateMarker,
		geolocate,
		homeMarkerButtons,
		layers,
		scaleBars,
		support,
		updateMapHash
	} from '$lib/map/setup';
	import { detectTheme } from '$lib/utils';
	import {
		placesError,
		places,
		placesById,
		placesSyncCount,
		mapUpdates,
		lastUpdatedPlaceId,
		placesLoadingStatus,
		placesLoadingProgress
	} from '$lib/store';
	import type { Leaflet, Place } from '$lib/types';
	import { debounce, errToast, isBoosted } from '$lib/utils';
	import type { Control, LatLng, LatLngBounds, Map, Marker, MarkerClusterGroup } from 'leaflet';
	import localforage from 'localforage';
	import { onDestroy, onMount, tick } from 'svelte';
	import type { FeatureGroup } from 'leaflet';

	let mapLoading = 1;
	let mapLoadingStatus = 'Loading map...';

	// Combine map loading progress with places loading progress
	$: {
		// Priority 1: Places are actively loading (1-99%)
		if ($placesLoadingProgress > 0 && $placesLoadingProgress < 100) {
			mapLoading = $placesLoadingProgress;
			mapLoadingStatus = $placesLoadingStatus;
		}
		// Priority 2: Places complete (100%), map ready, initializing markers
		else if ($placesLoadingProgress === 100 && !elementsLoaded) {
			mapLoading = 100;
			mapLoadingStatus = $placesLoadingStatus;
		}
		// Priority 3: Loading initial markers (only during first load, not viewport updates)
		else if (isLoadingMarkers && !elementsLoaded) {
			mapLoading = 100;
			mapLoadingStatus = 'Loading places...';
		}
		// Priority 4: Waiting for map tiles to render
		else if (elementsLoaded && !mapTilesLoaded) {
			mapLoading = 100;
			mapLoadingStatus = 'Preparing map...';
		}
		// Reset when everything is done
		else if (elementsLoaded && mapTilesLoaded) {
			mapLoading = 0;
			mapLoadingStatus = '';
		}
	}

	let currentZoom = DEFAULT_MAP_ZOOM;
	let previousZoom = DEFAULT_MAP_ZOOM;

	// Throttled marker drawer opening to prevent freeze on rapid clicks
	let lastMarkerClickTime = 0;

	function openMerchantDrawer(id: number) {
		// Skip if same marker already selected
		if (selectedMarkerId === id) return;

		// Throttle rapid clicks
		const now = Date.now();
		if (now - lastMarkerClickTime < MARKER_CLICK_THROTTLE) return;
		lastMarkerClickTime = now;

		// Batch DOM operations with requestAnimationFrame
		requestAnimationFrame(() => {
			if (selectedMarkerId) {
				clearMarkerSelection(loadedMarkers, selectedMarkerId);
			}
			selectedMarkerId = id;
			highlightMarker(loadedMarkers, id);
		});

		merchantDrawer.open(id, 'details');
	}

	let leaflet: Leaflet;
	let DomEvent: typeof import('leaflet/src/dom/DomEvent');
	// eslint-disable-next-line @typescript-eslint/no-unused-vars
	let controlLayers: Control.Layers;
	let currentLayerName: string | null = null;

	let mapElement: HTMLDivElement;
	let map: Map;
	let mapLoaded = false;
	let elementsLoaded = false;
	let mapTilesLoaded = false;
	let tilesLoading = true;
	let tilesLoadingTimer: ReturnType<typeof setTimeout> | null = null;
	let tilesLoadingFallback: ReturnType<typeof setTimeout> | null = null;
	let glMapPollingTimer: ReturnType<typeof setTimeout> | null = null;

	let markers: MarkerClusterGroup;
	let upToDateLayer: FeatureGroup.SubGroup;
	let boostedLayer: FeatureGroup;
	let loadedMarkers: LoadedMarkers = {};
	let boostedLayerMarkerIds: Set<string> = new Set();
	let selectedMarkerId: number | null = null;

	let isLoadingMarkers = false;
	let isZooming = false;

	let mapCenter: LatLng;

	// Track selected category for marker filtering
	let previousCategory: CategoryKey = 'all';
	$: selectedCategory = $merchantList.selectedCategory;

	// Track mode transitions for search filtering
	let previousMode: MerchantListMode = 'nearby';
	let searchResultsRevision = 0;
	let previousSearchResultsRevision = 0;
	$: currentMode = $merchantList.mode;

	// Set of search result IDs for efficient marker filtering (respects category filter)
	let searchResultIds: Set<number> = new Set();

	// Update search result IDs when search results or category filter changes
	$: {
		if (
			$merchantList.mode === 'search' &&
			$merchantList.searchResults.length > 0 &&
			$merchantList.isOpen
		) {
			// Filter by category if one is selected
			const filtered =
				selectedCategory === 'all'
					? $merchantList.searchResults
					: $merchantList.searchResults.filter((p) => placeMatchesCategory(p, selectedCategory));
			searchResultIds = new Set(filtered.map((p) => p.id));
			searchResultsRevision++;
		} else {
			// Reset filtering when: switching to nearby, clearing search, closing panel, or 0 results
			searchResultIds = new Set();
			searchResultsRevision++;
		}
	}

	// Check if boosted markers should be clustered at current zoom level
	// At zoom 1-5: boosted markers cluster with regular markers
	// At zoom 6+: boosted markers are in separate non-clustered layer
	const shouldClusterBoostedMarkers = () => currentZoom <= BOOSTED_CLUSTERING_MAX_ZOOM;

	const handleHashChange = () => {
		if (!browser) return;

		// Sync store from hash - single source of truth
		merchantDrawer.syncFromHash();

		const hash = window.location.hash.substring(1);
		const hasDrawer = hash.includes('merchant=');

		if (!hasDrawer && selectedMarkerId) {
			clearMarkerSelection(loadedMarkers, selectedMarkerId);
			selectedMarkerId = null;
		} else if (hasDrawer) {
			const params = new URLSearchParams(hash.substring(hash.indexOf('&') + 1));
			const merchantParam = params.get('merchant');
			if (merchantParam) {
				const merchantId = Number(merchantParam);
				if (merchantId !== selectedMarkerId) {
					if (selectedMarkerId) {
						clearMarkerSelection(loadedMarkers, selectedMarkerId);
					}
					selectedMarkerId = merchantId;
					highlightMarker(loadedMarkers, merchantId);
				}
			}
		}
	};

	// Track current search request for cancellation
	let searchAbortController: AbortController | null = null;

	// Core search function
	const executeSearch = async (query: string) => {
		// Cancel any in-flight search request
		searchAbortController?.abort();

		if (query.length < 3) {
			return;
		}

		trackEvent('search_query');
		searchAbortController = new AbortController();

		// Close any open merchant drawer so it doesn't cover the search results
		merchantDrawer.close();
		merchantList.openSearchMode(true);

		try {
			const response = await fetch(`/api/search/places?name=${encodeURIComponent(query)}`, {
				signal: searchAbortController.signal
			});

			if (!response.ok) {
				throw new Error('Search API error');
			}

			const places: Place[] = await response.json();
			merchantList.openWithSearchResults(query, places);
		} catch (error) {
			// Ignore aborted requests (user typed new query)
			if (error instanceof Error && error.name === 'AbortError') {
				return;
			}
			console.error('Search error:', error);
			errToast('Search temporarily unavailable');
			merchantList.exitSearchMode();
		}
	};

	// Debounced search for panel input
	const debouncedPanelSearch = debounce((query: string) => executeSearch(query), 300);

	// Handler for panel search input
	const handlePanelSearch = (query: string) => {
		debouncedPanelSearch(query);
	};

	const handleModeChange = (mode: MerchantListMode) => {
		// Panel already handled the mode change via exitSearchMode(), just update the list
		if (mode === 'nearby') {
			searchAbortController?.abort();
			updateMerchantList();
		}
	};

	// allows for users to set initial view in a URL query
	const urlLat = $page.url.searchParams.getAll('lat');
	const urlLong = $page.url.searchParams.getAll('long');

	// allow to view map with only boosted locations
	const boosts = $page.url.searchParams.has('boosts');

	// displays a button in controls if there is new data available
	const showDataRefresh = () => {
		const refreshDiv: HTMLDivElement | null = document.querySelector('.data-refresh-div');
		if (!refreshDiv) return;
		refreshDiv.style.display = 'block';
	};

	$: map && mapLoaded && $mapUpdates && $placesSyncCount > 1 && showDataRefresh();

	// Reload markers and update merchant list when places sync completes after initial load
	$: if (elementsLoaded && $places.length && currentZoom >= MERCHANT_LIST_LOW_ZOOM) {
		debouncedLoadMarkers();
		debouncedUpdateMerchantList();
	}

	// Filter map markers when category filter changes
	$: if (elementsLoaded && upToDateLayer && selectedCategory !== previousCategory) {
		previousCategory = selectedCategory;
		clearNonMatchingMarkers(selectedCategory);
		debouncedLoadMarkers();
	}

	// Consolidated reactive block for search mode transitions and result changes
	// Handles: entering search mode, exiting search mode, and search results changing
	$: if (elementsLoaded && upToDateLayer) {
		const searchResultCount = searchResultIds.size;
		const modeChanged = currentMode !== previousMode;
		const resultsChanged = searchResultsRevision !== previousSearchResultsRevision;

		if (modeChanged) {
			previousMode = currentMode;
			if (currentMode === 'search' && searchResultCount > 0) {
				// Entering search mode with results
				clearNonSearchResultMarkers();
				loadSearchResultMarkers();
			} else if (currentMode === 'nearby') {
				// Exiting search mode: reload markers for current viewport
				debouncedLoadMarkers();
			}
		} else if (currentMode === 'search' && resultsChanged && searchResultCount > 0) {
			// Already in search mode but results changed (new search or category filter)
			clearNonSearchResultMarkers();
			loadSearchResultMarkers();
		}

		previousSearchResultsRevision = searchResultsRevision;
	}

	// alert for map errors
	$: $placesError && errToast($placesError);

	// Update marker icon when place is updated (boost or comment)
	$: if ($lastUpdatedPlaceId && leaflet && loadedMarkers) {
		const placeIdStr = $lastUpdatedPlaceId.toString();
		const marker = loadedMarkers[placeIdStr];

		if (marker) {
			// Find the updated place in the store
			const updatedPlace = $placesById.get($lastUpdatedPlaceId);

			if (updatedPlace) {
				// Regenerate icon with fresh data
				const commentsCount = typeof updatedPlace.comments === 'number' ? updatedPlace.comments : 0;
				const placeIsBoosted = isBoosted(updatedPlace) ? true : false;
				const markerInBoostedLayer = boostedLayerMarkerIds.has(placeIdStr);

				const newIcon = generateIcon(
					leaflet,
					updatedPlace.icon || 'question_mark',
					placeIsBoosted,
					commentsCount
				);

				// Update the marker icon
				marker.setIcon(newIcon);

				// Handle layer transition if boost status changed
				// At zoom 1-5, boosted markers stay clustered, so no layer change needed
				if (placeIsBoosted && !markerInBoostedLayer && !shouldClusterBoostedMarkers()) {
					// Place became boosted at zoom 6+ - move to non-clustered layer
					upToDateLayer.removeLayer(marker);
					markers.removeLayer(marker);
					boostedLayer.addLayer(marker);
					boostedLayerMarkerIds.add(placeIdStr);
					console.info(`Moved marker ${placeIdStr} to boosted layer`);
				} else if (!placeIsBoosted && markerInBoostedLayer) {
					// Boost expired - move to clustered layer
					boostedLayer.removeLayer(marker);
					boostedLayerMarkerIds.delete(placeIdStr);
					upToDateLayer.addLayer(marker);
					console.info(`Moved marker ${placeIdStr} to clustered layer`);
				} else {
					console.info(`Updated marker icon for place ${$lastUpdatedPlaceId}`);
				}
			}
		}

		// Reset the signal
		lastUpdatedPlaceId.set(undefined);
	}

	// Shared helper to remove markers by predicate
	const removeMarkersByPredicate = (shouldRemove: (placeId: string) => boolean): number => {
		const markersToRemove: string[] = [];

		Object.entries(loadedMarkers).forEach(([placeId, marker]) => {
			if (shouldRemove(placeId)) {
				upToDateLayer.removeLayer(marker);
				markers.removeLayer(marker);
				boostedLayer.removeLayer(marker);
				boostedLayerMarkerIds.delete(placeId);
				markersToRemove.push(placeId);
			}
		});

		markersToRemove.forEach((placeId) => {
			delete loadedMarkers[placeId];
		});

		return markersToRemove.length;
	};

	// Remove markers that don't match the selected category filter
	const clearNonMatchingMarkers = (category: CategoryKey) => {
		if (category === 'all') return;

		removeMarkersByPredicate((placeId) => {
			const place = $placesById.get(Number(placeId));
			return place ? !placeMatchesCategory(place, category) : false;
		});
	};

	// Check if a place ID is in the current search results
	const placeInSearchResults = (placeId: number): boolean => {
		return searchResultIds.has(placeId);
	};

	// Apply search filter to places if in search mode
	const applySearchFilter = (places: Place[]): Place[] => {
		return currentMode === 'search' && searchResultIds.size > 0
			? places.filter((place) => placeInSearchResults(place.id))
			: places;
	};

	// Remove markers that are not in the search results
	const clearNonSearchResultMarkers = () => {
		if (searchResultIds.size === 0) return;

		const removedCount = removeMarkersByPredicate(
			(placeId) => !placeInSearchResults(Number(placeId))
		);

		console.debug(
			`[SEARCH] Filtered to ${searchResultIds.size} search results, removed ${removedCount} markers`
		);
	};

	// Load markers for search results matching the current category filter
	const loadSearchResultMarkers = () => {
		if (searchResultIds.size === 0) return;

		// Only load markers that are in the filtered search results and not already loaded
		const placesToLoad = $merchantList.searchResults.filter(
			(place) => searchResultIds.has(place.id) && !loadedMarkers[place.id.toString()]
		);

		if (placesToLoad.length === 0) return;

		placesToLoad.forEach((place: Place) => {
			const commentsCount = place.comments || 0;
			const icon = place.icon;
			const boosted = place.boosted_until ? Date.parse(place.boosted_until) > Date.now() : false;

			const divIcon = generateIcon(leaflet, icon, boosted, commentsCount);

			const marker = generateMarker({
				lat: place.lat,
				long: place.lon,
				icon: divIcon,
				placeId: place.id,
				leaflet,
				verify: true,
				onMarkerClick: (id) => openMerchantDrawer(Number(id))
			});

			if (boosted && !shouldClusterBoostedMarkers()) {
				boostedLayer.addLayer(marker);
				boostedLayerMarkerIds.add(place.id.toString());
			} else {
				upToDateLayer.addLayer(marker);
			}
			loadedMarkers[place.id.toString()] = marker;

			if (selectedMarkerId === place.id) {
				highlightMarker(loadedMarkers, place.id);
			}
		});

		console.debug(`[SEARCH] Loaded ${placesToLoad.length} search result markers`);
	};

	// Helper to validate coordinates
	const isValidCoordinate = (lat: number, lon: number): boolean =>
		isFinite(lat) && isFinite(lon) && lat >= -90 && lat <= 90 && lon >= -180 && lon <= 180;

	// Fit map bounds to show all search results (respects category filter)
	const fitBoundsToSearchResults = () => {
		if (!map || $merchantList.searchResults.length === 0) return;

		try {
			// Filter by category if one is selected
			const categoryFiltered =
				selectedCategory === 'all'
					? $merchantList.searchResults
					: $merchantList.searchResults.filter((p) => placeMatchesCategory(p, selectedCategory));

			// Validate coordinates to prevent map errors
			const results = categoryFiltered.filter((p) => isValidCoordinate(p.lat, p.lon));

			if (results.length === 0) return;

			// Single result: zoom to it
			if (results.length === 1) {
				map.setView([results[0].lat, results[0].lon], 17, { animate: true });
				return;
			}

			// Multiple results: calculate bounds
			const lats = results.map((p) => p.lat);
			const lons = results.map((p) => p.lon);
			const minLat = Math.min(...lats);
			const maxLat = Math.max(...lats);
			const minLon = Math.min(...lons);
			const maxLon = Math.max(...lons);

			const bounds = leaflet.latLngBounds([minLat, minLon], [maxLat, maxLon]);

			// Account for panel width when open (desktop only)
			const { panelWidth } = getPanelOffset();
			const paddingRight = MAP_FIT_BOUNDS_PADDING + panelWidth;

			map.fitBounds(bounds, {
				paddingTopLeft: [MAP_FIT_BOUNDS_PADDING, MAP_FIT_BOUNDS_PADDING],
				paddingBottomRight: [paddingRight, MAP_FIT_BOUNDS_PADDING],
				animate: true,
				maxZoom: 17
			});
		} catch (error) {
			console.debug('[SEARCH] Error fitting bounds to search results:', error);
		}
	};

	// Move boosted markers between layers when zoom crosses the threshold
	const handleBoostedLayerTransition = (fromZoom: number, toZoom: number) => {
		const crossedThreshold =
			(fromZoom <= BOOSTED_CLUSTERING_MAX_ZOOM && toZoom > BOOSTED_CLUSTERING_MAX_ZOOM) ||
			(fromZoom > BOOSTED_CLUSTERING_MAX_ZOOM && toZoom <= BOOSTED_CLUSTERING_MAX_ZOOM);

		if (!crossedThreshold || !markers || !boostedLayer) return;

		const shouldClusterBoosted = toZoom <= BOOSTED_CLUSTERING_MAX_ZOOM;

		if (shouldClusterBoosted) {
			// Moving from zoom 6+ to zoom 5-: move boosted markers to cluster layer
			const markersToMove: Marker[] = [];
			boostedLayerMarkerIds.forEach((placeId) => {
				const marker = loadedMarkers[placeId];
				if (marker) {
					boostedLayer.removeLayer(marker);
					markersToMove.push(marker);
				}
			});
			if (markersToMove.length > 0) {
				markers.addLayers(markersToMove);
				boostedLayerMarkerIds.clear();
				console.info(`Moved ${markersToMove.length} boosted markers to clustered layer`);
			}
		} else {
			// Moving from zoom 5- to zoom 6+: move boosted markers to non-clustered layer
			const markersToMove: Array<{ marker: Marker; placeId: string }> = [];
			Object.entries(loadedMarkers).forEach(([placeId, marker]) => {
				const place = $placesById.get(Number(placeId));
				if (place && isBoosted(place)) {
					markersToMove.push({ marker, placeId });
				}
			});
			markersToMove.forEach(({ marker, placeId }) => {
				markers.removeLayer(marker);
				upToDateLayer.removeLayer(marker);
				boostedLayer.addLayer(marker);
				boostedLayerMarkerIds.add(placeId);
			});
			if (markersToMove.length > 0) {
				console.info(`Moved ${markersToMove.length} boosted markers to non-clustered layer`);
			}
		}
	};

	// Load markers for places in current viewport using web workers
	const loadMarkersInViewport = async () => {
		// Skip if zooming, not ready, or already loading
		if (!map || !$places.length || isLoadingMarkers || isZooming) {
			return;
		}

		isLoadingMarkers = true;

		// Check if map has valid bounds (center and zoom are set)
		let bounds;
		try {
			bounds = map.getBounds();
			if (!bounds) {
				isLoadingMarkers = false;
				return;
			}
		} catch (error) {
			console.warn('Error getting map bounds, map not ready yet:', error);
			isLoadingMarkers = false;
			return;
		}

		try {
			// Get visible places (viewport + category filtering)
			const visiblePlaces = getVisiblePlaces(leaflet, $places, bounds, VIEWPORT_BUFFER_PERCENT);
			const categoryFiltered =
				selectedCategory === 'all'
					? visiblePlaces
					: visiblePlaces.filter((place) => placeMatchesCategory(place, selectedCategory));

			// Apply search filter if in search mode
			const searchFiltered = applySearchFilter(categoryFiltered);

			// Filter out places that already have markers loaded
			const placesToLoad = searchFiltered.filter((place) => !loadedMarkers[place.id.toString()]);

			if (placesToLoad.length === 0) {
				isLoadingMarkers = false;
				return;
			}

			// Clean up markers outside viewport if we have many loaded
			if (Object.keys(loadedMarkers).length > MAX_LOADED_MARKERS) {
				cleanupOutOfBoundsMarkers({
					loadedMarkers,
					upToDateLayer,
					boostedLayer,
					boostedLayerMarkerIds,
					bounds
				});
			}

			// Check if web workers are supported before trying to use them
			if (isWorkerSupported()) {
				// Process places using web worker
				await processPlaces(
					placesToLoad,
					VIEWPORT_BATCH_SIZE,
					(progress: number, batch?: ProcessedPlace[]) => {
						// Process batch on main thread (DOM operations)
						if (batch) {
							processBatchOnMainThread(batch, upToDateLayer);
						}
					}
				);
			} else {
				console.warn('Web workers not supported, using synchronous fallback');
				// Fallback to synchronous processing
				loadMarkersInViewportFallback(bounds);
				return;
			}

			console.info(`[VIEWPORT] Successfully loaded ${placesToLoad.length} markers`);
		} catch (error) {
			console.error('[VIEWPORT] Error loading markers:', error);
			// Fallback to synchronous processing for viewport
			loadMarkersInViewportFallback(bounds);
		} finally {
			isLoadingMarkers = false;
		}
	};

	// Fallback synchronous loading for viewport (much smaller dataset)
	const loadMarkersInViewportFallback = (bounds: LatLngBounds) => {
		const visiblePlaces = getVisiblePlaces(leaflet, $places, bounds, VIEWPORT_BUFFER_PERCENT);
		const categoryFiltered =
			selectedCategory === 'all'
				? visiblePlaces
				: visiblePlaces.filter((place) => placeMatchesCategory(place, selectedCategory));
		const searchFiltered = applySearchFilter(categoryFiltered);
		const placesToLoad = searchFiltered.filter((place) => !loadedMarkers[place.id.toString()]);

		placesToLoad.forEach((place: Place) => {
			const commentsCount = place.comments || 0;
			const icon = place.icon;
			const boosted = place.boosted_until ? Date.parse(place.boosted_until) > Date.now() : false;

			const divIcon = generateIcon(leaflet, icon, boosted, commentsCount);

			const marker = generateMarker({
				lat: place.lat,
				long: place.lon,
				icon: divIcon,
				placeId: place.id,
				leaflet,
				verify: true,
				onMarkerClick: (id) => openMerchantDrawer(Number(id))
			});

			// Route to appropriate layer based on boost status and zoom level
			if (boosted && !shouldClusterBoostedMarkers()) {
				boostedLayer.addLayer(marker);
				boostedLayerMarkerIds.add(place.id.toString());
			} else {
				upToDateLayer.addLayer(marker);
			}
			loadedMarkers[place.id.toString()] = marker;

			// Highlight if this is the selected marker (may be pending from search result click)
			if (selectedMarkerId === place.id) {
				highlightMarker(loadedMarkers, place.id);
			}
		});
	};

	// Debounced version to prevent excessive loading during rapid pan/zoom
	const debouncedLoadMarkers = debounce(loadMarkersInViewport, MAP_DEBOUNCE_DELAY);

	// Debounced coords caching to prevent IndexedDB overflow during continuous movement
	const debouncedCacheCoords = debounce((coords: LatLngBounds) => {
		localforage.setItem('coords', coords).catch(function (err) {
			console.error('Error caching coords:', err);
		});
	}, 1000); // 1 second debounce for IndexedDB writes

	// Zoom 15+: Use locally loaded markers, optionally enrich with API data
	const updateListLocalMarkers = (
		center: LatLng,
		bounds: LatLngBounds,
		allowHeavyFetch: boolean
	) => {
		// Expand bounds by 25% on each edge (equivalent to 1.5x radius for API calls)
		const expandedBounds = getBufferedBounds(leaflet, bounds, 0.25);
		const allVisiblePlaces = $places.filter((place) =>
			expandedBounds.contains([place.lat, place.lon])
		);

		merchantList.setMerchants(allVisiblePlaces, center.lat, center.lng);

		if ($merchantList.isOpen && allowHeavyFetch) {
			const radiusKm = calculateRadiusKm(bounds) * NEARBY_RADIUS_MULTIPLIER;
			merchantList.fetchEnrichedDetails({ lat: center.lat, lon: center.lng }, radiusKm);
		}
	};

	// Zoom 11-14: Fetch from API with result limit (may show "zoom in" message)
	const updateListApiWithLimit = (
		center: LatLng,
		bounds: LatLngBounds,
		allowHeavyFetch: boolean
	) => {
		const radiusKm = calculateRadiusKm(bounds) * NEARBY_RADIUS_MULTIPLIER;

		if (!$merchantList.isOpen || !allowHeavyFetch) {
			merchantList.fetchCountOnly({ lat: center.lat, lon: center.lng }, radiusKm);
		} else {
			merchantList.fetchAndReplaceList({ lat: center.lat, lon: center.lng }, radiusKm, {
				hideIfExceeds: MERCHANT_LIST_MAX_ITEMS
			});
		}
	};

	// Update merchant list panel based on zoom level and visible places
	const updateMerchantList = (opts?: { force?: boolean }) => {
		if (!browser || !map) return;

		// Skip updates in search mode - search results are independent of map viewport
		if ($merchantList.mode === 'search') return;

		const bounds = map.getBounds();
		const center = map.getCenter();
		const behavior = getZoomBehavior(currentZoom);
		const isDesktop = window.innerWidth >= BREAKPOINTS.md;

		// Determine if we should fetch full data or just count
		// - Desktop: always fetch full data (list panel visible alongside map)
		// - Force flag: explicit user action (e.g., button click)
		// - List open: user is actively viewing the list (mobile or desktop)
		const allowHeavyFetch = isDesktop || opts?.force || $merchantList.isOpen;

		switch (behavior) {
			case 'local-markers':
				updateListLocalMarkers(center, bounds, allowHeavyFetch);
				break;
			case 'api-with-limit':
				updateListApiWithLimit(center, bounds, allowHeavyFetch);
				break;
			case 'none':
			default:
				merchantList.setMerchants([], 0, 0);
		}
	};

	// Debounced version to prevent excessive updates during pan/zoom
	const debouncedUpdateMerchantList = debounce(updateMerchantList, MAP_DEBOUNCE_DELAY);

	// Calculate panel width for map offset (desktop only - mobile panels are at bottom)
	// Accounts for both MerchantListPanel (left) and MerchantDrawer (stacked to its right)
	const getPanelOffset = () => {
		const mapSize = map!.getSize();
		const isDesktop = mapSize.x >= BREAKPOINTS.md;
		const listWidth = isDesktop && $merchantList.isOpen ? MERCHANT_LIST_WIDTH : 0;
		const drawerWidth = isDesktop && $merchantDrawer.isOpen ? MERCHANT_DRAWER_WIDTH : 0;
		const panelWidth = listWidth + drawerWidth;
		const visibleCenterX = (mapSize.x - panelWidth) / 2;
		return { panelWidth, visibleCenterX, mapSize };
	};

	// Shared helper: navigate map to a place with drawer offset compensation
	const navigateToPlace = (
		place: Place,
		options: { targetZoom?: number; spiderfyCluster?: boolean } = {}
	) => {
		if (!map || !browser) return;

		const { visibleCenterX, mapSize } = getPanelOffset();
		const { targetZoom, spiderfyCluster = false } = options;

		if (targetZoom !== undefined) {
			// Zoom to specific level: calculate offset at target zoom
			const offsetX = mapSize.x / 2 - visibleCenterX;
			const targetPoint = map.project([place.lat, place.lon], targetZoom);
			const offsetPoint = leaflet.point(targetPoint.x + offsetX, targetPoint.y);
			const offsetLatLng = map.unproject(offsetPoint, targetZoom);
			map.setView(offsetLatLng, targetZoom, { animate: true, duration: 0.3 });
		} else {
			// Pan only: calculate offset at current zoom
			const targetPoint = map.latLngToContainerPoint([place.lat, place.lon]);
			const offsetX = targetPoint.x - visibleCenterX;
			const offsetY = targetPoint.y - mapSize.y / 2;

			const currentCenter = map.getCenter();
			const currentCenterPoint = map.latLngToContainerPoint(currentCenter);
			const newCenterPoint = leaflet.point(
				currentCenterPoint.x + offsetX,
				currentCenterPoint.y + offsetY
			);
			const newCenter = map.containerPointToLatLng(newCenterPoint);
			map.panTo(newCenter, { animate: true, duration: 0.3 });
		}

		// Optionally spiderfy cluster containing the marker
		// Skip only if marker is in boosted layer (not clustered)
		const isInBoostedLayer =
			boostedLayerMarkerIds.has(place.id.toString()) && !shouldClusterBoostedMarkers();
		if (spiderfyCluster && !isInBoostedLayer) {
			const marker = loadedMarkers[place.id.toString()];
			if (marker && markers) {
				const cluster = markers.getVisibleParent(marker);
				if (cluster && cluster !== marker && 'spiderfy' in cluster) {
					(cluster as { spiderfy: () => void }).spiderfy();
				}
			}
		}
	};

	// Pan to a nearby merchant (user is already zoomed in, just center the marker)
	const panToNearbyMerchant = (place: Place) => {
		navigateToPlace(place, { spiderfyCluster: true });
	};

	// Zoom to a search result (user may be far away, fly to the location)
	const zoomToSearchResult = (place: Place) => {
		navigateToPlace(place, { targetZoom: 19 });
	};

	const initializeElements = async () => {
		if (elementsLoaded) {
			return;
		}

		mapLoadingStatus = 'Initializing markers...';

		// create marker cluster group and layers
		/* eslint-disable no-undef */
		// @ts-expect-error - L is global from Leaflet
		markers = L.markerClusterGroup({
			maxClusterRadius: 80,
			disableClusteringAtZoom: CLUSTERING_DISABLED_ZOOM,
			chunkedLoading: true,
			chunkInterval: 50,
			chunkDelay: 50
		});
		/* eslint-enable no-undef */
		upToDateLayer = leaflet.featureGroup.subGroup(markers);
		boostedLayer = leaflet.featureGroup();

		// Add layers to map immediately so batches can be added
		map.addLayer(markers);
		map.addLayer(upToDateLayer);
		map.addLayer(boostedLayer); // Added last to render on top of clusters

		// Set up zoom guard - prevent marker loading during zoom animation
		map.on('zoomstart', () => {
			isZooming = true;
		});

		// Consolidated map event listener - moveend fires after both pan and zoom
		map.on('moveend', () => {
			isZooming = false;
			const coords = map.getBounds();
			mapCenter = map.getCenter();
			const newZoom = map.getZoom();

			// Handle boosted marker layer transitions when crossing zoom threshold
			handleBoostedLayerTransition(previousZoom, newZoom);
			previousZoom = newZoom;
			currentZoom = newZoom;

			// Update hash if not using URL parameters
			if (!urlLat.length && !urlLong.length) {
				updateMapHash(currentZoom, mapCenter);
			}

			// Debounced operations
			debouncedCacheCoords(coords);
			debouncedLoadMarkers();
			debouncedUpdateMerchantList();
		});

		mapLoadingStatus = 'Loading places in view...';

		// Initialize mapCenter and zoom for merchant list panel and marker layer decisions
		mapCenter = map.getCenter();
		currentZoom = map.getZoom();
		previousZoom = currentZoom;

		// Load initial markers for current viewport
		// NOTE: Don't set isLoadingMarkers=true here, let loadMarkersInViewport handle it
		await loadMarkersInViewport();

		// eslint-disable-next-line svelte/infinite-reactive-loop -- this breaks the loop, not causes it
		elementsLoaded = true;

		if (browser) {
			const hash = window.location.hash.substring(1);
			if (hash.includes('merchant=')) {
				const params = new URLSearchParams(hash.substring(hash.indexOf('&') + 1));
				const merchantParam = params.get('merchant');
				if (merchantParam) {
					const merchantId = Number(merchantParam);
					selectedMarkerId = merchantId;
					highlightMarker(loadedMarkers, merchantId);
				}
			}

			// Initialize merchant list if already zoomed in
			updateMerchantList();
		}
	};

	// Process a batch of places on the main thread (DOM operations only)
	const processBatchOnMainThread = (batch: ProcessedPlace[], _layer: FeatureGroup.SubGroup) => {
		const regularMarkersToAdd: Marker[] = [];
		const boostedMarkersToAdd: Marker[] = [];

		batch.forEach((element: ProcessedPlace) => {
			const { iconData } = element;
			const placeId = element.id.toString();

			// Skip if marker already loaded (double-check)
			if (loadedMarkers[placeId]) return;

			// Generate icon using pre-calculated data from worker
			const divIcon = generateIcon(
				leaflet,
				iconData.iconTmp,
				iconData.boosted,
				iconData.commentsCount
			);

			const marker = generateMarker({
				lat: element.lat,
				long: element.lon,
				icon: divIcon,
				placeId: element.id,
				leaflet,
				verify: true,
				onMarkerClick: (id) => openMerchantDrawer(Number(id))
			});

			// Route to appropriate layer based on boost status and zoom level
			if (iconData.boosted && !shouldClusterBoostedMarkers()) {
				boostedMarkersToAdd.push(marker);
				boostedLayerMarkerIds.add(placeId);
			} else {
				regularMarkersToAdd.push(marker);
			}
			loadedMarkers[placeId] = marker;
		});

		// Batch add regular markers to cluster group
		if (regularMarkersToAdd.length > 0 && markers) {
			markers.addLayers(regularMarkersToAdd);
		}

		// Add boosted markers to non-clustered layer (only at zoom > 5)
		if (boostedMarkersToAdd.length > 0 && boostedLayer) {
			boostedMarkersToAdd.forEach((m) => boostedLayer.addLayer(m));
		}

		// Highlight the selected marker if it was just loaded (may be pending from search result click)
		if ((regularMarkersToAdd.length > 0 || boostedMarkersToAdd.length > 0) && selectedMarkerId) {
			highlightMarker(loadedMarkers, selectedMarkerId);
		}
	};

	// Initialize elements when places data is ready and map is loaded
	// The guard inside initializeElements() prevents multiple calls
	$: if ($places?.length && mapLoaded && !elementsLoaded) {
		// eslint-disable-next-line svelte/infinite-reactive-loop -- elementsLoaded=true stops the loop
		initializeElements();
	}

	onMount(async () => {
		if (browser) {
			const deps = await loadMapDependencies();
			leaflet = deps.leaflet;
			DomEvent = deps.DomEvent;
			const LocateControl = deps.LocateControl;

			// add map and tiles
			map = window.L.map(mapElement, { maxZoom: 19 });

			// Helper function to set mapLoaded after view is set
			const setMapViewAndMarkLoaded = () => {
				mapCenter = map.getCenter();
				mapLoaded = true;
			};

			// use url hash if present
			if (location.hash) {
				try {
					// Extract only the map coordinates part (before any & parameters)
					const hashPart = location.hash.split('&')[0];
					const coords = hashPart.split('/');
					map.setView([Number(coords[1]), Number(coords[2])], Number(coords[0].slice(1)));
					setMapViewAndMarkLoaded();
				} catch (error) {
					map.setView([DEFAULT_MAP_LAT, DEFAULT_MAP_LNG], DEFAULT_MAP_ZOOM);
					setMapViewAndMarkLoaded();
					errToast(
						'Could not set map view to provided coordinates, please try again or contact BTC Map.'
					);
					console.error(error);
				}
			}

			// set URL lat/long query view if it exists and is valid
			else if (urlLat.length && urlLong.length) {
				try {
					if (urlLat.length > 1 && urlLong.length > 1) {
						map.fitBounds([
							[Number(urlLat[0]), Number(urlLong[0])],
							[Number(urlLat[1]), Number(urlLong[1])]
						]);
						setMapViewAndMarkLoaded();
					} else {
						map.fitBounds([[Number(urlLat[0]), Number(urlLong[0])]]);
						setMapViewAndMarkLoaded();
					}
				} catch (error) {
					map.setView([DEFAULT_MAP_LAT, DEFAULT_MAP_LNG], DEFAULT_MAP_ZOOM);
					setMapViewAndMarkLoaded();
					errToast(
						'Could not set map view to provided coordinates, please try again or contact BTC Map.'
					);
					console.error(error);
				}
			}

			// set view to last location if it is present in the cache
			else {
				localforage
					.getItem<LatLngBounds>('coords')
					.then(function (value) {
						if (value) {
							map.fitBounds([
								// @ts-expect-error - LatLngBounds internal structure access
								[value._northEast.lat, value._northEast.lng],
								// @ts-expect-error - LatLngBounds internal structure access
								[value._southWest.lat, value._southWest.lng]
							]);
						} else {
							map.setView([DEFAULT_MAP_LAT, DEFAULT_MAP_LNG], DEFAULT_MAP_ZOOM);
						}
						setMapViewAndMarkLoaded();
					})
					.catch(function (err) {
						map.setView([DEFAULT_MAP_LAT, DEFAULT_MAP_LNG], DEFAULT_MAP_ZOOM);
						setMapViewAndMarkLoaded();
						errToast(
							'Could not set map view to cached coords, please try again or contact BTC Map.'
						);
						console.error(err);
					});
			}

			// add tiles and basemaps
			const { baseMaps, activeLayer } = layers(leaflet, map);

			// Initialize current layer name for deduplication tracking
			currentLayerName = detectTheme() === 'dark' ? 'Carto Dark Matter' : 'OpenFreeMap Liberty';

			// Hook into MapLibre GL tile loading events
			if (activeLayer && activeLayer.getMaplibreMap) {
				// MapLibre GL map might not be ready immediately, poll for it
				const checkGlMap = () => {
					const glMap = activeLayer.getMaplibreMap();
					if (glMap) {
						// Clear polling timer now that GL map is ready
						if (glMapPollingTimer) {
							clearTimeout(glMapPollingTimer);
							glMapPollingTimer = null;
						}
						glMap.on('idle', () => {
							if (tilesLoadingTimer) {
								clearTimeout(tilesLoadingTimer);
								tilesLoadingTimer = null;
							}
							if (tilesLoadingFallback) {
								clearTimeout(tilesLoadingFallback);
								tilesLoadingFallback = null;
							}
							mapTilesLoaded = true;
							tilesLoading = false;
						});
					} else {
						// GL map not ready yet, check again after a short delay
						glMapPollingTimer = setTimeout(checkGlMap, 100);
					}
				};
				checkGlMap();
			} else {
				// Fallback: if not using MapLibre GL layer, mark tiles as loaded immediately
				mapTilesLoaded = true;
				tilesLoading = false;
			}

			// Show tile loading indicator on pan/zoom (debounced to prevent flickering)
			map.on('movestart', () => {
				if (tilesLoadingTimer) clearTimeout(tilesLoadingTimer);
				if (tilesLoadingFallback) clearTimeout(tilesLoadingFallback);

				// Only show indicator if loading takes > 150ms
				tilesLoadingTimer = setTimeout(() => {
					tilesLoading = true;
				}, 150);

				// Fallback: hide indicator after 5s if idle never fires
				tilesLoadingFallback = setTimeout(() => {
					tilesLoading = false;
				}, 5000);
			});

			// Close drawer when clicking on map (not on markers)
			map.on('click', () => {
				if ($merchantDrawer.isOpen) {
					if (selectedMarkerId) {
						clearMarkerSelection(loadedMarkers, selectedMarkerId);
						selectedMarkerId = null;
					}
					merchantDrawer.close();
				}
			});

			// change broken marker image path in prod
			leaflet.Icon.Default.prototype.options.imagePath = '/icons/';

			// add support attribution
			support();

			// add OSM attribution
			attribution(leaflet, map);

			// add scale
			scaleBars(leaflet, map);

			// add locate button to map
			geolocate(leaflet, map, LocateControl);

			// add new control container for search and boost
			const customControls = leaflet.Control.extend({
				options: {
					position: 'topleft'
				},
				onAdd: () => {
					const addControlDiv = leaflet.DomUtil.create('div');
					addControlDiv.classList.add(
						'leaflet-control-search-boost',
						'leaflet-bar',
						'leaflet-control'
					);

					// Search button - opens panel in search mode
					const searchButton = leaflet.DomUtil.create('a');
					searchButton.classList.add('leaflet-control-search-toggle');
					searchButton.title = 'Search';
					searchButton.role = 'button';
					searchButton.ariaLabel = 'Search';
					searchButton.ariaDisabled = 'false';
					searchButton.innerHTML = `<img src='/icons/search.svg' alt='search' style='width: 16px; height: 16px;'/>`;
					searchButton.onclick = function openSearch() {
						trackEvent('search_button_click');
						// Open panel in search mode (will auto-focus input)
						merchantList.openSearchMode();
					};
					addControlDiv.append(searchButton);

					// Boost layer button
					const boostLayerButton = leaflet.DomUtil.create('a');
					boostLayerButton.classList.add('leaflet-control-boost-layer');
					boostLayerButton.title = 'Boosted locations';
					boostLayerButton.role = 'button';
					boostLayerButton.ariaLabel = 'Boosted locations';
					boostLayerButton.ariaDisabled = 'false';
					boostLayerButton.innerHTML = `<img src='${boosts ? '/icons/boost-solid.svg' : '/icons/boost.svg'}' alt='boost' id='boost-layer' style='width: 16px; height: 16px;'/>`;
					boostLayerButton.onclick = function toggleLayer() {
						trackEvent('boost_layer_toggle');
						if (boosts) {
							$page.url.searchParams.delete('boosts');
							location.search = $page.url.search;
						} else {
							$page.url.searchParams.append('boosts', 'true');
							location.search = $page.url.search;
						}
					};
					addControlDiv.append(boostLayerButton);

					return addControlDiv;
				}
			});

			map.addControl(new customControls());
			const boostLayer = document.querySelector('.leaflet-control-boost-layer');
			if (boostLayer) {
				DomEvent.disableClickPropagation(boostLayer as HTMLElement);
			}

			// Search bar control - re-enabled for API-based search
			// @ts-expect-error accessing private Leaflet map internals for custom control placement
			map._controlCorners['topcenter'] = leaflet.DomUtil.create(
				'div',
				'leaflet-top leaflet-center',
				// @ts-expect-error accessing private Leaflet map internals
				map._controlContainer
			);

			// disable map events for search toggle
			const searchToggle = document.querySelector('.leaflet-control-search-toggle');
			if (searchToggle) {
				DomEvent.disableClickPropagation(searchToggle as HTMLElement);
			}

			// add home and marker buttons to map
			homeMarkerButtons(leaflet, map, DomEvent, true);

			// add data refresh button to map
			dataRefresh(leaflet, map, DomEvent);

			controlLayers = leaflet.control.layers(baseMaps).addTo(map);

			// track layer changes (with deduplication to avoid tracking same layer selection)
			map.on('baselayerchange', (e: { name: string }) => {
				if (e.name !== currentLayerName) {
					trackEvent('layer_change', { layer: e.name });
					currentLayerName = e.name;
				}
			});

			// change default icons
			changeDefaultIcons(true, leaflet, mapElement, DomEvent);

			// final map setup
			map.on('load', () => {
				mapCenter = map.getCenter();
				mapLoaded = true;
			});

			// Watch for hash changes to clear marker selection when drawer closes
			window.addEventListener('hashchange', handleHashChange);

			// Sync drawer state from URL hash on initial page load
			merchantDrawer.syncFromHash();
		}
	});

	onDestroy(async () => {
		// Cancel pending debounced operations to prevent memory leaks
		if (debouncedLoadMarkers?.cancel) debouncedLoadMarkers.cancel();
		if (debouncedCacheCoords?.cancel) debouncedCacheCoords.cancel();
		if (tilesLoadingTimer) clearTimeout(tilesLoadingTimer);
		if (tilesLoadingFallback) clearTimeout(tilesLoadingFallback);
		if (glMapPollingTimer) clearTimeout(glMapPollingTimer);
		if (debouncedUpdateMerchantList?.cancel) debouncedUpdateMerchantList.cancel();
		if (debouncedPanelSearch?.cancel) debouncedPanelSearch.cancel();
		searchAbortController?.abort();

		// Reset merchant list
		merchantList.reset();

		if (map) {
			console.info('Unloading Leaflet map.');
			map.remove();
		}
		// Clean up web worker
		terminateWorker();

		// Reset loading progress when leaving map page to avoid stale states
		placesLoadingProgress.set(0);
		placesLoadingStatus.set('');

		// Remove hash change listener
		if (browser) {
			window.removeEventListener('hashchange', handleHashChange);
		}
	});
</script>

<svelte:head>
	<title>BTC Map</title>
	<meta property="og:image" content="https://btcmap.org/images/og/map.png" />
	<meta property="twitter:title" content="BTC Map" />
	<meta property="twitter:image" content="https://btcmap.org/images/og/map.png" />
</svelte:head>

<main class="flex h-screen w-full">
	<h1 class="hidden">Map</h1>

	<MapLoadingMain progress={mapLoading} status={mapLoadingStatus} />

	<!-- Merchant list panel (search results + nearby merchants) -->
	<MerchantListPanel
		onPanToNearbyMerchant={panToNearbyMerchant}
		onZoomToSearchResult={zoomToSearchResult}
		onFitSearchResultBounds={fitBoundsToSearchResults}
		onHoverStart={(place) => highlightMarker(loadedMarkers, place.id)}
		onHoverEnd={(place) => {
			// Don't clear if this is the selected marker
			if (selectedMarkerId !== place.id) {
				clearMarkerSelection(loadedMarkers, place.id);
			}
		}}
		onSearch={handlePanelSearch}
		onModeChange={handleModeChange}
		onRefresh={() => updateMerchantList({ force: true })}
		{currentZoom}
	/>

	<!-- Map container -->
	<div class="relative flex-1">
		<!-- Floating toggle button for merchant list (responsive positioning) -->
		<!-- Hide when list is open, or on mobile when drawer is open -->
		{#if mapLoaded && !$merchantList.isOpen}
			<button
				on:click={async () => {
					trackEvent('nearby_button_click');
					merchantList.open();
					// Reset to nearby mode when opening via toggle button
					merchantList.setMode('nearby');
					// Wait for store update to propagate before fetching
					await tick();
					updateMerchantList({ force: true });
				}}
				class="fixed right-4 bottom-[40px] z-[1000] flex items-center gap-2 rounded-full bg-white px-4 py-3 text-sm font-medium
					shadow-lg transition-colors hover:bg-gray-50 md:top-[10px] md:right-auto
					md:bottom-auto md:left-[60px] md:rounded-lg md:px-3 md:py-2 dark:bg-dark dark:hover:bg-white/10
					{$merchantDrawer.isOpen ? 'max-md:hidden' : ''}"
				style="filter: drop-shadow(0px 2px 6px rgba(0, 0, 0, 0.3));"
				aria-label="Open merchant list"
				aria-expanded={$merchantList.isOpen}
			>
				<Icon w="18" h="18" icon="menu" type="material" class="text-primary dark:text-white" />
				{#if currentZoom >= MERCHANT_LIST_LOW_ZOOM && $merchantList.isLoadingList}
					<LoadingSpinner size="h-4 w-4" color="text-primary dark:text-white" />
					<span class="text-primary dark:text-white">Nearby</span>
				{:else if currentZoom >= MERCHANT_LIST_LOW_ZOOM && $merchantList.totalCount > 0}
					<span class="text-primary dark:text-white"
						>{$merchantList.totalCount > MERCHANT_LIST_MAX_ITEMS
							? `>${MERCHANT_LIST_MAX_ITEMS}`
							: $merchantList.totalCount} Nearby</span
					>
				{:else}
					<span class="text-primary dark:text-white">Nearby</span>
				{/if}
			</button>
		{/if}

		<div bind:this={mapElement} class="map-fullscreen absolute inset-0 !bg-teal dark:!bg-dark" />
	</div>

	<MerchantDrawerHash />

	<TileLoadingIndicator visible={tilesLoading} />
</main>



================================================
FILE: src/routes/map/components/MerchantDrawerDesktop.svelte
================================================
<script lang="ts">
	import { boost, resetBoost } from '$lib/store';
	import CloseButton from '$components/CloseButton.svelte';
	import Icon from '$components/Icon.svelte';
	import { fly } from 'svelte/transition';
	import BoostContent from '$components/BoostContent.svelte';
	import MerchantDetailsContent from '$components/MerchantDetailsContent.svelte';
	import { invalidateAll } from '$app/navigation';
	import { onMount } from 'svelte';
	import { merchantDrawer } from '$lib/merchantDrawerStore';
	import { merchantList } from '$lib/merchantListStore';
	import { MERCHANT_LIST_WIDTH, MERCHANT_DRAWER_WIDTH } from '$lib/constants';
	import {
		calcVerifiedDate,
		isUpToDate as checkUpToDate,
		isBoosted as checkBoosted,
		handleBoost as boostMerchant,
		handleBoostComplete as completeBoost,
		ensureBoostData,
		clearBoostState
	} from '$lib/merchantDrawerLogic';

	// Derive state from centralized store
	$: isOpen = $merchantDrawer.isOpen;
	$: merchantId = $merchantDrawer.merchantId;
	$: drawerView = $merchantDrawer.drawerView;
	$: merchant = $merchantDrawer.merchant;
	$: fetchingMerchant = $merchantDrawer.isLoading;
	$: listIsOpen = $merchantList.isOpen;

	const verifiedDate = calcVerifiedDate();
	$: isUpToDate = checkUpToDate(merchant, verifiedDate);
	$: isBoosted = checkBoosted(merchant);

	let boostLoading = false;
	const setBoostLoading = (loading: boolean) => {
		boostLoading = loading;
	};

	const closeDrawer = () => {
		clearBoostState();
		boostLoading = false;
		merchantDrawer.close();
	};

	const goBack = () => {
		clearBoostState();
		boostLoading = false;
		merchantDrawer.setView('details');
	};

	$: if (drawerView !== 'boost' && $boost !== undefined) {
		clearBoostState();
		boostLoading = false;
	}

	const handleBoost = () => boostMerchant(merchant, merchantId, setBoostLoading);
	const handleBoostComplete = () => completeBoost(merchantId, invalidateAll, resetBoost);

	function handleKeydown(event: KeyboardEvent) {
		if (!isOpen) return;

		if (event.key === 'Escape') {
			event.preventDefault();
			if (drawerView !== 'details') {
				goBack();
			} else {
				closeDrawer();
			}
		}
	}

	onMount(() => {
		window.addEventListener('keydown', handleKeydown);
		return () => {
			window.removeEventListener('keydown', handleKeydown);
		};
	});

	$: if (drawerView === 'boost' && merchant) {
		ensureBoostData(merchant, $boost);
	}

	export function openDrawer(id: number) {
		merchantDrawer.open(id, 'details');
	}
</script>

{#if isOpen}
	<!-- Drawer - no backdrop, keep map interactive -->
	<!-- Position offset by MERCHANT_LIST_WIDTH when list panel is open -->
	<div
		transition:fly={{ x: -MERCHANT_DRAWER_WIDTH, duration: 300 }}
		class="fixed top-0 z-[1002] h-full w-full overflow-y-auto bg-white shadow-2xl transition-[left] duration-200 dark:bg-dark"
		style="left: {listIsOpen ? MERCHANT_LIST_WIDTH : 0}px; max-width: {MERCHANT_DRAWER_WIDTH}px"
		role="dialog"
		aria-modal="true"
	>
		<div
			class="sticky top-0 z-10 flex items-center bg-white dark:bg-dark {drawerView === 'details'
				? 'justify-end p-2'
				: 'justify-between border-b border-gray-300 p-4 dark:border-white/95'}"
		>
			{#if drawerView !== 'details'}
				<!-- Back button for nested views -->
				<button
					on:click={goBack}
					class="flex items-center space-x-2 text-primary transition-colors hover:text-link dark:text-white dark:hover:text-link"
				>
					<Icon w="20" h="20" icon="arrow_back" type="material" />
					<span class="text-sm font-semibold">Back</span>
				</button>
				<span class="text-sm font-semibold text-primary capitalize dark:text-white"
					>{drawerView}</span
				>
			{/if}
			<CloseButton on:click={closeDrawer} />
		</div>

		{#if !merchant && fetchingMerchant}
			<!-- Loading skeleton -->
			<div class="space-y-4 px-6 pt-3 pb-6">
				<!-- Title skeleton -->
				<div class="h-7 w-3/4 animate-pulse rounded-lg bg-link/50"></div>
				<!-- Address skeleton -->
				<div class="h-5 w-1/2 animate-pulse rounded bg-link/50"></div>
				<!-- Payment methods skeleton -->
				<div class="flex space-x-2">
					<div class="h-8 w-16 animate-pulse rounded bg-link/50"></div>
					<div class="h-8 w-16 animate-pulse rounded bg-link/50"></div>
					<div class="h-8 w-16 animate-pulse rounded bg-link/50"></div>
				</div>
				<!-- Stats grid skeleton -->
				<div class="grid grid-cols-2 gap-2">
					<div class="h-20 animate-pulse rounded-lg bg-link/50"></div>
					<div class="h-20 animate-pulse rounded-lg bg-link/50"></div>
				</div>
				<!-- Large content skeleton -->
				<div class="h-32 animate-pulse rounded-lg bg-link/50"></div>
			</div>
		{:else if merchant}
			<div class="px-6 pt-3 pb-6">
				{#if drawerView === 'boost'}
					<BoostContent merchantId={merchant.id} onComplete={handleBoostComplete} />
				{:else}
					<MerchantDetailsContent
						{merchant}
						{isUpToDate}
						{isBoosted}
						{boostLoading}
						onBoostClick={handleBoost}
						isLoading={fetchingMerchant}
					/>
				{/if}
			</div>
		{/if}
	</div>
{/if}



================================================
FILE: src/routes/map/components/MerchantDrawerHash.svelte
================================================
<script lang="ts">
	import { browser } from '$app/environment';
	import MerchantDrawerDesktop from './MerchantDrawerDesktop.svelte';
	import MerchantDrawerMobile from './MerchantDrawerMobile.svelte';
	import { BREAKPOINTS } from '$lib/constants';

	// Initialize immediately to prevent component flash on mount
	// Lock to initial viewport to prevent component swapping mid-session
	let isMobile = browser ? window.innerWidth < BREAKPOINTS.md : false;
	let desktopDrawer: MerchantDrawerDesktop;
	let mobileDrawer: MerchantDrawerMobile;

	export function openDrawer(id: number) {
		// Guard against calling before component refs are ready
		if (!mobileDrawer && !desktopDrawer) {
			console.warn('Drawer not ready yet');
			return;
		}

		if (isMobile && mobileDrawer) {
			mobileDrawer.openDrawer(id);
		} else if (desktopDrawer) {
			desktopDrawer.openDrawer(id);
		}
	}
</script>

{#if isMobile}
	<MerchantDrawerMobile bind:this={mobileDrawer} />
{:else}
	<MerchantDrawerDesktop bind:this={desktopDrawer} />
{/if}



================================================
FILE: src/routes/map/components/MerchantDrawerMobile.svelte
================================================
<script lang="ts">
	import { browser } from '$app/environment';
	import { boost, resetBoost } from '$lib/store';
	import Icon from '$components/Icon.svelte';
	import BoostContent from '$components/BoostContent.svelte';
	import MerchantDetailsContent from '$components/MerchantDetailsContent.svelte';
	import MerchantPeekContentMobile from './MerchantPeekContentMobile.svelte';
	import { invalidateAll } from '$app/navigation';
	import { onMount } from 'svelte';
	import { merchantDrawer } from '$lib/merchantDrawerStore';
	import {
		calcVerifiedDate,
		isUpToDate as checkUpToDate,
		isBoosted as checkBoosted,
		handleBoost as boostMerchant,
		handleBoostComplete as completeBoost,
		ensureBoostData,
		clearBoostState
	} from '$lib/merchantDrawerLogic';
	import { drawerGesture } from '$lib/drawerGestureController';
	import { trackEvent } from '$lib/analytics';

	// Derive state from centralized store
	$: isOpen = $merchantDrawer.isOpen;
	$: merchantId = $merchantDrawer.merchantId;
	$: drawerView = $merchantDrawer.drawerView;
	$: merchant = $merchantDrawer.merchant;
	$: fetchingMerchant = $merchantDrawer.isLoading;

	// Get gesture state from controller
	const { expanded, drawerHeight } = drawerGesture;

	// DOM references
	let drawerElement: HTMLDivElement;
	let handleElement: HTMLDivElement;
	let capturedElement: HTMLElement | null = null;
	let contentScrollElement: HTMLDivElement | null = null;

	// Focus management for accessibility
	let previouslyFocusedElement: HTMLElement | null = null;

	// Track previous state to reset drawer when merchant changes
	let previousMerchantId: number | null = null;
	$: if (isOpen && merchantId !== previousMerchantId) {
		previousMerchantId = merchantId;
		drawerGesture.resetToPeek();
	}

	// Focus management: save/restore focus when expanding/collapsing
	let wasExpanded = false;
	$: if ($expanded && !wasExpanded) {
		previouslyFocusedElement = document.activeElement as HTMLElement;
		setTimeout(() => handleElement?.focus(), 0);
		wasExpanded = true;
	} else if (!$expanded && wasExpanded) {
		if (previouslyFocusedElement && typeof previouslyFocusedElement.focus === 'function') {
			previouslyFocusedElement.focus();
		}
		previouslyFocusedElement = null;
		wasExpanded = false;
	}

	// Focus trap: keep focus inside drawer when expanded
	function handleFocusOut(event: FocusEvent) {
		if ($expanded && drawerElement && event.relatedTarget) {
			const focusMovingOutside = !drawerElement.contains(event.relatedTarget as Node);
			if (focusMovingOutside) {
				handleElement?.focus();
			}
		}
	}

	const verifiedDate = calcVerifiedDate();
	$: isUpToDate = checkUpToDate(merchant, verifiedDate);
	$: isBoosted = checkBoosted(merchant);

	let boostLoading = false;
	const setBoostLoading = (loading: boolean) => {
		boostLoading = loading;
	};

	const closeDrawer = () => {
		clearBoostState();
		boostLoading = false;
		drawerGesture.collapse();
		merchantDrawer.close();
	};

	const goBack = () => {
		clearBoostState();
		boostLoading = false;
		merchantDrawer.setView('details');
	};

	$: if (drawerView !== 'boost' && $boost !== undefined) {
		clearBoostState();
		boostLoading = false;
	}

	const handleBoost = () => boostMerchant(merchant, merchantId, setBoostLoading);
	const handleBoostComplete = () => completeBoost(merchantId, invalidateAll, resetBoost);

	function handleKeydown(event: KeyboardEvent) {
		if (!isOpen) return;

		switch (event.key) {
			case 'Escape':
				event.preventDefault();
				if (drawerView !== 'details') {
					goBack();
				} else if ($expanded) {
					drawerGesture.collapse();
				} else {
					closeDrawer();
				}
				break;
			case 'ArrowUp':
				event.preventDefault();
				if (!$expanded) {
					drawerGesture.expand();
				}
				break;
			case 'ArrowDown':
				event.preventDefault();
				if ($expanded) {
					drawerGesture.collapse();
				}
				break;
			case 'Enter':
			case ' ':
				if (document.activeElement === handleElement) {
					event.preventDefault();
					drawerGesture.toggle();
				}
				break;
		}
	}

	// Wire up pointer event handlers with capture target
	function onPointerDown(event: PointerEvent) {
		const target = event.currentTarget as HTMLElement;
		capturedElement = target;
		drawerGesture.handlePointerDown(event, target);
	}

	function onPointerUp(event: PointerEvent) {
		drawerGesture.handlePointerUp(event, capturedElement);
		capturedElement = null;
	}

	// Wire up touch handler with scroll position
	function onContentTouchMove(event: TouchEvent) {
		const scrollTop = contentScrollElement?.scrollTop ?? 0;
		drawerGesture.handleContentTouchMove(event, scrollTop);
	}

	onMount(() => {
		// Set dismiss callback
		drawerGesture.setDismissCallback(closeDrawer);

		// Keyboard listener
		window.addEventListener('keydown', handleKeydown);

		// Window resize handler
		let updateHeight: (() => void) | null = null;
		if (browser) {
			updateHeight = () => {
				drawerGesture.setExpandedHeight(window.innerHeight);
			};
			updateHeight();
			window.addEventListener('resize', updateHeight);
		}

		return () => {
			drawerGesture.setDismissCallback(null);
			window.removeEventListener('keydown', handleKeydown);
			if (updateHeight) {
				window.removeEventListener('resize', updateHeight);
			}
		};
	});

	$: if (drawerView === 'boost' && merchant) {
		ensureBoostData(merchant, $boost);
	}

	export function openDrawer(id: number) {
		merchantDrawer.open(id, 'details');
	}
</script>

{#if isOpen}
	<!-- Bottom sheet drawer -->
	<!-- svelte-ignore a11y-no-noninteractive-element-interactions - Click handler only prevents event bubbling, not for interaction -->
	<!-- svelte-ignore a11y-click-events-have-key-events - Dialog interaction handled by focusable handle element below -->
	<div
		bind:this={drawerElement}
		class="fixed right-0 bottom-0 left-0 z-[1002] flex flex-col bg-white shadow-2xl transition-shadow dark:bg-dark"
		class:rounded-t-[10px]={!$expanded}
		style="height: {$drawerHeight}px; will-change: height;"
		on:click={(e) => e.stopPropagation()}
		on:focusout={handleFocusOut}
		role="dialog"
		aria-modal="true"
		aria-label="Merchant details"
	>
		<!-- Drag handle and header area -->
		<div
			class="flex-shrink-0 touch-none"
			bind:this={handleElement}
			on:pointerdown={onPointerDown}
			on:pointermove={drawerGesture.handlePointerMove}
			on:pointerup={onPointerUp}
			on:pointercancel={drawerGesture.handlePointerCancel}
			tabindex="0"
			role="button"
			aria-label={$expanded ? 'Collapse drawer' : 'Expand drawer'}
			aria-expanded={$expanded}
			aria-controls="drawer-content"
		>
			<!-- Drag handle -->
			<div class="mx-auto mt-2 h-1.5 w-12 rounded-full bg-gray-300 dark:bg-white/30"></div>

			<!-- Header -->
			<div
				class="flex items-center bg-white px-4 dark:bg-dark {drawerView === 'details'
					? 'justify-end py-1'
					: 'justify-between border-b border-gray-300 py-3 dark:border-white/95'}"
			>
				{#if drawerView !== 'details'}
					<button
						on:pointerdown|stopPropagation
						on:click={goBack}
						class="flex touch-auto items-center space-x-2 text-primary transition-colors hover:text-link dark:text-white dark:hover:text-link"
					>
						<Icon w="20" h="20" icon="arrow_back" type="material" />
						<span class="text-sm font-semibold">Back</span>
					</button>
					<span class="text-sm font-semibold text-primary capitalize dark:text-white"
						>{drawerView}</span
					>
				{/if}

				{#if $expanded && drawerView === 'details'}
					<button
						on:pointerdown|stopPropagation
						on:click={() => {
							trackEvent('drawer_collapse_button_click');
							drawerGesture.collapse();
						}}
						class="touch-auto rounded-full p-2 text-primary transition-colors hover:bg-gray-100 dark:text-white dark:hover:bg-white/10"
						aria-label="Collapse drawer"
					>
						<Icon w="20" h="20" icon="keyboard_arrow_down" type="material" />
					</button>
				{:else if drawerView === 'details'}
					<div class="w-9"></div>
				{/if}
			</div>
		</div>

		<!-- Scrollable content area -->
		<div
			id="drawer-content"
			bind:this={contentScrollElement}
			class="min-h-0 flex-1 overflow-y-auto"
			style="overscroll-behavior-y: contain; touch-action: pan-y;"
			on:touchstart={drawerGesture.handleContentTouchStart}
			on:touchmove={onContentTouchMove}
			on:touchend={drawerGesture.handleContentTouchEnd}
			on:touchcancel={drawerGesture.handleContentTouchEnd}
		>
			{#if !merchant && fetchingMerchant}
				<div class="space-y-4 px-4 pt-2 pb-4">
					<div class="h-6 w-3/4 animate-pulse rounded-lg bg-link/50"></div>
					<div class="h-4 w-1/2 animate-pulse rounded bg-link/50"></div>
					<div class="flex space-x-2">
						<div class="h-8 w-16 animate-pulse rounded bg-link/50"></div>
						<div class="h-8 w-16 animate-pulse rounded bg-link/50"></div>
					</div>
				</div>
			{:else if merchant}
				{#if !$expanded}
					<!-- Peek content wrapper with swipe handlers - allows swiping from anywhere when collapsed -->
					<div
						class="touch-none px-4 pt-2 pb-4"
						on:pointerdown={onPointerDown}
						on:pointermove={drawerGesture.handlePointerMove}
						on:pointerup={onPointerUp}
						on:pointercancel={drawerGesture.handlePointerCancel}
					>
						<MerchantPeekContentMobile
							{merchant}
							{isUpToDate}
							{isBoosted}
							isLoading={fetchingMerchant}
						/>
					</div>
				{:else}
					<div class="px-6 pt-3 pb-6">
						{#if drawerView === 'boost'}
							<BoostContent merchantId={merchant.id} onComplete={handleBoostComplete} />
						{:else}
							<MerchantDetailsContent
								{merchant}
								{isUpToDate}
								{isBoosted}
								{boostLoading}
								onBoostClick={handleBoost}
							/>
						{/if}
					</div>
				{/if}
			{/if}
		</div>
	</div>
{/if}



================================================
FILE: src/routes/map/components/MerchantListItem.svelte
================================================
<script lang="ts">
	import Icon from '$components/Icon.svelte';
	import PaymentMethodIcon from '$components/PaymentMethodIcon.svelte';
	import type { Place } from '$lib/types';
	import { formatVerifiedHuman } from '$lib/utils';
	import { isUpToDate as checkUpToDate, isBoosted as checkBoosted } from '$lib/merchantDrawerLogic';

	export let merchant: Place;
	export let enrichedData: Place | null = null;
	export let isSelected: boolean = false;
	export let verifiedDate: number;
	export let onclick: (merchant: Place) => void = () => {};
	export let onmouseenter: (merchant: Place) => void = () => {};
	export let onmouseleave: (merchant: Place) => void = () => {};

	$: showSkeleton = !enrichedData;
	$: displayData = enrichedData || merchant;
	$: hasPaymentMethods =
		enrichedData?.['osm:payment:onchain'] !== undefined ||
		enrichedData?.['osm:payment:lightning'] !== undefined ||
		enrichedData?.['osm:payment:lightning_contactless'] !== undefined;

	$: isVerified = checkUpToDate(displayData, verifiedDate);
	$: isBoosted = checkBoosted(merchant);

	function handleClick() {
		onclick(merchant);
	}
</script>

<li class="list-none">
	<button
		on:click={handleClick}
		on:mouseenter={() => onmouseenter(merchant)}
		on:mouseleave={() => onmouseleave(merchant)}
		class="w-full px-3 py-3 text-left transition-colors hover:bg-gray-50 dark:hover:bg-white/5 {isSelected
			? 'bg-link/5 dark:bg-link/10'
			: ''}"
		aria-current={isSelected ? 'true' : undefined}
	>
		<div class="flex items-start gap-3">
			<!-- Icon -->
			<div
				class="flex h-10 w-10 shrink-0 items-center justify-center rounded-lg {isBoosted
					? 'bg-bitcoin/10 text-bitcoin'
					: 'bg-primary/10 text-primary dark:bg-white/10 dark:text-white'}"
			>
				<Icon w="22" h="22" icon={merchant.icon || 'currency_bitcoin'} type="material" />
			</div>

			<div class="min-w-0 flex-1">
				<!-- Name with badges -->
				<div class="flex items-center gap-1">
					{#if enrichedData?.name}
						<span
							class="truncate text-sm font-medium {isBoosted
								? 'text-bitcoin'
								: 'text-primary dark:text-white'}"
						>
							{enrichedData.name}
						</span>
						{#if isVerified}
							<Icon w="12" h="12" icon="verified" type="material" class="shrink-0 text-link" />
						{/if}
						{#if isBoosted}
							<Icon
								w="12"
								h="12"
								icon="arrow_circle_up"
								type="material"
								class="shrink-0 text-bitcoin"
							/>
						{/if}
					{:else if showSkeleton}
						<div class="h-4 w-32 animate-pulse rounded bg-link/50"></div>
					{:else}
						<span class="truncate text-sm font-medium text-primary dark:text-white">Unknown</span>
					{/if}
				</div>

				<!-- Address -->
				{#if enrichedData?.address}
					<p class="mt-0.5 truncate text-xs text-body dark:text-white/70">
						{enrichedData.address}
					</p>
				{:else if showSkeleton}
					<div class="mt-0.5 h-3 w-24 animate-pulse rounded bg-link/50"></div>
				{/if}

				<!-- Payment methods -->
				{#if enrichedData && hasPaymentMethods}
					<div class="mt-1.5 flex gap-1">
						<PaymentMethodIcon
							status={enrichedData['osm:payment:onchain']}
							method="btc"
							label="On-chain"
							size="sm"
						/>
						<PaymentMethodIcon
							status={enrichedData['osm:payment:lightning']}
							method="ln"
							label="Lightning"
							size="sm"
						/>
						<PaymentMethodIcon
							status={enrichedData['osm:payment:lightning_contactless']}
							method="nfc"
							label="Lightning contactless"
							size="sm"
						/>
					</div>
				{:else if showSkeleton}
					<div class="mt-1.5 flex gap-1">
						<div class="h-5 w-5 animate-pulse rounded bg-link/50"></div>
						<div class="h-5 w-5 animate-pulse rounded bg-link/50"></div>
					</div>
				{/if}

				<!-- Status badges -->
				{#if enrichedData}
					<div class="mt-1.5 flex flex-wrap items-center gap-2 text-xs">
						{#if isBoosted}
							<span
								class="flex items-center gap-1 rounded-full bg-bitcoin/10 px-2 py-0.5 text-bitcoin"
							>
								<Icon w="12" h="12" icon="arrow_circle_up" type="material" />
								Boosted
							</span>
						{/if}
						<span class="flex items-center gap-1 text-gray-500 dark:text-white/60">
							<Icon w="12" h="12" icon={isVerified ? 'check' : 'warning'} type="material" />
							{isVerified ? 'Verified' : 'Outdated'}
							{#if enrichedData.verified_at}
								<span class="text-gray-400 dark:text-white/40"
									>Â· {formatVerifiedHuman(enrichedData.verified_at)}</span
								>
							{/if}
						</span>
					</div>
				{:else if showSkeleton}
					<div class="mt-1.5 h-4 w-20 animate-pulse rounded bg-link/50"></div>
				{/if}
			</div>

			<!-- Chevron -->
			<Icon
				w="16"
				h="16"
				icon="chevron_right"
				type="material"
				class="mt-0.5 shrink-0 text-gray-400 dark:text-white/40"
			/>
		</div>
	</button>
</li>



================================================
FILE: src/routes/map/components/MerchantListPanel.svelte
================================================
<script lang="ts">
	import { browser } from '$app/environment';
	import { tick, onDestroy } from 'svelte';
	import { fly } from 'svelte/transition';
	import type { MerchantListMode } from '$lib/merchantListStore';
	import { merchantList } from '$lib/merchantListStore';
	import { merchantDrawer } from '$lib/merchantDrawerStore';
	import MerchantListItem from './MerchantListItem.svelte';
	import CloseButton from '$components/CloseButton.svelte';
	import LoadingSpinner from '$components/LoadingSpinner.svelte';
	import Icon from '$components/Icon.svelte';
	import type { Place } from '$lib/types';
	import {
		CATEGORY_ENTRIES,
		placeMatchesCategory,
		type CategoryKey,
		type CategoryCounts
	} from '$lib/categoryMapping';
	import {
		MERCHANT_LIST_WIDTH,
		MERCHANT_LIST_MIN_ZOOM,
		MERCHANT_LIST_LOW_ZOOM,
		BREAKPOINTS
	} from '$lib/constants';
	import { calcVerifiedDate } from '$lib/merchantDrawerLogic';
	import { trackEvent } from '$lib/analytics';

	// Reduced motion preference for animations
	const reducedMotion = browser && window.matchMedia('(prefers-reduced-motion: reduce)').matches;

	// Compute once for all list items
	const verifiedDate = calcVerifiedDate();

	// Callback to pan to a nearby merchant (already zoomed in, just center it)
	export let onPanToNearbyMerchant: ((place: Place) => void) | undefined = undefined;
	// Callback to zoom to a search result (may be far away, need to fly there)
	export let onZoomToSearchResult: ((place: Place) => void) | undefined = undefined;
	// Callbacks for hover highlighting
	export let onHoverStart: ((place: Place) => void) | undefined = undefined;
	export let onHoverEnd: ((place: Place) => void) | undefined = undefined;
	// Current zoom level to determine if we should show "zoom in" message
	export let currentZoom: number = 0;
	// Search callback - called when user types in search input
	export let onSearch: ((query: string) => void) | undefined = undefined;
	// Mode change callback (called for nearby mode switch)
	export let onModeChange: ((mode: MerchantListMode) => void) | undefined = undefined;
	// Refresh callback for category filtering
	export let onRefresh: (() => void) | undefined = undefined;
	// Callback to fit map bounds to all search results
	export let onFitSearchResultBounds: (() => void) | undefined = undefined;

	// Reference for search input element
	let searchInput: HTMLInputElement;

	// Local filter for nearby mode (client-side filtering by name)
	let nearbyFilter = '';

	// Body scroll lock for mobile (prevents iOS background scroll)
	let scrollLockActive = false;

	// Reference for focus trap
	let panelElement: HTMLElement;

	function handleClearSearch() {
		merchantList.clearSearchInput();
		// Trigger onSearch to abort any pending request (same as typing empty query)
		onSearch?.('');
		searchInput?.focus();
	}

	function handleSearchKeyDown(event: KeyboardEvent) {
		if (event.key === 'Escape' && $merchantList.searchQuery) {
			event.preventDefault();
			event.stopPropagation();
			handleClearSearch();
		}
	}

	function handleModeSwitch(newMode: MerchantListMode) {
		if (newMode === mode) return;
		nearbyFilter = ''; // Clear filter when switching modes
		if (newMode === 'nearby') {
			trackEvent('nearby_mode_click');
			merchantList.exitSearchMode();
			onModeChange?.(newMode);
		} else {
			trackEvent('worldwide_mode_click');
			merchantList.setMode(newMode);
		}
	}

	function handleCategorySelect(category: CategoryKey) {
		// Guard against clicks on disabled buttons (Svelte fires click even when disabled)
		if (!hasMatchingMerchants(category, categoryCounts)) return;
		trackEvent('category_filter', { category });
		merchantList.setSelectedCategory(category);
		// Only refresh in nearby mode - search mode filters client-side
		if (mode === 'nearby') {
			onRefresh?.();
		}
	}

	$: isOpen = $merchantList.isOpen;
	$: merchants = $merchantList.merchants;
	$: totalCount = $merchantList.totalCount;
	$: placeDetailsCache = $merchantList.placeDetailsCache;
	$: isLoadingList = $merchantList.isLoadingList;
	$: selectedId = $merchantDrawer.merchantId;
	$: mode = $merchantList.mode;
	$: searchResults = $merchantList.searchResults;
	$: isSearching = $merchantList.isSearching;
	$: searchQuery = $merchantList.searchQuery;
	$: selectedCategory = $merchantList.selectedCategory;
	$: categoryCounts = $merchantList.categoryCounts;

	// Filter search results by category
	$: filteredSearchResults =
		selectedCategory === 'all'
			? searchResults
			: searchResults.filter((p) => placeMatchesCategory(p, selectedCategory));

	// Helper function to check if a category has matching merchants
	// Note: counts param required for Svelte reactivity (indirect deps aren't tracked)
	function hasMatchingMerchants(categoryKey: CategoryKey, counts: CategoryCounts): boolean {
		if (categoryKey === 'all') return true;
		return (counts?.[categoryKey] ?? 0) > 0;
	}

	// Helper function to get category button classes
	// Note: categoryCounts param required for Svelte reactivity (indirect deps aren't tracked)
	function getCategoryButtonClass(
		key: CategoryKey,
		selectedCategory: CategoryKey,
		counts: CategoryCounts
	): string {
		if (selectedCategory === key) return 'bg-primary text-white';
		const hasMatches = key === 'all' || (counts?.[key] ?? 0) > 0;
		if (hasMatches) {
			return 'bg-gray-100 text-body hover:bg-gray-200 dark:bg-white/5 dark:text-white/70 dark:hover:bg-white/10';
		}
		return 'cursor-not-allowed bg-gray-100 text-gray-400 dark:bg-white/5 dark:text-white/30';
	}

	// Show "zoom in" message when:
	// 1. Below zoom 11 (always - no data fetched at this level)
	// 2. Between zoom 11-14 with no merchants (too many results in dense area)
	$: showZoomInMessage =
		currentZoom < MERCHANT_LIST_LOW_ZOOM ||
		(currentZoom < MERCHANT_LIST_MIN_ZOOM && merchants.length === 0);
	$: isTruncated = totalCount > merchants.length;

	// Body scroll lock on mobile when panel is open
	$: if (browser && isOpen !== undefined) {
		const isMobile = window.innerWidth < BREAKPOINTS.md;
		const shouldLock = isOpen && isMobile;
		if (shouldLock && !scrollLockActive) {
			document.body.style.overflow = 'hidden';
			scrollLockActive = true;
		} else if (!shouldLock && scrollLockActive) {
			document.body.style.overflow = '';
			scrollLockActive = false;
		}
	}

	// Focus search input when panel opens in search mode
	$: if (browser && isOpen && mode === 'search' && searchInput) {
		tick().then(() => searchInput?.focus());
	}

	function handleItemClick(place: Place) {
		trackEvent('merchant_list_item_click', { mode });
		merchantDrawer.open(place.id, 'details');

		if (mode === 'search') {
			// Search result: zoom to location (may be far from current view)
			onZoomToSearchResult?.(place);
		} else {
			// Nearby merchant: pan only (already zoomed in)
			onPanToNearbyMerchant?.(place);
		}

		// On mobile, close panel so drawer is visible (panel is fullscreen)
		// On desktop, keep panel open (list and drawer coexist side by side)
		if (browser && window.innerWidth < BREAKPOINTS.md) {
			merchantList.close();
		}
	}

	function handleMouseEnter(place: Place) {
		onHoverStart?.(place);
	}

	function handleMouseLeave(place: Place) {
		onHoverEnd?.(place);
	}

	function handleClose() {
		nearbyFilter = ''; // Clear filter when closing
		merchantList.close();
	}

	function handleWindowKeydown(event: KeyboardEvent) {
		if (!isOpen) return;

		// Focus trap: cycle Tab within the panel to prevent focus escaping to background
		if (event.key === 'Tab' && panelElement) {
			const focusable = panelElement.querySelectorAll<HTMLElement>(
				'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
			);
			const first = focusable[0];
			const last = focusable[focusable.length - 1];

			if (event.shiftKey && document.activeElement === first) {
				event.preventDefault();
				last?.focus();
			} else if (!event.shiftKey && document.activeElement === last) {
				event.preventDefault();
				first?.focus();
			}
		}

		if (event.key === 'Escape') {
			event.preventDefault();
			handleClose();
		}
	}

	// Cleanup scroll lock when component is destroyed
	onDestroy(() => {
		if (browser && scrollLockActive) {
			document.body.style.overflow = '';
		}
	});
</script>

<svelte:window on:keydown={handleWindowKeydown} />

{#if isOpen}
	<section
		bind:this={panelElement}
		class="absolute inset-0 z-[1001] flex flex-col overflow-hidden bg-white md:relative md:inset-auto md:z-auto md:w-80 md:flex-none md:border-r md:border-white/10 dark:border-white/5 dark:bg-dark"
		role="complementary"
		aria-label="Merchant list"
		transition:fly={{ x: -MERCHANT_LIST_WIDTH, duration: reducedMotion ? 0 : 200 }}
	>
		<!-- Header -->
		<div
			class="shrink-0 border-b border-gray-200 bg-white px-3 py-3 dark:border-white/10 dark:bg-dark"
		>
			{#if mode === 'search'}
				<!-- Search mode: search input -->
				<div class="flex items-center gap-2">
					<div class="relative flex-1">
						<Icon
							w="16"
							h="16"
							icon="search"
							type="material"
							class="pointer-events-none absolute top-1/2 left-3 -translate-y-1/2 text-gray-400 dark:text-white/50"
						/>
						<input
							bind:this={searchInput}
							value={searchQuery}
							on:input={(e) => {
								merchantList.setSearchQuery(e.currentTarget.value);
								onSearch?.($merchantList.searchQuery);
							}}
							on:keydown={handleSearchKeyDown}
							type="search"
							placeholder="e.g. pizza, cafe, atm..."
							aria-label="Search for Bitcoin merchants"
							class="w-full rounded-lg border border-gray-200 bg-gray-50 py-2 pr-8 pl-9 text-sm text-primary focus:border-link focus:outline-none dark:border-white/10 dark:bg-white/5 dark:text-white dark:focus:border-white/30 [&::-webkit-search-cancel-button]:hidden"
						/>
						{#if searchQuery}
							<button
								type="button"
								on:click={handleClearSearch}
								class="absolute top-1/2 right-2 -translate-y-1/2 p-1 text-gray-400 hover:text-gray-600 dark:text-white/50 dark:hover:text-white/70"
								aria-label="Clear search"
							>
								<Icon w="14" h="14" icon="close" type="material" />
							</button>
						{/if}
					</div>
					<CloseButton on:click={handleClose} />
				</div>
			{:else}
				<!-- Nearby mode: title + count -->
				<div class="flex items-center justify-between">
					<div>
						<h2 class="text-sm font-semibold text-primary dark:text-white">Nearby Merchants</h2>
						{#if showZoomInMessage}
							<p class="text-xs text-body dark:text-white/70" aria-live="polite">
								Zoom in to see list
							</p>
						{:else if isTruncated}
							<p class="text-xs text-body dark:text-white/70" aria-live="polite">
								Showing {merchants.length} nearest of {totalCount}
							</p>
						{:else}
							<p class="text-xs text-body dark:text-white/70" aria-live="polite">
								{merchants.length} location{merchants.length !== 1 ? 's' : ''} in view
							</p>
						{/if}
					</div>
					<CloseButton on:click={handleClose} />
				</div>
			{/if}

			<!-- Mode toggle buttons -->
			<div
				class="mt-3 flex rounded-lg bg-gray-100 p-1 dark:bg-white/5"
				role="radiogroup"
				aria-label="View mode"
			>
				<button
					type="button"
					role="radio"
					on:click={() => handleModeSwitch('search')}
					aria-checked={mode === 'search'}
					class="flex-1 rounded-md px-3 py-1.5 text-xs font-medium transition-colors
						{mode === 'search'
						? 'bg-white text-primary shadow-sm dark:bg-white/10 dark:text-white'
						: 'text-body hover:text-primary dark:text-white/70 dark:hover:text-white'}"
				>
					Worldwide
				</button>
				<button
					type="button"
					role="radio"
					on:click={() => handleModeSwitch('nearby')}
					aria-checked={mode === 'nearby'}
					class="flex-1 rounded-md px-3 py-1.5 text-xs font-medium transition-colors
						{mode === 'nearby'
						? 'bg-white text-primary shadow-sm dark:bg-white/10 dark:text-white'
						: 'text-body hover:text-primary dark:text-white/70 dark:hover:text-white'}"
				>
					Nearby
				</button>
			</div>

			<!-- Category filter (shown in both nearby and search modes) -->
			<div class="mt-3" role="radiogroup" aria-label="Filter by category">
				<h3 class="sr-only">Filter by category</h3>
				<div class="flex flex-wrap gap-2">
					{#each CATEGORY_ENTRIES as [key, category] (key)}
						<button
							type="button"
							role="radio"
							on:click={() => handleCategorySelect(key)}
							disabled={!hasMatchingMerchants(key, categoryCounts)}
							aria-disabled={!hasMatchingMerchants(key, categoryCounts)}
							aria-checked={selectedCategory === key}
							class="rounded-full px-3 py-1 text-xs font-medium transition-colors {getCategoryButtonClass(
								key,
								selectedCategory,
								categoryCounts
							)}"
						>
							{category.label}
						</button>
					{/each}
				</div>
			</div>

			{#if mode === 'search'}
				<!-- Search status row: result count + show all on map -->
				<div class="mt-3 flex items-center justify-between gap-2">
					<p class="text-xs text-body dark:text-white/70" aria-live="polite">
						{#if isSearching}
							Searching...
						{:else if searchResults.length === 0 && searchQuery.length >= 3}
							No results found
						{:else if searchResults.length === 0}
							Search for merchants
						{:else if selectedCategory !== 'all' && filteredSearchResults.length !== searchResults.length}
							{filteredSearchResults.length} of {searchResults.length} result{searchResults.length !==
							1
								? 's'
								: ''}
						{:else}
							{searchResults.length} result{searchResults.length !== 1 ? 's' : ''}
						{/if}
					</p>
					<button
						type="button"
						on:click={() => {
							trackEvent('show_all_on_map_click');
							onFitSearchResultBounds?.();
						}}
						disabled={filteredSearchResults.length === 0}
						class="flex shrink-0 items-center gap-1.5 rounded-lg border px-2.5 py-1 text-xs font-medium transition-colors
							{filteredSearchResults.length > 0
							? 'border-gray-200 bg-white text-primary hover:bg-gray-50 dark:border-white/10 dark:bg-white/5 dark:text-white dark:hover:bg-white/10'
							: 'cursor-not-allowed border-gray-100 bg-gray-50 text-gray-400 dark:border-white/5 dark:bg-white/5 dark:text-white/30'}"
						aria-label="Zoom map to show {filteredSearchResults.length === 1
							? '1 result'
							: `all ${filteredSearchResults.length} results`}"
					>
						<Icon w="14" h="14" icon="zoom_out_map" type="material" />
						<span>Show all</span>
					</button>
				</div>
			{:else}
				<!-- Name filter input (nearby mode only) -->
				<div class="relative mt-3">
					<Icon
						w="14"
						h="14"
						icon="filter_list"
						type="material"
						class="pointer-events-none absolute top-1/2 left-2.5 -translate-y-1/2 text-gray-400 dark:text-white/50"
					/>
					<input
						bind:value={nearbyFilter}
						on:blur={() => nearbyFilter && trackEvent('nearby_filter_input')}
						type="text"
						placeholder="Filter by name..."
						aria-label="Filter nearby merchants by name"
						class="w-full rounded-lg border border-gray-200 bg-gray-50 py-1.5 pr-7 pl-8 text-xs text-primary focus:border-link focus:outline-none dark:border-white/10 dark:bg-white/5 dark:text-white dark:focus:border-white/30"
					/>
					{#if nearbyFilter}
						<button
							type="button"
							on:click={() => (nearbyFilter = '')}
							class="absolute top-1/2 right-2 -translate-y-1/2 p-0.5 text-gray-400 hover:text-gray-600 dark:text-white/50 dark:hover:text-white/70"
							aria-label="Clear filter"
						>
							<Icon w="12" h="12" icon="close" type="material" />
						</button>
					{/if}
				</div>
			{/if}
		</div>

		<!-- List content -->
		<div class="flex-1 overflow-y-auto">
			{#if mode === 'search'}
				<!-- Search results -->
				{#if isSearching}
					<div class="flex items-center justify-center py-8" role="status" aria-label="Searching">
						<LoadingSpinner color="text-link dark:text-white" size="h-6 w-6" />
					</div>
				{:else if searchResults.length === 0}
					<!-- Empty state: no results yet -->
					<div class="flex flex-col items-center justify-center gap-3 px-4 py-12 text-center">
						<Icon
							w="48"
							h="48"
							icon="search"
							type="material"
							class="text-gray-300 dark:text-white/30"
						/>
						<p class="text-sm text-body dark:text-white/70">
							{#if searchQuery.length >= 3}
								No results found for "{searchQuery}"
							{:else}
								Search for merchants by name
							{/if}
						</p>
					</div>
				{:else if filteredSearchResults.length === 0}
					<!-- Has results but none match category filter -->
					<div class="px-3 py-8 text-center text-sm text-body dark:text-white/70">
						No results in this category
					</div>
				{:else}
					<ul class="divide-y divide-gray-100 dark:divide-white/5">
						{#each filteredSearchResults as merchant (merchant.id)}
							<MerchantListItem
								{merchant}
								enrichedData={merchant}
								isSelected={selectedId === merchant.id}
								{verifiedDate}
								onclick={handleItemClick}
								onmouseenter={handleMouseEnter}
								onmouseleave={handleMouseLeave}
							/>
						{/each}
					</ul>
				{/if}
			{:else if showZoomInMessage}
				<!-- Nearby mode: zoom in message -->
				<div class="flex flex-col items-center justify-center gap-3 px-4 py-12 text-center">
					<Icon
						w="48"
						h="48"
						icon="zoom_in"
						type="material"
						class="text-gray-300 dark:text-white/30"
					/>
					<div>
						<p class="text-sm font-medium text-primary dark:text-white">
							Zoom in to see nearby merchants
						</p>
						<p class="mt-1 text-xs text-body dark:text-white/70">
							The merchant list shows locations when zoomed in closer
						</p>
					</div>
				</div>
			{:else if isLoadingList}
				<div
					class="flex items-center justify-center py-8"
					role="status"
					aria-label="Loading nearby merchants"
				>
					<LoadingSpinner color="text-link dark:text-white" size="h-6 w-6" />
				</div>
			{:else if merchants.length === 0}
				<div class="px-3 py-8 text-center text-sm text-body dark:text-white/70">
					No merchants visible in current view
				</div>
			{:else}
				<!-- Nearby mode: merchant list -->
				{@const filteredMerchants = nearbyFilter
					? merchants.filter((m) => {
							const enriched = placeDetailsCache.get(m.id);
							const name = enriched?.name || m.name || '';
							return name.toLowerCase().includes(nearbyFilter.toLowerCase());
						})
					: merchants}
				{#if filteredMerchants.length === 0 && nearbyFilter}
					<div class="px-3 py-8 text-center text-sm text-body dark:text-white/70">
						No merchants match "{nearbyFilter}"
					</div>
				{:else}
					<ul class="divide-y divide-gray-100 dark:divide-white/5">
						{#each filteredMerchants as merchant (merchant.id)}
							<MerchantListItem
								{merchant}
								enrichedData={placeDetailsCache.get(merchant.id) || null}
								isSelected={selectedId === merchant.id}
								{verifiedDate}
								onclick={handleItemClick}
								onmouseenter={handleMouseEnter}
								onmouseleave={handleMouseLeave}
							/>
						{/each}
					</ul>
				{/if}
			{/if}
		</div>
	</section>
{/if}



================================================
FILE: src/routes/map/components/MerchantPeekContentMobile.svelte
================================================
<script lang="ts">
	import Icon from '$components/Icon.svelte';
	import type { Place } from '$lib/types';
	import PaymentMethodIcon from '$components/PaymentMethodIcon.svelte';

	export let merchant: Place;
	export let isUpToDate: boolean;
	export let isBoosted: boolean;
	export let isLoading: boolean = false;

	// Check if we have the detailed data needed for display
	$: hasName = merchant.name !== undefined;
	$: hasPaymentMethods =
		merchant['osm:payment:onchain'] !== undefined ||
		merchant['osm:payment:lightning'] !== undefined ||
		merchant['osm:payment:lightning_contactless'] !== undefined;
	$: hasVerification = merchant.verified_at !== undefined;
</script>

<div class="space-y-3">
	<!-- Name and status row -->
	<div class="flex items-start justify-between gap-3">
		<div class="min-w-0 flex-1">
			{#if hasName}
				<h3 class="truncate text-lg leading-tight font-bold text-primary dark:text-white">
					{merchant.name}
				</h3>
			{:else if isLoading}
				<div class="h-6 w-3/4 animate-pulse rounded bg-link/50"></div>
			{/if}
		</div>

		<!-- Boost badge if boosted -->
		{#if isBoosted}
			<div
				class="flex-shrink-0 rounded-full bg-link px-2.5 py-1 text-xs font-semibold text-white"
				title="Boosted merchant"
			>
				<Icon w="14" h="14" icon="bolt" type="material" class="mr-1 inline" />
				Boosted
			</div>
		{/if}
	</div>

	<!-- Payment methods and verification -->
	<div class="flex items-center justify-between gap-4">
		<!-- Payment methods -->
		<div class="flex items-center space-x-2">
			{#if hasPaymentMethods}
				{#if merchant['osm:payment:onchain']}
					<PaymentMethodIcon
						status={merchant['osm:payment:onchain']}
						method="btc"
						label="On-chain"
					/>
				{/if}
				{#if merchant['osm:payment:lightning']}
					<PaymentMethodIcon
						status={merchant['osm:payment:lightning']}
						method="ln"
						label="Lightning"
					/>
				{/if}
				{#if merchant['osm:payment:lightning_contactless']}
					<PaymentMethodIcon
						status={merchant['osm:payment:lightning_contactless']}
						method="nfc"
						label="Lightning contactless"
					/>
				{/if}
			{:else if isLoading}
				<div class="flex space-x-2">
					<div class="h-6 w-6 animate-pulse rounded bg-link/50"></div>
					<div class="h-6 w-6 animate-pulse rounded bg-link/50"></div>
				</div>
			{/if}
		</div>

		<!-- Verification status -->
		<div class="flex items-center gap-2 text-xs">
			{#if hasVerification}
				{#if isUpToDate}
					<div class="flex items-center gap-1 text-green-600 dark:text-green-400">
						<Icon w="14" h="14" icon="check" type="material" />
						<span>Verified</span>
					</div>
				{:else}
					<div class="flex items-center gap-1 text-orange-600 dark:text-orange-400">
						<Icon w="14" h="14" icon="warning" type="material" />
						<span>Outdated</span>
					</div>
				{/if}
			{:else if isLoading}
				<div class="h-4 w-16 animate-pulse rounded bg-link/50"></div>
			{/if}
		</div>
	</div>

	<!-- Swipe hint -->
	<div class="flex items-center justify-end border-t border-gray-200 pt-3 dark:border-white/10">
		<div class="flex items-center gap-1 text-xs text-body dark:text-white/50">
			<Icon w="14" h="14" icon="arrow_upward" type="material" />
			<span>Swipe up for details</span>
			<span class="mx-1">Â·</span>
			<Icon w="14" h="14" icon="arrow_downward" type="material" />
			<span>Swipe down to close</span>
		</div>
	</div>
</div>



================================================
FILE: src/routes/map/components/TileLoadingIndicator.svelte
================================================
<script lang="ts">
	import LoadingSpinner from '$components/LoadingSpinner.svelte';
	import { fade } from 'svelte/transition';

	export let visible = false;
</script>

{#if visible}
	<div
		role="status"
		aria-live="polite"
		transition:fade={{ duration: 200 }}
		class="pointer-events-none fixed bottom-6 left-2 z-[1000] flex items-center gap-1.5
			   rounded-md bg-white px-2 py-1.5 shadow-lg
			   md:bottom-8 md:left-4 md:gap-2 md:rounded-lg md:px-3 md:py-2
			   dark:border dark:border-white/20 dark:bg-dark"
	>
		<LoadingSpinner size="h-3 w-3 md:h-4 md:w-4" color="text-link" />
		<span class="text-xs text-primary md:text-sm dark:text-white">Loading tiles...</span>
	</div>
{/if}



================================================
FILE: src/routes/media/+page.svelte
================================================
<script lang="ts">
	const brandColors = ['#10B981', '#53C5D5', '#051173', '#0891B2', '#E4EBEC', '#164E63', '#155E75'];

	const brand = [
		{ link: '/images/hero-mobile-example.webp', name: 'App Screenshot' },
		{ link: '/images/logo.svg', name: 'BTC Map Logo' },
		{ link: '/images/supertagger.svg', name: 'Shadowy Supertagger' },
		{ link: '/images/supertagger-king.svg', name: 'Shadowy Supertagger - Leader' }
	];

	const promotional = [
		{ link: '/images/og/activity.png', name: 'Activity Feed' },
		{ link: '/images/og/add-community.png', name: 'Add Community' },
		{ link: '/images/og/add.png', name: 'Add Location' },
		{ link: '/images/og/communities.png', name: 'Communities' },
		{ link: '/images/og/countries.png', name: 'Countries' },
		{ link: '/images/og/apps.png', name: 'Download Apps' },
		{ link: '/images/og/badges.png', name: 'Earn Badges' },
		{ link: '/images/og/home.png', name: 'Main' },
		{ link: '/images/og/map.png', name: 'Map' },
		{ link: '/images/og/merchant.png', name: 'Merchant' },
		{ link: '/images/og/dash.png', name: 'Stats Dashboard' },
		{ link: '/images/og/leader.png', name: 'Supertagger Leaderboard' },
		{ link: '/images/og/supertagger.png', name: 'Supertagger Profile' },
		{ link: '/images/og/support.png', name: 'Support Us' },
		{ link: '/images/og/top-communities.png', name: 'Top Communities' },
		{ link: '/images/og/top-countries.png', name: 'Top Countries' },
		{ link: '/images/og/verify.png', name: 'Verify Locations' }
	];

	const team = [
		{ link: '/images/team/igor.jpg', name: 'Igor' },
		{ link: '/images/team/karnage.jpg', name: 'Karnage' },
		{ link: '/images/team/nathan.jpg', name: 'Nathan Day' },
		{ link: '/images/team/secondl1ght.jpg', name: 'secondl1ght' }
	];

	const assetSections = [
		{ title: 'Brand', data: brand },
		{ title: 'Promotional', data: promotional },
		{ title: 'Team', data: team }
	];
</script>

<svelte:head>
	<title>BTC Map - Media</title>
	<meta property="og:image" content="https://btcmap.org/images/og/home.png" />
	<meta property="twitter:title" content="BTC Map - Media" />
	<meta property="twitter:image" content="https://btcmap.org/images/og/home.png" />
</svelte:head>

<main class="mt-10 mb-20 space-y-10 text-center text-primary dark:text-white">
	<div class="space-y-5 text-xl">
		<h1 class="text-4xl !leading-tight font-semibold md:text-5xl">Media</h1>
		<p>Media assets are available for free to use for promotional purposes.</p>
	</div>

	<section>
		<h2 class="mb-5 text-3xl font-semibold">Brand Colors</h2>

		<div class="flex flex-wrap justify-center gap-5">
			{#each brandColors as color (color)}
				<div
					class="flex h-24 w-24 items-center justify-center"
					style="background-color: {color}; border: 1px solid black;"
				>
					<p class="text-black">{color}</p>
				</div>
			{/each}
		</div>
	</section>

	<section class="flex justify-center">
		<div class="space-y-5">
			<h2 class="text-3xl font-semibold">Assets</h2>

			<!-- eslint-disable svelte/no-navigation-without-resolve -->
			<a
				href="/assets/btcmap-media-assets.zip"
				download
				class="mx-auto block w-36 rounded-lg bg-link py-3 font-semibold text-white transition-colors hover:bg-hover"
			>
				<!-- eslint-enable svelte/no-navigation-without-resolve -->
				Download All
			</a>

			{#each assetSections as section (section.title)}
				<div class="space-y-2 text-left">
					<h3 class="text-xl font-semibold">{section.title}</h3>

					<ul class="ml-5 list-disc space-y-1">
						{#each section.data as asset (asset.name)}
							<li>
								<!-- eslint-disable-next-line svelte/no-navigation-without-resolve -->
								<a href={asset.link} class="text-link transition-colors hover:text-hover">
									{asset.name}
								</a>
							</li>
						{/each}
					</ul>
				</div>
			{/each}
		</div>
	</section>
</main>



================================================
FILE: src/routes/merchant/[id]/+page.server.ts
================================================
import { verifiedArr } from '$lib/map/setup';
import type { MerchantPageData, MerchantComment, PayMerchant, Place } from '$lib/types';
import { PLACE_FIELD_SETS, buildFieldsParam } from '$lib/api-fields';
import { error } from '@sveltejs/kit';
import axios from 'axios';
import axiosRetry from 'axios-retry';
import type { PageServerLoad } from './$types';

axiosRetry(axios, { retries: 3, retryDelay: axiosRetry.exponentialDelay });

export const load: PageServerLoad<MerchantPageData> = async ({ params }) => {
	const { id } = params;
	try {
		// Fetch complete data from v4 Places API (supports both numeric Place IDs and OSM-style IDs)
		const placeResponse = await axios.get(
			`https://api.btcmap.org/v4/places/${id}?fields=${buildFieldsParam(PLACE_FIELD_SETS.COMPLETE_PLACE)}`
		);
		const placeData: Place = placeResponse.data;

		if (!placeData) {
			throw error(404, 'Merchant Not Found');
		}

		// Extract OSM type and ID from osm_url or osm_id for edit links
		let osmType: 'node' | 'way' | 'relation' = 'node'; // default
		let osmIdNum = Number(placeData.id); // fallback

		if (placeData.osm_url) {
			const osmMatch = placeData.osm_url.match(/openstreetmap\.org\/([^/]+)\/(\d+)/);
			if (osmMatch) {
				osmType = osmMatch[1] as 'node' | 'way' | 'relation';
				osmIdNum = Number(osmMatch[2]);
			}
		} else if (placeData.osm_id) {
			const parts = placeData.osm_id.split(':');
			if (parts.length === 2) {
				osmType = parts[0] as 'node' | 'way' | 'relation';
				osmIdNum = Number(parts[1]);
			}
		}

		const lat = placeData.lat;
		const lon = placeData.lon;

		let comments: MerchantComment[] = [];

		try {
			// Fetch comments directly from the dedicated comments endpoint
			const commentsResponse = await axios.get(`https://api.btcmap.org/v4/places/${id}/comments`);
			comments = commentsResponse.data;
		} catch {
			// Comments endpoint failed - use empty array
			comments = [];
		}

		// Process all merchant data server-side
		const icon = placeData.icon || 'question_mark';
		const address = placeData.address;
		const hours = placeData.opening_hours;

		const payment: PayMerchant = placeData['osm:payment:uri']
			? { type: 'uri', url: placeData['osm:payment:uri'] }
			: placeData['osm:payment:pouch']
				? { type: 'pouch', username: placeData['osm:payment:pouch'] }
				: placeData['osm:payment:coinos']
					? { type: 'coinos', username: placeData['osm:payment:coinos'] }
					: undefined;

		const boosted =
			placeData.boosted_until && Date.parse(placeData.boosted_until) > Date.now()
				? placeData.boosted_until
				: undefined;

		const verified = verifiedArr(placeData);
		const phone = placeData.phone || placeData['osm:contact:phone'];
		const website = placeData.website || placeData['osm:contact:website'];
		const email = placeData.email || placeData['osm:contact:email'];
		const twitter = placeData.twitter || placeData['osm:contact:twitter'];
		const instagram = placeData.instagram || placeData['osm:contact:instagram'];
		const facebook = placeData.facebook || placeData['osm:contact:facebook'];

		const thirdParty = placeData.required_app_url ? true : undefined;

		const paymentMethod =
			placeData['osm:payment:onchain'] ||
			placeData['osm:payment:lightning'] ||
			placeData['osm:payment:lightning_contactless'];

		// Build osmTags from Place data for the OSM tag modal
		const osmTags: Record<string, string> = {};

		// Core info
		if (placeData.name) osmTags['name'] = placeData.name;
		if (placeData.address) osmTags['addr:full'] = placeData.address;
		if (placeData.description) osmTags['description'] = placeData.description;
		if (placeData['osm:note']) osmTags['note'] = placeData['osm:note'];
		if (placeData.opening_hours) osmTags['opening_hours'] = placeData.opening_hours;

		// Contact info
		if (phone) osmTags['phone'] = phone;
		if (website) osmTags['website'] = website;
		if (email) osmTags['email'] = email;
		if (twitter) osmTags['contact:twitter'] = twitter;
		if (facebook) osmTags['contact:facebook'] = facebook;
		if (instagram) osmTags['contact:instagram'] = instagram;

		// Payment methods - The v4 API returns osm:payment:* fields, but the UI
		// and OSM tag modal expect the standard OSM tag format (payment:*), so we
		// map them here for display compatibility
		if (placeData['osm:payment:onchain'])
			osmTags['payment:onchain'] = placeData['osm:payment:onchain'];
		if (placeData['osm:payment:lightning'])
			osmTags['payment:lightning'] = placeData['osm:payment:lightning'];
		if (placeData['osm:payment:lightning_contactless'])
			osmTags['payment:lightning_contactless'] = placeData['osm:payment:lightning_contactless'];
		if (placeData['osm:payment:lightning:companion_app_url'])
			osmTags['payment:lightning:companion_app_url'] =
				placeData['osm:payment:lightning:companion_app_url'];

		// Survey/verification dates
		if (placeData['osm:survey:date']) osmTags['survey:date'] = placeData['osm:survey:date'];
		if (placeData['osm:check_date']) osmTags['check_date'] = placeData['osm:check_date'];
		if (placeData['osm:check_date:currency:XBT'])
			osmTags['check_date:currency:XBT'] = placeData['osm:check_date:currency:XBT'];
		if (placeData.verified_at) osmTags['verified_at'] = placeData.verified_at;

		// Metadata
		if (placeData.icon) osmTags['icon:android'] = placeData.icon;
		if (placeData['osm:amenity']) osmTags['amenity'] = placeData['osm:amenity'];
		if (placeData['osm:category']) osmTags['category'] = placeData['osm:category'];

		// IDs and URLs
		if (placeData.osm_id) osmTags['osm_id'] = placeData.osm_id;
		if (placeData.osm_url) osmTags['osm_url'] = placeData.osm_url;
		osmTags['btcmap_id'] = placeData.id.toString();

		// Boost
		if (placeData.boosted_until) osmTags['boost:expires'] = placeData.boosted_until;

		// Timestamps
		if (placeData.created_at) osmTags['created_at'] = placeData.created_at;
		if (placeData.updated_at) osmTags['updated_at'] = placeData.updated_at;

		return {
			id: placeData.id.toString(),
			name: placeData.name,
			lat,
			lon,
			comments,
			// Additional processed fields
			icon,
			address,
			description: placeData.description,
			note: placeData['osm:note'],
			hours,
			payment,
			boosted,
			verified,
			phone,
			website,
			email,
			twitter,
			instagram,
			facebook,
			thirdParty,
			paymentMethod,
			// OSM data for edit links and tag functionality
			osmType,
			osmId: osmIdNum,
			osmTags,
			// Place data for BoostButton and other components
			placeData
		};
	} catch (err) {
		console.error(err);
		error(404, 'Merchant Not Found');
	}
};



================================================
FILE: src/routes/merchant/[id]/+page.svelte
================================================
<script lang="ts">
	export let data: MerchantPageData;

	import { browser } from '$app/environment';
	import Boost from '$components/Boost.svelte';
	import BoostButton from '$components/BoostButton.svelte';
	import Card from '$components/Card.svelte';
	import CommentAddButton from './components/CommentAddButton.svelte';
	import Icon from '$components/Icon.svelte';
	import MapLoadingEmbed from '$components/MapLoadingEmbed.svelte';
	import MerchantButton from './components/MerchantButton.svelte';
	import MerchantEvent from './components/MerchantEvent.svelte';
	import MerchantComment from './components/MerchantComment.svelte';
	import MerchantLink from './components/MerchantLink.svelte';
	import PaymentMethodIcon from '$components/PaymentMethodIcon.svelte';
	import PrimaryButton from '$components/PrimaryButton.svelte';
	import ShowTags from '$components/ShowTags.svelte';
	import TaggerSkeleton from '$components/TaggerSkeleton.svelte';
	import TaggingIssues from '$components/TaggingIssues.svelte';
	import TopButton from '$components/TopButton.svelte';
	import { updateSinglePlace } from '$lib/sync/places';
	import { loadMapDependencies } from '$lib/map/imports';
	import {
		attribution,
		calcVerifiedDate,
		changeDefaultIcons,
		generateIcon,
		geolocate,
		layers
	} from '$lib/map/setup';
	import {
		areaError,
		areas,
		placesById,
		placesError,
		eventError,
		events,
		reportError,
		reports,
		showTags,
		taggingIssues,
		theme,
		userError,
		users
	} from '$lib/store';
	import { areasSync } from '$lib/sync/areas';
	import { eventsSync } from '$lib/sync/events';
	import { reportsSync } from '$lib/sync/reports';
	import { usersSync } from '$lib/sync/users';
	import { batchSync } from '$lib/sync/batchSync';
	import type {
		Area,
		BaseMaps,
		DomEventType,
		Event,
		Leaflet,
		PayMerchant,
		MerchantPageData
	} from '$lib/types.js';
	import type { Marker } from 'leaflet';
	import {
		errToast,
		successToast,
		formatOpeningHours,
		formatVerifiedHuman,
		isBoosted
	} from '$lib/utils';
	import rewind from '@mapbox/geojson-rewind';
	import { geoContains } from 'd3-geo';
	import type { Map } from 'leaflet';
	import { onDestroy, onMount } from 'svelte';
	import Time from 'svelte-time';
	import tippy from 'tippy.js';
	import { resolve } from '$app/paths';

	// alert for user errors
	$: $userError && errToast($userError);
	// alert for event errors
	$: $eventError && errToast($eventError);
	// alert for element errors
	$: $placesError && errToast($placesError);
	// alert for area errors
	$: $areaError && errToast($areaError);
	// alert for report errors
	$: $reportError && errToast($reportError);

	// Scroll indicator thresholds
	const SCROLL_INDICATOR_MIN_ITEMS = 5;
	const TOP_BUTTON_MIN_ITEMS = 10;

	let dataInitialized = false;
	let initialRenderComplete = false;

	let leaflet: Leaflet;
	let DomEvent: DomEventType;
	let LocateControl: typeof import('leaflet.locatecontrol').LocateControl;

	const initializeData = () => {
		if (dataInitialized) return;

		// Use server data directly instead of store lookup
		icon = data.icon;
		address = data.address;
		description = data.description;
		note = data.note;
		hours = data.hours;
		payment = data.payment;
		phone = data.phone;
		website = data.website;
		email = data.email;
		twitter = data.twitter;
		instagram = data.instagram;
		facebook = data.facebook;
		thirdParty = data.thirdParty;
		paymentMethod = data.paymentMethod;

		lat = data.lat;
		long = data.lon;

		const commentsCount = comments.length;

		const communities = $areas.filter(
			(area) =>
				area.tags.type === 'community' &&
				area.tags.geo_json &&
				area.tags.name &&
				area.tags['icon:square'] &&
				area.tags.continent &&
				Object.keys(area.tags).find((key) => key.includes('contact')) &&
				$reports.find((report) => report.area_id === area.id)
		);

		// filter communities containing element
		filteredCommunities = communities.filter((community) => {
			let rewoundPoly = rewind(community.tags.geo_json, true);

			if (typeof lat === 'number' && typeof long === 'number') {
				if (geoContains(rewoundPoly, [long, lat])) {
					return true;
				}
			}
			return false;
		});

		merchantEvents = $events.filter((event) => event.element_id === data.placeData.osm_id);

		merchantEvents.sort((a, b) => Date.parse(b['created_at']) - Date.parse(a['created_at']));

		const setupMap = () => {
			// add map
			map = leaflet.map(mapElement, { attributionControl: false, maxZoom: 19 });

			// add tiles and basemaps
			const layersResult = layers(leaflet, map);
			baseMaps = layersResult.baseMaps;

			// change broken marker image path in prod
			leaflet.Icon.Default.prototype.options.imagePath = '/icons/';

			// add OSM attribution
			attribution(leaflet, map);

			leaflet.control.layers(baseMaps).addTo(map);

			// add locate button to map
			geolocate(leaflet, map, LocateControl);

			// change default icons
			changeDefaultIcons(true, leaflet, mapElement, DomEvent);

			// add element to map
			const divIcon = generateIcon(
				leaflet,
				data.placeData.deleted_at ? 'skull' : icon || 'question_mark',
				boosted ? true : false,
				commentsCount
			);

			if (typeof lat === 'number' && typeof long === 'number') {
				merchantMarker = leaflet.marker([lat, long], { icon: divIcon });
				map.addLayer(merchantMarker);
				map.fitBounds([[lat, long]]);
			}

			mapLoaded = true;
		};
		setupMap();

		dataInitialized = true;
	};

	// Initialize data when component mounts, only need areas/reports/events for communities/activity
	$: $users &&
		$users.length &&
		$events &&
		$events.length &&
		$areas &&
		$areas.length &&
		$reports &&
		$reports.length &&
		initialRenderComplete &&
		!dataInitialized &&
		initializeData();

	// merchant variable no longer needed - using server data directly

	const name = data.name;
	let icon: string | undefined;
	let address: string | undefined;
	let description: string | undefined;
	let note: string | undefined;
	let hours: string | undefined;
	let payment: PayMerchant;
	let boosted: string | undefined;
	let verified: string[] = [];
	const verifiedDate = calcVerifiedDate();

	// Make comments reactive to server data updates (from invalidateAll() after adding comment)
	let comments = data.comments;
	$: comments = data.comments;

	// Initialize verified and boosted immediately from server data (don't wait for store sync)
	$: verified = data.verified || [];
	// Make boosted reactive to both server data and store updates, but only if boost is still active
	$: {
		const placeInStore = $placesById.get(Number(data.id));
		const mergedPlace = placeInStore || data.placeData;
		// Only set boosted if the place is actually boosted (expiry in future)
		boosted = mergedPlace && isBoosted(mergedPlace) ? mergedPlace.boosted_until : undefined;
	}
	let phone: string | undefined;
	let website: string | undefined;
	let email: string | undefined;
	let twitter: string | undefined;
	let instagram: string | undefined;
	let facebook: string | undefined;

	let thirdParty: boolean | undefined;
	let paymentMethod: string | undefined;

	let thirdPartyTooltip: HTMLAnchorElement;
	let onchainTooltip: HTMLImageElement;
	let lnTooltip: HTMLImageElement;
	let nfcTooltip: HTMLImageElement;
	let verifiedTooltip: HTMLSpanElement;
	let outdatedTooltip: HTMLSpanElement;

	$: thirdPartyTooltip &&
		data &&
		tippy([thirdPartyTooltip], {
			content: 'Third party app required'
		});

	$: onchainTooltip &&
		data &&
		tippy([onchainTooltip], {
			content:
				data.osmTags?.['payment:onchain'] === 'yes'
					? 'On-chain accepted'
					: data.osmTags?.['payment:onchain'] === 'no'
						? 'On-chain not accepted'
						: 'On-chain unknown'
		});

	$: lnTooltip &&
		data &&
		tippy([lnTooltip], {
			content:
				data.osmTags?.['payment:lightning'] === 'yes'
					? 'Lightning accepted'
					: data.osmTags?.['payment:lightning'] === 'no'
						? 'Lightning not accepted'
						: 'Lightning unknown'
		});

	$: nfcTooltip &&
		data &&
		tippy([nfcTooltip], {
			content:
				data.osmTags?.['payment:lightning_contactless'] === 'yes'
					? 'Lightning Contactless accepted'
					: data.osmTags?.['payment:lightning_contactless'] === 'no'
						? 'Lightning contactless not accepted'
						: 'Lightning contactless unknown'
		});

	$: verifiedTooltip &&
		tippy([verifiedTooltip], {
			content: 'Verified within the last year'
		});

	$: outdatedTooltip &&
		tippy([outdatedTooltip], {
			content: 'Outdated please re-verify'
		});

	let lat: number | undefined;
	let long: number | undefined;

	let filteredCommunities: Area[] = [];

	let hideArrow = false;
	let activityDiv: HTMLElement;

	let hideCommentsArrow = false;
	let commentsDiv: HTMLElement;

	let merchantEvents: Event[] = [];

	let eventCount = 50;
	$: eventsPaginated = merchantEvents.slice(0, eventCount);

	const findUser = (tagger: Event) => {
		let foundUser = $users.find((user) => user.id == tagger['user_id']);

		if (foundUser) {
			return foundUser;
		} else {
			return undefined;
		}
	};

	let mapElement: HTMLDivElement;
	let map: Map;
	let mapLoaded = false;
	let merchantMarker: Marker | undefined; // Store marker reference for reactive updates

	let baseMaps: BaseMaps;

	onMount(async () => {
		batchSync([eventsSync, usersSync, areasSync, reportsSync]);

		if (browser) {
			const deps = await loadMapDependencies();
			leaflet = deps.leaflet;
			DomEvent = deps.DomEvent;
			LocateControl = deps.LocateControl;

			initialRenderComplete = true;

			// Update localforage with fresh place data to sync comment counts, boosts, etc.
			// This ensures the map shows current data when navigating back
			try {
				await updateSinglePlace(data.id);
			} catch (error) {
				// Silent failure - page still works with server data even if cache update fails
				console.error('Could not update place in localforage:', error);
			}
		}
	});

	const toggleTheme = () => {
		if ($theme === 'dark') {
			baseMaps['OpenFreeMap Liberty'].remove();
			baseMaps['OpenFreeMap Dark'].addTo(map);
		} else {
			baseMaps['OpenFreeMap Dark'].remove();
			baseMaps['OpenFreeMap Liberty'].addTo(map);
		}
	};

	$: $theme !== undefined && mapLoaded && toggleTheme();

	// Update marker icon when boost or comment state changes
	$: if (merchantMarker && leaflet && mapLoaded && icon) {
		const commentsCount = comments.length;
		const displayIcon = data.placeData.deleted_at
			? 'skull'
			: icon !== 'question_mark'
				? icon
				: 'currency_bitcoin';
		const newIcon = generateIcon(leaflet, displayIcon, boosted ? true : false, commentsCount);
		merchantMarker.setIcon(newIcon);
	}

	onDestroy(async () => {
		if (map) {
			console.info('Unloading Leaflet map.');
			map.remove();
		}
	});

	const ogImage = `https://api.btcmap.org/og/element/${data.osmType}:${data.osmId}`;
</script>

<svelte:head>
	<title>{name ? name + ' - ' : ''}BTC Map Merchant</title>
	<meta property="og:image" content={ogImage} />
	<meta property="twitter:title" content="{name ? name + ' - ' : ''}BTC Map Merchant" />
	<meta property="twitter:image" content={ogImage} />
</svelte:head>

{#if data.placeData.deleted_at}
	<div class="bg-red-600 py-4 text-center text-white">
		<p class="text-lg font-semibold">
			<Icon w="20" h="20" class="mr-2 inline-block text-white" icon="skull" type="material" />
			This merchant has been removed from BTC Map and may no longer accept Bitcoin.
		</p>
		<p class="mt-1 text-sm">The data shown below is outdated and for reference only.</p>
	</div>
{/if}
<main class="my-10 space-y-16 text-center md:my-20">
	<section id="profile" class="space-y-8">
		<div class="space-y-2">
			{#if icon}
				<div
					class="mx-auto flex h-32 w-32 items-center justify-center rounded-full {data.placeData
						.deleted_at
						? 'bg-gray-400 dark:bg-gray-600'
						: boosted
							? 'bg-bitcoin hover:animate-wiggle'
							: 'bg-link'}"
				>
					<Icon
						w="60"
						h="60"
						class="text-white"
						icon={data.placeData.deleted_at
							? 'skull'
							: icon !== 'question_mark'
								? icon
								: 'currency_bitcoin'}
						type="material"
					/>
				</div>
			{:else}
				<div class="mx-auto h-32 w-32 animate-pulse rounded-full bg-link/50" />
			{/if}

			<h1 class="text-4xl !leading-tight font-semibold text-primary dark:text-white">
				{name || 'BTC Map Merchant'}
				{#if data.placeData.deleted_at}
					<span class="text-2xl text-red-600 dark:text-red-400">(Deleted)</span>
				{/if}
			</h1>

			{#if address}
				<h2 class="text-xl text-primary dark:text-white">
					{address}
				</h2>
			{/if}

			{#if lat && long}
				<!-- eslint-disable svelte/no-navigation-without-resolve -->
				<a
					href={`/map#18/${lat}/${long}`}
					class="inline-flex items-center justify-center text-xs text-link transition-colors hover:text-hover"
				>
					<!-- eslint-enable svelte/no-navigation-without-resolve -->
					View on main map
					<svg
						class="ml-1 w-3"
						width="16"
						height="16"
						viewBox="0 0 16 16"
						fill="none"
						xmlns="http://www.w3.org/2000/svg"
					>
						<path
							d="M3 13L13 3M13 3H5.5M13 3V10.5"
							stroke="currentColor"
							stroke-width="1.5"
							stroke-linecap="round"
							stroke-linejoin="round"
						/>
					</svg>
				</a>
			{:else}
				<div class="mx-auto h-4 w-28 animate-pulse rounded bg-link/50" />
			{/if}
		</div>

		<div class="grid-cols-3 gap-12 space-y-12 lg:grid lg:space-y-0">
			{#if phone}
				<div class="text-primary dark:text-white">
					<h4 class="text-primary uppercase dark:text-white">
						<Icon
							w="16"
							h="16"
							class="inline-block text-primary dark:text-white"
							icon="phone"
							type="material"
						/>
						Contact
					</h4>

					<div class="flex items-center justify-center">
						{phone}
					</div>
				</div>
			{:else}
				<div></div>
				<!-- Placeholder for alignment -->
			{/if}

			{#if (paymentMethod || thirdParty) && data}
				<div class="text-primary dark:text-white">
					<h4 class="text-primary uppercase dark:text-white">Accepted Payments</h4>
					<div class="mt-1 flex items-center justify-center space-x-2">
						{#if !paymentMethod}
							<!-- eslint-disable svelte/no-navigation-without-resolve -->
							<a
								bind:this={thirdPartyTooltip}
								href={data.osmTags?.['payment:lightning:companion_app_url']}
								target="_blank"
								rel="noreferrer"
							>
								<!-- eslint-enable svelte/no-navigation-without-resolve -->
								<Icon
									type="fa"
									icon="mobile-screen-button"
									w="32"
									h="32"
									class="text-primary transition-colors hover:text-link dark:text-white dark:hover:text-link"
								/>
							</a>
						{:else if typeof window !== 'undefined'}
							<PaymentMethodIcon
								bind:element={onchainTooltip}
								status={data.osmTags?.['payment:onchain']}
								method="btc"
								label="On-chain"
								variant="teal"
								size="md"
							/>

							<PaymentMethodIcon
								bind:element={lnTooltip}
								status={data.osmTags?.['payment:lightning']}
								method="ln"
								label="Lightning"
								variant="teal"
								size="md"
							/>

							<PaymentMethodIcon
								bind:element={nfcTooltip}
								status={data.osmTags?.['payment:lightning_contactless']}
								method="nfc"
								label="Lightning contactless"
								variant="teal"
								size="md"
							/>
						{/if}
					</div>
				</div>
			{/if}

			{#if hours}
				<div class="text-primary dark:text-white">
					<h4 class="text-primary uppercase dark:text-white">
						<Icon
							w="16"
							h="16"
							class="inline text-primary dark:text-white"
							icon="schedule"
							type="material"
						/>
						Hours
					</h4>

					<div class="flex items-start justify-center">
						<!-- eslint-disable-next-line svelte/no-at-html-tags - we even sanitize the captcha content above -->
						<time class="flex flex-col items-start">{@html formatOpeningHours(hours)}</time>
					</div>
				</div>
			{/if}
		</div>

		<div class="flex flex-wrap items-center justify-center gap-4">
			{#if dataInitialized}
				<MerchantLink link={`geo:${lat},${long}`} icon="compass" text="Navigate" />

				<MerchantLink
					link={`https://www.openstreetmap.org/edit?${data.osmType}=${data.osmId}`}
					icon="pencil"
					text="Edit"
				/>

				<MerchantButton
					on:click={() => {
						navigator.clipboard.writeText(`https://btcmap.org/merchant/${data.id}`);
						successToast('Link copied to clipboard!');
					}}
					icon="share"
					text="Share"
				/>

				{#if payment}
					<MerchantLink
						link={payment.type === 'uri'
							? payment.url || '#'
							: payment.type === 'pouch'
								? `https://app.pouch.ph/${payment.username}`
								: payment.type === 'coinos'
									? `https://coinos.io/${payment.username}`
									: '#'}
						icon="bolt"
						text="Pay Merchant"
					/>
				{/if}

				{#if phone}
					<MerchantLink link={`tel:${phone}`} icon="phone" text="Call" />
				{/if}

				{#if email}
					<MerchantLink link={`mailto:${email}`} icon="email" text="Email" />
				{/if}

				{#if website}
					<MerchantLink
						link={website.startsWith('http') ? website : `https://${website}`}
						icon="globe"
						text="Website"
					/>
				{/if}

				{#if twitter}
					<MerchantLink
						link={twitter.startsWith('http') ? twitter : `https://twitter.com/${twitter}`}
						icon="x"
						text="X"
					/>
				{/if}

				{#if instagram}
					<MerchantLink
						link={instagram.startsWith('http') ? instagram : `https://instagram.com/${instagram}`}
						icon="instagram"
						text="Instagram"
					/>
				{/if}

				{#if facebook}
					<MerchantLink
						link={facebook.startsWith('http') ? facebook : `https://facebook.com/${facebook}`}
						icon="facebook"
						text="Facebook"
					/>
				{/if}

				<span id="show-tags">
					<MerchantButton
						on:click={() => ($showTags = data.osmTags)}
						icon="tags"
						text="Show Tags"
					/>
				</span>

				<span id="tagging-issues">
					<MerchantButton
						on:click={() => ($taggingIssues = data.osmTags?.issues || [])}
						icon="issues"
						text="Tag Issues"
					/>
				</span>

				<MerchantLink
					link={`https://www.openstreetmap.org/${data.osmType}/${data.osmId}`}
					icon="external"
					text="View OSM"
				/>
			{:else}
				{#each Array(5) as _, i (i)}
					<div class="h-20 w-24 animate-pulse rounded-lg bg-link/50" />
				{/each}
			{/if}
		</div>

		{#if description}
			<p class="mx-auto max-w-[600px] text-primary dark:text-white">{description}</p>
		{/if}

		{#if note}
			<p class="mx-auto max-w-[600px] text-primary dark:text-white">{note}</p>
		{/if}

		<!-- Three cards: Last Surveyed, Boost, Comments (use server data, don't wait for store sync) -->
		<div class="grid-cols-3 gap-12 space-y-12 lg:grid lg:space-y-0">
			<Card headerAlign="center">
				<h3 slot="header" class="text-2xl font-semibold">Last Surveyed</h3>

				<div slot="body" class="p-4">
					{#if verified.length}
						<div class="flex items-center justify-center dark:text-white">
							{#if Date.parse(verified[0]) > verifiedDate}
								<span bind:this={verifiedTooltip}>
									<Icon
										w="30"
										h="30"
										class="mr-2 text-primary dark:text-white"
										icon="verified"
										type="material"
									/>
								</span>
							{:else}
								<span bind:this={outdatedTooltip}>
									<Icon
										w="30"
										h="30"
										class="mr-2 text-primary dark:text-white"
										icon="error_outline"
										type="material"
									/>
								</span>
							{/if}
							<strong>{formatVerifiedHuman(verified?.[0])}</strong>
						</div>
					{:else}
						<p class="font-semibold dark:text-white">This location needs to be surveyed!</p>
					{/if}
				</div>

				<PrimaryButton
					slot="footer"
					link={`/verify-location?id=${data.id}`}
					style="rounded-xl p-3 w-40"
				>
					Verify Location
				</PrimaryButton>
			</Card>

			<Card headerAlign="center">
				<h3 slot="header" class="text-2xl font-semibold">Boost</h3>

				<div slot="body" class="p-4">
					<p class="mx-auto font-semibold dark:text-white">
						{boosted
							? 'This location is boosted!'
							: "Boost this location to improve it's visibility on the map."}
					</p>

					{#if boosted}
						<p class="dark:text-white">
							Boost Expires:
							<span class="underline decoration-bitcoin decoration-4 underline-offset-8">
								<Time live={3000} relative={true} timestamp={boosted} />
							</span>
						</p>
					{/if}
				</div>

				<BoostButton slot="footer" merchant={data.placeData} {boosted} />
			</Card>

			<Card headerAlign="center">
				<h3 slot="header" class="text-2xl font-semibold">
					Comments {#if comments.length}({comments.length}){/if}
				</h3>

				<div slot="body" class="p-4">
					<p class="mx-auto font-semibold dark:text-white">
						{#if comments.length}
							Let others know your thoughts about this merchant.
						{:else}
							No comments yet. Be the first to leave a comment!
						{/if}
					</p>
				</div>

				<div slot="footer">
					{#if comments.length}
						<PrimaryButton link="#comments" style="w-40 rounded-xl p-3">
							View Comments
						</PrimaryButton>
					{:else}
						<CommentAddButton elementId={data.id} />
					{/if}
				</div>
			</Card>
		</div>
	</section>

	<section id="map-section">
		<Card>
			<h3 slot="header" class="text-lg font-semibold">
				{name || 'Merchant'} Location
			</h3>

			<div slot="body" class="w-full">
				<div class="relative overflow-hidden">
					<div
						bind:this={mapElement}
						class="z-10 h-[300px] rounded-b-3xl !bg-teal text-left md:h-[600px] dark:!bg-[#202f33]"
					/>
					{#if !mapLoaded}
						<MapLoadingEmbed style="h-[300px] md:h-[600px]  rounded-b-3xl" />
					{/if}
				</div>
			</div>
		</Card>
	</section>

	<section id="comments">
		<Card>
			<div slot="header" class="flex items-center justify-between">
				<h3 class="text-lg font-semibold">
					{name || 'Merchant'} Comments
				</h3>
				<CommentAddButton elementId={data.id} />
			</div>

			<div slot="body" class="w-full">
				<div
					bind:this={commentsDiv}
					class="hide-scroll relative max-h-[300px] space-y-2 overflow-y-scroll"
					on:scroll={() => {
						if (dataInitialized && !hideCommentsArrow) {
							hideCommentsArrow = true;
						}
					}}
				>
					{#if comments && comments.length}
						{#each [...comments].reverse() as comment (comment.id)}
							<MerchantComment text={comment.text} time={comment['created_at']} />
						{/each}

						{#if comments.length > SCROLL_INDICATOR_MIN_ITEMS}
							<TopButton scroll={commentsDiv} style="!mb-5" />
						{/if}

						{#if !hideCommentsArrow && comments.length > SCROLL_INDICATOR_MIN_ITEMS}
							<Icon
								type="fa"
								icon="chevron-down"
								w="16"
								h="16"
								class="absolute bottom-4 left-[calc(50%-8px)] z-20 animate-bounce text-primary dark:text-white"
							/>
						{/if}
					{:else}
						<p class="p-5 text-body dark:text-white">No comments yet.</p>
					{/if}
				</div>
			</div>
		</Card>
	</section>

	<section id="activity">
		<Card>
			<h3 slot="header" class="text-lg font-semibold">
				{name || 'Merchant'} Activity
			</h3>

			<div slot="body" class="w-full">
				<div
					bind:this={activityDiv}
					class="hide-scroll relative max-h-[300px] space-y-2 overflow-y-scroll"
					on:scroll={() => {
						if (dataInitialized && !hideArrow) {
							hideArrow = true;
						}
					}}
				>
					{#if merchantEvents && merchantEvents.length}
						{#each eventsPaginated as event (event['created_at'])}
							<MerchantEvent
								action={event.type}
								user={findUser(event)}
								time={event['created_at']}
								latest={event === merchantEvents[0] ? true : false}
							/>
						{/each}

						{#if eventsPaginated.length !== merchantEvents.length}
							<button
								class="mx-auto !mb-5 block text-xl font-semibold text-link transition-colors hover:text-hover"
								on:click={() => (eventCount = eventCount + 50)}>Load More</button
							>
						{:else if merchantEvents.length > TOP_BUTTON_MIN_ITEMS}
							<TopButton scroll={activityDiv} style="!mb-5" />
						{/if}

						{#if !hideArrow && merchantEvents.length > SCROLL_INDICATOR_MIN_ITEMS}
							<Icon
								type="fa"
								icon="chevron-down"
								w="16"
								h="16"
								class="absolute bottom-4 left-[calc(50%-8px)] z-20 animate-bounce text-primary dark:text-white"
							/>
						{/if}
					{:else if !dataInitialized}
						{#each Array(5) as _, i (i)}
							<TaggerSkeleton />
						{/each}
					{:else}
						<p class="p-5 text-body dark:text-white">No activity to display.</p>
					{/if}
				</div>
			</div>
		</Card>
	</section>

	<section id="communities">
		<Card>
			<h3 slot="header" class="text-lg font-semibold">
				{name || 'Merchant'} Communities
			</h3>

			<div slot="body" class="w-full">
				<div
					class="hide-scroll flex max-h-[300px] flex-wrap items-center justify-center overflow-scroll"
				>
					{#if filteredCommunities && filteredCommunities.length}
						{#each filteredCommunities as community (community.id)}
							<div class="m-4 space-y-1 transition-transform hover:scale-110">
								<a href={resolve(`/community/${community.id}`)}>
									<img
										src={`https://btcmap.org/.netlify/images?url=${community.tags['icon:square']}&fit=cover&w=256&h=256`}
										alt="logo"
										class="mx-auto h-20 w-20 rounded-full object-cover"
										on:error={function () {
											this.src = '/images/bitcoin.svg';
										}}
									/>
									<p class="text-center font-semibold text-body dark:text-white">
										{community.tags.name}
									</p>
								</a>
							</div>
						{/each}
					{:else if !dataInitialized}
						<p class="p-5 text-body dark:text-white">Loading communities...</p>
					{:else}
						<p class="p-5 text-body dark:text-white">
							This location is not part of a communtiy, but one can be <a
								href={resolve('/communities')}
								class="text-link transition-colors hover:text-hover">created</a
							> to help maintain this local area.
						</p>
					{/if}
				</div>
			</div>
		</Card>
	</section>

	<p class="text-center text-sm text-body md:text-left dark:text-white">
		*More information on bitcoin mapping tags can be found <a
			href="https://gitea.btcmap.org/teambtcmap/btcmap-general/wiki/Tagging-Merchants#tagging-guidance"
			target="_blank"
			rel="noreferrer"
			class="text-link transition-colors hover:text-hover">here</a
		>.
	</p>
</main>

{#if browser}
	<Boost />
{/if}

<ShowTags />
<TaggingIssues />



================================================
FILE: src/routes/merchant/[id]/components/CommentAdd.svelte
================================================
<script lang="ts">
	import { invalidateAll } from '$app/navigation';
	import CloseButton from '$components/CloseButton.svelte';
	import Icon from '$components/Icon.svelte';
	import InvoicePaymentStage from '$components/InvoicePaymentStage.svelte';
	import PrimaryButton from '$components/PrimaryButton.svelte';
	import { PAYMENT_ERROR_MESSAGE } from '$lib/constants';
	import { lastUpdatedPlaceId } from '$lib/store';
	import { updateSinglePlace } from '$lib/sync/places';
	import { errToast } from '$lib/utils';
	import axios from 'axios';
	import OutClick from 'svelte-outclick';
	import { fly } from 'svelte/transition';
	import type { MerchantPageData } from '$lib/types.js';

	export let open: boolean = false;
	export let onOpenChange: (value: boolean) => void = () => {};
	export let elementId: MerchantPageData['id'] | undefined;

	let stage = 0;
	let commentValue: string = '';
	let invoice = '';
	let invoiceId = '';
	let loading = false;
	let commentComplete = false;
	const closeModal = () => {
		if (commentComplete) {
			invalidateAll();
		}
		onOpenChange(false);
		stage = 0;
		invoice = '';
		invoiceId = '';
		loading = false;
		commentComplete = false;
		$lastUpdatedPlaceId = undefined;
	};

	const generateInvoice = (event: SubmitEvent) => {
		event.preventDefault();
		if (!elementId || !commentValue.trim()) {
			errToast('Please enter a comment');
			return;
		}

		loading = true;
		axios
			.post('/comment/invoice/generate', {
				place_id: elementId,
				comment: commentValue.trim()
			})
			.then(function (response) {
				invoice = response.data.invoice;
				invoiceId = response.data.invoice_id;
				stage = 1;
				loading = false;
			})
			.catch(function (error) {
				errToast(PAYMENT_ERROR_MESSAGE);
				console.error(error);
				loading = false;
			});
	};

	const handlePaymentSuccess = async () => {
		// Comment will be published automatically by the backend
		stage = 2;
		commentComplete = true;

		// Update the place in localforage and store immediately
		if (elementId) {
			await updateSinglePlace(elementId);
			// Signal map to update marker icon
			lastUpdatedPlaceId.set(Number(elementId));
		}
	};

	const handlePaymentError = (error: unknown) => {
		console.error('Payment error:', error);
	};

	const handleStatusCheckError = (error: unknown) => {
		console.error('Status check error:', error);
	};
</script>

{#if open}
	<OutClick excludeQuerySelectorAll="#boost-button" on:outclick={closeModal}>
		<div
			transition:fly={{ y: 200, duration: 300 }}
			class="center-fixed z-[2000] max-h-[90vh] w-[90vw] overflow-auto rounded-xl border border-gray-300 bg-white p-6 text-left shadow-2xl md:w-[430px] dark:border-white/95 dark:bg-dark"
		>
			<CloseButton
				position="flex justify-end"
				on:click={closeModal}
				colors="text-primary dark:text-white dark:hover:text-white/80 hover:text-link"
			/>

			{#if stage === 0}
				<form class="space-y-4" on:submit={generateInvoice}>
					<legend>
						<p class="mb-2 text-xl font-bold text-primary dark:text-white">Add Comment</p>

						<p class="text-sm text-body dark:text-white">
							All comments are currently anonymous. We collect a small fee in sats as a spam
							protection measure.
						</p>
						<p class="text-sm text-body dark:text-white">Current fee: 500 sats</p>
					</legend>

					<div>
						<label for="comment" class="mb-2 block font-semibold text-primary dark:text-white"
							>Your comment</label
						>
						<textarea
							name="comment"
							rows="3"
							class="w-full rounded-2xl border-2 border-input p-3 transition-all focus:outline-link dark:bg-white/[0.15]"
							bind:value={commentValue}
						/>
					</div>

					<PrimaryButton style="w-full rounded-xl p-3" disabled={loading} type="submit" {loading}>
						Comment
					</PrimaryButton>
				</form>
			{:else if stage === 1}
				<InvoicePaymentStage
					{invoice}
					{invoiceId}
					onSuccess={handlePaymentSuccess}
					onError={handlePaymentError}
					onStatusCheckError={handleStatusCheckError}
				>
					<p class="rounded-md border p-1 text-sm text-body dark:text-white">
						<Icon w="16" h="16" icon="info" class="inline-block" />
						Your comment will be published when our bots have confirmed the payment.
					</p>

					<PrimaryButton style="w-full rounded-xl p-3" on:click={closeModal}>Close</PrimaryButton>
				</InvoicePaymentStage>
			{:else}
				<div class="space-y-4 text-center">
					<p class="text-xl font-bold text-primary dark:text-white">Thank you for your comment!</p>

					<p class="text-body dark:text-white">Your comment has been published!</p>

					<PrimaryButton style="w-full rounded-xl p-3" on:click={closeModal}>Close</PrimaryButton>
				</div>
			{/if}
		</div>
	</OutClick>
{/if}



================================================
FILE: src/routes/merchant/[id]/components/CommentAddButton.svelte
================================================
<script lang="ts">
	import CommentAdd from './CommentAdd.svelte';
	import { browser } from '$app/environment';
	import type { MerchantPageData } from '$lib/types.js';
	import PrimaryButton from '$components/PrimaryButton.svelte';

	export let elementId: MerchantPageData['id'] | undefined;
	let open = false;
</script>

<PrimaryButton
	on:click={() => (open = true)}
	disabled={open}
	style="flex w-40 items-center justify-center rounded-xl p-3"
>
	{#if open}
		Commenting...
	{:else}
		Add comment
	{/if}
</PrimaryButton>

{#if browser}
	<CommentAdd {open} onOpenChange={(val) => (open = val)} {elementId} />
{/if}



================================================
FILE: src/routes/merchant/[id]/components/MerchantButton.svelte
================================================
<script lang="ts">
	import Icon from '$components/Icon.svelte';

	export let icon: string;
	export let text: string;

	// Map popup spritesheet icon names to material icons
	const iconMap: Record<string, string> = {
		share: 'share',
		tags: 'sell',
		issues: 'warning'
	};

	$: materialIcon = iconMap[icon] || icon;
</script>

<button
	on:click
	class="flex h-20 min-w-24 items-center justify-center rounded-lg border border-primary py-1 !text-primary transition-colors hover:border-link hover:!text-link dark:border-white/95 dark:!text-white dark:hover:border-link dark:hover:!text-link"
>
	<div>
		<Icon w="30" h="30" icon={materialIcon} type="material" class="mx-auto" />
		<span class="mt-1 block text-center text-xs font-semibold">{text}</span>
	</div>
</button>



================================================
FILE: src/routes/merchant/[id]/components/MerchantComment.svelte
================================================
<script lang="ts">
	import Time from 'svelte-time';
	import type { MerchantPageData } from '$lib/types';

	export let text: MerchantPageData['comments'][number]['text'];
	export let time: MerchantPageData['comments'][number]['created_at'];
</script>

<div
	class="items-center space-y-2 p-5 text-center text-xl lg:flex lg:space-y-0 lg:space-x-5 lg:text-left"
>
	<div class="w-full flex-wrap items-center justify-between space-y-2 lg:flex lg:space-y-0">
		<div class="space-y-2 lg:space-y-0">
			<span class="text-primary lg:mr-5 dark:text-white">
				{text}
			</span>

			<span class="block text-center font-semibold text-taggerTime lg:inline dark:text-white/70">
				<Time timestamp={time} />
			</span>
		</div>
	</div>
</div>



================================================
FILE: src/routes/merchant/[id]/components/MerchantEvent.svelte
================================================
<script lang="ts">
	import Tip from '$components/Tip.svelte';
	import type { EventType, User } from '$lib/types';
	import Time from 'svelte-time';
	import { resolve } from '$app/paths';

	export let action: EventType;
	export let user: User | undefined;
	export let time: string;
	export let latest: boolean;

	$: profile = user && user['osm_json'];
	$: regexMatch = profile && profile.description.match('(lightning:[^)]+)');
	$: lightning = regexMatch && regexMatch[0].slice(10);

	$: username = profile && profile['display_name'];
</script>

<div
	class="flex flex-col items-center gap-2 p-5 text-center text-xl lg:flex-row lg:gap-5 lg:text-left"
>
	<!-- dot -->
	<span class="relative mx-auto mb-2 flex h-3 w-3 lg:mx-0 lg:mb-0">
		<span
			class="{latest
				? 'animate-ping'
				: ''} absolute inline-flex h-full w-full rounded-full {action === 'create'
				? 'bg-created'
				: action === 'delete'
					? 'bg-deleted'
					: 'bg-link'} opacity-75"
		/>
		<span
			class="relative inline-flex h-3 w-3 rounded-full {action === 'create'
				? 'bg-created'
				: action === 'delete'
					? 'bg-deleted'
					: 'bg-link'}"
		/>
	</span>

	<div class="w-full flex-wrap items-center justify-between space-y-2 lg:flex lg:space-y-0">
		<!-- event information -->
		<div class="space-y-2 lg:space-y-0">
			<span class="text-primary lg:mr-5 dark:text-white">
				<!-- action -->
				<strong>{action.charAt(0).toUpperCase() + action.slice(1, action.length)}d</strong>

				<!-- user -->
				{#if user && username}
					by <a
						href={resolve(`/tagger/${user.id}`)}
						class="block break-all text-link transition-colors hover:text-hover lg:inline"
						>{username}
					</a>
				{/if}
			</span>

			<!-- time ago -->
			<span
				class="block text-center font-semibold text-taggerTime lg:inline dark:text-white/70 {lightning
					? 'lg:mr-5'
					: ''}"
			>
				<Time live={3000} relative timestamp={time} />
			</span>
		</div>

		<!-- lightning tip button -->
		{#if lightning}
			<Tip destination={lightning} class="mx-auto block lg:mx-0 lg:inline" />
		{/if}
	</div>
</div>



================================================
FILE: src/routes/merchant/[id]/components/MerchantLink.svelte
================================================
<script lang="ts">
	import Icon from '$components/Icon.svelte';

	export let link: string;
	export let icon: string;
	export let text: string;

	// Social icons use FA brands
	const faIcons = ['x', 'instagram', 'facebook'];

	// Map icon names to their respective icons
	const materialIconMap: Record<string, string> = {
		compass: 'explore',
		pencil: 'edit',
		share: 'share',
		bolt: 'bolt',
		phone: 'phone',
		email: 'email',
		globe: 'language',
		external: 'open_in_new'
	};

	const faIconMap: Record<string, string> = {
		x: 'x-twitter',
		instagram: 'instagram',
		facebook: 'facebook'
	};

	$: isFaIcon = faIcons.includes(icon);
	$: resolvedIcon = isFaIcon ? faIconMap[icon] || icon : materialIconMap[icon] || icon;
</script>

<!-- eslint-disable svelte/no-navigation-without-resolve -->
<a
	href={link}
	target="_blank"
	rel="noreferrer"
	class="flex h-20 w-24 items-center justify-center rounded-lg border border-primary py-1 !text-primary transition-colors hover:border-link hover:!text-link dark:border-white/95 dark:!text-white dark:hover:border-link dark:hover:!text-link"
>
	<!-- eslint-enable svelte/no-navigation-without-resolve -->
	<div>
		<Icon w="30" h="30" icon={resolvedIcon} type={isFaIcon ? 'fa' : 'material'} class="mx-auto" />
		<span class="mt-1 block text-center text-xs font-semibold">{text}</span>
	</div>
</a>



================================================
FILE: src/routes/privacy-policy/+page.svelte
================================================
<script lang="ts">
	import { socials } from '$lib/store';
</script>

<svelte:head>
	<title>BTC Map - Privacy Policy</title>
	<meta property="og:image" content="https://btcmap.org/images/og/home.png" />
	<meta property="twitter:title" content="BTC Map - Privacy Policy" />
	<meta property="twitter:image" content="https://btcmap.org/images/og/home.png" />
</svelte:head>

<main class="mt-10 mb-20 space-y-10">
	<div class="space-y-5 text-xl text-body dark:text-white">
		<h1 class="text-4xl !leading-tight font-semibold text-primary md:text-5xl dark:text-white">
			Privacy Policy
		</h1>
		<p>
			We <strong>do not</strong> collect your personal information.
		</p>
		<p>Please read further for more details.</p>
	</div>

	<div class="space-y-5 text-xl text-body dark:text-white">
		<h2 class="text-3xl font-semibold text-primary dark:text-white">Forms</h2>
		<p>What happens when you submit a form on our website:</p>
		<ol class="ml-5 list-decimal space-y-2">
			<li>
				An issue is automatically created in our self-hosted <a
					href="https://gitea.btcmap.org/teambtcmap/btcmap-data/issues/"
					class="text-link transition-colors hover:text-hover">btcmap-data</a
				> repo containing the form information.
			</li>
			<li>
				A message is automatically sent to our <a
					href="https://matrix.to/#/#btcmap:matrix.org"
					class="text-link transition-colors hover:text-hover">Matrix Space</a
				> .
			</li>
			<li>
				If the submission is valid, it is added to <a
					href="https://www.openstreetmap.org"
					class="text-link transition-colors hover:text-hover">OpenStreetMap</a
				> by a BTC Map contributor and will appear in our apps.
			</li>
			<li>
				Some information including communities is not stored on OpenStreetMap but in the BTC Map
				database instead.
			</li>
		</ol>
		<p>
			Please refer to the privacy policies of each of these third parties to understand how your
			information is used there.
		</p>
		<ul class="ml-5 list-disc space-y-2">
			<li>
				<a
					href="https://docs.github.com/en/site-policy/privacy-policies/github-privacy-statement"
					class="text-link transition-colors hover:text-hover">GitHub Privacy Policy</a
				>
			</li>
			<li>
				<a href="https://discord.com/privacy" class="text-link transition-colors hover:text-hover"
					>Discord Privacy Policy</a
				>
			</li>
			<li>
				<a
					href="https://wiki.osmfoundation.org/wiki/Privacy_Policy"
					class="text-link transition-colors hover:text-hover">OpenStreetMap Privacy Policy</a
				>
			</li>
		</ul>
		<p>
			By submitting information through one of our forms you are agreeing that this information will
			be used publicly.
		</p>
		<p><strong>Do not</strong> submit any personal or private information.</p>
		<p>
			If you include an X handle, we may post about your submission from the
			<!-- eslint-disable-next-line svelte/no-navigation-without-resolve -->
			<a href={$socials.x} class="text-link transition-colors hover:text-hover">@btcmap</a>
			X account.
		</p>
	</div>

	<div class="space-y-5 text-xl text-body dark:text-white">
		<h2 class="text-3xl font-semibold text-primary dark:text-white">Analytics</h2>
		<p>
			We use privacy respecting analytics provided by <a
				href="https://www.netlify.com/"
				class="text-link transition-colors hover:text-hover"
			>
				Netlify
			</a>

			and a self-hosted instance of
			<a href="https://umami.is/" class="text-link transition-colors hover:text-hover"> Umami </a>
			in order to track usage statistics over time and improve the user experience.
		</p>
		<p>
			These analytics do not use any cookies or trackers. There is no personally identifiable
			information included. All of the data is anonymous and complies with the <a
				href="https://www.netlify.com/gdpr-ccpa/"
				class="text-link transition-colors hover:text-hover"
			>
				GDPR
			</a>.
		</p>
		<p>Below are some links to read more about Netlify Analytics:</p>
		<ul class="ml-5 list-disc space-y-2">
			<li>
				<a
					href="https://www.netlify.com/products/analytics/"
					class="text-link transition-colors hover:text-hover">Netlify Analytics</a
				>
			</li>
			<li>
				<a
					href="https://docs.netlify.com/monitor-sites/analytics/"
					class="text-link transition-colors hover:text-hover">Netlify Docs - Analytics</a
				>
			</li>
			<li>
				<a
					href="https://docs.netlify.com/monitor-sites/analytics/how-analytics-works/"
					class="text-link transition-colors hover:text-hover">Netlify Docs - How Analytics Works</a
				>
			</li>
		</ul>
	</div>

	<div class="space-y-5 text-xl text-body dark:text-white">
		<h2 class="text-3xl font-semibold text-primary dark:text-white">Cookies</h2>
		<p>We <strong>do not</strong> use cookies.</p>
	</div>

	<div class="space-y-5 text-xl text-body dark:text-white">
		<h2 class="text-3xl font-semibold text-primary dark:text-white">
			How to Protect Your IP Online
		</h2>
		<p>
			It is good practice to protect your public IP address when surfing the web. The two most
			common methods to do this are:
		</p>
		<ol class="ml-5 list-decimal space-y-2">
			<li>
				Use a VPN service like <a
					href="https://mullvad.net/en/"
					class="text-link transition-colors hover:text-hover">Mullvad</a
				>.
			</li>
			<li>
				Use <a
					href="https://www.torproject.org/"
					class="text-link transition-colors hover:text-hover">Tor</a
				> browser.
			</li>
		</ol>
	</div>

	<div class="space-y-5 text-xl text-body dark:text-white">
		<h2 class="text-3xl font-semibold text-primary dark:text-white">
			Changes to this Privacy Policy
		</h2>
		<p>This privacy policy was last updated: July 10, 2023.</p>
	</div>

	<div class="space-y-5 text-xl text-body dark:text-white">
		<h2 class="text-3xl font-semibold text-primary dark:text-white">Contact Us</h2>
		<p>
			If you have any questions or feedback about our privacy policy, please contact us at <a
				href="mailto:hello@btcmap.org"
				class="text-link transition-colors hover:text-hover"
			>
				hello@btcmap.org
			</a> or on any of our social platforms.
		</p>
	</div>
</main>



================================================
FILE: src/routes/report-outdated-info/+server.ts
================================================
import { redirect } from '@sveltejs/kit';

export async function GET() {
	redirect(301, `/verify-location`);
}



================================================
FILE: src/routes/support-us/+page.svelte
================================================
<script lang="ts">
	import CloseButton from '$components/CloseButton.svelte';
	import DonationOption from './components/DonationOption.svelte';
	import HeaderPlaceholder from '$components/layout/HeaderPlaceholder.svelte';
	import SupportSection from './components/SupportSection.svelte';
	import { BREAKPOINTS, QR_CODE_SIZE } from '$lib/constants';
	import { theme } from '$lib/store';
	import type { DonationType } from '$lib/types';
	import { detectTheme, warningToast } from '$lib/utils';
	import type { Action } from 'svelte/action';

	const onchain = 'bc1qt4g28vq480ec4ncl4h67qu4q4k2zel7xu0c2wg';
	const lnurlp = 'LNURL1DP68GURN8GHJ7CM0WFJJUCN5VDKKZUPWDAEXWTMVDE6HYMRS9ARKXVN4W5EQPSYZ34';

	let showQr = false;
	let network: DonationType;

	const showQrToggle = (type: DonationType) => {
		network = type;
		showQr = true;
	};

	const renderQr: Action<HTMLCanvasElement> = (node) => {
		import('qrcode')
			.then((QRCode) => {
				QRCode.default.toCanvas(
					node,
					network === 'Lightning' ? 'lightning:' + lnurlp : 'bitcoin:' + onchain,
					{
						width: window.innerWidth > BREAKPOINTS.md ? QR_CODE_SIZE.desktop : QR_CODE_SIZE.mobile
					},
					function (error: Error | null | undefined) {
						if (error) {
							warningToast('Could not generate QR, please try again or contact BTC Map.');
							console.error(error);
						}
					}
				);
			})
			.catch((error) => {
				warningToast('Could not load QR generator. Please try again.');
				console.error('Failed to load QRCode module:', error);
			});
	};

	const supporters = [
		{ url: 'https://coinos.io/', title: 'coinos', logo: 'coinos.svg', logoDark: 'coinos-dark.svg' },
		{ url: 'https://www.walletofsatoshi.com/', title: 'Wallet of Satoshi', logo: 'wos.png' },
		{ url: 'https://btccuracao.com/', title: 'BTC Curacao', logo: 'btccuracao.png' },
		{ url: 'https://geyser.fund/project/satsnfacts', title: 'Sats n Facts', logo: 'satsnfacts.png' }
	];
</script>

<svelte:head>
	<title>BTC Map - Support Us</title>
	<meta property="og:image" content="https://btcmap.org/images/og/support.png" />
	<meta property="twitter:title" content="BTC Map - Support Us" />
	<meta property="twitter:image" content="https://btcmap.org/images/og/support.png" />
</svelte:head>

<main class="my-10 space-y-10 text-center md:my-20">
	{#if typeof window !== 'undefined'}
		<h1
			class="{detectTheme() === 'dark' || $theme === 'dark'
				? 'text-white'
				: 'gradient'} text-4xl !leading-tight font-semibold md:text-5xl"
		>
			Help place bitcoin on the map.
		</h1>
	{:else}
		<HeaderPlaceholder />
	{/if}

	<h2 class="mx-auto w-full text-xl font-semibold text-primary lg:w-[800px] dark:text-white">
		BTCMap.org is a free and open source project (FOSS). We rely on donations and sponsorship to
		continue.

		<br /><br />
		We greatly appreciate all support.
	</h2>

	<section id="donate">
		{#if showQr}
			<div
				class="relative mx-auto flex h-[450px] w-full items-center justify-center rounded-xl bg-slate-100 drop-shadow-xl md:h-[380px] md:w-[475px] dark:bg-white/[0.15]"
			>
				<div class="space-y-5">
					<CloseButton
						position="absolute top-4 right-6"
						colors="text-link hover:text-hover"
						on:click={() => (showQr = false)}
					/>

					<!-- qr -->
					<!-- eslint-disable-next-line svelte/no-navigation-without-resolve -->
					<a href={network === 'Lightning' ? `lightning:${lnurlp}` : `bitcoin:${onchain}`}>
						<canvas
							use:renderQr
							class="mx-auto h-[200px] w-[200px] rounded-xl border-4 border-link transition-colors hover:border-hover sm:h-[256px] sm:w-[256px]"
						/>
					</a>

					<!-- cta -->
					<p class="text-center text-xl text-primary dark:text-white">
						Scan or click to donate <br class="block md:hidden" /><strong class="lowercase"
							>{network}</strong
						>
						<img
							src={network === 'Lightning' ? '/icons/ln-highlight.svg' : '/icons/btc-highlight.svg'}
							alt="protocol"
							class="mb-1 inline dark:rounded-full dark:bg-white dark:p-0.5"
						/>
					</p>
				</div>
			</div>
		{:else}
			<div class="space-y-5">
				<!-- onchain -->
				<DonationOption value={onchain} text="On-chain" {showQrToggle} />
				<!-- lightning -->
				<DonationOption value={lnurlp} text="Lightning" {showQrToggle} />
			</div>
		{/if}
	</section>

	<section id="supporters">
		<h2 class="text-xl font-semibold text-primary uppercase dark:text-white">
			Our amazing supporters
		</h2>
		<a href="mailto:hello@btcmap.org" class="text-link transition-colors hover:text-hover"
			>Become a Sponsor</a
		>

		<SupportSection {supporters} placeholders={2} />
	</section>

	<section id="node">
		<!-- channel -->
		<div>
			<h3 class="text-lg font-semibold text-body uppercase dark:text-white">
				Open a lightning channel to us
			</h3>
			<a
				href="https://amboss.space/node/03ef01535d57cd3a3ddff8b4050650b278991b3eb7853f772a200079b9adb24988"
				target="_blank"
				rel="noreferrer"
				class="break-all text-link transition-colors hover:text-hover"
				>03ef01535d57cd3a3ddff8b4050650b278991b3eb7853f772a200079b9adb24988</a
			>
		</div>
	</section>
</main>



================================================
FILE: src/routes/support-us/components/DonationOption.svelte
================================================
<script lang="ts">
	import CopyButton from '$components/CopyButton.svelte';
	import Icon from '$components/Icon.svelte';
	import type { DonationType } from '$lib/types';

	export let value: string;
	export let text: DonationType;
	export let showQrToggle: (type: DonationType) => void;
</script>

<div>
	<h3 class="hidden text-lg text-body uppercase md:block dark:text-white">
		{text}
		<img
			src={text === 'Lightning' ? '/icons/ln-highlight.svg' : '/icons/btc-highlight.svg'}
			alt="protocol"
			class="mb-1 inline dark:rounded-full dark:bg-white dark:p-0.5"
		/>
	</h3>
	<div
		class="mx-auto flex w-full items-center justify-between rounded-xl bg-slate-100 px-4 py-4 text-body md:w-[475px] md:justify-center md:space-x-4 md:px-0 md:py-3 dark:bg-white/[0.15] dark:text-white"
	>
		<!-- value -->
		<span class="hidden lowercase md:block">{value.slice(0, 39)}...</span>
		<span class="block uppercase md:hidden"
			>{text}
			<img
				src={text === 'Lightning' ? '/icons/ln-highlight.svg' : '/icons/btc-highlight.svg'}
				alt="protocol"
				class="mb-1 inline dark:rounded-full dark:bg-white dark:p-0.5"
			/>
		</span>

		<div class="space-x-4">
			<!-- qr button -->
			<button
				class="text-link transition-colors hover:text-hover"
				on:click={() => showQrToggle(text)}
			>
				<Icon type="fa" icon="qrcode" w="24" h="24" />
			</button>

			<!-- copy button -->
			<CopyButton {value} />
		</div>
	</div>
</div>



================================================
FILE: src/routes/support-us/components/SupportSection.svelte
================================================
<script lang="ts">
	export let supporters: { url: string; logoDark?: string; logo: string; title: string }[];
	export let placeholders: number;

	import { theme } from '$lib/store';
	import { detectTheme } from '$lib/utils';
</script>

<div class="mt-4">
	<div class="mx-auto w-full grid-cols-3 gap-10 space-y-10 lg:grid lg:w-[830px] lg:space-y-0">
		{#each supporters as supporter (supporter.url)}
			<!-- eslint-disable svelte/no-navigation-without-resolve -->

			<a
				href={supporter.url}
				target="_blank"
				rel="noreferrer"
				class="mx-auto block w-full self-center md:w-[250px]"
			>
				<!-- eslint-enable svelte/no-navigation-without-resolve -->

				{#if typeof window !== 'undefined'}
					<img
						src="/images/supporters/{supporter.logoDark
							? detectTheme() === 'dark' || $theme === 'dark'
								? supporter.logoDark
								: supporter.logo
							: supporter.logo}"
						alt={supporter.title}
						class="mx-auto w-[250px]"
					/>
				{/if}
			</a>
		{/each}
		{#each Array(placeholders) as _, index (index)}
			<div
				class="mx-auto flex h-[90px] w-full items-center justify-center self-center rounded-xl bg-supporter/50 drop-shadow-xl md:w-[250px]"
			>
				<a href="mailto:hello@btcmap.org" class="text-white uppercase">Apply here</a>
			</div>
		{/each}
	</div>
</div>



================================================
FILE: src/routes/tagger/[id]/+page.svelte
================================================
<script lang="ts">
	import type { PageData } from './$types';
	export let data: PageData;

	import { browser } from '$app/environment';
	import { goto } from '$app/navigation';
	import ProfileActivity from './components/ProfileActivity.svelte';
	import ProfileStat from '$components/ProfileStat.svelte';
	import Tip from '$components/Tip.svelte';
	import Icon from '$components/Icon.svelte';
	import {
		placesError,
		eventError,
		events,
		excludeLeader,
		places,
		userError,
		users
	} from '$lib/store';
	import {
		BadgeType,
		type ActivityEvent,
		type EarnedBadge,
		type ProfileLeaderboard
	} from '$lib/types.js';
	import { eventsSync } from '$lib/sync/events';
	import { usersSync } from '$lib/sync/users';
	import { batchSync } from '$lib/sync/batchSync';
	import { errToast, formatElementID } from '$lib/utils';
	import Chart from 'chart.js/auto';
	import { format } from 'date-fns/format';
	import DOMPurify from 'dompurify';
	import { marked } from 'marked';
	import { onMount } from 'svelte';

	// alert for user errors
	$: $userError && errToast($userError);
	// alert for event errors
	$: $eventError && errToast($eventError);
	// alert for element errors
	$: $placesError && errToast($placesError);

	let dataInitialized = false;
	let initialRenderComplete = false;

	let filteredDesc: string | undefined;
	let sanitizedMarkdown: string = '';

	const initializeData = async () => {
		if (dataInitialized) return;

		const userFound = $users.find((user) => user.id == data.user);
		if (!userFound) {
			console.error('Could not find user, please try again or contact BTC Map.');
			// eslint-disable-next-line svelte/no-navigation-without-resolve
			goto('/404');
			return;
		}
		userCreated = userFound['created_at'];
		supporter = Boolean(
			userFound.tags['supporter:expires'] &&
			Date.parse(userFound.tags['supporter:expires']) > Date.now()
		);
		const user = userFound['osm_json'];
		avatar = user.img ? user.img.href : '/images/satoshi-nakamoto.png';
		mappingSince = user['account_created'];
		const description = user.description;
		const removeLightning = description.match(/(\[âš¡]\(lightning:[^)]+\))/g);
		filteredDesc = removeLightning?.length
			? description.replaceAll(removeLightning[0], '')
			: description;
		const regexMatch = description.match('(lightning:[^)]+)');
		lightning = regexMatch && regexMatch[0].slice(10);

		const userEvents = $events.filter((event) => event['user_id'] == user.id);
		userEvents.sort((a, b) => Date.parse(b['created_at']) - Date.parse(a['created_at']));
		created =
			user.id === 17221642
				? userEvents.filter((event) => event.type === 'create').length + 100
				: userEvents.filter((event) => event.type === 'create').length;
		updated =
			user.id === 17221642
				? userEvents.filter((event) => event.type === 'update').length + 20
				: userEvents.filter((event) => event.type === 'update').length;
		deleted = userEvents.filter((event) => event.type === 'delete').length;
		total = created + updated + deleted;

		const populateLeaderboard = () => {
			$users.forEach((user) => {
				if ($excludeLeader.includes(user.id)) {
					return;
				}

				let userEvents = $events.filter((event) => event['user_id'] == user.id);

				if (userEvents.length) {
					leaderboard.push({
						id: user.id,
						total: user.id === 17221642 ? userEvents.length + 120 : userEvents.length
					});
				}
			});

			leaderboard.sort((a, b) => b.total - a.total);
			leaderboard = leaderboard.slice(0, 10);
		};
		populateLeaderboard();

		const badges = [
			{
				check: [
					10396321, 17441326, 17199501, 668096, 17462838, 17221642, 5432507, 17354902, 18452174,
					18360665, 616774, 18062435, 7522075, 18380975, 1697546, 19288099, 11903494, 18552145,
					1836965, 19795869, 17872, 19768735, 17573979, 2929493, 19714509, 1851550, 18244560,
					19756689, 527105, 2339960, 17322349, 17300693, 1236325, 1787080
				].includes(user.id),
				title: 'Geyser Tournament',
				icon: 'geyser',
				type: BadgeType.Achievement
			},
			{ check: supporter, title: 'Supporter', icon: 'supporter', type: BadgeType.Achievement },
			{
				check: leaderboard[0].id == user.id,
				title: 'Top Tagger',
				icon: 'top-tagger',
				type: BadgeType.Achievement
			},
			{
				check: Boolean(leaderboard.slice(0, 3).find((item) => item.id == user.id)),
				title: 'Podium',
				icon: 'podium',
				type: BadgeType.Achievement
			},
			{
				check: Boolean(leaderboard.find((item) => item.id == user.id)),
				title: 'High Rank',
				icon: 'high-rank',
				type: BadgeType.Achievement
			},
			{
				check: Date.parse(userCreated) < new Date('December 26, 2022 00:00:00').getTime(),
				title: 'OG Supertagger',
				icon: 'og-supertagger',
				type: BadgeType.Achievement
			},
			{
				check: Boolean(lightning),
				title: 'Lightning Junkie',
				icon: 'lightning-junkie',
				type: BadgeType.Achievement
			},
			{
				check: Boolean(user.img),
				title: 'Hello World',
				icon: 'hello-world',
				type: BadgeType.Achievement
			},
			{
				check: created > updated && created > deleted,
				title: 'Creator',
				icon: 'creator',
				type: BadgeType.Achievement
			},
			{
				check: updated > created && updated > deleted,
				title: 'Update Maxi',
				icon: 'update-maxi',
				type: BadgeType.Achievement
			},
			{
				check: deleted > created && deleted > updated,
				title: 'Demolition Specialist',
				icon: 'demolition-specialist',
				type: BadgeType.Achievement
			},
			{
				check: total >= 21000000,
				title: 'Hyperbitcoinisation',
				icon: 'hyperbitcoinisation',
				type: BadgeType.Contribution
			},
			{
				check: total >= 10000,
				title: 'Pizza Time',
				icon: 'pizza-time',
				type: BadgeType.Contribution
			},
			{ check: total >= 7777, title: 'Godly', icon: 'godly', type: BadgeType.Contribution },
			{ check: total >= 5000, title: 'Shadow', icon: 'shadow', type: BadgeType.Contribution },
			{
				check: total >= 3110,
				title: 'Whitepaper',
				icon: 'whitepaper',
				type: BadgeType.Contribution
			},
			{ check: total >= 1984, title: 'Winston', icon: 'winston', type: BadgeType.Contribution },
			{ check: total >= 1000, title: 'Whale', icon: 'whale', type: BadgeType.Contribution },
			{ check: total >= 821, title: 'Infinity', icon: 'infinity', type: BadgeType.Contribution },
			{ check: total >= 500, title: 'Legend', icon: 'legend', type: BadgeType.Contribution },
			{
				check: total >= 301,
				title: 'Chancellor',
				icon: 'chancellor',
				type: BadgeType.Contribution
			},
			{ check: total >= 256, title: 'SHA', icon: 'sha', type: BadgeType.Contribution },
			{
				check: total >= 210,
				title: 'No Bailouts',
				icon: 'no-bailouts',
				type: BadgeType.Contribution
			},
			{
				check: total >= 100,
				title: 'Supertagger',
				icon: 'supertagger',
				type: BadgeType.Contribution
			},
			{ check: total >= 69, title: 'ATH', icon: 'ath', type: BadgeType.Contribution },
			{
				check: total >= 51,
				title: 'Longest Chain',
				icon: 'longest-chain',
				type: BadgeType.Contribution
			},
			{ check: total >= 21, title: 'Satoshi', icon: 'satoshi', type: BadgeType.Contribution },
			{ check: total >= 10, title: 'Heartbeat', icon: 'heartbeat', type: BadgeType.Contribution },
			{ check: total >= 4, title: 'Segwit', icon: 'segwit', type: BadgeType.Contribution },
			{
				check: total >= 1,
				title: 'Whole Tagger',
				icon: 'whole-tagger',
				type: BadgeType.Contribution
			}
		];

		const addBadge = (check: boolean, title: string, icon: string, type: BadgeType) => {
			if (check) {
				earnedBadges.push({ title, icon, type });
			}
		};

		badges.some((badge) => {
			if (earnedBadges.find((badge) => badge.type === BadgeType.Contribution)) {
				return true;
			}
			addBadge(Boolean(badge.check), badge.title, badge.icon, badge.type);
		});

		createdPercent = new Intl.NumberFormat('en-US').format(
			Number((created / (total / 100)).toFixed(0))
		);

		updatedPercent = new Intl.NumberFormat('en-US').format(
			Number((updated / (total / 100)).toFixed(0))
		);

		deletedPercent = new Intl.NumberFormat('en-US').format(
			Number((deleted / (total / 100)).toFixed(0))
		);

		// Create activity events without fetching element data - names will be fetched on-demand
		eventElements = userEvents.map((event) => {
			return {
				...event,
				location: formatElementID(event.element_id), // Will be updated with actual names on-demand
				merchantId: event.element_id
			};
		});

		// add markdown support for profile description
		const markdown = await marked.parse(filteredDesc || '');
		sanitizedMarkdown = DOMPurify.sanitize(markdown);

		const setupChart = () => {
			tagTypeChart = new Chart(tagTypeChartCanvas, {
				type: 'pie',
				data: {
					labels: ['Created', 'Updated', 'Deleted'],
					datasets: [
						{
							label: 'Tag Types',
							data: [created, updated, deleted],
							backgroundColor: ['rgb(16, 183, 145)', 'rgb(0, 153, 175)', 'rgb(235, 87, 87)'],
							hoverOffset: 4
						}
					]
				},
				options: {
					maintainAspectRatio: false,
					plugins: {
						legend: {
							labels: {
								font: {
									weight: 600
								}
							}
						}
					}
				}
			});
		};
		setupChart();

		// eslint-disable-next-line svelte/infinite-reactive-loop
		dataInitialized = true;
	};

	$: $users &&
		$users.length &&
		$events &&
		$events.length &&
		$places &&
		$places.length &&
		initialRenderComplete &&
		!dataInitialized &&
		// eslint-disable-next-line svelte/infinite-reactive-loop
		initializeData();

	let userCreated: string | undefined;
	let supporter: boolean | undefined;
	let avatar: string | undefined;
	let mappingSince: string | undefined;
	let username = data.username;

	let lightning: string | null;

	let created: number | undefined;
	let updated: number | undefined;
	let deleted: number | undefined;
	let total: number | undefined;

	let leaderboard: ProfileLeaderboard[] = [];

	let earnedBadges: EarnedBadge[] = [];

	let createdPercent: string | undefined;
	let updatedPercent: string | undefined;
	let deletedPercent: string | undefined;

	let tagTypeChartCanvas: HTMLCanvasElement;
	// eslint-disable-next-line @typescript-eslint/no-unused-vars
	let tagTypeChart;

	let eventElements: ActivityEvent[] = [];

	let loadingNames = false;
	let nameCache: Record<string, string> = {};

	// Fetch place names for current page
	const fetchPageNames = async (events: ActivityEvent[]) => {
		if (loadingNames) return;
		loadingNames = true;

		const uniqueIds = [...new Set(events.map((event) => event.element_id))];
		const idsToFetch = uniqueIds.filter((id) => !nameCache[id]);

		if (idsToFetch.length > 0) {
			const promises = idsToFetch.map(async (id) => {
				try {
					const response = await fetch(`https://api.btcmap.org/v4/places/${id}?fields=name`);
					if (response.ok) {
						const data = await response.json();
						return { id, name: data.name || formatElementID(id) };
					}
					return { id, name: formatElementID(id) };
				} catch (error) {
					console.warn(`Failed to fetch name for ${id}:`, error);
					return { id, name: formatElementID(id) };
				}
			});

			const results = await Promise.all(promises);
			results.forEach(({ id, name }) => {
				nameCache[id] = name;
			});

			// Update eventElements with new names
			eventElements = eventElements.map((event) => ({
				...event,
				location: nameCache[event.element_id] || event.location
			}));
		}

		loadingNames = false;
	};

	const handleFetchNames = (data: { events: ActivityEvent[] }) => {
		fetchPageNames(data.events);
	};

	onMount(async () => {
		batchSync([eventsSync, usersSync]);

		if (browser) {
			// setup chart
			tagTypeChartCanvas.getContext('2d');

			initialRenderComplete = true;
		}
	});
</script>

<svelte:head>
	<title>{username ? username + ' - ' : ''}BTC Map Supertagger</title>
	<meta property="og:image" content="https://btcmap.org/images/og/supertagger.png" />
	<meta property="twitter:title" content="{username ? username + ' - ' : ''}BTC Map Supertagger" />
	<meta property="twitter:image" content="https://btcmap.org/images/og/supertagger.png" />
</svelte:head>

<main class="my-10 text-center md:my-20">
	<section id="profile" class="space-y-8">
		{#if avatar}
			<img
				src={avatar}
				alt="avatar"
				class="mx-auto h-32 w-32 rounded-full object-cover"
				on:error={function () {
					this.src = '/images/satoshi-nakamoto.png';
				}}
			/>
		{:else}
			<div class="mx-auto h-32 w-32 animate-pulse rounded-full bg-link/50" />
		{/if}

		<div class="space-y-1">
			<h1 class="text-4xl !leading-tight font-semibold text-primary dark:text-white">
				{username || 'BTC Map Supertagger'}
			</h1>
			<p class="flex items-center justify-center space-x-1 text-sm text-primary dark:text-white">
				<Icon type="fa" icon="map-pin" w="16" h="16" />
				<span class="block">
					Mapping Since: {mappingSince ? format(new Date(mappingSince), 'yyyy-MM-dd') : '-'}
				</span>
			</p>
			{#if username}
				<a
					href="https://www.openstreetmap.org/user/{username}"
					target="_blank"
					rel="noreferrer"
					class="mx-auto flex w-24 items-center justify-center text-xs text-link transition-colors hover:text-hover"
					>OSM Profile <svg
						class="ml-1 w-3"
						width="16"
						height="16"
						viewBox="0 0 16 16"
						fill="none"
						xmlns="http://www.w3.org/2000/svg"
					>
						<path
							d="M3 13L13 3M13 3H5.5M13 3V10.5"
							stroke="currentColor"
							stroke-width="1.5"
							stroke-linecap="round"
							stroke-linejoin="round"
						/>
					</svg></a
				>
			{/if}
		</div>

		<h2 class="mx-auto w-full text-xl break-all text-body lg:w-[800px] dark:text-white">
			<!-- eslint-disable-next-line svelte/no-at-html-tags - we even sanitize the captcha content above -->
			{@html sanitizedMarkdown}
		</h2>

		{#if lightning}
			<Tip destination={lightning} user={username} />
		{/if}
	</section>

	<section id="badges" class="mt-16">
		<div class="flex flex-wrap items-center justify-center">
			{#if dataInitialized}
				{#each earnedBadges as badge (badge.title)}
					<!-- eslint-disable-next-line svelte/no-navigation-without-resolve -->
					<a href="/badges#{badge.icon}" class="transition-transform hover:scale-110">
						<div class="mx-3 mb-6">
							<img
								src="/icons/badges/{badge.icon}.svg"
								alt={badge.title}
								class="mx-auto mb-1 h-24 w-24"
							/>
							<p class="text-center text-sm dark:text-white">{badge.title}</p>
						</div>
					</a>
				{/each}
			{:else}
				{#each Array(3) as _, i (i)}
					<div class="mx-3 mb-6">
						<div class="mx-auto mb-1 h-24 w-24 animate-pulse rounded-full bg-link/50" />
						<div class="mx-auto h-5 w-20 animate-pulse rounded bg-link/50" />
					</div>
				{/each}
			{/if}
		</div>
	</section>

	<section id="stats" class="mt-10 mb-16">
		<div
			class="grid rounded-t-3xl border border-gray-300 md:grid-cols-2 xl:grid-cols-4 dark:border-white/95 dark:bg-white/10"
		>
			<ProfileStat
				title="Total Tags"
				stat={total}
				border="border-b xl:border-b-0 md:border-r border-gray-300 dark:border-white/95"
			/>
			<ProfileStat
				title="Created"
				stat={created}
				percent={createdPercent}
				border="border-b xl:border-b-0 xl:border-r border-gray-300 dark:border-white/95"
			/>
			<ProfileStat
				title="Updated"
				stat={updated}
				percent={updatedPercent}
				border="border-b md:border-b-0 md:border-r border-gray-300 dark:border-white/95"
			/>
			<ProfileStat title="Deleted" stat={deleted} percent={deletedPercent} />
		</div>

		<div
			class="relative rounded-b-3xl border border-t border-gray-300 p-5 dark:border-white/95 dark:bg-white/10"
		>
			{#if !dataInitialized}
				<div>
					<Icon
						type="fa"
						icon="chart-pie"
						w="208"
						h="208"
						class="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 animate-pulse text-link/50"
					/>
				</div>
			{/if}

			<canvas bind:this={tagTypeChartCanvas} width="100%" height="250" />
		</div>
	</section>

	<section id="activity" class="my-16">
		<ProfileActivity
			{eventElements}
			{username}
			{dataInitialized}
			{loadingNames}
			onfetchNames={handleFetchNames}
		/>
	</section>
</main>



================================================
FILE: src/routes/tagger/[id]/+page.ts
================================================
import { error } from '@sveltejs/kit';
import axios from 'axios';
import axiosRetry from 'axios-retry';
import type { PageLoad } from './$types';

axiosRetry(axios, { retries: 3, retryDelay: axiosRetry.exponentialDelay });

export const load: PageLoad = async ({ params }) => {
	const { id } = params;
	try {
		const response = await axios.get(`https://api.btcmap.org/v2/users/${id}`);

		const data = response.data;

		if (data) {
			return { user: data.id, username: data['osm_json']['display_name'] };
		}
	} catch (err) {
		console.error(err);
		error(404, 'User Not Found');
	}
};



================================================
FILE: src/routes/tagger/[id]/components/ProfileActivity.svelte
================================================
<script lang="ts">
	import type { ActivityEvent } from '$lib/types';
	import { format } from 'date-fns/format';
	import { resolve } from '$app/paths';
	import LeaderboardSearch from '$components/leaderboard/LeaderboardSearch.svelte';
	import LeaderboardPagination from '$components/leaderboard/LeaderboardPagination.svelte';
	import {
		createSvelteTable,
		getCoreRowModel,
		getFilteredRowModel,
		getPaginationRowModel,
		getSortedRowModel,
		type ColumnDef,
		type FilterFn,
		type OnChangeFn,
		type PaginationState,
		type SortingState,
		type TableOptions
	} from '@tanstack/svelte-table';
	import { rankItem } from '@tanstack/match-sorter-utils';
	import { writable } from 'svelte/store';
	import { debounce } from '$lib/utils';

	export let eventElements: ActivityEvent[] = [];
	export let username: string;
	export let dataInitialized: boolean = false;
	export let loadingNames: boolean = false;
	export let onfetchNames: (data: { events: ActivityEvent[] }) => void = () => {};

	const pageSizes = [10, 20, 30, 40, 50];
	let globalFilter = '';

	const fuzzyFilter: FilterFn<ActivityEvent> = (row, columnId, value, addMeta) => {
		const itemRank = rankItem(row.getValue(columnId), value);
		addMeta?.({ itemRank });
		return itemRank.passed;
	};

	const columns: ColumnDef<ActivityEvent>[] = [
		{
			id: 'location',
			header: 'Location',
			accessorFn: (row) => row.location,
			enableSorting: false,
			filterFn: fuzzyFilter,
			enableGlobalFilter: true
		},
		{
			id: 'type',
			header: 'Action',
			accessorFn: (row) => row.type,
			enableSorting: true,
			filterFn: fuzzyFilter,
			enableGlobalFilter: true
		},
		{
			id: 'created_at',
			header: 'Date',
			accessorFn: (row) => row.created_at,
			enableSorting: true,
			filterFn: fuzzyFilter,
			enableGlobalFilter: true
		}
	];

	let sorting: SortingState = [{ id: 'created_at', desc: true }];
	let pagination: PaginationState = {
		pageIndex: 0,
		pageSize: pageSizes[0]
	};

	const setSorting: OnChangeFn<SortingState> = (updater) => {
		sorting = updater instanceof Function ? updater(sorting) : updater;
		options.update((old) => ({
			...old,
			state: {
				...old.state,
				sorting
			}
		}));
	};

	const setPagination: OnChangeFn<PaginationState> = (updater) => {
		pagination = updater instanceof Function ? updater(pagination) : updater;
		options.update((old) => ({
			...old,
			state: {
				...old.state,
				pagination
			}
		}));
	};

	const options = writable<TableOptions<ActivityEvent>>({
		data: eventElements,
		columns,
		state: {
			sorting,
			pagination
		},
		onSortingChange: setSorting,
		onPaginationChange: setPagination,
		globalFilterFn: fuzzyFilter,
		getCoreRowModel: getCoreRowModel(),
		getSortedRowModel: getSortedRowModel(),
		getPaginationRowModel: getPaginationRowModel(),
		getFilteredRowModel: getFilteredRowModel()
	});

	const table = createSvelteTable(options);

	$: options.update((current) => ({
		...current,
		data: eventElements
	}));

	const fetchPageNames = (events: ActivityEvent[]) => {
		if (loadingNames) return;

		onfetchNames({ events });
	};

	$: if ($table.getRowModel().rows.length > 0 && dataInitialized) {
		const currentPageEvents = $table.getRowModel().rows.map((row) => row.original);
		fetchPageNames(currentPageEvents);
	}

	const handleKeyUp = (e: KeyboardEvent) => {
		$table?.setGlobalFilter(String((e.target as HTMLInputElement)?.value));
	};

	const searchDebounce = debounce((e) => handleKeyUp(e));
</script>

<div class="w-full rounded-3xl border border-gray-300 dark:border-white/95 dark:bg-white/10">
	<h3
		class="border-b border-gray-300 p-5 text-center text-lg font-semibold text-primary md:text-left dark:border-white/95 dark:text-white"
	>
		{username || 'BTC Map Supertagger'}'s Activity
	</h3>

	{#if eventElements && eventElements.length && dataInitialized}
		<div class="p-5">
			<LeaderboardSearch table={$table} bind:globalFilter {searchDebounce} />
		</div>

		{#if $table.getFilteredRowModel().rows.length === 0}
			<p class="w-full p-5 text-center text-primary dark:text-white">No results found.</p>
		{:else}
			<div class="overflow-x-auto">
				<table class="w-full">
					<thead>
						{#each $table.getHeaderGroups() as headerGroup (headerGroup.id)}
							<tr class="border-b border-gray-300 text-left dark:border-white/95">
								{#each headerGroup.headers as header (header.id)}
									<th
										colSpan={header.colSpan}
										class="px-5 py-3 text-left text-sm font-semibold text-primary dark:text-white {header
											.column.id === 'location'
											? 'w-2/3'
											: 'w-1/6'}"
										aria-sort={header.column.getIsSorted() === 'asc'
											? 'ascending'
											: header.column.getIsSorted() === 'desc'
												? 'descending'
												: 'none'}
									>
										{#if !header.isPlaceholder}
											<button
												type="button"
												class="flex items-center gap-x-1 leading-tight select-none"
												class:cursor-pointer={header.column.getCanSort()}
												on:click={header.column.getToggleSortingHandler()}
												on:keydown={(e) => {
													if (e.key === 'Enter' || e.key === ' ') {
														e.preventDefault();
														header.column.getToggleSortingHandler()?.(e);
													}
												}}
												tabindex={header.column.getCanSort() ? 0 : -1}
												aria-label={header.column.getCanSort()
													? 'Sort by ' +
														String(header.column.columnDef.header) +
														', currently ' +
														(header.column.getIsSorted() === 'asc'
															? 'ascending'
															: header.column.getIsSorted() === 'desc'
																? 'descending'
																: 'unsorted')
													: String(header.column.columnDef.header)}
											>
												<span class="break-words">
													{String(header.column.columnDef.header)}
												</span>
												{#if header.column.getIsSorted().toString() === 'asc'}
													<span aria-hidden="true">â–²</span>
												{:else if header.column.getIsSorted().toString() === 'desc'}
													<span aria-hidden="true">â–¼</span>
												{/if}
											</button>
										{/if}
									</th>
								{/each}
							</tr>
						{/each}
					</thead>
					<tbody>
						{#if loadingNames}
							<!-- Show loading skeleton rows while fetching names -->
							{#each Array($table.getState().pagination.pageSize) as _, i (i)}
								<tr class="border-b border-gray-300/50 dark:border-white/50">
									<td class="w-2/3 px-5 py-3">
										<div class="h-6 animate-pulse rounded bg-link/20"></div>
									</td>
									<td class="w-1/6 px-5 py-3">
										<div class="h-6 animate-pulse rounded bg-link/20"></div>
									</td>
									<td class="w-1/6 px-5 py-3">
										<div class="h-6 animate-pulse rounded bg-link/20"></div>
									</td>
								</tr>
							{/each}
						{:else}
							{#each $table.getRowModel().rows as row, _ (row.id)}
								<tr
									class="border-b border-gray-300/50 hover:bg-gray-50 dark:border-white/50 dark:hover:bg-white/5"
								>
									{#each row.getVisibleCells() as cell (cell.id)}
										<td
											class="px-5 py-3 text-left text-sm text-body dark:text-white {cell.column
												.id === 'location'
												? 'w-2/3'
												: 'w-1/6'}"
										>
											{#if cell.column.id === 'location'}
												<a
													href={resolve(`/merchant/${row.original.merchantId}`)}
													class="text-link transition-colors hover:text-hover"
												>
													{row.original.location}
												</a>
											{:else if cell.column.id === 'type'}
												<span
													class="inline-flex items-center rounded-full px-2 py-1 text-xs font-medium
												{row.original.type === 'create'
														? 'bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200'
														: row.original.type === 'update'
															? 'bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-200'
															: 'bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-200'}"
												>
													{row.original.type}
												</span>
											{:else}
												{format(new Date(row.original.created_at), 'MMM d, yyyy HH:mm')}
											{/if}
										</td>
									{/each}
								</tr>
							{/each}
						{/if}
					</tbody>
				</table>
			</div>

			<LeaderboardPagination table={$table} {pageSizes} />
		{/if}
	{:else}
		<div class="p-5">
			{#each Array(10) as _, i (i)}
				<div class="mb-3 animate-pulse">
					<div class="flex space-x-4">
						<div class="h-4 w-2/3 rounded bg-link/20"></div>
						<div class="h-4 w-1/6 rounded bg-link/20"></div>
						<div class="h-4 w-1/6 rounded bg-link/20"></div>
					</div>
				</div>
			{/each}
		</div>
	{/if}
</div>



================================================
FILE: src/routes/tagging-issues/+page.server.ts
================================================
import type { PageServerLoad } from './$types';

export const load: PageServerLoad = async () => {
	try {
		const response = await fetch('https://api.btcmap.org/rpc', {
			method: 'POST',
			headers: {
				'Content-Type': 'application/json'
			},
			body: JSON.stringify({
				jsonrpc: '2.0',
				id: 1,
				method: 'get_element_issues',
				params: {
					area_id: 662,
					limit: 10_000,
					offset: 0
				}
			})
		});

		const data = await response.json();

		if (data.error) {
			const errorMessage = data.error.message || 'RPC Error';
			const errorDetails = data.error.data ? `: ${JSON.stringify(data.error.data)}` : '';
			return {
				error: errorMessage + errorDetails,
				rpcResult: null
			};
		}
		return {
			rpcResult: data.result
		};
	} catch (err) {
		return {
			error: err instanceof Error ? err.message : 'Failed to load element issues',
			rpcResult: null
		};
	}
};



================================================
FILE: src/routes/tagging-issues/+page.svelte
================================================
<script lang="ts">
	import HeaderPlaceholder from '$components/layout/HeaderPlaceholder.svelte';
	import IssuesTable from '$components/IssuesTable.svelte';
	import { theme } from '$lib/store';
	import { detectTheme } from '$lib/utils';
	import type { RpcIssue } from '$lib/types';

	export let data;
	let issues: RpcIssue[] = data.rpcResult.requested_issues;
</script>

<svelte:head>
	<title>BTC Map - Tagging Issues</title>
	<meta property="og:image" content="https://btcmap.org/images/og/home.png" />
	<meta property="twitter:title" content="BTC Map - Tagging Issues" />
	<meta property="twitter:image" content="https://btcmap.org/images/og/home.png" />
</svelte:head>

<main class="mt-10 mb-20 space-y-10">
	{#if typeof window !== 'undefined'}
		<h1
			class="{detectTheme() === 'dark' || $theme === 'dark'
				? 'text-white'
				: 'gradient'} text-center text-4xl !leading-tight font-semibold md:text-5xl lg:text-left"
		>
			Tagging Issues
		</h1>
	{:else}
		<HeaderPlaceholder />
	{/if}

	<h2
		class="w-full text-center text-xl font-semibold text-primary lg:w-[675px] lg:text-left dark:text-white"
	>
		Contribute to THE map by resolving tagging issues!
	</h2>

	<p class="text-center text-xl text-primary lg:text-left dark:text-white">
		More information about how to get involved can be found on our <a
			href="https://gitea.btcmap.org/teambtcmap/btcmap-general/wiki/Tagging-Merchants"
			class="text-link transition-colors hover:text-hover">Tagging Instructions</a
		>
		Wiki page.
	</p>
	<IssuesTable title="Global Issues" {issues} loading={false} initialPageSize={50} />
</main>



================================================
FILE: src/routes/tickets/+page.server.ts
================================================
import { getIssues } from '$lib/gitea';
import type { PageServerLoad } from './$types';

export const load: PageServerLoad = async () => {
	try {
		const { issues, totalCount } = await getIssues();
		return {
			tickets: issues,
			totalTickets: totalCount
		};
	} catch (error) {
		console.error('Failed to fetch issues:', error);
		return {
			error: 'Could not load tickets',
			tickets: [],
			totalTickets: 0
		};
	}
};



================================================
FILE: src/routes/tickets/+page.svelte
================================================
<script lang="ts">
	import HeaderPlaceholder from '$components/layout/HeaderPlaceholder.svelte';
	import OpenTicket from '$components/OpenTicket.svelte';
	import OpenTicketSkeleton from './components/OpenTicketSkeleton.svelte';
	import TopButton from '$components/TopButton.svelte';
	import { theme } from '$lib/store';
	import { detectTheme, errToast } from '$lib/utils';
	import type { GiteaLabel } from '$lib/types';

	const ticketTypes = ['Add', 'Verify', 'Community'];
	let showType = 'Add';

	export let data;

	$: tickets = data.tickets;

	$: add =
		tickets?.filter((issue) =>
			issue?.labels?.some((label: GiteaLabel) => label?.name === 'location-submission')
		) || [];
	$: verify =
		tickets?.filter((issue) =>
			issue?.labels?.some((label: GiteaLabel) => label?.name === 'location-verification')
		) || [];
	$: community =
		tickets?.filter((issue) =>
			issue?.labels?.some((label: GiteaLabel) => label?.name === 'community-submission')
		) || [];

	let totalTickets = data.totalTickets;

	if (data.error) {
		errToast(data.error);
	}
</script>

<svelte:head>
	<title>BTC Map - Open Tickets</title>
	<meta property="og:image" content="https://btcmap.org/images/og/home.png" />
	<meta property="twitter:title" content="BTC Map - Open Tickets" />
	<meta property="twitter:image" content="https://btcmap.org/images/og/home.png" />
</svelte:head>

<main class="mt-10 mb-20 space-y-10">
	{#if typeof window !== 'undefined'}
		<h1
			class="{detectTheme() === 'dark' || $theme === 'dark'
				? 'text-white'
				: 'gradient'} text-center text-4xl !leading-tight font-semibold md:text-5xl lg:text-left"
		>
			Open Tickets
			{#if totalTickets}
				<span class="text-3xl">({totalTickets})</span>
			{/if}
		</h1>
	{:else}
		<HeaderPlaceholder />
	{/if}

	<h2
		class="w-full text-center text-xl font-semibold text-primary lg:w-[675px] lg:text-left dark:text-white"
	>
		Tickets up for grabs from our noob forms! Anyone can help add or verify location submissions and
		help vet communities.
	</h2>

	<p class="text-center text-xl text-primary lg:text-left dark:text-white">
		More information on how to get involved can be found in our <a
			href="https://gitea.btcmap.org/teambtcmap/btcmap-general/wiki/Tagging-Merchants#shadowy-supertaggers"
			class="text-link transition-colors hover:text-hover">Tagging Merchant Instructions</a
		>.
	</p>

	<section id="tickets">
		<div class="w-full rounded-3xl border border-gray-300 dark:border-white/95 dark:bg-white/10">
			<div class="p-5 text-center text-2xl font-semibold text-primary dark:text-white">
				{#each ticketTypes as type (type)}
					<button
						class="mx-auto block w-40 border border-link py-2 md:inline {type === 'Add'
							? 'rounded-t md:rounded-l md:rounded-tr-none'
							: type === 'Community'
								? 'rounded-b md:rounded-r md:rounded-bl-none'
								: ''} {showType === type ? 'bg-link text-white' : ''} transition-colors"
						on:click={() => (showType = type)}>{type}</button
					>
				{/each}
			</div>

			{#if tickets && tickets.length}
				{#if showType === 'Add'}
					{#if add.length}
						{#each add as ticket (ticket.number)}
							<OpenTicket
								assignees={ticket.assignees}
								comments={ticket.comments}
								created={ticket.created_at}
								url={ticket.html_url}
								labels={ticket.labels}
								id={ticket.number}
								name={ticket.title}
								user={ticket.user}
							/>
						{/each}
					{:else}
						<p
							class="border-t border-gray-300 p-5 text-center text-body dark:border-white/95 dark:text-white"
						>
							No open <strong>add</strong> tickets.
						</p>
					{/if}
				{:else if showType === 'Verify'}
					{#if verify.length}
						{#each verify as ticket (ticket.number)}
							<OpenTicket
								assignees={ticket.assignees}
								comments={ticket.comments}
								created={ticket.created_at}
								url={ticket.html_url}
								labels={ticket.labels}
								id={ticket.number}
								name={ticket.title}
								user={ticket.user}
							/>
						{/each}
					{:else}
						<p
							class="border-t border-gray-300 p-5 text-center text-body dark:border-white/95 dark:text-white"
						>
							No open <strong>verify</strong> tickets.
						</p>
					{/if}
				{:else if showType === 'Community'}
					{#if community.length}
						{#each community as ticket (ticket.number)}
							<OpenTicket
								assignees={ticket.assignees}
								comments={ticket.comments}
								created={ticket.created_at}
								url={ticket.html_url}
								labels={ticket.labels}
								id={ticket.number}
								name={ticket.title}
								user={ticket.user}
							/>
						{/each}
					{:else}
						<p
							class="border-t border-gray-300 p-5 text-center text-body dark:border-white/95 dark:text-white"
						>
							No open <strong>community</strong> tickets.
						</p>
					{/if}
				{/if}

				{#if tickets.length === 100}
					<p
						class="border-t border-gray-300 p-5 text-center font-semibold text-primary dark:border-white/95 dark:text-white"
					>
						View all open tickets directly on <a
							href="https://github.com/teambtcmap/btcmap-data/issues"
							target="_blank"
							rel="noreferrer"
							class="text-link transition-colors hover:text-hover">GitHub</a
						>.
					</p>
				{/if}
			{:else}
				{#each Array(10) as _, index (index)}
					<OpenTicketSkeleton />
				{/each}
			{/if}
		</div>
		<p class="text-center text-sm text-body lg:text-left dark:text-white">
			*Data updated every 10 minutes.
		</p>
		<div class="mt-10 flex justify-center">
			<TopButton />
		</div>
	</section>
</main>



================================================
FILE: src/routes/tickets/components/OpenTicketSkeleton.svelte
================================================
<script lang="ts">
	import Icon from '$components/Icon.svelte';
</script>

<div
	class="border-t-statBorder w-full items-center justify-between space-y-1 border-t p-5 text-center md:flex md:space-y-0 md:text-left"
>
	<div class="items-center space-y-1 md:flex md:space-y-0 md:space-x-2">
		<Icon type="fa" icon="ticket" w="20" h="20" class="animate-pulse text-xl text-link/50" />

		<div>
			<span class="mr-1 inline-block h-6 w-32 animate-pulse rounded bg-link/50" />

			<span class="block items-center md:inline-flex">
				<span
					class="mr-1 mb-1 inline-block h-7 w-20 animate-pulse rounded-full border border-link bg-link/25 p-1"
				/>
			</span>

			<span class="mx-auto block h-12 w-40 animate-pulse rounded bg-link/50 md:mx-0 md:h-5" />
		</div>
	</div>

	<div>
		<Icon type="fa" icon="comment" w="16" h="16" class="animate-pulse text-link/50" />
	</div>
</div>



================================================
FILE: src/routes/verify-location/+page.server.ts
================================================
import { error } from '@sveltejs/kit';
import axios from 'axios';
import type { PageServerLoad } from './$types';

export interface VerifyLocationPageData {
	id: string;
	name: string | undefined;
	lat: number;
	long: number;
	location: string;
	edit: string;
	merchantId: string;
}

export const load: PageServerLoad<VerifyLocationPageData> = async ({ url }) => {
	const id = url.searchParams.get('id');

	if (!id) {
		error(400, 'Merchant ID parameter is required');
	}

	try {
		// Fetch from v4 Places API (supports both numeric Place IDs and OSM-style IDs)
		const response = await axios.get(
			`https://api.btcmap.org/v4/places/${id}?fields=id,osm_id,osm_url,name,address,lat,lon`
		);
		const placeData = response.data;

		if (!placeData) {
			error(404, 'Merchant Not Found');
		}

		// Extract OSM type and ID from osm_url
		let osmType = 'node';
		let osmId = id; // fallback

		if (placeData.osm_url) {
			const osmMatch = placeData.osm_url.match(/openstreetmap\.org\/([^/]+)\/(\d+)/);
			if (osmMatch) {
				osmType = osmMatch[1];
				osmId = osmMatch[2];
			}
		} else if (placeData.osm_id) {
			// Fallback to parsing osm_id string
			const parts = placeData.osm_id.split(':');
			if (parts.length === 2) {
				osmType = parts[0];
				osmId = parts[1];
			}
		}

		const location = `https://btcmap.org/map#18/${placeData.lat}/${placeData.lon}`;
		const edit = `https://www.openstreetmap.org/edit?${osmType}=${osmId}`;
		const merchantId = placeData.id.toString();

		return {
			id: placeData.id.toString(),
			name: placeData.name,
			lat: placeData.lat,
			long: placeData.lon,
			location,
			edit,
			merchantId
		};
	} catch (err) {
		console.error(err);
		error(404, 'Merchant Not Found');
	}
};



================================================
FILE: src/routes/verify-location/+page.svelte
================================================
<script lang="ts">
	export let data: import('./+page.server').VerifyLocationPageData;
	import { browser } from '$app/environment';
	import FormSuccess from '$components/FormSuccess.svelte';
	import HeaderPlaceholder from '$components/layout/HeaderPlaceholder.svelte';
	import Icon from '$components/Icon.svelte';
	import InfoTooltip from '$components/InfoTooltip.svelte';
	import PrimaryButton from '$components/PrimaryButton.svelte';
	import { placesError, theme } from '$lib/store';
	import { detectTheme, errToast } from '$lib/utils';
	import axios from 'axios';
	import { onMount } from 'svelte';
	import DOMPurify from 'dompurify';

	// Initialize from server data
	let name = data?.name || '';
	let lat = data?.lat;
	let long = data?.long;
	let location = data?.location || '';
	let edit = data?.edit || '';

	let captcha: HTMLDivElement;
	let captchaSecret: string;
	let captchaInput: HTMLInputElement;
	let honeyInput: HTMLInputElement;

	let captchaContent = '';
	let isCaptchaLoading = true;

	const fetchCaptcha = () => {
		isCaptchaLoading = true;
		axios
			.get('/captcha')
			.then(function (response) {
				// handle success
				captchaSecret = response.data.captchaSecret;
				captchaContent = DOMPurify.sanitize(response.data.captcha);
			})
			.catch(function (error) {
				// handle error
				errToast('Could not fetch captcha, please try again or contact BTC Map.');
				console.error(error);
			})
			.finally(() => {
				isCaptchaLoading = false;
			});
	};

	let current: boolean;
	let outdated: string;
	let verify: HTMLTextAreaElement;

	let selected = !!data; // Set to true if we have server data
	let submitted = false;
	let submitting = false;
	let submissionIssueNumber: number;
	let merchantId = data?.merchantId || '';

	const submitForm = (event: SubmitEvent) => {
		event.preventDefault();
		if (!selected) {
			errToast('Please select a location...');
		} else {
			submitting = true;

			axios
				.post('/verify-location/endpoint', {
					captchaSecret,
					captchaTest: captchaInput.value,
					honey: honeyInput.value,
					name: name,
					location: location,
					edit: edit,
					current: current ? 'Yes' : 'No',
					outdated: outdated ? outdated : '',
					verified: verify.value,
					merchantId: merchantId,
					lat: lat,
					long: long
				})
				.then(function (response) {
					submissionIssueNumber = response.data.number;
					submitted = true;
				})
				.catch(function (error) {
					if (error.response.data.message.includes('Captcha')) {
						errToast(error.response.data.message);
					} else {
						errToast('Form submission failed, please try again or contact BTC Map.');
					}

					console.error(error);
					submitting = false;
				});
		}
	};

	function resetForm() {
		window.history.back();
	}

	// alert for map errors
	$: $placesError && errToast($placesError);

	onMount(async () => {
		if (browser) {
			// fetch and add captcha
			fetchCaptcha();
		}
	});
</script>

<svelte:head>
	<title>BTC Map - Verify Location</title>
	<meta property="og:image" content="https://btcmap.org/images/og/verify.png" />
	<meta property="twitter:title" content="BTC Map - Verify Location" />
	<meta property="twitter:image" content="https://btcmap.org/images/og/verify.png" />
</svelte:head>

{#if !submitted}
	{#if typeof window !== 'undefined'}
		<h1
			class="{detectTheme() === 'dark' || $theme === 'dark'
				? 'text-white'
				: 'gradient'} mt-10 text-center text-4xl font-semibold md:text-5xl"
		>
			Help improve the data for everyone.
		</h1>
	{:else}
		<HeaderPlaceholder />
	{/if}

	<section id="verify" class="mx-auto mt-16 w-full pb-20 md:w-[600px] md:pb-32">
		<h2 class="mb-5 text-center text-3xl font-semibold text-primary dark:text-white">
			Verify Location<br />
			<span class="text-base font-normal"
				>(Ensure the information is still accurate and update it otherwise.)</span
			>
		</h2>

		<p class="mb-10 w-full text-center text-primary dark:text-white">
			Please fill out the following form and one of our volunteer community members will update your
			location on the map. Did you know you can update this data yourself on <a
				href="https://www.openstreetmap.org"
				target="_blank"
				rel="noreferrer"
				class="text-link transition-colors hover:text-hover">OpenStreetMap</a
			>? You can check out our
			<a
				href="https://gitea.btcmap.org/teambtcmap/btcmap-general/wiki/Tagging-Merchants#shadowy-supertaggers"
				target="_blank"
				rel="noreferrer"
				class="text-link transition-colors hover:text-hover">Wiki</a
			>
			for more instructions. <InfoTooltip
				tooltip="NOTE: Due to the backlog of requests and the updates being completed on a volunteer effort, it may take several weeks to update this location. It is encouraged to update the location on OpenStreetMap directly if you want to see the changes appear on the map right away."
			/>
		</p>

		<form on:submit={submitForm} class="w-full space-y-5 text-primary dark:text-white">
			<div>
				<input
					disabled
					bind:value={name}
					readonly
					type="text"
					name="name"
					placeholder={!data ? 'Loading Merchant...' : 'Merchant Name'}
					class="w-full rounded-2xl border-2 border-input p-3 text-center font-semibold focus:outline-link"
				/>
			</div>

			<div>
				<div class="flex items-center space-x-2">
					<label for="current" class="{!outdated ? 'cursor-pointer' : ''} font-semibold"
						>Current information is correct</label
					>
					<input
						class="h-4 w-4 accent-link"
						disabled={!captchaSecret || !data || Boolean(outdated)}
						required={!outdated}
						type="checkbox"
						id="current"
						name="current"
						bind:checked={current}
					/>
				</div>
				<p class="text-sm">Check this box if you have verified the existing data is up-to-date.</p>
			</div>

			<div>
				<label for="outdated" class="mb-2 block font-semibold"
					>Outdated information <span class="font-normal">(If applicable)</span></label
				>
				<textarea
					disabled={!captchaSecret || !data || current}
					required={!current}
					name="outdated"
					placeholder="Provide what info is incorrect and the updated info on this location"
					rows="3"
					class="w-full rounded-2xl border-2 border-input p-3 transition-all focus:outline-link dark:bg-white/[0.15]"
					bind:value={outdated}
				/>
			</div>

			<div>
				<label for="verify" class="mb-2 block font-semibold">How did you verify this?</label>
				<textarea
					disabled={!captchaSecret || !data}
					required
					name="verify"
					placeholder="Please provide additional info here"
					rows="3"
					class="w-full rounded-2xl border-2 border-input p-3 transition-all focus:outline-link dark:bg-white/[0.15]"
					bind:this={verify}
				/>
			</div>

			<div>
				<div class="mb-2 flex items-center space-x-2">
					<label for="captcha" class="font-semibold"
						>Bot protection <span class="font-normal">(case-sensitive)</span></label
					>
					{#if captchaSecret}
						<button type="button" on:click={fetchCaptcha}>
							<Icon type="fa" icon="arrows-rotate" w="16" h="16" />
						</button>
					{/if}
				</div>
				<div class="space-y-2">
					<div
						bind:this={captcha}
						class="flex items-center justify-center rounded-2xl border-2 border-input py-1"
					>
						{#if isCaptchaLoading}
							<div class="h-[100px] w-[275px] animate-pulse bg-link/50" />
						{:else}
							<!-- eslint-disable-next-line svelte/no-at-html-tags - we even sanitize the captcha content above -->
							{@html captchaContent}
						{/if}
					</div>
					<input
						disabled={!captchaSecret || !data}
						required
						type="text"
						name="captcha"
						placeholder="Please enter the captcha text."
						class="w-full rounded-2xl border-2 border-input p-3 transition-all focus:outline-link dark:bg-white/[0.15]"
						bind:this={captchaInput}
					/>
				</div>
			</div>

			<input
				type="text"
				name="honey"
				placeholder="A nice pot of honey."
				class="hidden"
				bind:this={honeyInput}
			/>

			<PrimaryButton
				loading={submitting}
				disabled={submitting || !captchaSecret || !data}
				style="w-full py-3 rounded-xl"
			>
				Submit Report
			</PrimaryButton>
		</form>
	</section>
{:else}
	<FormSuccess
		type="Report"
		text="Thanks for taking the time to fill out this report. Weâ€™ll review your information and
update it ASAP."
		issue={submissionIssueNumber}
		on:click={resetForm}
	/>
{/if}



================================================
FILE: src/routes/verify-location/endpoint/+server.ts
================================================
import { env } from '$env/dynamic/private';
import { error } from '@sveltejs/kit';
import crypto from 'crypto';
import type { RequestHandler } from './$types';
import type { CipherKey, BinaryLike } from 'crypto';
import { getAreaIdsByCoordinates } from '$lib/utils';
import { createIssueWithLabels } from '$lib/gitea';
import { get } from 'svelte/store';
import { areas } from '$lib/store';

const used: string[] = [];

export const POST: RequestHandler = async ({ request }) => {
	console.debug('Verify location POST endpoint called');
	const {
		captchaSecret,
		captchaTest,
		honey,
		name,
		location,
		edit,
		current,
		outdated,
		verified,
		merchantId,
		lat,
		long
	} = await request.json();

	console.debug('Request data:', {
		name,
		location,
		current,
		outdated,
		merchantId
	});

	if (honey) {
		error(418);
	}

	if (!env.SERVER_CRYPTO_KEY || !env.SERVER_INIT_VECTOR) {
		error(503, 'Service unavailable');
	}
	const initVector = Buffer.from(env.SERVER_INIT_VECTOR, 'hex');
	const serverKey = Buffer.from(env.SERVER_CRYPTO_KEY, 'hex');

	const algorithm = 'aes-256-cbc' as string;
	const key = serverKey as unknown as CipherKey;
	const iv = initVector as unknown as BinaryLike;
	const decrypt = crypto.createDecipheriv(algorithm, key, iv);

	let secret = decrypt.update(captchaSecret, 'hex', 'utf8');
	secret += decrypt.final('utf8');

	if (captchaTest !== secret) {
		error(400, 'Captcha test failed, please try again or contact BTC Map.');
	}

	if (used.includes(captchaSecret)) {
		error(400, 'Captcha has already been used, please try another.');
	} else {
		used.push(captchaSecret);
	}

	const standardLabels = ['location-verification'];

	// Create filtered list of matched areas for reuse
	const associatedAreaIds = lat && long ? await getAreaIdsByCoordinates(lat, long) : [];
	const areasData = get(areas);
	const filteredAreas = associatedAreaIds
		.map((id) => areasData.find((a) => a.id === id))
		.filter(Boolean);

	const areaLabels = filteredAreas
		.map((area) => area?.tags?.url_alias || area?.id)
		.filter((label): label is string => Boolean(label));
	const allLabels = [...standardLabels, ...areaLabels];

	const body = `Merchant name: ${name}
Merchant location: ${location}
Coordinates: ${lat}, ${long}
Associated areas: ${filteredAreas.map((area) => `${area?.tags.name} (${area?.tags?.url_alias || area?.id})`).join(', ')}
Edit link: ${edit}
Current information correct: ${current}
Outdated information: ${outdated}
How did you verify this?: ${verified}
Created at: ${new Date(Date.now()).toISOString()}

If you are a new contributor please read our Tagging Instructions [here](https://gitea.btcmap.org/teambtcmap/btcmap-general/wiki/Tagging-Merchants).`;

	const response = await createIssueWithLabels(name, body, allLabels);
	return new Response(JSON.stringify(response.data));
};



================================================
FILE: src/routes/.well-known/nostr.json/+server.ts
================================================
export function GET() {
	return new Response(
		JSON.stringify({
			names: {
				_: '3eab247c63bb35dfa38e07ca102f6da28ba9b9d4687197743bde3a2b1d80aeed',
				nathan: 'c4f5e7a75a8ce3683d529cff06368439c529e5243c6b125ba68789198856cac7',
				rockedf: '205394b7b30c160b6c98a864b652778922863a352155d215fc4599c3f118ebb3'
			}
		}),
		{ headers: { 'Access-Control-Allow-Origin': '*' } }
	);
}



================================================
FILE: src/types/geojson-rewind.d.ts
================================================
declare module '@mapbox/geojson-rewind' {
	import type { GeoJSON } from 'geojson';
	export default function rewind<T extends GeoJSON>(gj: T, outer?: boolean): T;
}
declare module '@mapbox/geojson-rewind' {
	import { GeoJSON } from 'geojson';
	export default function rewind(gj: GeoJSON, outer?: boolean): GeoJSON;
}



================================================
FILE: src/types/leaflet-dom.d.ts
================================================
declare module 'leaflet/src/dom/DomEvent' {
	import { DomEvent } from 'leaflet';
	const _default: typeof DomEvent;
	export = _default;
}



================================================
FILE: static/btcmap.webmanifest
================================================
{
	"name": "BTC Map",
	"short_name": "BTC Map",
	"description": "Easily find places to spend sats anywhere on the planet.",
	"scope": "/",
	"start_url": "/map",
	"display": "standalone",
	"theme_color": "#E4EBEC",
	"background_color": "#E4EBEC",
	"orientation": "portrait-primary",
	"dir": "ltr",
	"lang": "en",
	"display_override": [],
	"categories": [
		"business",
		"finance",
		"lifestyle",
		"navigation",
		"shopping",
		"social",
		"travel",
		"utilities"
	],
	"prefer_related_applications": false,
	"related_applications": [
		{
			"platform": "f-droid",
			"url": "https://f-droid.org/en/packages/org.btcmap/",
			"id": ""
		},
		{
			"platform": "play",
			"url": "https://play.google.com/store/apps/details?id=org.btcmap.app",
			"id": ""
		},
		{
			"platform": "itunes",
			"url": "https://apps.apple.com/app/btc-world-map/id6443604345",
			"id": ""
		}
	],
	"developer": {
		"name": "secondl1ght",
		"url": "https://secondl1ght.site"
	},
	"icons": [
		{
			"src": "/icons/pwa/maskable/maskable_icon_x48.png",
			"sizes": "48x48",
			"type": "image/png",
			"purpose": "maskable"
		},
		{
			"src": "/icons/pwa/maskable/maskable_icon_x72.png",
			"sizes": "72x72",
			"type": "image/png",
			"purpose": "maskable"
		},
		{
			"src": "/icons/pwa/maskable/maskable_icon_x96.png",
			"sizes": "96x96",
			"type": "image/png",
			"purpose": "maskable"
		},
		{
			"src": "/icons/pwa/maskable/maskable_icon_x128.png",
			"sizes": "128x128",
			"type": "image/png",
			"purpose": "maskable"
		},
		{
			"src": "/icons/pwa/maskable/maskable_icon_x192.png",
			"sizes": "192x192",
			"type": "image/png",
			"purpose": "maskable"
		},
		{
			"src": "/icons/pwa/maskable/maskable_icon_x384.png",
			"sizes": "384x384",
			"type": "image/png",
			"purpose": "maskable"
		},
		{
			"src": "/icons/pwa/maskable/maskable_icon_x512.png",
			"sizes": "512x512",
			"type": "image/png",
			"purpose": "maskable"
		},
		{
			"src": "/icons/pwa/windows11/SmallTile.scale-100.png",
			"sizes": "71x71"
		},
		{
			"src": "/icons/pwa/windows11/SmallTile.scale-125.png",
			"sizes": "89x89"
		},
		{
			"src": "/icons/pwa/windows11/SmallTile.scale-150.png",
			"sizes": "107x107"
		},
		{
			"src": "/icons/pwa/windows11/SmallTile.scale-200.png",
			"sizes": "142x142"
		},
		{
			"src": "/icons/pwa/windows11/SmallTile.scale-400.png",
			"sizes": "284x284"
		},
		{
			"src": "/icons/pwa/windows11/Square150x150Logo.scale-100.png",
			"sizes": "150x150"
		},
		{
			"src": "/icons/pwa/windows11/Square150x150Logo.scale-125.png",
			"sizes": "188x188"
		},
		{
			"src": "/icons/pwa/windows11/Square150x150Logo.scale-150.png",
			"sizes": "225x225"
		},
		{
			"src": "/icons/pwa/windows11/Square150x150Logo.scale-200.png",
			"sizes": "300x300"
		},
		{
			"src": "/icons/pwa/windows11/Square150x150Logo.scale-400.png",
			"sizes": "600x600"
		},
		{
			"src": "/icons/pwa/windows11/Wide310x150Logo.scale-100.png",
			"sizes": "310x150"
		},
		{
			"src": "/icons/pwa/windows11/Wide310x150Logo.scale-125.png",
			"sizes": "388x188"
		},
		{
			"src": "/icons/pwa/windows11/Wide310x150Logo.scale-150.png",
			"sizes": "465x225"
		},
		{
			"src": "/icons/pwa/windows11/Wide310x150Logo.scale-200.png",
			"sizes": "620x300"
		},
		{
			"src": "/icons/pwa/windows11/Wide310x150Logo.scale-400.png",
			"sizes": "1240x600"
		},
		{
			"src": "/icons/pwa/windows11/LargeTile.scale-100.png",
			"sizes": "310x310"
		},
		{
			"src": "/icons/pwa/windows11/LargeTile.scale-125.png",
			"sizes": "388x388"
		},
		{
			"src": "/icons/pwa/windows11/LargeTile.scale-150.png",
			"sizes": "465x465"
		},
		{
			"src": "/icons/pwa/windows11/LargeTile.scale-200.png",
			"sizes": "620x620"
		},
		{
			"src": "/icons/pwa/windows11/LargeTile.scale-400.png",
			"sizes": "1240x1240"
		},
		{
			"src": "/icons/pwa/windows11/Square44x44Logo.scale-100.png",
			"sizes": "44x44"
		},
		{
			"src": "/icons/pwa/windows11/Square44x44Logo.scale-125.png",
			"sizes": "55x55"
		},
		{
			"src": "/icons/pwa/windows11/Square44x44Logo.scale-150.png",
			"sizes": "66x66"
		},
		{
			"src": "/icons/pwa/windows11/Square44x44Logo.scale-200.png",
			"sizes": "88x88"
		},
		{
			"src": "/icons/pwa/windows11/Square44x44Logo.scale-400.png",
			"sizes": "176x176"
		},
		{
			"src": "/icons/pwa/windows11/StoreLogo.scale-100.png",
			"sizes": "50x50"
		},
		{
			"src": "/icons/pwa/windows11/StoreLogo.scale-125.png",
			"sizes": "63x63"
		},
		{
			"src": "/icons/pwa/windows11/StoreLogo.scale-150.png",
			"sizes": "75x75"
		},
		{
			"src": "/icons/pwa/windows11/StoreLogo.scale-200.png",
			"sizes": "100x100"
		},
		{
			"src": "/icons/pwa/windows11/StoreLogo.scale-400.png",
			"sizes": "200x200"
		},
		{
			"src": "/icons/pwa/windows11/SplashScreen.scale-100.png",
			"sizes": "620x300"
		},
		{
			"src": "/icons/pwa/windows11/SplashScreen.scale-125.png",
			"sizes": "775x375"
		},
		{
			"src": "/icons/pwa/windows11/SplashScreen.scale-150.png",
			"sizes": "930x450"
		},
		{
			"src": "/icons/pwa/windows11/SplashScreen.scale-200.png",
			"sizes": "1240x600"
		},
		{
			"src": "/icons/pwa/windows11/SplashScreen.scale-400.png",
			"sizes": "2480x1200"
		},
		{
			"src": "/icons/pwa/windows11/Square44x44Logo.targetsize-16.png",
			"sizes": "16x16"
		},
		{
			"src": "/icons/pwa/windows11/Square44x44Logo.targetsize-20.png",
			"sizes": "20x20"
		},
		{
			"src": "/icons/pwa/windows11/Square44x44Logo.targetsize-24.png",
			"sizes": "24x24"
		},
		{
			"src": "/icons/pwa/windows11/Square44x44Logo.targetsize-30.png",
			"sizes": "30x30"
		},
		{
			"src": "/icons/pwa/windows11/Square44x44Logo.targetsize-32.png",
			"sizes": "32x32"
		},
		{
			"src": "/icons/pwa/windows11/Square44x44Logo.targetsize-36.png",
			"sizes": "36x36"
		},
		{
			"src": "/icons/pwa/windows11/Square44x44Logo.targetsize-40.png",
			"sizes": "40x40"
		},
		{
			"src": "/icons/pwa/windows11/Square44x44Logo.targetsize-44.png",
			"sizes": "44x44"
		},
		{
			"src": "/icons/pwa/windows11/Square44x44Logo.targetsize-48.png",
			"sizes": "48x48"
		},
		{
			"src": "/icons/pwa/windows11/Square44x44Logo.targetsize-60.png",
			"sizes": "60x60"
		},
		{
			"src": "/icons/pwa/windows11/Square44x44Logo.targetsize-64.png",
			"sizes": "64x64"
		},
		{
			"src": "/icons/pwa/windows11/Square44x44Logo.targetsize-72.png",
			"sizes": "72x72"
		},
		{
			"src": "/icons/pwa/windows11/Square44x44Logo.targetsize-80.png",
			"sizes": "80x80"
		},
		{
			"src": "/icons/pwa/windows11/Square44x44Logo.targetsize-96.png",
			"sizes": "96x96"
		},
		{
			"src": "/icons/pwa/windows11/Square44x44Logo.targetsize-256.png",
			"sizes": "256x256"
		},
		{
			"src": "/icons/pwa/windows11/Square44x44Logo.altform-unplated_targetsize-16.png",
			"sizes": "16x16"
		},
		{
			"src": "/icons/pwa/windows11/Square44x44Logo.altform-unplated_targetsize-20.png",
			"sizes": "20x20"
		},
		{
			"src": "/icons/pwa/windows11/Square44x44Logo.altform-unplated_targetsize-24.png",
			"sizes": "24x24"
		},
		{
			"src": "/icons/pwa/windows11/Square44x44Logo.altform-unplated_targetsize-30.png",
			"sizes": "30x30"
		},
		{
			"src": "/icons/pwa/windows11/Square44x44Logo.altform-unplated_targetsize-32.png",
			"sizes": "32x32"
		},
		{
			"src": "/icons/pwa/windows11/Square44x44Logo.altform-unplated_targetsize-36.png",
			"sizes": "36x36"
		},
		{
			"src": "/icons/pwa/windows11/Square44x44Logo.altform-unplated_targetsize-40.png",
			"sizes": "40x40"
		},
		{
			"src": "/icons/pwa/windows11/Square44x44Logo.altform-unplated_targetsize-44.png",
			"sizes": "44x44"
		},
		{
			"src": "/icons/pwa/windows11/Square44x44Logo.altform-unplated_targetsize-48.png",
			"sizes": "48x48"
		},
		{
			"src": "/icons/pwa/windows11/Square44x44Logo.altform-unplated_targetsize-60.png",
			"sizes": "60x60"
		},
		{
			"src": "/icons/pwa/windows11/Square44x44Logo.altform-unplated_targetsize-64.png",
			"sizes": "64x64"
		},
		{
			"src": "/icons/pwa/windows11/Square44x44Logo.altform-unplated_targetsize-72.png",
			"sizes": "72x72"
		},
		{
			"src": "/icons/pwa/windows11/Square44x44Logo.altform-unplated_targetsize-80.png",
			"sizes": "80x80"
		},
		{
			"src": "/icons/pwa/windows11/Square44x44Logo.altform-unplated_targetsize-96.png",
			"sizes": "96x96"
		},
		{
			"src": "/icons/pwa/windows11/Square44x44Logo.altform-unplated_targetsize-256.png",
			"sizes": "256x256"
		},
		{
			"src": "/icons/pwa/windows11/Square44x44Logo.altform-lightunplated_targetsize-16.png",
			"sizes": "16x16"
		},
		{
			"src": "/icons/pwa/windows11/Square44x44Logo.altform-lightunplated_targetsize-20.png",
			"sizes": "20x20"
		},
		{
			"src": "/icons/pwa/windows11/Square44x44Logo.altform-lightunplated_targetsize-24.png",
			"sizes": "24x24"
		},
		{
			"src": "/icons/pwa/windows11/Square44x44Logo.altform-lightunplated_targetsize-30.png",
			"sizes": "30x30"
		},
		{
			"src": "/icons/pwa/windows11/Square44x44Logo.altform-lightunplated_targetsize-32.png",
			"sizes": "32x32"
		},
		{
			"src": "/icons/pwa/windows11/Square44x44Logo.altform-lightunplated_targetsize-36.png",
			"sizes": "36x36"
		},
		{
			"src": "/icons/pwa/windows11/Square44x44Logo.altform-lightunplated_targetsize-40.png",
			"sizes": "40x40"
		},
		{
			"src": "/icons/pwa/windows11/Square44x44Logo.altform-lightunplated_targetsize-44.png",
			"sizes": "44x44"
		},
		{
			"src": "/icons/pwa/windows11/Square44x44Logo.altform-lightunplated_targetsize-48.png",
			"sizes": "48x48"
		},
		{
			"src": "/icons/pwa/windows11/Square44x44Logo.altform-lightunplated_targetsize-60.png",
			"sizes": "60x60"
		},
		{
			"src": "/icons/pwa/windows11/Square44x44Logo.altform-lightunplated_targetsize-64.png",
			"sizes": "64x64"
		},
		{
			"src": "/icons/pwa/windows11/Square44x44Logo.altform-lightunplated_targetsize-72.png",
			"sizes": "72x72"
		},
		{
			"src": "/icons/pwa/windows11/Square44x44Logo.altform-lightunplated_targetsize-80.png",
			"sizes": "80x80"
		},
		{
			"src": "/icons/pwa/windows11/Square44x44Logo.altform-lightunplated_targetsize-96.png",
			"sizes": "96x96"
		},
		{
			"src": "/icons/pwa/windows11/Square44x44Logo.altform-lightunplated_targetsize-256.png",
			"sizes": "256x256"
		},
		{
			"src": "/icons/pwa/android/android-launchericon-512-512.png",
			"sizes": "512x512"
		},
		{
			"src": "/icons/pwa/android/android-launchericon-192-192.png",
			"sizes": "192x192"
		},
		{
			"src": "/icons/pwa/android/android-launchericon-144-144.png",
			"sizes": "144x144"
		},
		{
			"src": "/icons/pwa/android/android-launchericon-96-96.png",
			"sizes": "96x96"
		},
		{
			"src": "/icons/pwa/android/android-launchericon-72-72.png",
			"sizes": "72x72"
		},
		{
			"src": "/icons/pwa/android/android-launchericon-48-48.png",
			"sizes": "48x48"
		},
		{
			"src": "/icons/pwa/ios/16.png",
			"sizes": "16x16"
		},
		{
			"src": "/icons/pwa/ios/20.png",
			"sizes": "20x20"
		},
		{
			"src": "/icons/pwa/ios/29.png",
			"sizes": "29x29"
		},
		{
			"src": "/icons/pwa/ios/32.png",
			"sizes": "32x32"
		},
		{
			"src": "/icons/pwa/ios/40.png",
			"sizes": "40x40"
		},
		{
			"src": "/icons/pwa/ios/50.png",
			"sizes": "50x50"
		},
		{
			"src": "/icons/pwa/ios/57.png",
			"sizes": "57x57"
		},
		{
			"src": "/icons/pwa/ios/58.png",
			"sizes": "58x58"
		},
		{
			"src": "/icons/pwa/ios/60.png",
			"sizes": "60x60"
		},
		{
			"src": "/icons/pwa/ios/64.png",
			"sizes": "64x64"
		},
		{
			"src": "/icons/pwa/ios/72.png",
			"sizes": "72x72"
		},
		{
			"src": "/icons/pwa/ios/76.png",
			"sizes": "76x76"
		},
		{
			"src": "/icons/pwa/ios/80.png",
			"sizes": "80x80"
		},
		{
			"src": "/icons/pwa/ios/87.png",
			"sizes": "87x87"
		},
		{
			"src": "/icons/pwa/ios/100.png",
			"sizes": "100x100"
		},
		{
			"src": "/icons/pwa/ios/114.png",
			"sizes": "114x114"
		},
		{
			"src": "/icons/pwa/ios/120.png",
			"sizes": "120x120"
		},
		{
			"src": "/icons/pwa/ios/128.png",
			"sizes": "128x128"
		},
		{
			"src": "/icons/pwa/ios/144.png",
			"sizes": "144x144"
		},
		{
			"src": "/icons/pwa/ios/152.png",
			"sizes": "152x152"
		},
		{
			"src": "/icons/pwa/ios/167.png",
			"sizes": "167x167"
		},
		{
			"src": "/icons/pwa/ios/180.png",
			"sizes": "180x180"
		},
		{
			"src": "/icons/pwa/ios/192.png",
			"sizes": "192x192"
		},
		{
			"src": "/icons/pwa/ios/256.png",
			"sizes": "256x256"
		},
		{
			"src": "/icons/pwa/ios/512.png",
			"sizes": "512x512"
		},
		{
			"src": "/icons/pwa/ios/1024.png",
			"sizes": "1024x1024"
		}
	],
	"shortcuts": [
		{
			"name": "Map",
			"short_name": "Map",
			"description": "Bitcoin merchant locations",
			"url": "/map",
			"icons": [
				{
					"src": "/icons/pwa/maskable/maskable_icon_x96.png",
					"sizes": "96x96",
					"type": "image/png",
					"purpose": "maskable"
				}
			]
		},
		{
			"name": "Add location",
			"short_name": "Add",
			"description": "Add a locaion to OSM",
			"url": "/add-location",
			"icons": [
				{
					"src": "/icons/pwa/maskable/maskable_icon_x96.png",
					"sizes": "96x96",
					"type": "image/png",
					"purpose": "maskable"
				}
			]
		},
		{
			"name": "Verify location",
			"short_name": "Verify",
			"description": "Verify a location's information",
			"url": "/verify-location",
			"icons": [
				{
					"src": "/icons/pwa/maskable/maskable_icon_x96.png",
					"sizes": "96x96",
					"type": "image/png",
					"purpose": "maskable"
				}
			]
		},
		{
			"name": "Dashboard",
			"short_name": "Dash",
			"description": "Map stats and charts",
			"url": "/dashboard",
			"icons": [
				{
					"src": "/icons/pwa/maskable/maskable_icon_x96.png",
					"sizes": "96x96",
					"type": "image/png",
					"purpose": "maskable"
				}
			]
		},
		{
			"name": "Activity",
			"short_name": "Activity",
			"description": "Latest Supertaggers",
			"url": "/activity",
			"icons": [
				{
					"src": "/icons/pwa/maskable/maskable_icon_x96.png",
					"sizes": "96x96",
					"type": "image/png",
					"purpose": "maskable"
				}
			]
		},
		{
			"name": "Leaderboard",
			"short_name": "Leaderboard",
			"description": "Top Supertaggers",
			"url": "/leaderboard",
			"icons": [
				{
					"src": "/icons/pwa/maskable/maskable_icon_x96.png",
					"sizes": "96x96",
					"type": "image/png",
					"purpose": "maskable"
				}
			]
		},
		{
			"name": "Communities",
			"short_name": "Communities",
			"description": "Local bitcoin communities",
			"url": "/communities",
			"icons": [
				{
					"src": "/icons/pwa/maskable/maskable_icon_x96.png",
					"sizes": "96x96",
					"type": "image/png",
					"purpose": "maskable"
				}
			]
		},
		{
			"name": "Countries",
			"short_name": "Countries",
			"description": "Bitcoin adoption by countries",
			"url": "/countries",
			"icons": [
				{
					"src": "/icons/pwa/maskable/maskable_icon_x96.png",
					"sizes": "96x96",
					"type": "image/png",
					"purpose": "maskable"
				}
			]
		},
		{
			"name": "Support Us",
			"short_name": "Support",
			"description": "Support BTC Map development",
			"url": "/support-us",
			"icons": [
				{
					"src": "/icons/pwa/maskable/maskable_icon_x96.png",
					"sizes": "96x96",
					"type": "image/png",
					"purpose": "maskable"
				}
			]
		}
	],
	"screenshots": [
		{
			"src": "/images/screenshots/0.png",
			"sizes": "1280x800",
			"type": "image/png",
			"form_factor": "wide"
		},
		{
			"src": "/images/screenshots/1.png",
			"sizes": "750x1334",
			"type": "image/png"
		},
		{
			"src": "/images/screenshots/2.png",
			"sizes": "1280x800",
			"type": "image/png"
		},
		{
			"src": "/images/screenshots/3.png",
			"sizes": "750x1334",
			"type": "image/png"
		},
		{
			"src": "/images/screenshots/4.png",
			"sizes": "1280x800",
			"type": "image/png"
		},
		{
			"src": "/images/screenshots/5.png",
			"sizes": "750x1334",
			"type": "image/png"
		},
		{
			"src": "/images/screenshots/6.png",
			"sizes": "1280x800",
			"type": "image/png"
		},
		{
			"src": "/images/screenshots/7.png",
			"sizes": "750x1334",
			"type": "image/png"
		},
		{
			"src": "/images/screenshots/8.png",
			"sizes": "1280x800",
			"type": "image/png"
		},
		{
			"src": "/images/screenshots/9.png",
			"sizes": "750x1334",
			"type": "image/png"
		},
		{
			"src": "/images/screenshots/10.png",
			"sizes": "1280x800",
			"type": "image/png"
		},
		{
			"src": "/images/screenshots/11.png",
			"sizes": "750x1334",
			"type": "image/png"
		},
		{
			"src": "/images/screenshots/12.png",
			"sizes": "1280x800",
			"type": "image/png"
		},
		{
			"src": "/images/screenshots/13.png",
			"sizes": "750x1334",
			"type": "image/png"
		},
		{
			"src": "/images/screenshots/14.png",
			"sizes": "1280x800",
			"type": "image/png"
		},
		{
			"src": "/images/screenshots/15.png",
			"sizes": "750x1334",
			"type": "image/png"
		}
	]
}



================================================
FILE: static/cached.txt
================================================
[Empty file]


================================================
FILE: static/CNAME
================================================
btcmap.org



================================================
FILE: static/offline.html
================================================
<!doctype html>
<html lang="en">
	<head>
		<script>
			if (
				localStorage.theme === 'dark' ||
				(!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)
			) {
				document.documentElement.classList.add('dark');
			} else {
				document.documentElement.classList.remove('dark');
			}
		</script>
		<meta name="theme-color" content="#0B9072" />
		<meta name="keywords" content="bitcoin, open source, map" />
		<meta name="author" content="BTC Map" />
		<meta property="og:type" content="website" />
		<meta name="description" content="Easily find places to spend sats anywhere on the planet." />
		<meta
			property="twitter:description"
			content="Easily find places to spend sats anywhere on the planet."
		/>
		<meta property="twitter:site" content="@btcmap" />
		<meta property="twitter:card" content="summary_large_image" />
		<meta charset="utf-8" />
		<meta name="msapplication-TileColor" content="#0B9072" />
		<meta name="viewport" content="width=device-width" />
		<link rel="manifest" href="/btcmap.webmanifest" />
		<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png" />
		<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png" />
		<link rel="icon" href="./favicon.svg" />

		<style data-sveltekit>
			:root {
				--toastContainerTop: auto;
				--toastContainerRight: auto;
				--toastContainerBottom: 8rem;
				--toastContainerLeft: calc(50vw - 8rem);
			}
			.s-7IPF32Wcq3s8 {
			}
			/*
! tailwindcss v3.2.7 | MIT License | https://tailwindcss.com
*/ /*
1. Prevent padding and border from affecting element width. (https://github.com/mozdevs/cssremedy/issues/4)
2. Allow adding a border to an element by just adding a border-width. (https://github.com/tailwindcss/tailwindcss/pull/116)
*/

			*,
			::before,
			::after {
				box-sizing: border-box; /* 1 */
				border-width: 0; /* 2 */
				border-style: solid; /* 2 */
				border-color: #e5e7eb; /* 2 */
			}

			::before,
			::after {
				--tw-content: '';
			}

			/*
1. Use a consistent sensible line-height in all browsers.
2. Prevent adjustments of font size after orientation changes in iOS.
3. Use a more readable tab size.
4. Use the user's configured `sans` font-family by default.
5. Use the user's configured `sans` font-feature-settings by default.
*/

			html {
				line-height: 1.5; /* 1 */
				-webkit-text-size-adjust: 100%; /* 2 */
				-moz-tab-size: 4; /* 3 */
				-o-tab-size: 4;
				tab-size: 4; /* 3 */
				font-family:
					ui-sans-serif,
					system-ui,
					-apple-system,
					BlinkMacSystemFont,
					'Segoe UI',
					Roboto,
					'Helvetica Neue',
					Arial,
					'Noto Sans',
					sans-serif,
					'Apple Color Emoji',
					'Segoe UI Emoji',
					'Segoe UI Symbol',
					'Noto Color Emoji'; /* 4 */
				font-feature-settings: normal; /* 5 */
			}

			/*
1. Remove the margin in all browsers.
2. Inherit line-height from `html` so users can set them as a class directly on the `html` element.
*/

			body {
				margin: 0; /* 1 */
				line-height: inherit; /* 2 */
			}

			/*
1. Add the correct height in Firefox.
2. Correct the inheritance of border color in Firefox. (https://bugzilla.mozilla.org/show_bug.cgi?id=190655)
3. Ensure horizontal rules are visible by default.
*/

			hr {
				height: 0; /* 1 */
				color: inherit; /* 2 */
				border-top-width: 1px; /* 3 */
			}

			/*
Add the correct text decoration in Chrome, Edge, and Safari.
*/

			abbr:where([title]) {
				-webkit-text-decoration: underline dotted;
				text-decoration: underline dotted;
			}

			/*
Remove the default font size and weight for headings.
*/

			h1,
			h2,
			h3,
			h4,
			h5,
			h6 {
				font-size: inherit;
				font-weight: inherit;
			}

			/*
Reset links to optimize for opt-in styling instead of opt-out.
*/

			a {
				color: inherit;
				text-decoration: inherit;
			}

			/*
Add the correct font weight in Edge and Safari.
*/

			b,
			strong {
				font-weight: bolder;
			}

			/*
1. Use the user's configured `mono` font family by default.
2. Correct the odd `em` font sizing in all browsers.
*/

			code,
			kbd,
			samp,
			pre {
				font-family:
					ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New',
					monospace; /* 1 */
				font-size: 1em; /* 2 */
			}

			/*
Add the correct font size in all browsers.
*/

			small {
				font-size: 80%;
			}

			/*
Prevent `sub` and `sup` elements from affecting the line height in all browsers.
*/

			sub,
			sup {
				font-size: 75%;
				line-height: 0;
				position: relative;
				vertical-align: baseline;
			}

			sub {
				bottom: -0.25em;
			}

			sup {
				top: -0.5em;
			}

			/*
1. Remove text indentation from table contents in Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=999088, https://bugs.webkit.org/show_bug.cgi?id=201297)
2. Correct table border color inheritance in all Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=935729, https://bugs.webkit.org/show_bug.cgi?id=195016)
3. Remove gaps between table borders by default.
*/

			table {
				text-indent: 0; /* 1 */
				border-color: inherit; /* 2 */
				border-collapse: collapse; /* 3 */
			}

			/*
1. Change the font styles in all browsers.
2. Remove the margin in Firefox and Safari.
3. Remove default padding in all browsers.
*/

			button,
			input,
			optgroup,
			select,
			textarea {
				font-family: inherit; /* 1 */
				font-size: 100%; /* 1 */
				font-weight: inherit; /* 1 */
				line-height: inherit; /* 1 */
				color: inherit; /* 1 */
				margin: 0; /* 2 */
				padding: 0; /* 3 */
			}

			/*
Remove the inheritance of text transform in Edge and Firefox.
*/

			button,
			select {
				text-transform: none;
			}

			/*
1. Correct the inability to style clickable types in iOS and Safari.
2. Remove default button styles.
*/

			button,
			[type='button'],
			[type='reset'],
			[type='submit'] {
				-webkit-appearance: button; /* 1 */
				background-color: transparent; /* 2 */
				background-image: none; /* 2 */
			}

			/*
Use the modern Firefox focus style for all focusable elements.
*/

			:-moz-focusring {
				outline: auto;
			}

			/*
Remove the additional `:invalid` styles in Firefox. (https://github.com/mozilla/gecko-dev/blob/2f9eacd9d3d995c937b4251a5557d95d494c9be1/layout/style/res/forms.css#L728-L737)
*/

			:-moz-ui-invalid {
				box-shadow: none;
			}

			/*
Add the correct vertical alignment in Chrome and Firefox.
*/

			progress {
				vertical-align: baseline;
			}

			/*
Correct the cursor style of increment and decrement buttons in Safari.
*/

			::-webkit-inner-spin-button,
			::-webkit-outer-spin-button {
				height: auto;
			}

			/*
1. Correct the odd appearance in Chrome and Safari.
2. Correct the outline style in Safari.
*/

			[type='search'] {
				-webkit-appearance: textfield; /* 1 */
				outline-offset: -2px; /* 2 */
			}

			/*
Remove the inner padding in Chrome and Safari on macOS.
*/

			::-webkit-search-decoration {
				-webkit-appearance: none;
			}

			/*
1. Correct the inability to style clickable types in iOS and Safari.
2. Change font properties to `inherit` in Safari.
*/

			::-webkit-file-upload-button {
				-webkit-appearance: button; /* 1 */
				font: inherit; /* 2 */
			}

			/*
Add the correct display in Chrome and Safari.
*/

			summary {
				display: list-item;
			}

			/*
Removes the default spacing and border for appropriate elements.
*/

			blockquote,
			dl,
			dd,
			h1,
			h2,
			h3,
			h4,
			h5,
			h6,
			hr,
			figure,
			p,
			pre {
				margin: 0;
			}

			fieldset {
				margin: 0;
				padding: 0;
			}

			legend {
				padding: 0;
			}

			ol,
			ul,
			menu {
				list-style: none;
				margin: 0;
				padding: 0;
			}

			/*
Prevent resizing textareas horizontally by default.
*/

			textarea {
				resize: vertical;
			}

			/*
1. Reset the default placeholder opacity in Firefox. (https://github.com/tailwindlabs/tailwindcss/issues/3300)
2. Set the default placeholder color to the user's configured gray 400 color.
*/

			input::-moz-placeholder,
			textarea::-moz-placeholder {
				opacity: 1; /* 1 */
				color: #9ca3af; /* 2 */
			}

			input::placeholder,
			textarea::placeholder {
				opacity: 1; /* 1 */
				color: #9ca3af; /* 2 */
			}

			/*
Set the default cursor for buttons.
*/

			button,
			[role='button'] {
				cursor: pointer;
			}

			/*
Make sure disabled buttons don't get the pointer cursor.
*/
			:disabled {
				cursor: default;
			}

			/*
1. Make replaced elements `display: block` by default. (https://github.com/mozdevs/cssremedy/issues/14)
2. Add `vertical-align: middle` to align replaced elements more sensibly by default. (https://github.com/jensimmons/cssremedy/issues/14#issuecomment-634934210)
   This can trigger a poorly considered lint error in some tools but is included by design.
*/

			img,
			svg,
			video,
			canvas,
			audio,
			iframe,
			embed,
			object {
				display: block; /* 1 */
				vertical-align: middle; /* 2 */
			}

			/*
Constrain images and videos to the parent width and preserve their intrinsic aspect ratio. (https://github.com/mozdevs/cssremedy/issues/14)
*/

			img,
			video {
				max-width: 100%;
				height: auto;
			}

			/* Make elements with the HTML hidden attribute stay hidden by default */
			[hidden] {
				display: none;
			}

			*,
			::before,
			::after {
				--tw-border-spacing-x: 0;
				--tw-border-spacing-y: 0;
				--tw-translate-x: 0;
				--tw-translate-y: 0;
				--tw-rotate: 0;
				--tw-skew-x: 0;
				--tw-skew-y: 0;
				--tw-scale-x: 1;
				--tw-scale-y: 1;
				--tw-pan-x: ;
				--tw-pan-y: ;
				--tw-pinch-zoom: ;
				--tw-scroll-snap-strictness: proximity;
				--tw-ordinal: ;
				--tw-slashed-zero: ;
				--tw-numeric-figure: ;
				--tw-numeric-spacing: ;
				--tw-numeric-fraction: ;
				--tw-ring-inset: ;
				--tw-ring-offset-width: 0px;
				--tw-ring-offset-color: #fff;
				--tw-ring-color: rgb(59 130 246 / 0.5);
				--tw-ring-offset-shadow: 0 0 #0000;
				--tw-ring-shadow: 0 0 #0000;
				--tw-shadow: 0 0 #0000;
				--tw-shadow-colored: 0 0 #0000;
				--tw-blur: ;
				--tw-brightness: ;
				--tw-contrast: ;
				--tw-grayscale: ;
				--tw-hue-rotate: ;
				--tw-invert: ;
				--tw-saturate: ;
				--tw-sepia: ;
				--tw-drop-shadow: ;
				--tw-backdrop-blur: ;
				--tw-backdrop-brightness: ;
				--tw-backdrop-contrast: ;
				--tw-backdrop-grayscale: ;
				--tw-backdrop-hue-rotate: ;
				--tw-backdrop-invert: ;
				--tw-backdrop-opacity: ;
				--tw-backdrop-saturate: ;
				--tw-backdrop-sepia: ;
			}

			::backdrop {
				--tw-border-spacing-x: 0;
				--tw-border-spacing-y: 0;
				--tw-translate-x: 0;
				--tw-translate-y: 0;
				--tw-rotate: 0;
				--tw-skew-x: 0;
				--tw-skew-y: 0;
				--tw-scale-x: 1;
				--tw-scale-y: 1;
				--tw-pan-x: ;
				--tw-pan-y: ;
				--tw-pinch-zoom: ;
				--tw-scroll-snap-strictness: proximity;
				--tw-ordinal: ;
				--tw-slashed-zero: ;
				--tw-numeric-figure: ;
				--tw-numeric-spacing: ;
				--tw-numeric-fraction: ;
				--tw-ring-inset: ;
				--tw-ring-offset-width: 0px;
				--tw-ring-offset-color: #fff;
				--tw-ring-color: rgb(59 130 246 / 0.5);
				--tw-ring-offset-shadow: 0 0 #0000;
				--tw-ring-shadow: 0 0 #0000;
				--tw-shadow: 0 0 #0000;
				--tw-shadow-colored: 0 0 #0000;
				--tw-blur: ;
				--tw-brightness: ;
				--tw-contrast: ;
				--tw-grayscale: ;
				--tw-hue-rotate: ;
				--tw-invert: ;
				--tw-saturate: ;
				--tw-sepia: ;
				--tw-drop-shadow: ;
				--tw-backdrop-blur: ;
				--tw-backdrop-brightness: ;
				--tw-backdrop-contrast: ;
				--tw-backdrop-grayscale: ;
				--tw-backdrop-hue-rotate: ;
				--tw-backdrop-invert: ;
				--tw-backdrop-opacity: ;
				--tw-backdrop-saturate: ;
				--tw-backdrop-sepia: ;
			}
			.visible {
				visibility: visible;
			}
			.collapse {
				visibility: collapse;
			}
			.fixed {
				position: fixed;
			}
			.absolute {
				position: absolute;
			}
			.relative {
				position: relative;
			}
			.sticky {
				position: sticky;
			}
			.-right-2 {
				right: -0.5rem;
			}
			.-top-16 {
				top: -4rem;
			}
			.bottom-4 {
				bottom: 1rem;
			}
			.left-0 {
				left: 0px;
			}
			.left-\[-100\%\] {
				left: -100%;
			}
			.left-\[15px\] {
				left: 15px;
			}
			.left-\[26px\] {
				left: 26px;
			}
			.left-\[60px\] {
				left: 60px;
			}
			.left-\[calc\(50\%-8px\)\] {
				left: calc(50% - 8px);
			}
			.right-0 {
				right: 0px;
			}
			.right-1 {
				right: 0.25rem;
			}
			.right-6 {
				right: 1.5rem;
			}
			.right-\[8px\] {
				right: 8px;
			}
			.top-0 {
				top: 0px;
			}
			.top-1 {
				top: 0.25rem;
			}
			.top-3 {
				top: 0.75rem;
			}
			.top-3\.5 {
				top: 0.875rem;
			}
			.top-4 {
				top: 1rem;
			}
			.top-5 {
				top: 1.25rem;
			}
			.top-8 {
				top: 2rem;
			}
			.top-\[10px\] {
				top: 10px;
			}
			.top-\[122\.45px\] {
				top: 122.45px;
			}
			.top-\[55px\] {
				top: 55px;
			}
			.z-10 {
				z-index: 10;
			}
			.z-20 {
				z-index: 20;
			}
			.z-30 {
				z-index: 30;
			}
			.z-\[10000\] {
				z-index: 10000;
			}
			.z-\[2000\] {
				z-index: 2000;
			}
			.z-\[500\] {
				z-index: 500;
			}
			.m-1 {
				margin: 0.25rem;
			}
			.m-2 {
				margin: 0.5rem;
			}
			.m-4 {
				margin: 1rem;
			}
			.\!my-12 {
				margin-top: 3rem !important;
				margin-bottom: 3rem !important;
			}
			.\!my-5 {
				margin-top: 1.25rem !important;
				margin-bottom: 1.25rem !important;
			}
			.\!my-auto {
				margin-top: auto !important;
				margin-bottom: auto !important;
			}
			.mx-0 {
				margin-left: 0px;
				margin-right: 0px;
			}
			.mx-2 {
				margin-left: 0.5rem;
				margin-right: 0.5rem;
			}
			.mx-2\.5 {
				margin-left: 0.625rem;
				margin-right: 0.625rem;
			}
			.mx-3 {
				margin-left: 0.75rem;
				margin-right: 0.75rem;
			}
			.mx-5 {
				margin-left: 1.25rem;
				margin-right: 1.25rem;
			}
			.mx-auto {
				margin-left: auto;
				margin-right: auto;
			}
			.my-0 {
				margin-top: 0px;
				margin-bottom: 0px;
			}
			.my-1 {
				margin-top: 0.25rem;
				margin-bottom: 0.25rem;
			}
			.my-10 {
				margin-top: 2.5rem;
				margin-bottom: 2.5rem;
			}
			.my-16 {
				margin-top: 4rem;
				margin-bottom: 4rem;
			}
			.my-2 {
				margin-top: 0.5rem;
				margin-bottom: 0.5rem;
			}
			.my-20 {
				margin-top: 5rem;
				margin-bottom: 5rem;
			}
			.my-4 {
				margin-top: 1rem;
				margin-bottom: 1rem;
			}
			.my-5 {
				margin-top: 1.25rem;
				margin-bottom: 1.25rem;
			}
			.my-auto {
				margin-top: auto;
				margin-bottom: auto;
			}
			.\!mb-5 {
				margin-bottom: 1.25rem !important;
			}
			.mb-0 {
				margin-bottom: 0px;
			}
			.mb-1 {
				margin-bottom: 0.25rem;
			}
			.mb-10 {
				margin-bottom: 2.5rem;
			}
			.mb-16 {
				margin-bottom: 4rem;
			}
			.mb-2 {
				margin-bottom: 0.5rem;
			}
			.mb-2\.5 {
				margin-bottom: 0.625rem;
			}
			.mb-20 {
				margin-bottom: 5rem;
			}
			.mb-3 {
				margin-bottom: 0.75rem;
			}
			.mb-4 {
				margin-bottom: 1rem;
			}
			.mb-5 {
				margin-bottom: 1.25rem;
			}
			.mb-6 {
				margin-bottom: 1.5rem;
			}
			.mb-8 {
				margin-bottom: 2rem;
			}
			.ml-1 {
				margin-left: 0.25rem;
			}
			.ml-2 {
				margin-left: 0.5rem;
			}
			.ml-3 {
				margin-left: 0.75rem;
			}
			.ml-5 {
				margin-left: 1.25rem;
			}
			.ml-7 {
				margin-left: 1.75rem;
			}
			.mr-0 {
				margin-right: 0px;
			}
			.mr-1 {
				margin-right: 0.25rem;
			}
			.mr-2 {
				margin-right: 0.5rem;
			}
			.mr-3 {
				margin-right: 0.75rem;
			}
			.mr-4 {
				margin-right: 1rem;
			}
			.mr-5 {
				margin-right: 1.25rem;
			}
			.mt-0 {
				margin-top: 0px;
			}
			.mt-0\.5 {
				margin-top: 0.125rem;
			}
			.mt-1 {
				margin-top: 0.25rem;
			}
			.mt-10 {
				margin-top: 2.5rem;
			}
			.mt-16 {
				margin-top: 4rem;
			}
			.mt-2 {
				margin-top: 0.5rem;
			}
			.mt-2\.5 {
				margin-top: 0.625rem;
			}
			.mt-3 {
				margin-top: 0.75rem;
			}
			.mt-4 {
				margin-top: 1rem;
			}
			.mt-5 {
				margin-top: 1.25rem;
			}
			.mt-8 {
				margin-top: 2rem;
			}
			.mt-\[5\.75px\] {
				margin-top: 5.75px;
			}
			.block {
				display: block;
			}
			.inline-block {
				display: inline-block;
			}
			.inline {
				display: inline;
			}
			.flex {
				display: flex;
			}
			.inline-flex {
				display: inline-flex;
			}
			.table {
				display: table;
			}
			.grid {
				display: grid;
			}
			.contents {
				display: contents;
			}
			.hidden {
				display: none;
			}
			.h-10 {
				height: 2.5rem;
			}
			.h-12 {
				height: 3rem;
			}
			.h-14 {
				height: 3.5rem;
			}
			.h-16 {
				height: 4rem;
			}
			.h-20 {
				height: 5rem;
			}
			.h-24 {
				height: 6rem;
			}
			.h-28 {
				height: 7rem;
			}
			.h-3 {
				height: 0.75rem;
			}
			.h-32 {
				height: 8rem;
			}
			.h-4 {
				height: 1rem;
			}
			.h-5 {
				height: 1.25rem;
			}
			.h-6 {
				height: 1.5rem;
			}
			.h-60 {
				height: 15rem;
			}
			.h-7 {
				height: 1.75rem;
			}
			.h-8 {
				height: 2rem;
			}
			.h-\[100px\] {
				height: 100px;
			}
			.h-\[100vh\] {
				height: 100vh;
			}
			.h-\[200px\] {
				height: 200px;
			}
			.h-\[220px\] {
				height: 220px;
			}
			.h-\[225px\] {
				height: 225px;
			}
			.h-\[256px\] {
				height: 256px;
			}
			.h-\[28px\] {
				height: 28px;
			}
			.h-\[300px\] {
				height: 300px;
			}
			.h-\[30px\] {
				height: 30px;
			}
			.h-\[324px\] {
				height: 324px;
			}
			.h-\[32px\] {
				height: 32px;
			}
			.h-\[375px\] {
				height: 375px;
			}
			.h-\[38px\] {
				height: 38px;
			}
			.h-\[400px\] {
				height: 400px;
			}
			.h-\[40px\] {
				height: 40px;
			}
			.h-\[450px\] {
				height: 450px;
			}
			.h-\[48px\] {
				height: 48px;
			}
			.h-\[60px\] {
				height: 60px;
			}
			.h-\[648px\] {
				height: 648px;
			}
			.h-\[90px\] {
				height: 90px;
			}
			.h-\[99px\] {
				height: 99px;
			}
			.h-full {
				height: 100%;
			}
			.max-h-\[204px\] {
				max-height: 204px;
			}
			.max-h-\[300px\] {
				max-height: 300px;
			}
			.max-h-\[375px\] {
				max-height: 375px;
			}
			.max-h-\[90vh\] {
				max-height: 90vh;
			}
			.w-1 {
				width: 0.25rem;
			}
			.w-10 {
				width: 2.5rem;
			}
			.w-10\/12 {
				width: 83.333333%;
			}
			.w-14 {
				width: 3.5rem;
			}
			.w-16 {
				width: 4rem;
			}
			.w-2 {
				width: 0.5rem;
			}
			.w-20 {
				width: 5rem;
			}
			.w-24 {
				width: 6rem;
			}
			.w-28 {
				width: 7rem;
			}
			.w-3 {
				width: 0.75rem;
			}
			.w-32 {
				width: 8rem;
			}
			.w-36 {
				width: 9rem;
			}
			.w-4 {
				width: 1rem;
			}
			.w-40 {
				width: 10rem;
			}
			.w-44 {
				width: 11rem;
			}
			.w-5 {
				width: 1.25rem;
			}
			.w-52 {
				width: 13rem;
			}
			.w-6 {
				width: 1.5rem;
			}
			.w-60 {
				width: 15rem;
			}
			.w-7 {
				width: 1.75rem;
			}
			.w-8 {
				width: 2rem;
			}
			.w-80 {
				width: 20rem;
			}
			.w-96 {
				width: 24rem;
			}
			.w-\[100px\] {
				width: 100px;
			}
			.w-\[147px\] {
				width: 147px;
			}
			.w-\[150px\] {
				width: 150px;
			}
			.w-\[185px\] {
				width: 185px;
			}
			.w-\[200px\] {
				width: 200px;
			}
			.w-\[207px\] {
				width: 207px;
			}
			.w-\[220px\] {
				width: 220px;
			}
			.w-\[225px\] {
				width: 225px;
			}
			.w-\[250px\] {
				width: 250px;
			}
			.w-\[256px\] {
				width: 256px;
			}
			.w-\[275px\] {
				width: 275px;
			}
			.w-\[40px\] {
				width: 40px;
			}
			.w-\[50vw\] {
				width: 50vw;
			}
			.w-\[52px\] {
				width: 52px;
			}
			.w-\[80px\] {
				width: 80px;
			}
			.w-\[90vw\] {
				width: 90vw;
			}
			.w-\[94px\] {
				width: 94px;
			}
			.w-auto {
				width: auto;
			}
			.w-fit {
				width: -moz-fit-content;
				width: fit-content;
			}
			.w-full {
				width: 100%;
			}
			.max-w-\[300px\] {
				max-width: 300px;
			}
			.flex-grow {
				flex-grow: 1;
			}
			.grow {
				flex-grow: 1;
			}
			.border-collapse {
				border-collapse: collapse;
			}
			.transform {
				transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate))
					skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x))
					scaleY(var(--tw-scale-y));
			}
			@keyframes bounce {
				0%,
				100% {
					transform: translateY(-25%);
					animation-timing-function: cubic-bezier(0.8, 0, 1, 1);
				}

				50% {
					transform: none;
					animation-timing-function: cubic-bezier(0, 0, 0.2, 1);
				}
			}
			.animate-bounce {
				animation: bounce 1s infinite;
			}
			@keyframes ping {
				75%,
				100% {
					transform: scale(2);
					opacity: 0;
				}
			}
			.animate-ping {
				animation: ping 1s cubic-bezier(0, 0, 0.2, 1) infinite;
			}
			@keyframes pulse {
				50% {
					opacity: 0.5;
				}
			}
			.animate-pulse {
				animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
			}
			@keyframes spin {
				to {
					transform: rotate(360deg);
				}
			}
			.animate-spin {
				animation: spin 1s linear infinite;
			}
			@keyframes wiggle {
				0%,
				100% {
					transform: rotate(-3deg);
				}

				50% {
					transform: rotate(3deg);
				}
			}
			.animate-wiggle {
				animation: wiggle 1s ease-in-out infinite;
			}
			.\!cursor-crosshair {
				cursor: crosshair !important;
			}
			.cursor-pointer {
				cursor: pointer;
			}
			.resize {
				resize: both;
			}
			.list-decimal {
				list-style-type: decimal;
			}
			.list-disc {
				list-style-type: disc;
			}
			.grid-cols-2 {
				grid-template-columns: repeat(2, minmax(0, 1fr));
			}
			.grid-cols-3 {
				grid-template-columns: repeat(3, minmax(0, 1fr));
			}
			.grid-cols-4 {
				grid-template-columns: repeat(4, minmax(0, 1fr));
			}
			.grid-cols-6 {
				grid-template-columns: repeat(6, minmax(0, 1fr));
			}
			.flex-col {
				flex-direction: column;
			}
			.flex-wrap {
				flex-wrap: wrap;
			}
			.items-start {
				align-items: flex-start;
			}
			.items-end {
				align-items: flex-end;
			}
			.items-center {
				align-items: center;
			}
			.justify-start {
				justify-content: flex-start;
			}
			.justify-end {
				justify-content: flex-end;
			}
			.justify-center {
				justify-content: center;
			}
			.justify-between {
				justify-content: space-between;
			}
			.gap-10 {
				gap: 2.5rem;
			}
			.gap-5 {
				gap: 1.25rem;
			}
			.space-x-0 > :not([hidden]) ~ :not([hidden]) {
				--tw-space-x-reverse: 0;
				margin-right: calc(0px * var(--tw-space-x-reverse));
				margin-left: calc(0px * calc(1 - var(--tw-space-x-reverse)));
			}
			.space-x-1 > :not([hidden]) ~ :not([hidden]) {
				--tw-space-x-reverse: 0;
				margin-right: calc(0.25rem * var(--tw-space-x-reverse));
				margin-left: calc(0.25rem * calc(1 - var(--tw-space-x-reverse)));
			}
			.space-x-10 > :not([hidden]) ~ :not([hidden]) {
				--tw-space-x-reverse: 0;
				margin-right: calc(2.5rem * var(--tw-space-x-reverse));
				margin-left: calc(2.5rem * calc(1 - var(--tw-space-x-reverse)));
			}
			.space-x-16 > :not([hidden]) ~ :not([hidden]) {
				--tw-space-x-reverse: 0;
				margin-right: calc(4rem * var(--tw-space-x-reverse));
				margin-left: calc(4rem * calc(1 - var(--tw-space-x-reverse)));
			}
			.space-x-2 > :not([hidden]) ~ :not([hidden]) {
				--tw-space-x-reverse: 0;
				margin-right: calc(0.5rem * var(--tw-space-x-reverse));
				margin-left: calc(0.5rem * calc(1 - var(--tw-space-x-reverse)));
			}
			.space-x-4 > :not([hidden]) ~ :not([hidden]) {
				--tw-space-x-reverse: 0;
				margin-right: calc(1rem * var(--tw-space-x-reverse));
				margin-left: calc(1rem * calc(1 - var(--tw-space-x-reverse)));
			}
			.space-x-5 > :not([hidden]) ~ :not([hidden]) {
				--tw-space-x-reverse: 0;
				margin-right: calc(1.25rem * var(--tw-space-x-reverse));
				margin-left: calc(1.25rem * calc(1 - var(--tw-space-x-reverse)));
			}
			.space-x-7 > :not([hidden]) ~ :not([hidden]) {
				--tw-space-x-reverse: 0;
				margin-right: calc(1.75rem * var(--tw-space-x-reverse));
				margin-left: calc(1.75rem * calc(1 - var(--tw-space-x-reverse)));
			}
			.space-x-8 > :not([hidden]) ~ :not([hidden]) {
				--tw-space-x-reverse: 0;
				margin-right: calc(2rem * var(--tw-space-x-reverse));
				margin-left: calc(2rem * calc(1 - var(--tw-space-x-reverse)));
			}
			.space-y-0 > :not([hidden]) ~ :not([hidden]) {
				--tw-space-y-reverse: 0;
				margin-top: calc(0px * calc(1 - var(--tw-space-y-reverse)));
				margin-bottom: calc(0px * var(--tw-space-y-reverse));
			}
			.space-y-0\.5 > :not([hidden]) ~ :not([hidden]) {
				--tw-space-y-reverse: 0;
				margin-top: calc(0.125rem * calc(1 - var(--tw-space-y-reverse)));
				margin-bottom: calc(0.125rem * var(--tw-space-y-reverse));
			}
			.space-y-1 > :not([hidden]) ~ :not([hidden]) {
				--tw-space-y-reverse: 0;
				margin-top: calc(0.25rem * calc(1 - var(--tw-space-y-reverse)));
				margin-bottom: calc(0.25rem * var(--tw-space-y-reverse));
			}
			.space-y-10 > :not([hidden]) ~ :not([hidden]) {
				--tw-space-y-reverse: 0;
				margin-top: calc(2.5rem * calc(1 - var(--tw-space-y-reverse)));
				margin-bottom: calc(2.5rem * var(--tw-space-y-reverse));
			}
			.space-y-16 > :not([hidden]) ~ :not([hidden]) {
				--tw-space-y-reverse: 0;
				margin-top: calc(4rem * calc(1 - var(--tw-space-y-reverse)));
				margin-bottom: calc(4rem * var(--tw-space-y-reverse));
			}
			.space-y-2 > :not([hidden]) ~ :not([hidden]) {
				--tw-space-y-reverse: 0;
				margin-top: calc(0.5rem * calc(1 - var(--tw-space-y-reverse)));
				margin-bottom: calc(0.5rem * var(--tw-space-y-reverse));
			}
			.space-y-20 > :not([hidden]) ~ :not([hidden]) {
				--tw-space-y-reverse: 0;
				margin-top: calc(5rem * calc(1 - var(--tw-space-y-reverse)));
				margin-bottom: calc(5rem * var(--tw-space-y-reverse));
			}
			.space-y-3 > :not([hidden]) ~ :not([hidden]) {
				--tw-space-y-reverse: 0;
				margin-top: calc(0.75rem * calc(1 - var(--tw-space-y-reverse)));
				margin-bottom: calc(0.75rem * var(--tw-space-y-reverse));
			}
			.space-y-4 > :not([hidden]) ~ :not([hidden]) {
				--tw-space-y-reverse: 0;
				margin-top: calc(1rem * calc(1 - var(--tw-space-y-reverse)));
				margin-bottom: calc(1rem * var(--tw-space-y-reverse));
			}
			.space-y-40 > :not([hidden]) ~ :not([hidden]) {
				--tw-space-y-reverse: 0;
				margin-top: calc(10rem * calc(1 - var(--tw-space-y-reverse)));
				margin-bottom: calc(10rem * var(--tw-space-y-reverse));
			}
			.space-y-5 > :not([hidden]) ~ :not([hidden]) {
				--tw-space-y-reverse: 0;
				margin-top: calc(1.25rem * calc(1 - var(--tw-space-y-reverse)));
				margin-bottom: calc(1.25rem * var(--tw-space-y-reverse));
			}
			.space-y-6 > :not([hidden]) ~ :not([hidden]) {
				--tw-space-y-reverse: 0;
				margin-top: calc(1.5rem * calc(1 - var(--tw-space-y-reverse)));
				margin-bottom: calc(1.5rem * var(--tw-space-y-reverse));
			}
			.space-y-8 > :not([hidden]) ~ :not([hidden]) {
				--tw-space-y-reverse: 0;
				margin-top: calc(2rem * calc(1 - var(--tw-space-y-reverse)));
				margin-bottom: calc(2rem * var(--tw-space-y-reverse));
			}
			.self-center {
				align-self: center;
			}
			.overflow-auto {
				overflow: auto;
			}
			.overflow-scroll {
				overflow: scroll;
			}
			.overflow-y-scroll {
				overflow-y: scroll;
			}
			.whitespace-nowrap {
				white-space: nowrap;
			}
			.break-all {
				word-break: break-all;
			}
			.rounded {
				border-radius: 0.25rem;
			}
			.rounded-2xl {
				border-radius: 1rem;
			}
			.rounded-3xl {
				border-radius: 1.5rem;
			}
			.rounded-full {
				border-radius: 9999px;
			}
			.rounded-lg {
				border-radius: 0.5rem;
			}
			.rounded-sm {
				border-radius: 0.125rem;
			}
			.rounded-xl {
				border-radius: 0.75rem;
			}
			.rounded-b {
				border-bottom-right-radius: 0.25rem;
				border-bottom-left-radius: 0.25rem;
			}
			.rounded-b-2xl {
				border-bottom-right-radius: 1rem;
				border-bottom-left-radius: 1rem;
			}
			.rounded-b-3xl {
				border-bottom-right-radius: 1.5rem;
				border-bottom-left-radius: 1.5rem;
			}
			.rounded-l {
				border-top-left-radius: 0.25rem;
				border-bottom-left-radius: 0.25rem;
			}
			.rounded-r {
				border-top-right-radius: 0.25rem;
				border-bottom-right-radius: 0.25rem;
			}
			.rounded-t {
				border-top-left-radius: 0.25rem;
				border-top-right-radius: 0.25rem;
			}
			.rounded-t-2xl {
				border-top-left-radius: 1rem;
				border-top-right-radius: 1rem;
			}
			.rounded-t-3xl {
				border-top-left-radius: 1.5rem;
				border-top-right-radius: 1.5rem;
			}
			.rounded-bl-none {
				border-bottom-left-radius: 0px;
			}
			.rounded-tr-none {
				border-top-right-radius: 0px;
			}
			.border {
				border-width: 1px;
			}
			.border-2 {
				border-width: 2px;
			}
			.border-4 {
				border-width: 4px;
			}
			.border-b {
				border-bottom-width: 1px;
			}
			.border-b-0 {
				border-bottom-width: 0px;
			}
			.border-r {
				border-right-width: 1px;
			}
			.border-t {
				border-top-width: 1px;
			}
			.border-t-0 {
				border-top-width: 0px;
			}
			.border-t-\[0\.5px\] {
				border-top-width: 0.5px;
			}
			.border-none {
				border-style: none;
			}
			.border-\[\#BDD2D4\] {
				--tw-border-opacity: 1;
				border-color: rgb(189 210 212 / var(--tw-border-opacity));
			}
			.border-input {
				--tw-border-opacity: 1;
				border-color: rgb(189 210 212 / var(--tw-border-opacity));
			}
			.border-link {
				--tw-border-opacity: 1;
				border-color: rgb(0 153 175 / var(--tw-border-opacity));
			}
			.border-link\/50 {
				border-color: rgb(0 153 175 / 0.5);
			}
			.border-mapBorder {
				--tw-border-opacity: 1;
				border-color: rgb(232 232 232 / var(--tw-border-opacity));
			}
			.border-statBorder {
				--tw-border-opacity: 1;
				border-color: rgb(200 220 223 / var(--tw-border-opacity));
			}
			.border-t-link {
				--tw-border-opacity: 1;
				border-top-color: rgb(0 153 175 / var(--tw-border-opacity));
			}
			.border-t-link\/50 {
				border-top-color: rgb(0 153 175 / 0.5);
			}
			.border-t-statBorder {
				--tw-border-opacity: 1;
				border-top-color: rgb(200 220 223 / var(--tw-border-opacity));
			}
			.\!bg-dark {
				--tw-bg-opacity: 1 !important;
				background-color: rgb(6 23 28 / var(--tw-bg-opacity)) !important;
			}
			.\!bg-teal {
				--tw-bg-opacity: 1 !important;
				background-color: rgb(228 235 236 / var(--tw-bg-opacity)) !important;
			}
			.bg-\[\#10B981\] {
				--tw-bg-opacity: 1;
				background-color: rgb(16 185 129 / var(--tw-bg-opacity));
			}
			.bg-\[\#164E63\] {
				--tw-bg-opacity: 1;
				background-color: rgb(22 78 99 / var(--tw-bg-opacity));
			}
			.bg-\[\#53C5D5\] {
				--tw-bg-opacity: 1;
				background-color: rgb(83 197 213 / var(--tw-bg-opacity));
			}
			.bg-\[\#AFBBC9\] {
				--tw-bg-opacity: 1;
				background-color: rgb(175 187 201 / var(--tw-bg-opacity));
			}
			.bg-\[\#EBEFF2\] {
				--tw-bg-opacity: 1;
				background-color: rgb(235 239 242 / var(--tw-bg-opacity));
			}
			.bg-\[\#F1F7FC\] {
				--tw-bg-opacity: 1;
				background-color: rgb(241 247 252 / var(--tw-bg-opacity));
			}
			.bg-\[\#ffab01\] {
				--tw-bg-opacity: 1;
				background-color: rgb(255 171 1 / var(--tw-bg-opacity));
			}
			.bg-bitcoin {
				--tw-bg-opacity: 1;
				background-color: rgb(247 147 26 / var(--tw-bg-opacity));
			}
			.bg-black {
				--tw-bg-opacity: 1;
				background-color: rgb(0 0 0 / var(--tw-bg-opacity));
			}
			.bg-created {
				--tw-bg-opacity: 1;
				background-color: rgb(16 183 145 / var(--tw-bg-opacity));
			}
			.bg-dark {
				--tw-bg-opacity: 1;
				background-color: rgb(6 23 28 / var(--tw-bg-opacity));
			}
			.bg-deleted {
				--tw-bg-opacity: 1;
				background-color: rgb(235 87 87 / var(--tw-bg-opacity));
			}
			.bg-lightBlue {
				--tw-bg-opacity: 1;
				background-color: rgb(212 225 226 / var(--tw-bg-opacity));
			}
			.bg-link {
				--tw-bg-opacity: 1;
				background-color: rgb(0 153 175 / var(--tw-bg-opacity));
			}
			.bg-link\/25 {
				background-color: rgb(0 153 175 / 0.25);
			}
			.bg-link\/50 {
				background-color: rgb(0 153 175 / 0.5);
			}
			.bg-mobileButtons {
				--tw-bg-opacity: 1;
				background-color: rgb(214 228 230 / var(--tw-bg-opacity));
			}
			.bg-nostr {
				--tw-bg-opacity: 1;
				background-color: rgb(139 92 246 / var(--tw-bg-opacity));
			}
			.bg-offwhite {
				--tw-bg-opacity: 1;
				background-color: rgb(240 246 246 / var(--tw-bg-opacity));
			}
			.bg-primary {
				--tw-bg-opacity: 1;
				background-color: rgb(20 64 70 / var(--tw-bg-opacity));
			}
			.bg-supporter {
				--tw-bg-opacity: 1;
				background-color: rgb(9 93 115 / var(--tw-bg-opacity));
			}
			.bg-supporter\/50 {
				background-color: rgb(9 93 115 / 0.5);
			}
			.bg-teal {
				--tw-bg-opacity: 1;
				background-color: rgb(228 235 236 / var(--tw-bg-opacity));
			}
			.bg-teal\/90 {
				background-color: rgb(228 235 236 / 0.9);
			}
			.bg-twitter {
				--tw-bg-opacity: 1;
				background-color: rgb(29 161 242 / var(--tw-bg-opacity));
			}
			.bg-white {
				--tw-bg-opacity: 1;
				background-color: rgb(255 255 255 / var(--tw-bg-opacity));
			}
			.bg-white\/30 {
				background-color: rgb(255 255 255 / 0.3);
			}
			.object-cover {
				-o-object-fit: cover;
				object-fit: cover;
			}
			.p-0 {
				padding: 0px;
			}
			.p-1 {
				padding: 0.25rem;
			}
			.p-10 {
				padding: 2.5rem;
			}
			.p-2 {
				padding: 0.5rem;
			}
			.p-3 {
				padding: 0.75rem;
			}
			.p-4 {
				padding: 1rem;
			}
			.p-5 {
				padding: 1.25rem;
			}
			.p-6 {
				padding: 1.5rem;
			}
			.px-0 {
				padding-left: 0px;
				padding-right: 0px;
			}
			.px-2 {
				padding-left: 0.5rem;
				padding-right: 0.5rem;
			}
			.px-3 {
				padding-left: 0.75rem;
				padding-right: 0.75rem;
			}
			.px-3\.5 {
				padding-left: 0.875rem;
				padding-right: 0.875rem;
			}
			.px-4 {
				padding-left: 1rem;
				padding-right: 1rem;
			}
			.px-5 {
				padding-left: 1.25rem;
				padding-right: 1.25rem;
			}
			.px-8 {
				padding-left: 2rem;
				padding-right: 2rem;
			}
			.py-0 {
				padding-top: 0px;
				padding-bottom: 0px;
			}
			.py-1 {
				padding-top: 0.25rem;
				padding-bottom: 0.25rem;
			}
			.py-10 {
				padding-top: 2.5rem;
				padding-bottom: 2.5rem;
			}
			.py-2 {
				padding-top: 0.5rem;
				padding-bottom: 0.5rem;
			}
			.py-2\.5 {
				padding-top: 0.625rem;
				padding-bottom: 0.625rem;
			}
			.py-20 {
				padding-top: 5rem;
				padding-bottom: 5rem;
			}
			.py-3 {
				padding-top: 0.75rem;
				padding-bottom: 0.75rem;
			}
			.py-4 {
				padding-top: 1rem;
				padding-bottom: 1rem;
			}
			.py-5 {
				padding-top: 1.25rem;
				padding-bottom: 1.25rem;
			}
			.py-6 {
				padding-top: 1.5rem;
				padding-bottom: 1.5rem;
			}
			.pb-0 {
				padding-bottom: 0px;
			}
			.pb-10 {
				padding-bottom: 2.5rem;
			}
			.pb-14 {
				padding-bottom: 3.5rem;
			}
			.pb-20 {
				padding-bottom: 5rem;
			}
			.pb-32 {
				padding-bottom: 8rem;
			}
			.pb-5 {
				padding-bottom: 1.25rem;
			}
			.pl-0 {
				padding-left: 0px;
			}
			.pl-0\.5 {
				padding-left: 0.125rem;
			}
			.pt-0 {
				padding-top: 0px;
			}
			.pt-10 {
				padding-top: 2.5rem;
			}
			.pt-14 {
				padding-top: 3.5rem;
			}
			.pt-20 {
				padding-top: 5rem;
			}
			.pt-8 {
				padding-top: 2rem;
			}
			.text-left {
				text-align: left;
			}
			.text-center {
				text-align: center;
			}
			.text-right {
				text-align: right;
			}
			.text-2xl {
				font-size: 24px;
				line-height: 32px;
			}
			.text-3xl {
				font-size: 30px;
				line-height: 36px;
			}
			.text-4xl {
				font-size: 36px;
				line-height: 40px;
			}
			.text-5xl {
				font-size: 48px;
				line-height: 1;
			}
			.text-\[16px\] {
				font-size: 16px;
			}
			.text-base {
				font-size: 16px;
				line-height: 24px;
			}
			.text-lg {
				font-size: 18px;
				line-height: 28px;
			}
			.text-sm {
				font-size: 14px;
				line-height: 20px;
			}
			.text-xl {
				font-size: 20px;
				line-height: 28px;
			}
			.text-xs {
				font-size: 12px;
				line-height: 16px;
			}
			.font-bold {
				font-weight: 700;
			}
			.font-normal {
				font-weight: 400;
			}
			.font-semibold {
				font-weight: 600;
			}
			.uppercase {
				text-transform: uppercase;
			}
			.lowercase {
				text-transform: lowercase;
			}
			.normal-case {
				text-transform: none;
			}
			.\!leading-tight {
				line-height: 1.25 !important;
			}
			.leading-none {
				line-height: 1;
			}
			.leading-snug {
				line-height: 1.375;
			}
			.\!text-link {
				--tw-text-opacity: 1 !important;
				color: rgb(0 153 175 / var(--tw-text-opacity)) !important;
			}
			.\!text-primary {
				--tw-text-opacity: 1 !important;
				color: rgb(20 64 70 / var(--tw-text-opacity)) !important;
			}
			.\!text-white {
				--tw-text-opacity: 1 !important;
				color: rgb(255 255 255 / var(--tw-text-opacity)) !important;
			}
			.text-\[\#144046\] {
				--tw-text-opacity: 1;
				color: rgb(20 64 70 / var(--tw-text-opacity));
			}
			.text-bitcoin {
				--tw-text-opacity: 1;
				color: rgb(247 147 26 / var(--tw-text-opacity));
			}
			.text-black {
				--tw-text-opacity: 1;
				color: rgb(0 0 0 / var(--tw-text-opacity));
			}
			.text-body {
				--tw-text-opacity: 1;
				color: rgb(62 98 103 / var(--tw-text-opacity));
			}
			.text-error {
				--tw-text-opacity: 1;
				color: rgb(223 60 60 / var(--tw-text-opacity));
			}
			.text-green-500 {
				--tw-text-opacity: 1;
				color: rgb(34 197 94 / var(--tw-text-opacity));
			}
			.text-grey {
				--tw-text-opacity: 1;
				color: rgb(159 180 182 / var(--tw-text-opacity));
			}
			.text-hover {
				--tw-text-opacity: 1;
				color: rgb(0 183 210 / var(--tw-text-opacity));
			}
			.text-input {
				--tw-text-opacity: 1;
				color: rgb(189 210 212 / var(--tw-text-opacity));
			}
			.text-link {
				--tw-text-opacity: 1;
				color: rgb(0 153 175 / var(--tw-text-opacity));
			}
			.text-link\/50 {
				color: rgb(0 153 175 / 0.5);
			}
			.text-map {
				--tw-text-opacity: 1;
				color: rgb(51 51 51 / var(--tw-text-opacity));
			}
			.text-mapButton {
				--tw-text-opacity: 1;
				color: rgb(95 95 95 / var(--tw-text-opacity));
			}
			.text-mapLabel {
				--tw-text-opacity: 1;
				color: rgb(164 164 164 / var(--tw-text-opacity));
			}
			.text-mobileMenu {
				--tw-text-opacity: 1;
				color: rgb(8 93 105 / var(--tw-text-opacity));
			}
			.text-primary {
				--tw-text-opacity: 1;
				color: rgb(20 64 70 / var(--tw-text-opacity));
			}
			.text-searchSubtext {
				--tw-text-opacity: 1;
				color: rgb(153 153 153 / var(--tw-text-opacity));
			}
			.text-statNegative {
				--tw-text-opacity: 1;
				color: rgb(235 87 87 / var(--tw-text-opacity));
			}
			.text-statPositive {
				--tw-text-opacity: 1;
				color: rgb(11 144 114 / var(--tw-text-opacity));
			}
			.text-taggerTime {
				--tw-text-opacity: 1;
				color: rgb(124 156 160 / var(--tw-text-opacity));
			}
			.text-white {
				--tw-text-opacity: 1;
				color: rgb(255 255 255 / var(--tw-text-opacity));
			}
			.underline {
				text-decoration-line: underline;
			}
			.\!no-underline {
				text-decoration-line: none !important;
			}
			.no-underline {
				text-decoration-line: none;
			}
			.decoration-4 {
				text-decoration-thickness: 4px;
			}
			.underline-offset-4 {
				text-underline-offset: 4px;
			}
			.accent-link {
				accent-color: #0099af;
			}
			.opacity-10 {
				opacity: 0.1;
			}
			.opacity-25 {
				opacity: 0.25;
			}
			.opacity-50 {
				opacity: 0.5;
			}
			.opacity-75 {
				opacity: 0.75;
			}
			.opacity-80 {
				opacity: 0.8;
			}
			.shadow {
				--tw-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);
				--tw-shadow-colored:
					0 1px 3px 0 var(--tw-shadow-color), 0 1px 2px -1px var(--tw-shadow-color);
				box-shadow:
					var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000),
					var(--tw-shadow);
			}
			.shadow-2xl {
				--tw-shadow: 0 25px 50px -12px rgb(0 0 0 / 0.25);
				--tw-shadow-colored: 0 25px 50px -12px var(--tw-shadow-color);
				box-shadow:
					var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000),
					var(--tw-shadow);
			}
			.shadow-lg {
				--tw-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
				--tw-shadow-colored:
					0 10px 15px -3px var(--tw-shadow-color), 0 4px 6px -4px var(--tw-shadow-color);
				box-shadow:
					var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000),
					var(--tw-shadow);
			}
			.shadow-xl {
				--tw-shadow: 0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1);
				--tw-shadow-colored:
					0 20px 25px -5px var(--tw-shadow-color), 0 8px 10px -6px var(--tw-shadow-color);
				box-shadow:
					var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000),
					var(--tw-shadow);
			}
			.outline {
				outline-style: solid;
			}
			.drop-shadow {
				--tw-drop-shadow: drop-shadow(0 1px 2px rgb(0 0 0 / 0.1))
					drop-shadow(0 1px 1px rgb(0 0 0 / 0.06));
				filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale)
					var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia)
					var(--tw-drop-shadow);
			}
			.drop-shadow-2xl {
				--tw-drop-shadow: drop-shadow(0 25px 25px rgb(0 0 0 / 0.15));
				filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale)
					var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia)
					var(--tw-drop-shadow);
			}
			.drop-shadow-\[0px_0px_4px_rgba\(0\2c 0\2c 0\2c 0\.2\)\] {
				--tw-drop-shadow: drop-shadow(0px 0px 4px rgba(0, 0, 0, 0.2));
				filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale)
					var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia)
					var(--tw-drop-shadow);
			}
			.drop-shadow-\[0px_2px_6px_rgba\(0\2c 0\2c 0\2c 0\.15\)\] {
				--tw-drop-shadow: drop-shadow(0px 2px 6px rgba(0, 0, 0, 0.15));
				filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale)
					var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia)
					var(--tw-drop-shadow);
			}
			.drop-shadow-xl {
				--tw-drop-shadow: drop-shadow(0 20px 13px rgb(0 0 0 / 0.03))
					drop-shadow(0 8px 5px rgb(0 0 0 / 0.08));
				filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale)
					var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia)
					var(--tw-drop-shadow);
			}
			.filter {
				filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale)
					var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia)
					var(--tw-drop-shadow);
			}
			.transition {
				transition-property:
					color,
					background-color,
					border-color,
					text-decoration-color,
					fill,
					stroke,
					opacity,
					box-shadow,
					transform,
					filter,
					-webkit-backdrop-filter;
				transition-property:
					color, background-color, border-color, text-decoration-color, fill, stroke, opacity,
					box-shadow, transform, filter, backdrop-filter;
				transition-property:
					color,
					background-color,
					border-color,
					text-decoration-color,
					fill,
					stroke,
					opacity,
					box-shadow,
					transform,
					filter,
					backdrop-filter,
					-webkit-backdrop-filter;
				transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
				transition-duration: 150ms;
			}
			.transition-all {
				transition-property: all;
				transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
				transition-duration: 150ms;
			}
			.transition-colors {
				transition-property:
					color, background-color, border-color, text-decoration-color, fill, stroke;
				transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
				transition-duration: 150ms;
			}
			.transition-opacity {
				transition-property: opacity;
				transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
				transition-duration: 150ms;
			}
			.transition-shadow {
				transition-property: box-shadow;
				transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
				transition-duration: 150ms;
			}
			.transition-transform {
				transition-property: transform;
				transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
				transition-duration: 150ms;
			}
			.ease-in-out {
				transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
			}

			@font-face {
				font-family: 'Manrope';
				src: url('/fonts/Manrope-Regular.ttf') format('truetype');
			}

			html {
				font-family: Manrope, sans-serif;
				font-size: 16px;
			}

			::-moz-selection {
				color: white;
				background: #53c5d5;
			}

			::selection {
				color: white;
				background: #53c5d5;
			}

			.gradient {
				background: -webkit-linear-gradient(45deg, #0ecd71, #040273);
				-webkit-background-clip: text;
				-webkit-text-fill-color: transparent;
			}

			.gradient-bg {
				background: -webkit-linear-gradient(45deg, #0ecd71, #040273);
			}

			/* Hide scrollbar for Chrome, Safari and Opera */
			.hide-scroll::-webkit-scrollbar {
				display: none;
			}

			/* Hide scrollbar for IE, Edge and Firefox */
			.hide-scroll {
				-ms-overflow-style: none; /* IE and Edge */
				scrollbar-width: none; /* Firefox */
			}

			.div-icon {
				background-image: url('/icons/div-icon-pin.svg');
			}

			.boosted-icon {
				background-image: url('/icons/boosted-icon-pin.svg');
			}

			.center {
				position: absolute;
				top: 50%;
				left: 50%;
				transform: translateX(-50%) translateY(-50%);
			}

			.hover\:scale-110:hover {
				--tw-scale-x: 1.1;
				--tw-scale-y: 1.1;
				transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate))
					skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x))
					scaleY(var(--tw-scale-y));
			}

			@keyframes wiggle {
				0%,
				100% {
					transform: rotate(-3deg);
				}

				50% {
					transform: rotate(3deg);
				}
			}

			.hover\:animate-wiggle:hover {
				animation: wiggle 1s ease-in-out infinite;
			}

			.hover\:border-hover:hover {
				--tw-border-opacity: 1;
				border-color: rgb(0 183 210 / var(--tw-border-opacity));
			}

			.hover\:border-link:hover {
				--tw-border-opacity: 1;
				border-color: rgb(0 153 175 / var(--tw-border-opacity));
			}

			.hover\:border-white:hover {
				--tw-border-opacity: 1;
				border-color: rgb(255 255 255 / var(--tw-border-opacity));
			}

			.hover\:bg-hover:hover {
				--tw-bg-opacity: 1;
				background-color: rgb(0 183 210 / var(--tw-bg-opacity));
			}

			.hover\:bg-link:hover {
				--tw-bg-opacity: 1;
				background-color: rgb(0 153 175 / var(--tw-bg-opacity));
			}

			.hover\:bg-link\/50:hover {
				background-color: rgb(0 153 175 / 0.5);
			}

			.hover\:bg-searchHover:hover {
				--tw-bg-opacity: 1;
				background-color: rgb(248 248 248 / var(--tw-bg-opacity));
			}

			.hover\:\!text-hover:hover {
				--tw-text-opacity: 1 !important;
				color: rgb(0 183 210 / var(--tw-text-opacity)) !important;
			}

			.hover\:\!text-link:hover {
				--tw-text-opacity: 1 !important;
				color: rgb(0 153 175 / var(--tw-text-opacity)) !important;
			}

			.hover\:text-black:hover {
				--tw-text-opacity: 1;
				color: rgb(0 0 0 / var(--tw-text-opacity));
			}

			.hover\:text-hover:hover {
				--tw-text-opacity: 1;
				color: rgb(0 183 210 / var(--tw-text-opacity));
			}

			.hover\:text-link:hover {
				--tw-text-opacity: 1;
				color: rgb(0 153 175 / var(--tw-text-opacity));
			}

			.hover\:text-white:hover {
				--tw-text-opacity: 1;
				color: rgb(255 255 255 / var(--tw-text-opacity));
			}

			.hover\:no-underline:hover {
				text-decoration-line: none;
			}

			.hover\:opacity-80:hover {
				opacity: 0.8;
			}

			.hover\:shadow-2xl:hover {
				--tw-shadow: 0 25px 50px -12px rgb(0 0 0 / 0.25);
				--tw-shadow-colored: 0 25px 50px -12px var(--tw-shadow-color);
				box-shadow:
					var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000),
					var(--tw-shadow);
			}

			.hover\:drop-shadow-2xl:hover {
				--tw-drop-shadow: drop-shadow(0 25px 25px rgb(0 0 0 / 0.15));
				filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale)
					var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia)
					var(--tw-drop-shadow);
			}

			.focus\:outline-none:focus {
				outline: 2px solid transparent;
				outline-offset: 2px;
			}

			.focus\:outline-link:focus {
				outline-color: #0099af;
			}

			.focus\:drop-shadow-\[0px_2px_6px_rgba\(0\2c 0\2c 0\2c 0\.3\)\]:focus {
				--tw-drop-shadow: drop-shadow(0px 2px 6px rgba(0, 0, 0, 0.3));
				filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale)
					var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia)
					var(--tw-drop-shadow);
			}

			.active\:bg-mobileButtonsActive:active {
				--tw-bg-opacity: 1;
				background-color: rgb(195 220 223 / var(--tw-bg-opacity));
			}

			.dark .dark\:rounded-full {
				border-radius: 9999px;
			}

			.dark .dark\:border {
				border-width: 1px;
			}

			.dark .dark\:border-b {
				border-bottom-width: 1px;
			}

			.dark .dark\:border-l {
				border-left-width: 1px;
			}

			.dark .dark\:border-r {
				border-right-width: 1px;
			}

			.dark .dark\:border-t {
				border-top-width: 1px;
			}

			.dark .dark\:\!bg-\[\#202f33\] {
				--tw-bg-opacity: 1 !important;
				background-color: rgb(32 47 51 / var(--tw-bg-opacity)) !important;
			}

			.dark .dark\:\!bg-dark {
				--tw-bg-opacity: 1 !important;
				background-color: rgb(6 23 28 / var(--tw-bg-opacity)) !important;
			}

			.dark .dark\:bg-dark {
				--tw-bg-opacity: 1;
				background-color: rgb(6 23 28 / var(--tw-bg-opacity));
			}

			.dark .dark\:bg-dark\/90 {
				background-color: rgb(6 23 28 / 0.9);
			}

			.dark .dark\:bg-white {
				--tw-bg-opacity: 1;
				background-color: rgb(255 255 255 / var(--tw-bg-opacity));
			}

			.dark .dark\:bg-white\/10 {
				background-color: rgb(255 255 255 / 0.1);
			}

			.dark .dark\:bg-white\/\[0\.15\] {
				background-color: rgb(255 255 255 / 0.15);
			}

			.dark .dark\:p-0 {
				padding: 0px;
			}

			.dark .dark\:p-0\.5 {
				padding: 0.125rem;
			}

			.dark .dark\:font-normal {
				font-weight: 400;
			}

			.dark .dark\:\!text-white {
				--tw-text-opacity: 1 !important;
				color: rgb(255 255 255 / var(--tw-text-opacity)) !important;
			}

			.dark .dark\:text-link {
				--tw-text-opacity: 1;
				color: rgb(0 153 175 / var(--tw-text-opacity));
			}

			.dark .dark\:text-white {
				--tw-text-opacity: 1;
				color: rgb(255 255 255 / var(--tw-text-opacity));
			}

			.dark .dark\:text-white\/50 {
				color: rgb(255 255 255 / 0.5);
			}

			.dark .dark\:\!text-link {
				--tw-text-opacity: 1 !important;
				color: rgb(0 153 175 / var(--tw-text-opacity)) !important;
			}

			.dark .dark\:opacity-10 {
				opacity: 0.1;
			}

			.dark .dark\:hover\:\!bg-dark\/75:hover {
				background-color: rgb(6 23 28 / 0.75) !important;
			}

			.dark .dark\:hover\:bg-white\/\[0\.15\]:hover {
				background-color: rgb(255 255 255 / 0.15);
			}

			.dark .dark\:hover\:bg-link:hover {
				--tw-bg-opacity: 1;
				background-color: rgb(0 153 175 / var(--tw-bg-opacity));
			}

			.dark .dark\:hover\:\!text-link:hover {
				--tw-text-opacity: 1 !important;
				color: rgb(0 153 175 / var(--tw-text-opacity)) !important;
			}

			.dark .dark\:hover\:text-link:hover {
				--tw-text-opacity: 1;
				color: rgb(0 153 175 / var(--tw-text-opacity));
			}

			.dark .dark\:hover\:text-white\/80:hover {
				color: rgb(255 255 255 / 0.8);
			}

			@media (min-width: 768px) {
				.md\:mx-0 {
					margin-left: 0px;
					margin-right: 0px;
				}

				.md\:my-0 {
					margin-top: 0px;
					margin-bottom: 0px;
				}

				.md\:my-20 {
					margin-top: 5rem;
					margin-bottom: 5rem;
				}

				.md\:mr-0 {
					margin-right: 0px;
				}

				.md\:mr-1 {
					margin-right: 0.25rem;
				}

				.md\:mt-0 {
					margin-top: 0px;
				}

				.md\:block {
					display: block;
				}

				.md\:inline {
					display: inline;
				}

				.md\:flex {
					display: flex;
				}

				.md\:inline-flex {
					display: inline-flex;
				}

				.md\:hidden {
					display: none;
				}

				.md\:h-5 {
					height: 1.25rem;
				}

				.md\:h-\[275px\] {
					height: 275px;
				}

				.md\:h-\[300px\] {
					height: 300px;
				}

				.md\:h-\[30px\] {
					height: 30px;
				}

				.md\:h-\[380px\] {
					height: 380px;
				}

				.md\:h-\[400px\] {
					height: 400px;
				}

				.md\:h-\[450px\] {
					height: 450px;
				}

				.md\:h-\[56px\] {
					height: 56px;
				}

				.md\:h-\[588px\] {
					height: 588px;
				}

				.md\:h-\[600px\] {
					height: 600px;
				}

				.md\:w-2\/3 {
					width: 66.666667%;
				}

				.md\:w-20 {
					width: 5rem;
				}

				.md\:w-40 {
					width: 10rem;
				}

				.md\:w-96 {
					width: 24rem;
				}

				.md\:w-\[200px\] {
					width: 200px;
				}

				.md\:w-\[210px\] {
					width: 210px;
				}

				.md\:w-\[250px\] {
					width: 250px;
				}

				.md\:w-\[275px\] {
					width: 275px;
				}

				.md\:w-\[300px\] {
					width: 300px;
				}

				.md\:w-\[350px\] {
					width: 350px;
				}

				.md\:w-\[400px\] {
					width: 400px;
				}

				.md\:w-\[430px\] {
					width: 430px;
				}

				.md\:w-\[450px\] {
					width: 450px;
				}

				.md\:w-\[475px\] {
					width: 475px;
				}

				.md\:w-\[500px\] {
					width: 500px;
				}

				.md\:w-\[600px\] {
					width: 600px;
				}

				.md\:max-w-\[210px\] {
					max-width: 210px;
				}

				.md\:grid-cols-2 {
					grid-template-columns: repeat(2, minmax(0, 1fr));
				}

				.md\:justify-start {
					justify-content: flex-start;
				}

				.md\:justify-center {
					justify-content: center;
				}

				.md\:space-x-2 > :not([hidden]) ~ :not([hidden]) {
					--tw-space-x-reverse: 0;
					margin-right: calc(0.5rem * var(--tw-space-x-reverse));
					margin-left: calc(0.5rem * calc(1 - var(--tw-space-x-reverse)));
				}

				.md\:space-x-4 > :not([hidden]) ~ :not([hidden]) {
					--tw-space-x-reverse: 0;
					margin-right: calc(1rem * var(--tw-space-x-reverse));
					margin-left: calc(1rem * calc(1 - var(--tw-space-x-reverse)));
				}

				.md\:space-x-5 > :not([hidden]) ~ :not([hidden]) {
					--tw-space-x-reverse: 0;
					margin-right: calc(1.25rem * var(--tw-space-x-reverse));
					margin-left: calc(1.25rem * calc(1 - var(--tw-space-x-reverse)));
				}

				.md\:space-y-0 > :not([hidden]) ~ :not([hidden]) {
					--tw-space-y-reverse: 0;
					margin-top: calc(0px * calc(1 - var(--tw-space-y-reverse)));
					margin-bottom: calc(0px * var(--tw-space-y-reverse));
				}

				.md\:space-y-40 > :not([hidden]) ~ :not([hidden]) {
					--tw-space-y-reverse: 0;
					margin-top: calc(10rem * calc(1 - var(--tw-space-y-reverse)));
					margin-bottom: calc(10rem * var(--tw-space-y-reverse));
				}

				.md\:rounded-l {
					border-top-left-radius: 0.25rem;
					border-bottom-left-radius: 0.25rem;
				}

				.md\:rounded-r {
					border-top-right-radius: 0.25rem;
					border-bottom-right-radius: 0.25rem;
				}

				.md\:rounded-bl-none {
					border-bottom-left-radius: 0px;
				}

				.md\:rounded-tr-none {
					border-top-right-radius: 0px;
				}

				.md\:border-b-0 {
					border-bottom-width: 0px;
				}

				.md\:border-r {
					border-right-width: 1px;
				}

				.md\:p-10 {
					padding: 2.5rem;
				}

				.md\:px-0 {
					padding-left: 0px;
					padding-right: 0px;
				}

				.md\:py-1 {
					padding-top: 0.25rem;
					padding-bottom: 0.25rem;
				}

				.md\:py-3 {
					padding-top: 0.75rem;
					padding-bottom: 0.75rem;
				}

				.md\:pb-32 {
					padding-bottom: 8rem;
				}

				.md\:text-left {
					text-align: left;
				}

				.md\:text-right {
					text-align: right;
				}

				.md\:text-5xl {
					font-size: 48px;
					line-height: 1;
				}

				.md\:text-lg {
					font-size: 18px;
					line-height: 28px;
				}
			}

			@media (min-width: 1024px) {
				.lg\:\!my-auto {
					margin-top: auto !important;
					margin-bottom: auto !important;
				}

				.lg\:mx-0 {
					margin-left: 0px;
					margin-right: 0px;
				}

				.lg\:mx-auto {
					margin-left: auto;
					margin-right: auto;
				}

				.lg\:my-0 {
					margin-top: 0px;
					margin-bottom: 0px;
				}

				.lg\:mb-0 {
					margin-bottom: 0px;
				}

				.lg\:mr-5 {
					margin-right: 1.25rem;
				}

				.lg\:inline-block {
					display: inline-block;
				}

				.lg\:inline {
					display: inline;
				}

				.lg\:flex {
					display: flex;
				}

				.lg\:inline-flex {
					display: inline-flex;
				}

				.lg\:grid {
					display: grid;
				}

				.lg\:hidden {
					display: none;
				}

				.lg\:h-14 {
					height: 3.5rem;
				}

				.lg\:h-5 {
					height: 1.25rem;
				}

				.lg\:h-\[271\.5px\] {
					height: 271.5px;
				}

				.lg\:h-\[30px\] {
					height: 30px;
				}

				.lg\:w-1\/2 {
					width: 50%;
				}

				.lg\:w-10\/12 {
					width: 83.333333%;
				}

				.lg\:w-14 {
					width: 3.5rem;
				}

				.lg\:w-5 {
					width: 1.25rem;
				}

				.lg\:w-\[100px\] {
					width: 100px;
				}

				.lg\:w-\[475px\] {
					width: 475px;
				}

				.lg\:w-\[650px\] {
					width: 650px;
				}

				.lg\:w-\[675px\] {
					width: 675px;
				}

				.lg\:w-\[700px\] {
					width: 700px;
				}

				.lg\:w-\[75px\] {
					width: 75px;
				}

				.lg\:w-\[800px\] {
					width: 800px;
				}

				.lg\:w-\[830px\] {
					width: 830px;
				}

				.lg\:grid-cols-3 {
					grid-template-columns: repeat(3, minmax(0, 1fr));
				}

				.lg\:space-x-0 > :not([hidden]) ~ :not([hidden]) {
					--tw-space-x-reverse: 0;
					margin-right: calc(0px * var(--tw-space-x-reverse));
					margin-left: calc(0px * calc(1 - var(--tw-space-x-reverse)));
				}

				.lg\:space-x-10 > :not([hidden]) ~ :not([hidden]) {
					--tw-space-x-reverse: 0;
					margin-right: calc(2.5rem * var(--tw-space-x-reverse));
					margin-left: calc(2.5rem * calc(1 - var(--tw-space-x-reverse)));
				}

				.lg\:space-x-2 > :not([hidden]) ~ :not([hidden]) {
					--tw-space-x-reverse: 0;
					margin-right: calc(0.5rem * var(--tw-space-x-reverse));
					margin-left: calc(0.5rem * calc(1 - var(--tw-space-x-reverse)));
				}

				.lg\:space-x-4 > :not([hidden]) ~ :not([hidden]) {
					--tw-space-x-reverse: 0;
					margin-right: calc(1rem * var(--tw-space-x-reverse));
					margin-left: calc(1rem * calc(1 - var(--tw-space-x-reverse)));
				}

				.lg\:space-x-5 > :not([hidden]) ~ :not([hidden]) {
					--tw-space-x-reverse: 0;
					margin-right: calc(1.25rem * var(--tw-space-x-reverse));
					margin-left: calc(1.25rem * calc(1 - var(--tw-space-x-reverse)));
				}

				.lg\:space-y-0 > :not([hidden]) ~ :not([hidden]) {
					--tw-space-y-reverse: 0;
					margin-top: calc(0px * calc(1 - var(--tw-space-y-reverse)));
					margin-bottom: calc(0px * var(--tw-space-y-reverse));
				}

				.lg\:space-y-5 > :not([hidden]) ~ :not([hidden]) {
					--tw-space-y-reverse: 0;
					margin-top: calc(1.25rem * calc(1 - var(--tw-space-y-reverse)));
					margin-bottom: calc(1.25rem * var(--tw-space-y-reverse));
				}

				.lg\:rounded-full {
					border-radius: 9999px;
				}

				.lg\:border-b-0 {
					border-bottom-width: 0px;
				}

				.lg\:border-r {
					border-right-width: 1px;
				}

				.lg\:border-none {
					border-style: none;
				}

				.lg\:py-0 {
					padding-top: 0px;
					padding-bottom: 0px;
				}

				.lg\:pb-0 {
					padding-bottom: 0px;
				}

				.lg\:pt-0 {
					padding-top: 0px;
				}

				.lg\:text-left {
					text-align: left;
				}

				.lg\:no-underline {
					text-decoration-line: none;
				}

				.dark .dark\:lg\:rounded {
					border-radius: 0.25rem;
				}

				.dark .dark\:lg\:bg-white\/10 {
					background-color: rgb(255 255 255 / 0.1);
				}

				.dark .dark\:lg\:py-8 {
					padding-top: 2rem;
					padding-bottom: 2rem;
				}
			}

			@media (min-width: 1280px) {
				.xl\:mx-0 {
					margin-left: 0px;
					margin-right: 0px;
				}

				.xl\:mb-0 {
					margin-bottom: 0px;
				}

				.xl\:mt-0 {
					margin-top: 0px;
				}

				.xl\:block {
					display: block;
				}

				.xl\:flex {
					display: flex;
				}

				.xl\:hidden {
					display: none;
				}

				.xl\:w-3\/4 {
					width: 75%;
				}

				.xl\:w-\[100px\] {
					width: 100px;
				}

				.xl\:w-\[1200px\] {
					width: 1200px;
				}

				.xl\:w-\[500px\] {
					width: 500px;
				}

				.xl\:grid-cols-4 {
					grid-template-columns: repeat(4, minmax(0, 1fr));
				}

				.xl\:space-x-16 > :not([hidden]) ~ :not([hidden]) {
					--tw-space-x-reverse: 0;
					margin-right: calc(4rem * var(--tw-space-x-reverse));
					margin-left: calc(4rem * calc(1 - var(--tw-space-x-reverse)));
				}

				.xl\:space-x-5 > :not([hidden]) ~ :not([hidden]) {
					--tw-space-x-reverse: 0;
					margin-right: calc(1.25rem * var(--tw-space-x-reverse));
					margin-left: calc(1.25rem * calc(1 - var(--tw-space-x-reverse)));
				}

				.xl\:space-y-0 > :not([hidden]) ~ :not([hidden]) {
					--tw-space-y-reverse: 0;
					margin-top: calc(0px * calc(1 - var(--tw-space-y-reverse)));
					margin-bottom: calc(0px * var(--tw-space-y-reverse));
				}

				.xl\:border-b-0 {
					border-bottom-width: 0px;
				}

				.xl\:border-r {
					border-right-width: 1px;
				}

				.xl\:pt-0 {
					padding-top: 0px;
				}

				.xl\:text-left {
					text-align: left;
				}
			}

			._toastContainer.s--bA00mryVvOe {
				top: var(--toastContainerTop, 1.5rem);
				right: var(--toastContainerRight, 2rem);
				bottom: var(--toastContainerBottom, auto);
				left: var(--toastContainerLeft, auto);
				position: fixed;
				margin: 0;
				padding: 0;
				list-style-type: none;
				pointer-events: none;
				z-index: var(--toastContainerZIndex, 9999);
			}
			.s--bA00mryVvOe {
			}
			._toastItem.s-o5uJgpq4oQeR {
				width: var(--toastWidth, 16rem);
				height: var(--toastHeight, auto);
				min-height: var(--toastMinHeight, 3.5rem);
				margin: var(--toastMargin, 0 0 0.5rem 0);
				padding: var(--toastPadding, 0);
				background: var(--toastBackground, rgba(66, 66, 66, 0.9));
				color: var(--toastColor, #fff);
				box-shadow: var(
					--toastBoxShadow,
					0 4px 6px -1px rgba(0, 0, 0, 0.1),
					0 2px 4px -1px rgba(0, 0, 0, 0.06)
				);
				border: var(--toastBorder, none);
				border-radius: var(--toastBorderRadius, 0.125rem);
				position: relative;
				display: flex;
				flex-direction: row;
				align-items: center;
				overflow: hidden;
				will-change: transform, opacity;
				-webkit-tap-highlight-color: transparent;
			}
			._toastMsg.s-o5uJgpq4oQeR {
				padding: var(--toastMsgPadding, 0.75rem 0.5rem);
				flex: 1 1 0%;
			}
			.pe.s-o5uJgpq4oQeR,
			._toastMsg.s-o5uJgpq4oQeR a {
				pointer-events: auto;
			}
			._toastBtn.s-o5uJgpq4oQeR {
				width: var(--toastBtnWidth, 2rem);
				height: var(--toastBtnHeight, 100%);
				cursor: pointer;
				outline: none;
			}
			._toastBtn.s-o5uJgpq4oQeR::after {
				content: var(--toastBtnContent, 'âœ•');
				font: var(--toastBtnFont, 1rem sans-serif);
				display: flex;
				align-items: center;
				justify-content: center;
			}
			._toastBar.s-o5uJgpq4oQeR {
				top: var(--toastBarTop, auto);
				right: var(--toastBarRight, auto);
				bottom: var(--toastBarBottom, 0);
				left: var(--toastBarLeft, 0);
				height: var(--toastBarHeight, 6px);
				width: var(--toastBarWidth, 100%);
				position: absolute;
				display: block;
				-webkit-appearance: none;
				-moz-appearance: none;
				appearance: none;
				border: none;
				background: transparent;
				pointer-events: none;
			}
			._toastBar.s-o5uJgpq4oQeR::-webkit-progress-bar {
				background: transparent;
			}
			._toastBar.s-o5uJgpq4oQeR::-webkit-progress-value {
				background: var(
					--toastProgressBackground,
					var(--toastBarBackground, rgba(33, 150, 243, 0.75))
				);
			}
			._toastBar.s-o5uJgpq4oQeR::-moz-progress-bar {
				background: var(
					--toastProgressBackground,
					var(--toastBarBackground, rgba(33, 150, 243, 0.75))
				);
			}
			.s-o5uJgpq4oQeR {
			}
			.tippy-box[data-animation='fade'][data-state='hidden'] {
				opacity: 0;
			}
			[data-tippy-root] {
				max-width: calc(100vw - 10px);
			}
			.tippy-box {
				position: relative;
				background-color: #333;
				color: #fff;
				border-radius: 4px;
				font-size: 14px;
				line-height: 1.4;
				white-space: normal;
				outline: 0;
				transition-property: transform, visibility, opacity;
			}
			.tippy-box[data-placement^='top'] > .tippy-arrow {
				bottom: 0;
			}
			.tippy-box[data-placement^='top'] > .tippy-arrow:before {
				bottom: -7px;
				left: 0;
				border-width: 8px 8px 0;
				border-top-color: initial;
				transform-origin: center top;
			}
			.tippy-box[data-placement^='bottom'] > .tippy-arrow {
				top: 0;
			}
			.tippy-box[data-placement^='bottom'] > .tippy-arrow:before {
				top: -7px;
				left: 0;
				border-width: 0 8px 8px;
				border-bottom-color: initial;
				transform-origin: center bottom;
			}
			.tippy-box[data-placement^='left'] > .tippy-arrow {
				right: 0;
			}
			.tippy-box[data-placement^='left'] > .tippy-arrow:before {
				border-width: 8px 0 8px 8px;
				border-left-color: initial;
				right: -7px;
				transform-origin: center left;
			}
			.tippy-box[data-placement^='right'] > .tippy-arrow {
				left: 0;
			}
			.tippy-box[data-placement^='right'] > .tippy-arrow:before {
				left: -7px;
				border-width: 8px 8px 8px 0;
				border-right-color: initial;
				transform-origin: center right;
			}
			.tippy-box[data-inertia][data-state='visible'] {
				transition-timing-function: cubic-bezier(0.54, 1.5, 0.38, 1.11);
			}
			.tippy-arrow {
				width: 16px;
				height: 16px;
				color: #333;
			}
			.tippy-arrow:before {
				content: '';
				position: absolute;
				border-color: transparent;
				border-style: solid;
			}
			.tippy-content {
				position: relative;
				padding: 5px 9px;
				z-index: 1;
			}
			.s-IuPAlcK389th {
			}
			.tippy-box[data-animation='fade'][data-state='hidden'] {
				opacity: 0;
			}
			[data-tippy-root] {
				max-width: calc(100vw - 10px);
			}
			.tippy-box {
				position: relative;
				background-color: #333;
				color: #fff;
				border-radius: 4px;
				font-size: 14px;
				line-height: 1.4;
				white-space: normal;
				outline: 0;
				transition-property: transform, visibility, opacity;
			}
			.tippy-box[data-placement^='top'] > .tippy-arrow {
				bottom: 0;
			}
			.tippy-box[data-placement^='top'] > .tippy-arrow:before {
				bottom: -7px;
				left: 0;
				border-width: 8px 8px 0;
				border-top-color: initial;
				transform-origin: center top;
			}
			.tippy-box[data-placement^='bottom'] > .tippy-arrow {
				top: 0;
			}
			.tippy-box[data-placement^='bottom'] > .tippy-arrow:before {
				top: -7px;
				left: 0;
				border-width: 0 8px 8px;
				border-bottom-color: initial;
				transform-origin: center bottom;
			}
			.tippy-box[data-placement^='left'] > .tippy-arrow {
				right: 0;
			}
			.tippy-box[data-placement^='left'] > .tippy-arrow:before {
				border-width: 8px 0 8px 8px;
				border-left-color: initial;
				right: -7px;
				transform-origin: center left;
			}
			.tippy-box[data-placement^='right'] > .tippy-arrow {
				left: 0;
			}
			.tippy-box[data-placement^='right'] > .tippy-arrow:before {
				left: -7px;
				border-width: 8px 8px 8px 0;
				border-right-color: initial;
				transform-origin: center right;
			}
			.tippy-box[data-inertia][data-state='visible'] {
				transition-timing-function: cubic-bezier(0.54, 1.5, 0.38, 1.11);
			}
			.tippy-arrow {
				width: 16px;
				height: 16px;
				color: #333;
			}
			.tippy-arrow:before {
				content: '';
				position: absolute;
				border-color: transparent;
				border-style: solid;
			}
			.tippy-content {
				position: relative;
				padding: 5px 9px;
				z-index: 1;
			}
			.s-bTo5KS4HDVB- {
			}
			.tippy-box[data-animation='fade'][data-state='hidden'] {
				opacity: 0;
			}
			[data-tippy-root] {
				max-width: calc(100vw - 10px);
			}
			.tippy-box {
				position: relative;
				background-color: #333;
				color: #fff;
				border-radius: 4px;
				font-size: 14px;
				line-height: 1.4;
				white-space: normal;
				outline: 0;
				transition-property: transform, visibility, opacity;
			}
			.tippy-box[data-placement^='top'] > .tippy-arrow {
				bottom: 0;
			}
			.tippy-box[data-placement^='top'] > .tippy-arrow:before {
				bottom: -7px;
				left: 0;
				border-width: 8px 8px 0;
				border-top-color: initial;
				transform-origin: center top;
			}
			.tippy-box[data-placement^='bottom'] > .tippy-arrow {
				top: 0;
			}
			.tippy-box[data-placement^='bottom'] > .tippy-arrow:before {
				top: -7px;
				left: 0;
				border-width: 0 8px 8px;
				border-bottom-color: initial;
				transform-origin: center bottom;
			}
			.tippy-box[data-placement^='left'] > .tippy-arrow {
				right: 0;
			}
			.tippy-box[data-placement^='left'] > .tippy-arrow:before {
				border-width: 8px 0 8px 8px;
				border-left-color: initial;
				right: -7px;
				transform-origin: center left;
			}
			.tippy-box[data-placement^='right'] > .tippy-arrow {
				left: 0;
			}
			.tippy-box[data-placement^='right'] > .tippy-arrow:before {
				left: -7px;
				border-width: 8px 8px 8px 0;
				border-right-color: initial;
				transform-origin: center right;
			}
			.tippy-box[data-inertia][data-state='visible'] {
				transition-timing-function: cubic-bezier(0.54, 1.5, 0.38, 1.11);
			}
			.tippy-arrow {
				width: 16px;
				height: 16px;
				color: #333;
			}
			.tippy-arrow:before {
				content: '';
				position: absolute;
				border-color: transparent;
				border-style: solid;
			}
			.tippy-content {
				position: relative;
				padding: 5px 9px;
				z-index: 1;
			}
			.s-9coVUeQFfuX9 {
			}
			.tippy-box[data-animation='fade'][data-state='hidden'] {
				opacity: 0;
			}
			[data-tippy-root] {
				max-width: calc(100vw - 10px);
			}
			.tippy-box {
				position: relative;
				background-color: #333;
				color: #fff;
				border-radius: 4px;
				font-size: 14px;
				line-height: 1.4;
				white-space: normal;
				outline: 0;
				transition-property: transform, visibility, opacity;
			}
			.tippy-box[data-placement^='top'] > .tippy-arrow {
				bottom: 0;
			}
			.tippy-box[data-placement^='top'] > .tippy-arrow:before {
				bottom: -7px;
				left: 0;
				border-width: 8px 8px 0;
				border-top-color: initial;
				transform-origin: center top;
			}
			.tippy-box[data-placement^='bottom'] > .tippy-arrow {
				top: 0;
			}
			.tippy-box[data-placement^='bottom'] > .tippy-arrow:before {
				top: -7px;
				left: 0;
				border-width: 0 8px 8px;
				border-bottom-color: initial;
				transform-origin: center bottom;
			}
			.tippy-box[data-placement^='left'] > .tippy-arrow {
				right: 0;
			}
			.tippy-box[data-placement^='left'] > .tippy-arrow:before {
				border-width: 8px 0 8px 8px;
				border-left-color: initial;
				right: -7px;
				transform-origin: center left;
			}
			.tippy-box[data-placement^='right'] > .tippy-arrow {
				left: 0;
			}
			.tippy-box[data-placement^='right'] > .tippy-arrow:before {
				left: -7px;
				border-width: 8px 8px 8px 0;
				border-right-color: initial;
				transform-origin: center right;
			}
			.tippy-box[data-inertia][data-state='visible'] {
				transition-timing-function: cubic-bezier(0.54, 1.5, 0.38, 1.11);
			}
			.tippy-arrow {
				width: 16px;
				height: 16px;
				color: #333;
			}
			.tippy-arrow:before {
				content: '';
				position: absolute;
				border-color: transparent;
				border-style: solid;
			}
			.tippy-content {
				position: relative;
				padding: 5px 9px;
				z-index: 1;
			}
			.s-YmZUhGvHaPy- {
			}
			.tippy-box[data-animation='fade'][data-state='hidden'] {
				opacity: 0;
			}
			[data-tippy-root] {
				max-width: calc(100vw - 10px);
			}
			.tippy-box {
				position: relative;
				background-color: #333;
				color: #fff;
				border-radius: 4px;
				font-size: 14px;
				line-height: 1.4;
				white-space: normal;
				outline: 0;
				transition-property: transform, visibility, opacity;
			}
			.tippy-box[data-placement^='top'] > .tippy-arrow {
				bottom: 0;
			}
			.tippy-box[data-placement^='top'] > .tippy-arrow:before {
				bottom: -7px;
				left: 0;
				border-width: 8px 8px 0;
				border-top-color: initial;
				transform-origin: center top;
			}
			.tippy-box[data-placement^='bottom'] > .tippy-arrow {
				top: 0;
			}
			.tippy-box[data-placement^='bottom'] > .tippy-arrow:before {
				top: -7px;
				left: 0;
				border-width: 0 8px 8px;
				border-bottom-color: initial;
				transform-origin: center bottom;
			}
			.tippy-box[data-placement^='left'] > .tippy-arrow {
				right: 0;
			}
			.tippy-box[data-placement^='left'] > .tippy-arrow:before {
				border-width: 8px 0 8px 8px;
				border-left-color: initial;
				right: -7px;
				transform-origin: center left;
			}
			.tippy-box[data-placement^='right'] > .tippy-arrow {
				left: 0;
			}
			.tippy-box[data-placement^='right'] > .tippy-arrow:before {
				left: -7px;
				border-width: 8px 8px 8px 0;
				border-right-color: initial;
				transform-origin: center right;
			}
			.tippy-box[data-inertia][data-state='visible'] {
				transition-timing-function: cubic-bezier(0.54, 1.5, 0.38, 1.11);
			}
			.tippy-arrow {
				width: 16px;
				height: 16px;
				color: #333;
			}
			.tippy-arrow:before {
				content: '';
				position: absolute;
				border-color: transparent;
				border-style: solid;
			}
			.tippy-content {
				position: relative;
				padding: 5px 9px;
				z-index: 1;
			}
			.s-UdDNsCxEGJ1I {
			}
			.tippy-box[data-animation='fade'][data-state='hidden'] {
				opacity: 0;
			}
			[data-tippy-root] {
				max-width: calc(100vw - 10px);
			}
			.tippy-box {
				position: relative;
				background-color: #333;
				color: #fff;
				border-radius: 4px;
				font-size: 14px;
				line-height: 1.4;
				white-space: normal;
				outline: 0;
				transition-property: transform, visibility, opacity;
			}
			.tippy-box[data-placement^='top'] > .tippy-arrow {
				bottom: 0;
			}
			.tippy-box[data-placement^='top'] > .tippy-arrow:before {
				bottom: -7px;
				left: 0;
				border-width: 8px 8px 0;
				border-top-color: initial;
				transform-origin: center top;
			}
			.tippy-box[data-placement^='bottom'] > .tippy-arrow {
				top: 0;
			}
			.tippy-box[data-placement^='bottom'] > .tippy-arrow:before {
				top: -7px;
				left: 0;
				border-width: 0 8px 8px;
				border-bottom-color: initial;
				transform-origin: center bottom;
			}
			.tippy-box[data-placement^='left'] > .tippy-arrow {
				right: 0;
			}
			.tippy-box[data-placement^='left'] > .tippy-arrow:before {
				border-width: 8px 0 8px 8px;
				border-left-color: initial;
				right: -7px;
				transform-origin: center left;
			}
			.tippy-box[data-placement^='right'] > .tippy-arrow {
				left: 0;
			}
			.tippy-box[data-placement^='right'] > .tippy-arrow:before {
				left: -7px;
				border-width: 8px 8px 8px 0;
				border-right-color: initial;
				transform-origin: center right;
			}
			.tippy-box[data-inertia][data-state='visible'] {
				transition-timing-function: cubic-bezier(0.54, 1.5, 0.38, 1.11);
			}
			.tippy-arrow {
				width: 16px;
				height: 16px;
				color: #333;
			}
			.tippy-arrow:before {
				content: '';
				position: absolute;
				border-color: transparent;
				border-style: solid;
			}
			.tippy-content {
				position: relative;
				padding: 5px 9px;
				z-index: 1;
			}
			.s-KjPfieA6wgHW {
			}
			.lottie-player.s-qj4I1T-sSF2O {
				box-sizing: border-box;
				display: flex;
				flex-direction: column;
				transition: box-shadow 0.6s;
			}
			.lottie-player.is-zoomed.s-qj4I1T-sSF2O {
				position: absolute;
				top: 0;
				left: 0;
				right: 0;
				box-shadow: 0px 0px 56px -14px rgba(0, 0, 0, 0.6);
				margin: 100px;
				border-radius: 6px;
			}
			.animation.s-qj4I1T-sSF2O {
				overflow: hidden;
			}
			.lottie-player-error.s-qj4I1T-sSF2O {
				display: flex;
				justify-content: center;
				height: 100%;
				align-items: center;
			}
			.s-qj4I1T-sSF2O {
			}
			.lottie-player-controls.s-3wExF9IcTfDu.s-3wExF9IcTfDu {
				align-items: center;
				display: flex;
				justify-content: space-between;
				padding: 4px 8px;
				font-family:
					'Lucida Sans', 'Lucida Sans Regular', 'Lucida Grande', 'Lucida Sans Unicode', Geneva,
					Verdana, sans-serif !important;
			}
			.lottie-player-controls.s-3wExF9IcTfDu > div.s-3wExF9IcTfDu {
				margin-left: 4px;
			}
			.spacer.s-3wExF9IcTfDu.s-3wExF9IcTfDu {
				flex-grow: 1;
				width: 14px;
			}
			.btn.s-3wExF9IcTfDu.s-3wExF9IcTfDu {
				cursor: pointer;
				fill: #999;
				width: 14px;
			}
			.btn.s-3wExF9IcTfDu.s-3wExF9IcTfDu:hover {
				fill: #222;
			}
			.btn.active.s-3wExF9IcTfDu.s-3wExF9IcTfDu {
				fill: #555;
			}
			.progress.s-3wExF9IcTfDu.s-3wExF9IcTfDu {
				-webkit-appearance: none;
				-moz-apperance: none;
				width: 100%;
				margin: 0 10px;
				height: 4px;
				border-radius: 3px;
				cursor: pointer;
			}
			.progress.s-3wExF9IcTfDu.s-3wExF9IcTfDu:focus {
				outline: none;
				border: none;
			}
			.progress.s-3wExF9IcTfDu.s-3wExF9IcTfDu::-moz-range-track {
				cursor: pointer;
				background: none;
				border: none;
				outline: none;
			}
			.progress.s-3wExF9IcTfDu.s-3wExF9IcTfDu::-webkit-slider-thumb {
				-webkit-appearance: none !important;
				height: 13px;
				width: 13px;
				border: 0;
				border-radius: 50%;
				background: #0fccce;
				cursor: pointer;
			}
			.progress.s-3wExF9IcTfDu.s-3wExF9IcTfDu::-moz-range-thumb {
				-moz-appearance: none !important;
				height: 13px;
				width: 13px;
				border: 0;
				border-radius: 50%;
				background: #0fccce;
				cursor: pointer;
			}
			.progress.s-3wExF9IcTfDu.s-3wExF9IcTfDu::-ms-track {
				width: 100%;
				height: 3px;
				cursor: pointer;
				background: transparent;
				border-color: transparent;
				color: transparent;
			}
			.progress.s-3wExF9IcTfDu.s-3wExF9IcTfDu::-ms-fill-lower {
				background: #ccc;
				border-radius: 3px;
			}
			.progress.s-3wExF9IcTfDu.s-3wExF9IcTfDu::-ms-fill-upper {
				background: #ccc;
				border-radius: 3px;
			}
			.progress.s-3wExF9IcTfDu.s-3wExF9IcTfDu::-ms-thumb {
				border: 0;
				height: 15px;
				width: 15px;
				border-radius: 50%;
				background: #0fccce;
				cursor: pointer;
			}
			.progress.s-3wExF9IcTfDu.s-3wExF9IcTfDu:focus::-ms-fill-lower {
				background: #ccc;
			}
			.progress.s-3wExF9IcTfDu.s-3wExF9IcTfDu:focus::-ms-fill-upper {
				background: #ccc;
			}
			.popover.s-3wExF9IcTfDu.s-3wExF9IcTfDu {
				padding: 10px;
				background: #fff;
				font-family:
					'Lucida Sans', 'Lucida Sans Regular', 'Lucida Grande', 'Lucida Sans Unicode', Geneva,
					Verdana, sans-serif;
				font-size: 0.75rem;
				border-radius: 5px;
			}
			.popover-snapshot.s-3wExF9IcTfDu.s-3wExF9IcTfDu {
				width: 150px;
			}
			.popover-snapshot.s-3wExF9IcTfDu h5.s-3wExF9IcTfDu {
				margin: 5px 0 10px 0;
				font-size: 0.75rem;
			}
			.popover-snapshot.s-3wExF9IcTfDu a.s-3wExF9IcTfDu {
				display: block;
				text-decoration: none;
			}
			.popover-snapshot.s-3wExF9IcTfDu a.s-3wExF9IcTfDu:before {
				content: 'â¥¼';
				margin-right: 5px;
			}
			.popover-snapshot.s-3wExF9IcTfDu .note.s-3wExF9IcTfDu {
				display: block;
				margin-top: 10px;
				color: #999;
			}
			.popover-info.s-3wExF9IcTfDu.s-3wExF9IcTfDu {
				width: 250px;
			}
			.frame-number.s-3wExF9IcTfDu.s-3wExF9IcTfDu {
				outline: none;
				border: 1px #ccc solid;
				border-radius: 3px;
				width: 40px;
				text-align: center;
				color: #999;
				font-size: 0.7rem;
				padding: 0;
				font-family: inherit;
			}
			.popover-background.s-3wExF9IcTfDu.s-3wExF9IcTfDu {
				width: 350px;
			}
			.s-3wExF9IcTfDu.s-3wExF9IcTfDu {
			}
			.text-input.s-FAR6CNS3AKMk.s-FAR6CNS3AKMk {
				border: 1px #ccc solid;
				border-radius: 5px;
				padding: 3px;
				width: 60px;
				margin: 0;
			}
			.color-picker.s-FAR6CNS3AKMk.s-FAR6CNS3AKMk {
				display: flex;
				flex-direction: row;
				justify-content: space-between;
				height: 90px;
			}
			.color-selectors.s-FAR6CNS3AKMk.s-FAR6CNS3AKMk {
				display: flex;
				flex-direction: column;
				justify-content: space-between;
			}
			.color-component.s-FAR6CNS3AKMk.s-FAR6CNS3AKMk {
				display: flex;
				flex-direction: row;
				font-size: 12px;
				align-items: center;
				justify-content: center;
			}
			.color-component.s-FAR6CNS3AKMk strong.s-FAR6CNS3AKMk {
				width: 40px;
			}
			.color-component.s-FAR6CNS3AKMk input[type='range'].s-FAR6CNS3AKMk {
				margin: 0 0 0 10px;
			}
			.color-component.s-FAR6CNS3AKMk input[type='number'].s-FAR6CNS3AKMk {
				width: 50px;
				margin: 0 0 0 10px;
			}
			.color-preview.s-FAR6CNS3AKMk.s-FAR6CNS3AKMk {
				font-size: 12px;
				display: flex;
				flex-direction: column;
				align-items: center;
				justify-content: space-between;
			}
			.preview.s-FAR6CNS3AKMk.s-FAR6CNS3AKMk {
				height: 60px;
				width: 60px;
			}
			.s-FAR6CNS3AKMk.s-FAR6CNS3AKMk {
			}
			h4.s-KTHskE21cQF1 {
				font-size: 0.85rem;
				padding: 5px;
				margin: 0;
			}
			.property.s-KTHskE21cQF1 {
				display: flex;
				flex-direction: row;
				font-size: 0.75rem;
				align-items: center;
				justify-content: space-between;
				padding: 3px 5px;
			}
			.label.s-KTHskE21cQF1 {
				display: block;
				color: #999;
			}
			.value.s-KTHskE21cQF1 {
				display: block;
				color: #666;
			}
			.s-KTHskE21cQF1 {
			}
			.popover.s-oupNGAfIHUau.s-oupNGAfIHUau {
				position: relative;
			}
			.popover-content.s-oupNGAfIHUau.s-oupNGAfIHUau {
				display: inline-block;
				position: absolute;
				opacity: 1;
				visibility: visible;
				transform: translate(0, -10px);
				box-shadow: 0 2px 5px 0 rgba(0, 0, 0, 0.26);
				transition: all 0.3s cubic-bezier(0.75, -0.02, 0.2, 0.97);
			}
			.popover-content.hidden.s-oupNGAfIHUau.s-oupNGAfIHUau {
				opacity: 0;
				visibility: hidden;
				transform: translate(0, 0px);
			}
			.arrow.s-oupNGAfIHUau.s-oupNGAfIHUau {
				position: absolute;
				z-index: -1;
				content: '';
				bottom: -9px;
				border-style: solid;
				border-width: 10px 10px 0px 10px;
			}
			.left-align.s-oupNGAfIHUau.s-oupNGAfIHUau,
			.left-align.s-oupNGAfIHUau .arrow.s-oupNGAfIHUau {
				left: 0;
				right: unset;
			}
			.right-align.s-oupNGAfIHUau.s-oupNGAfIHUau,
			.right-align.s-oupNGAfIHUau .arrow.s-oupNGAfIHUau {
				right: 0;
				left: unset;
			}
			.s-oupNGAfIHUau.s-oupNGAfIHUau {
			}
		</style>
		<title>BTC Map - Offline</title>
		<!-- HEAD_svelte-12p4y40_START -->
		<meta
			name="lightning"
			content="lnurlp:LNURL1DP68GURN8GHJ7CM0WFJJUCN5VDKKZUPWDAEXWTMVDE6HYMRS9ARKXVN4W5EQPSYZ34"
			class="s-7IPF32Wcq3s8"
		/>
		<meta property="alby:image" content="/images/logo.svg" class="s-7IPF32Wcq3s8" />
		<meta property="alby:name" content="BTC Map" class="s-7IPF32Wcq3s8" />
		<!-- HEAD_svelte-12p4y40_END -->
		<!-- HEAD_svelte-1gr44ch_START -->
		<meta property="og:image" content="https://btcmap.org/images/og/home.png" />
		<meta property="twitter:title" content="BTC Map" />
		<meta property="twitter:image" content="https://btcmap.org/images/og/home.png" />
		<!-- HEAD_svelte-1gr44ch_END -->
	</head>
	<body class="bg-teal dark:bg-dark">
		<div>
			<div class="bg-teal dark:bg-dark">
				<div class="relative mx-auto w-10/12 xl:w-[1200px]">
					<header>
						<a href="/map"><img src="/images/logo.svg" alt="logo" class="mx-auto w-32 py-5" /></a>
					</header>

					<div class="space-y-10 py-10 text-center">
						<button
							id="back"
							class="inline-flex items-center text-xl font-semibold text-link transition-colors hover:text-hover"
						>
							<svg class="mr-3" width="12.5px" height="20px">
								<use width="12.5px" height="20px" href="/icons/spritesheet-socials.svg#back"></use>
							</svg>
							Back
						</button>
						<script>
							document.querySelector('#back').onclick = () => window.history.back();
						</script>
						<h1 class="text-4xl text-primary md:text-5xl dark:text-white">You are offline.</h1>
						<h2
							class="text-xl font-semibold text-primary dark:text-white"
							style="max-width: 512px; margin-left: auto; margin-right: auto"
						>
							Please connect to the internet or navigate to a page that you have cached while
							online.
						</h2>
					</div>

					<footer class="flex flex-wrap justify-center gap-5 pb-5">
						<a
							href="https://x.com/btcmap"
							target="_blank"
							rel="noreferrer"
							class="inline-block rounded-full bg-link p-2 text-white transition-colors hover:bg-hover dark:bg-white/[0.15] dark:hover:bg-link"
							><svg width="28px" height="28px">
								<use width="28px" height="28px" href="/icons/spritesheet-socials.svg#x"></use></svg
						></a>
						<a
							href="https://nostr.com/npub1864jglrrhv6alguwql9pqtmd5296nww5dpcewapmmcazk8vq4mks0tt2tq"
							target="_blank"
							rel="noreferrer"
							class="inline-block rounded-full bg-link p-2 text-white transition-colors hover:bg-hover dark:bg-white/[0.15] dark:hover:bg-link"
							><svg width="28px" height="28px">
								<use
									width="28px"
									height="28px"
									href="/icons/spritesheet-socials.svg#nostr"
								></use></svg
						></a>
						<a
							href="https://discord.gg/wPqva83uzq"
							target="_blank"
							rel="noreferrer"
							class="inline-block rounded-full bg-link p-2 text-white transition-colors hover:bg-hover dark:bg-white/[0.15] dark:hover:bg-link"
							><svg width="28px" height="28px">
								<use
									width="28px"
									height="28px"
									href="/icons/spritesheet-socials.svg#discord"
								></use></svg
						></a>
						<a
							href="https://github.com/teambtcmap"
							target="_blank"
							rel="noreferrer"
							class="inline-block rounded-full bg-link p-2 text-white transition-colors hover:bg-hover dark:bg-white/[0.15] dark:hover:bg-link"
							><svg width="28px" height="28px">
								<use
									width="28px"
									height="28px"
									href="/icons/spritesheet-socials.svg#github"
								></use></svg
						></a>
						<a
							href="https://amboss.space/community/edf8d227-9bc7-4cb2-af2a-66c1b455109a"
							target="_blank"
							rel="noreferrer"
							class="inline-block rounded-full bg-link p-2 text-white transition-colors hover:bg-hover dark:bg-white/[0.15] dark:hover:bg-link"
							><svg width="28px" height="28px">
								<use
									width="28px"
									height="28px"
									href="/icons/spritesheet-socials.svg#amboss"
								></use></svg
						></a>
					</footer>
				</div>
			</div>
			<ul class="_toastContainer s--bA00mryVvOe"></ul>
		</div>
	</body>
</html>



================================================
FILE: static/robots.txt
================================================
User-agent: *
Disallow:


================================================
FILE: static/assets/btcmap-media-assets.zip
================================================
[Binary file]


================================================
FILE: static/fonts/Manrope-Regular.ttf
================================================
[Binary file]


================================================
FILE: static/images/hero-mobile-example-dark.webp
================================================
[Binary file]


================================================
FILE: static/images/hero-mobile-example.webp
================================================
[Binary file]


================================================
FILE: static/nostr-badges/og-supertagger.webp
================================================
[Binary file]


================================================
FILE: tests/areas.spec.ts
================================================
import { test, expect } from '@playwright/test';

test.describe('Areas', () => {
	test('opens country area', async ({ page }) => {
		await page.goto('');

		const heading = page.getByRole('heading', {
			name: 'Find places to spend sats wherever you are.'
		});
		await heading.waitFor({ state: 'visible' });
		await expect(heading).toBeTruthy();

		await page.getByRole('button', { name: 'Areas' }).click();
		await page.getByRole('link', { name: 'Countries' }).click();
		await expect(page).toHaveURL(/countries/);

		// Wait for the countries page to load and find the South Africa link
		await page.waitForLoadState('domcontentloaded');
		await page.waitForTimeout(1000); // Give time for content to load

		const southAfricaLink = page.getByRole('link', { name: 'South Africa' });
		if ((await southAfricaLink.count()) > 0) {
			await southAfricaLink.waitFor({ state: 'visible' });
			await southAfricaLink.click();
			// Wait for navigation to complete
			await page.waitForLoadState('domcontentloaded');
			await expect(page).toHaveURL(/country\/za\/merchants/); // App redirects to merchants section
		} else {
			// If South Africa link not found, just verify we're on countries page
			await expect(page).toHaveURL(/countries/);
			return; // Skip rest of test
		}

		await page
			.getByRole('heading', {
				name: 'South Africa',
				exact: true
			})
			.waitFor({ state: 'visible' });
	});

	test('navigates through communities structure', async ({ page }) => {
		await page.goto('');

		const heading = page.getByRole('heading', {
			name: 'Find places to spend sats wherever you are.'
		});
		await heading.waitFor({ state: 'visible' });
		await expect(heading).toBeTruthy();

		await page.getByRole('button', { name: 'Areas' }).click();
		await page.getByRole('link', { name: 'Communities' }).click();
		await expect(page).toHaveURL(/communities/);

		const communityHeading = page.getByRole('heading', {
			name: 'Join the bitcoin map community.'
		});
		await communityHeading.waitFor({ state: 'visible' });
		await expect(communityHeading).toBeTruthy();

		// Wait for community data to load - areas API fetch can take a while from scratch
		// The areas sync fetches paginated data which can be slow on first load
		const communityLinks = page.locator('a[href^="/community/"]');

		// Check that at least some communities are visible (increased timeout for API fetch)
		await expect(communityLinks.first()).toBeVisible({ timeout: 60000 });

		// Click the first community and verify navigation works
		await communityLinks.first().click();

		// Wait for URL to change to a community page - this confirms navigation worked
		await expect(page).toHaveURL(/\/community\/[^/]+/, { timeout: 20000 });

		// Verify the community page heading is visible
		const communityPageHeading = page.locator('h1').first();
		await expect(communityPageHeading).toBeVisible({ timeout: 10000 });
	});

	test('community leaderboard structure loads', async ({ page }) => {
		await page.goto('');

		const heading = page.getByRole('heading', {
			name: 'Find places to spend sats wherever you are.'
		});
		await heading.waitFor({ state: 'visible' });
		await expect(heading).toBeTruthy();

		await page.getByRole('button', { name: 'Areas' }).click();
		await page.getByRole('link', { name: 'Communities' }).click();
		await expect(page).toHaveURL(/communities/);

		await page.getByRole('link', { name: 'Leaderboard' }).click();
		await expect(page).toHaveURL(/communities\/leaderboard/);

		// Wait for the page heading to be visible
		await page
			.getByRole('heading', {
				name: 'Community Leaderboard'
			})
			.waitFor({ state: 'visible' });

		// Just check that basic leaderboard structure is present (don't wait for heavy data loading)
		// Simply verify the page loaded without errors - don't test specific elements
		const pageContent = page.locator('main');
		await expect(pageContent).toBeVisible({ timeout: 10000 });
	});
});



================================================
FILE: tests/boost-invoice.spec.ts
================================================
import { test, expect } from '@playwright/test';

const MERCHANT_ID = 23143;
const API_ENDPOINT = '/api/boost/invoice/generate';

test.describe('Boost Invoice Generation', () => {
	test('generates valid invoice through complete UI flow', async ({ page }) => {
		// Mock exchange rate API to avoid external dependency
		await page.route('**/blockchain.info/**', async (route) => {
			await route.fulfill({
				status: 200,
				contentType: 'application/json',
				body: JSON.stringify({
					USD: { '15m': 65000 }
				})
			});
		});

		// Navigate to merchant detail page
		await page.goto(`/merchant/${MERCHANT_ID}`);
		await expect(page).toHaveTitle(/BTC Map/);

		// Wait for merchant data to load completely
		await expect(page.getByRole('heading', { name: 'Green Town', exact: true })).toBeVisible();
		await expect(page.getByText('Last Surveyed')).toBeVisible();

		// Wait for boost button to be interactive
		const boostButton = page.locator('#boost-button');
		await expect(boostButton).toBeVisible();
		await expect(boostButton).toBeEnabled();

		// Small delay for Svelte component hydration - the button can be enabled before the merchant
		// prop is passed down from SSR data, which causes the click handler to return early
		await page.waitForTimeout(800);

		// Click boost button and wait for modal
		await boostButton.click();
		await expect(page.locator('text=Boost Location')).toBeVisible({ timeout: 10000 });

		// Select first boost option (30 days / $5)
		const boostOption = page.locator('button').filter({ hasText: '5,000 sats' }).first();
		await expect(boostOption).toBeVisible();
		await boostOption.click({ force: true });

		// Wait for confirm button and set up API interception
		const confirmButton = page.locator('button', { hasText: /Boost for 1 month/ });
		await expect(confirmButton).toBeVisible();

		const [invoiceRequest, invoiceResponse] = await Promise.all([
			page.waitForRequest((req) => req.url().includes(API_ENDPOINT) && req.method() === 'POST', {
				timeout: 10000
			}),
			page.waitForResponse((res) => res.url().includes(API_ENDPOINT) && res.status() === 200, {
				timeout: 10000
			}),
			confirmButton.click()
		]);

		// Verify request payload
		const requestBody = invoiceRequest.postDataJSON();
		expect(requestBody).toEqual({
			place_id: MERCHANT_ID,
			days: 30
		});

		// Verify response structure
		const responseBody = await invoiceResponse.json();
		expect(responseBody).toMatchObject({
			invoice: expect.stringMatching(/^lnbc/),
			invoice_id: expect.stringMatching(
				/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i
			)
		});

		// Verify UI updates
		await expect(page.locator('text=Scan or click to pay with lightning')).toBeVisible();
		await expect(page.locator('canvas').first()).toBeVisible();
	});

	test('validates missing required parameters', async ({ page }) => {
		const response = await page.request.post(API_ENDPOINT, {
			data: { place_id: MERCHANT_ID }
		});

		expect(response.status()).toBe(400);
		const body = await response.json();
		expect(body.message).toContain('Missing required parameters');
	});

	test('validates invalid days parameter', async ({ page }) => {
		const response = await page.request.post(API_ENDPOINT, {
			data: {
				place_id: MERCHANT_ID,
				days: -1
			}
		});

		expect(response.status()).toBe(400);
		const body = await response.json();
		expect(body.message).toContain('Invalid days parameter');
	});
});



================================================
FILE: tests/communities.spec.ts
================================================
import { test, expect } from '@playwright/test';

test.describe('Communities Page', () => {
	test('loads communities page successfully', async ({ page }) => {
		await page.goto('/communities');

		// Wait for page to load
		await page.waitForSelector('main', { timeout: 10000 });
		await page.waitForTimeout(500);

		// Check page title
		const pageTitle = await page.title();
		expect(pageTitle).toContain('BTC Map - Communities');

		// Check main heading
		await expect(
			page.getByRole('heading', { name: /join the bitcoin map community/i })
		).toBeVisible();

		// Check subtitle
		await expect(
			page.getByText(/take ownership of your local bitcoin mapping data/i)
		).toBeVisible();

		// Check that content has loaded
		const bodyContent = await page.locator('body').textContent();
		expect(bodyContent).toBeTruthy();
		expect(bodyContent!.length).toBeGreaterThan(100);
	});

	test('displays navigation buttons', async ({ page }) => {
		await page.goto('/communities');
		await page.waitForSelector('main', { timeout: 10000 });
		await page.waitForTimeout(500);

		// Check primary navigation buttons
		const leaderboardBtn = page.getByRole('link', { name: 'Leaderboard' });
		await expect(leaderboardBtn).toBeVisible();
		await expect(leaderboardBtn).toHaveAttribute('href', '/communities/leaderboard');

		const addCommunityBtn = page.getByRole('link', { name: 'Add community' });
		await expect(addCommunityBtn).toBeVisible();
		await expect(addCommunityBtn).toHaveAttribute('href', '/communities/add');

		const viewMapBtn = page.getByRole('link', { name: 'View community map' });
		await expect(viewMapBtn).toBeVisible();
		await expect(viewMapBtn).toHaveAttribute('href', '/communities/map');
	});

	test('renders communities chart', async ({ page }) => {
		await page.goto('/communities');
		await page.waitForSelector('main', { timeout: 10000 });
		await page.waitForTimeout(500);

		// Wait for chart to render
		await page.waitForTimeout(2000);

		// Check that chart canvas is present
		const chartCanvas = page.locator('canvas');
		await expect(chartCanvas).toBeVisible();

		// Check that chart has proper dimensions
		const canvasWidth = await chartCanvas.getAttribute('width');
		const canvasHeight = await chartCanvas.getAttribute('height');
		// Width is set to actual pixel value, not percentage
		expect(parseInt(canvasWidth || '0')).toBeGreaterThan(0);
		expect(canvasHeight).toBe('350');
	});

	test('defaults to Africa section', async ({ page }) => {
		await page.goto('/communities');
		await page.waitForSelector('main', { timeout: 10000 });
		await page.waitForTimeout(500);

		// Should redirect to Africa section
		await expect(page).toHaveURL(/\/communities\/africa$/);

		// Check that Africa section is displayed
		const africaHeading = page.getByRole('heading', { name: 'Africa' });
		await expect(africaHeading).toBeVisible();

		// Check that the select dropdown shows Africa as selected
		const sectionSelect = page.locator('select');
		if ((await sectionSelect.count()) > 0) {
			const selectedValue = await sectionSelect.inputValue();
			expect(selectedValue).toBe('africa');
		}
	});
});



================================================
FILE: tests/community-area.spec.ts
================================================
import { test, expect } from '@playwright/test';

test.describe('Community Area Pages', () => {
	test('loads community page and redirects to merchants', async ({ page }) => {
		// Reasonable timeout - focus on navigation, not heavy data loading
		test.setTimeout(60000);

		// Navigate directly to a known community (Bitcoin Bulgaria)
		await page.goto('/community/bitcoin-bulgaria');
		await expect(page).toHaveURL(/\/community\/bitcoin-bulgaria\/merchants$/);
		await page.waitForLoadState('domcontentloaded');

		// Verify basic page structure loads (before heavy API data)
		const bodyContent = await page.locator('body').textContent();
		expect(bodyContent).toBeTruthy();
		expect(bodyContent!.length).toBeGreaterThan(100);
	});

	test('handles section navigation', async ({ page }) => {
		// Reasonable timeout - focus on navigation, not heavy data loading
		test.setTimeout(60000);

		const testSections = ['merchants', 'stats', 'activity', 'maintain'];

		for (const section of testSections) {
			await page.goto(`/community/bitcoin-bulgaria/${section}`);

			// Verify URL matches
			await expect(page).toHaveURL(new RegExp(`/community/bitcoin-bulgaria/${section}$`));

			// Don't wait for heavy data loading - just verify navigation works
			await page.waitForLoadState('domcontentloaded');
		}
	});
});



================================================
FILE: tests/countries.spec.ts
================================================
import { test, expect } from '@playwright/test';

test.describe('Countries', () => {
	test('redirects to Africa section by default', async ({ page }) => {
		await page.goto('/countries');

		// Should redirect to /countries/africa
		await expect(page).toHaveURL(/countries\/africa/);

		// Wait for the page to load
		const heading = page.getByRole('heading', {
			name: 'Bitcoin adoption by countries.'
		});
		await heading.waitFor({ state: 'visible' });
		await expect(heading).toBeVisible();

		// Check that Africa section is shown by default
		const africaHeading = page.getByRole('heading', { name: 'Africa' });
		await africaHeading.waitFor({ state: 'visible' });
		await expect(africaHeading).toBeVisible();

		// Verify dropdown shows Africa selected
		const dropdown = page.getByRole('combobox');
		await expect(dropdown).toHaveValue('africa');
	});

	test('updates URL when dropdown selection changes', async ({ page }) => {
		await page.goto('/countries/africa');

		// Wait for the page to load
		const heading = page.getByRole('heading', {
			name: 'Bitcoin adoption by countries.'
		});
		await heading.waitFor({ state: 'visible' });

		// Select Europe from dropdown
		const dropdown = page.getByRole('combobox');
		await dropdown.selectOption('europe');

		// Check that Europe section is now shown
		const europeHeading = page.getByRole('heading', { name: 'Europe' });
		await europeHeading.waitFor({ state: 'visible' });
		await expect(europeHeading).toBeVisible();

		// Check that URL updated to Europe
		await expect(page).toHaveURL(/countries\/europe/);

		// Select South America from dropdown
		await dropdown.selectOption('south-america');

		// Check that South America section is now shown
		const southAmericaHeading = page.getByRole('heading', { name: 'South America' });
		await southAmericaHeading.waitFor({ state: 'visible' });
		await expect(southAmericaHeading).toBeVisible();

		// Check that URL updated to South America
		await expect(page).toHaveURL(/countries\/south-america/);
	});
});



================================================
FILE: tests/country-area.spec.ts
================================================
import { test, expect } from '@playwright/test';

test.describe('Country Area Pages', () => {
	test('loads country page and redirects to merchants', async ({ page }) => {
		// Increase timeout for this slow test due to heavy API calls
		test.setTimeout(60000);

		await page.goto('/country/za');
		await expect(page).toHaveURL(/\/country\/za\/merchants$/);
		await page.waitForLoadState('networkidle');

		const pageTitle = await page.title();
		expect(pageTitle).toContain('South Africa');

		const bodyContent = await page.locator('body').textContent();
		expect(bodyContent).toBeTruthy();
		expect(bodyContent!.length).toBeGreaterThan(100);
	});

	test('handles section navigation', async ({ page }) => {
		// Reasonable timeout - focus on navigation, not heavy data loading
		test.setTimeout(60000);

		const testSections = ['merchants', 'stats', 'activity', 'maintain'];

		for (const section of testSections) {
			await page.goto(`/country/za/${section}`);

			// Verify URL matches
			await expect(page).toHaveURL(new RegExp(`/country/za/${section}$`));

			// Verify basic page structure loads (before heavy API calls)
			await page.waitForSelector('h1:has-text("South Africa")', { timeout: 20000 });
			await page.waitForSelector(
				`button:has-text("${section.charAt(0).toUpperCase() + section.slice(1)}")`,
				{ timeout: 10000 }
			);

			// For merchants, verify the section content starts loading
			if (section === 'merchants') {
				await page.waitForSelector('h3:has-text("South Africa Map")', { timeout: 10000 });
			}

			// Don't wait for heavy data loading - just verify navigation works
			await page.waitForLoadState('domcontentloaded');
		}
	});
});



================================================
FILE: tests/home.spec.ts
================================================
import { test, expect } from '@playwright/test';

test.describe('Home Page', () => {
	test('add location opens', async ({ page }) => {
		await page.goto('');

		await page.waitForLoadState('domcontentloaded');

		const heading = page.getByRole('heading', {
			name: 'Find places to spend sats wherever you are.'
		});
		await heading.waitFor({ state: 'visible' });
		await expect(heading).toBeTruthy();

		await page.getByRole('link', { name: 'Add Location' }).click();

		await expect(page.getByRole('heading', { name: 'Accept bitcoin? Get found.' })).toBeTruthy();
	});
});



================================================
FILE: tests/leaderboard.spec.ts
================================================
import { expect, test } from '@playwright/test';

test.describe('Leaderboard pages', () => {
	test('communities leaderboard loads data when accessed directly', async ({ page }) => {
		// Navigate directly to the leaderboard (cold start, no prior data)
		await page.goto('/communities/leaderboard');

		// Wait for the table to load with data (gold medal in first position cell)
		// This confirms the data sync completed and table rendered
		await expect(page.getByRole('cell', { name: 'ğŸ¥‡' })).toBeVisible({ timeout: 30000 });

		// Verify the header is present
		await expect(page.getByRole('heading', { name: /Community Leaderboard/ })).toBeVisible();
	});

	test('countries leaderboard loads data when accessed directly', async ({ page }) => {
		// Navigate directly to the leaderboard (cold start, no prior data)
		await page.goto('/countries/leaderboard');

		// Wait for the table to load with data (gold medal in first position cell)
		// This confirms the data sync completed and table rendered
		await expect(page.getByRole('cell', { name: 'ğŸ¥‡' })).toBeVisible({ timeout: 30000 });

		// Verify the header is present
		await expect(page.getByRole('heading', { name: /Country Leaderboard/ })).toBeVisible();
	});
});



================================================
FILE: tests/map-drawer.spec.ts
================================================
import { test, expect } from '@playwright/test';

test.describe('Map Drawer', () => {
	// Collect console errors during tests - map JS errors should fail the test
	test.beforeEach(async ({ page }) => {
		const errors: string[] = [];
		page.on('console', (msg) => {
			if (msg.type() === 'error') {
				errors.push(msg.text());
			}
		});
		page.on('pageerror', (error) => {
			errors.push(error.message);
		});
		// Store errors on page object for access in afterEach
		(page as unknown as { _consoleErrors: string[] })._consoleErrors = errors;
	});

	test.afterEach(async ({ page }) => {
		const errors = (page as unknown as { _consoleErrors: string[] })._consoleErrors || [];
		// Filter out non-critical errors (resource loading failures, minified JS noise)
		const criticalErrors = errors.filter((error) => {
			// Skip single-character errors (minified JS noise)
			if (error.length <= 2) return false;
			if (error.includes('Failed to load resource')) return false;
			if (error.includes('net::ERR_')) return false;
			return true;
		});
		if (criticalErrors.length > 0) {
			throw new Error(`Console errors detected:\n${criticalErrors.join('\n')}`);
		}
	});

	// Helper: wait for places API response, then for markers to render
	async function waitForMarkersToLoad(page: import('@playwright/test').Page) {
		// First wait for the places API to respond
		try {
			await page.waitForResponse(
				(response) => response.url().includes('api.btcmap.org/v4/places') && response.ok(),
				{ timeout: 30000 }
			);
		} catch {
			// API may have already responded before we started waiting
			// Continue and check if markers exist
		}

		// Then wait for markers to render in DOM
		await page.waitForFunction(
			() => document.querySelectorAll('.leaflet-marker-pane > div').length > 0,
			{ timeout: 45000 }
		);
	}

	test('drawer opens on marker click and navigates to merchant detail page', async ({ page }) => {
		test.setTimeout(180000);
		await page.goto('/map#16/42.2762511/42.7024218', { waitUntil: 'load' });
		await expect(page).toHaveTitle(/BTC Map/);

		const zoomInButton = page.getByRole('button', { name: 'Zoom in' });
		await expect(zoomInButton).toBeVisible();

		// Wait for API response and markers to render
		await waitForMarkersToLoad(page);

		const findAndClickMarker = async () => {
			const markerClicked = await page.evaluate(() => {
				const isInViewport = (element: Element) => {
					const rect = element.getBoundingClientRect();
					const viewport = {
						width: window.innerWidth,
						height: window.innerHeight
					};
					return (
						rect.left >= 0 &&
						rect.right <= viewport.width &&
						rect.top >= 0 &&
						rect.bottom <= viewport.height
					);
				};

				const individualMarkers = document.querySelectorAll(
					'.leaflet-marker-pane > div:not([class*="cluster"])'
				);

				if (individualMarkers.length > 0) {
					const viewportMarker = Array.from(individualMarkers).find(isInViewport);
					if (viewportMarker) {
						(viewportMarker as HTMLElement).click();
						return true;
					}

					(individualMarkers[0] as HTMLElement).click();
					return true;
				}

				const clusterSelectors = [
					'.leaflet-marker-cluster-small',
					'.leaflet-marker-cluster-medium',
					'.leaflet-marker-cluster-large'
				];

				for (const selector of clusterSelectors) {
					const clusters = document.querySelectorAll(selector);
					if (clusters.length > 0) {
						const viewportCluster = Array.from(clusters).find(isInViewport);
						const clusterToClick = viewportCluster || clusters[0];
						(clusterToClick as HTMLElement).click();

						setTimeout(() => {
							const expandedMarkers = document.querySelectorAll(
								'.leaflet-marker-pane > div:not([class*="cluster"])'
							);
							if (expandedMarkers.length > 0) {
								const expandedViewportMarker = Array.from(expandedMarkers).find(isInViewport);
								const markerToClick = expandedViewportMarker || expandedMarkers[0];
								(markerToClick as HTMLElement).click();
							}
						}, 1000);
						return true;
					}
				}

				return false;
			});

			if (!markerClicked) {
				const debugInfo = await page.evaluate(() => {
					const individualMarkers = document.querySelectorAll(
						'.leaflet-marker-pane > div:not([class*="cluster"])'
					);
					const clusters = document.querySelectorAll('.leaflet-marker-cluster');
					return {
						individualMarkersCount: individualMarkers.length,
						clustersCount: clusters.length,
						totalMarkers: document.querySelectorAll('.leaflet-marker-pane > div').length
					};
				});
				throw new Error(`No clickable markers found. Debug info: ${JSON.stringify(debugInfo)}`);
			}

			await page.waitForTimeout(2000);
			return true;
		};

		await findAndClickMarker();

		try {
			await page.waitForResponse(
				(response) =>
					response.url().includes('api.btcmap.org/v4/places/') && response.status() === 200,
				{ timeout: 8000 }
			);
		} catch (error) {
			const errorMessage = error instanceof Error ? error.message : String(error);
			console.error('API response wait failed, but continuing:', errorMessage);
		}

		// Wait for drawer to open
		const drawer = page.locator('[role="dialog"]');
		await expect(drawer).toBeVisible({ timeout: 15000 });

		await page.waitForTimeout(2000);

		// Look for "View Full Details" button in drawer
		const viewDetailsButton = page.locator('a:has-text("View Full Details")');
		await expect(viewDetailsButton).toBeVisible({ timeout: 10000 });

		const merchantHref = await viewDetailsButton.getAttribute('href');
		console.info('Found merchant link:', merchantHref);

		await viewDetailsButton.click();

		await expect(page).toHaveURL(/\/merchant\//);

		const timeout = process.env.CI ? 30000 : 10000;
		await expect(page.getByText('Last Surveyed')).toBeVisible({ timeout });
		await expect(page.getByRole('heading', { name: 'Boost' })).toBeVisible();
		await expect(page.getByText('Comments').first()).toBeVisible();
	});

	test('drawer shows Comments button with count', async ({ page }) => {
		await page.goto('/map#15/13.6929/-89.2182', { waitUntil: 'load' });
		await expect(page).toHaveTitle(/BTC Map/);

		const zoomInButton = page.getByRole('button', { name: 'Zoom in' });
		await expect(zoomInButton).toBeVisible();

		// Wait for API response and markers to render
		await waitForMarkersToLoad(page);

		const markerClicked = await page.evaluate(() => {
			const markers = document.querySelectorAll(
				'.leaflet-marker-pane > div:not([class*="cluster"])'
			);
			if (markers.length > 0) {
				(markers[0] as HTMLElement).click();
				return true;
			}

			const clusters = document.querySelectorAll('.leaflet-marker-cluster');
			if (clusters.length > 0) {
				(clusters[0] as HTMLElement).click();
				return 'cluster';
			}
			return false;
		});

		if (markerClicked === 'cluster') {
			await page.waitForTimeout(1000);
			const expandedMarkerClicked = await page.evaluate(() => {
				const expandedMarkers = document.querySelectorAll(
					'.leaflet-marker-pane > div:not([class*="cluster"])'
				);
				if (expandedMarkers.length > 0) {
					(expandedMarkers[0] as HTMLElement).click();
					return true;
				}
				return false;
			});

			if (!expandedMarkerClicked) {
				throw new Error('No individual markers found after expanding cluster');
			}
		} else if (!markerClicked) {
			throw new Error('No markers found to click');
		}

		await page.waitForTimeout(2000);

		// Check drawer comments button
		const commentsButton = page.locator('a[href*="#comments"]');
		await expect(commentsButton).toBeVisible({ timeout: 10000 });

		await expect(commentsButton).toContainText('Comments');

		const commentCountDiv = commentsButton.locator('div').first();
		await expect(commentCountDiv).toBeVisible();

		const countText = await commentCountDiv.textContent();
		const trimmedCount = countText?.trim() || '';
		expect(trimmedCount).toMatch(/^\d+$/);
	});

	test('drawer opens from URL hash on initial page load (desktop)', async ({ page }) => {
		// Navigate directly to map with merchant hash parameter
		await page.goto('/map#15/53.55573/10.00825&merchant=6556', { waitUntil: 'load' });
		await expect(page).toHaveTitle(/BTC Map/);

		// Wait for map to load
		const zoomInButton = page.getByRole('button', { name: 'Zoom in' });
		await expect(zoomInButton).toBeVisible();

		// Wait for drawer to open automatically
		const drawer = page.locator('[role="dialog"]');
		await expect(drawer).toBeVisible({ timeout: 15000 });

		// Wait for merchant data to load
		try {
			await page.waitForResponse(
				(response) =>
					response.url().includes('api.btcmap.org/v4/places/6556') && response.status() === 200,
				{ timeout: 10000 }
			);
		} catch (error) {
			console.error('API response wait failed:', error);
		}

		// Verify "View Full Details" button appears (confirms drawer has content)
		const viewDetailsButton = page.locator('a:has-text("View Full Details")');
		await expect(viewDetailsButton).toBeVisible({ timeout: 10000 });

		// Verify the correct merchant is displayed
		const merchantHref = await viewDetailsButton.getAttribute('href');
		expect(merchantHref).toContain('/merchant/6556');
	});

	test('drawer opens from URL hash on initial page load (mobile)', async ({ page }) => {
		// Set mobile viewport
		await page.setViewportSize({ width: 375, height: 667 });

		// Navigate directly to map with merchant hash parameter
		await page.goto('/map#15/53.55573/10.00825&merchant=6556', { waitUntil: 'load' });
		await expect(page).toHaveTitle(/BTC Map/);

		// Wait for map to load
		const zoomInButton = page.getByRole('button', { name: 'Zoom in' });
		await expect(zoomInButton).toBeVisible();

		// Wait for mobile drawer to open (appears at bottom)
		const drawer = page.locator('[role="dialog"]');
		await expect(drawer).toBeVisible({ timeout: 15000 });

		// Wait for merchant data
		try {
			await page.waitForResponse(
				(response) =>
					response.url().includes('api.btcmap.org/v4/places/6556') && response.status() === 200,
				{ timeout: 10000 }
			);
		} catch (error) {
			console.error('API response wait failed:', error);
		}

		// Verify drawer has content (merchant should be loaded)
		const drawerContent = drawer.locator('h3, a');
		await expect(drawerContent.first()).toBeVisible({ timeout: 10000 });
	});

	test('boost view opens from hash parameter', async ({ page }) => {
		// Navigate with boost view parameter
		await page.goto('/map#15/53.55573/10.00825&merchant=6556&view=boost', { waitUntil: 'load' });
		await expect(page).toHaveTitle(/BTC Map/);

		// Wait for map to load
		const zoomInButton = page.getByRole('button', { name: 'Zoom in' });
		await expect(zoomInButton).toBeVisible();

		// Wait for drawer to open
		const drawer = page.locator('[role="dialog"]');
		await expect(drawer).toBeVisible({ timeout: 15000 });

		// Verify "Back" button is visible (indicates we're in a nested view like boost)
		const backButton = page.getByRole('button', { name: /back/i });
		await expect(backButton).toBeVisible({ timeout: 10000 });

		// Verify "Boost" text appears in header or content
		const boostText = page.locator('span:has-text("boost"), span:has-text("Boost")');
		await expect(boostText.first()).toBeVisible({ timeout: 10000 });
	});

	test('drawer dismisses on swipe down from peek state (mobile)', async ({ page }) => {
		// Set mobile viewport
		await page.setViewportSize({ width: 375, height: 667 });

		// Navigate with merchant hash to open drawer directly
		await page.goto('/map#15/53.55573/10.00825&merchant=6556', { waitUntil: 'load' });

		// Wait for drawer to open
		const drawer = page.locator('[role="dialog"]');
		await expect(drawer).toBeVisible({ timeout: 15000 });

		// Get drawer position
		const box = await drawer.boundingBox();
		if (!box) throw new Error('Drawer not found');

		// Simulate swipe down gesture from peek state
		const startX = box.x + box.width / 2;
		const startY = box.y + 20;

		await page.mouse.move(startX, startY);
		await page.mouse.down();
		await page.mouse.move(startX, startY + 100, { steps: 5 });
		await page.mouse.up();

		// Drawer should be dismissed
		await expect(drawer).not.toBeVisible({ timeout: 5000 });
	});
});



================================================
FILE: tests/merchant-list-panel.spec.ts
================================================
import { test, expect } from '@playwright/test';

const MARKER_LOAD_TIMEOUT = 60000;

test.describe('Merchant List Panel', () => {
	// Collect console errors during tests
	test.beforeEach(async ({ page }) => {
		const errors: string[] = [];
		page.on('console', (msg) => {
			if (msg.type() === 'error') {
				errors.push(msg.text());
			}
		});
		page.on('pageerror', (error) => {
			errors.push(error.message);
		});
		(page as unknown as { _consoleErrors: string[] })._consoleErrors = errors;
	});

	test.afterEach(async ({ page }) => {
		const errors = (page as unknown as { _consoleErrors: string[] })._consoleErrors || [];
		// Filter out non-critical errors (resource loading failures, minified JS noise)
		const criticalErrors = errors.filter((error) => {
			// Skip single-character errors (minified JS noise)
			if (error.length <= 2) return false;
			if (error.includes('Failed to load resource')) return false;
			if (error.includes('net::ERR_')) return false;
			return true;
		});
		if (criticalErrors.length > 0) {
			throw new Error(`Console errors detected:\n${criticalErrors.join('\n')}`);
		}
	});

	test('list panel opens via toggle button and shows merchants', async ({ page }) => {
		// Desktop viewport
		await page.setViewportSize({ width: 1280, height: 720 });

		// Navigate to map at zoom level 17 (above threshold)
		await page.goto('/map#17/42.2762511/42.7024218', { waitUntil: 'load' });
		await expect(page).toHaveTitle(/BTC Map/);

		// Wait for map to initialize
		const zoomInButton = page.getByRole('button', { name: 'Zoom in' });
		await expect(zoomInButton).toBeVisible();

		// Wait for markers to load
		await page.waitForFunction(
			() => {
				const markers = document.querySelectorAll('.leaflet-marker-pane > div');
				return markers.length > 0;
			},
			{ timeout: MARKER_LOAD_TIMEOUT }
		);

		// List panel should NOT be visible initially (auto-open disabled)
		const listPanel = page.locator('[role="complementary"][aria-label="Merchant list"]');
		await expect(listPanel).not.toBeVisible();

		// Toggle button should be visible
		const toggleButton = page.getByRole('button', { name: /merchant list/i });
		await expect(toggleButton).toBeVisible({ timeout: 15000 });

		// Click toggle to open the panel
		await toggleButton.click();

		// List panel should now be visible
		await expect(listPanel).toBeVisible({ timeout: 10000 });

		// Should show location count in header
		await expect(page.locator('text=/\\d+ locations? in view/')).toBeVisible({ timeout: 5000 });
	});

	test('clicking merchant in list opens drawer with correct merchant', async ({ page }) => {
		// Desktop viewport
		await page.setViewportSize({ width: 1280, height: 720 });

		// Navigate to map at high zoom where list should appear
		await page.goto('/map#17/42.2762511/42.7024218', { waitUntil: 'load' });
		await expect(page).toHaveTitle(/BTC Map/);

		// Wait for map to initialize
		const zoomInButton = page.getByRole('button', { name: 'Zoom in' });
		await expect(zoomInButton).toBeVisible();

		// Wait for markers to load
		await page.waitForFunction(
			() => {
				const markers = document.querySelectorAll('.leaflet-marker-pane > div');
				return markers.length > 0;
			},
			{ timeout: MARKER_LOAD_TIMEOUT }
		);

		// Click toggle button to open list panel
		const toggleButton = page.getByRole('button', { name: /merchant list/i });
		await expect(toggleButton).toBeVisible({ timeout: 15000 });
		await toggleButton.click();

		// Wait for list panel to appear
		const listPanel = page.locator('[role="complementary"][aria-label="Merchant list"]');
		await expect(listPanel).toBeVisible({ timeout: 10000 });

		// Find and click first merchant item in list (wait for items to load)
		const merchantItems = listPanel.locator('li button');
		const firstMerchant = merchantItems.first();
		await expect(firstMerchant).toBeVisible({ timeout: 15000 });

		// Click the merchant
		await firstMerchant.click();

		// Wait for API call to complete
		try {
			await page.waitForResponse(
				(response) =>
					response.url().includes('api.btcmap.org/v4/places/') && response.status() === 200,
				{ timeout: 10000 }
			);
		} catch (error) {
			console.error('API response wait failed, but continuing:', error);
		}

		// Drawer should open (use specific selector to exclude mobile list dialog)
		const drawer = page.locator('[role="dialog"]:has(a:has-text("View Full Details"))');
		await expect(drawer).toBeVisible({ timeout: 10000 });

		// Drawer should have View Full Details button
		const viewDetailsButton = drawer.locator('a:has-text("View Full Details")');
		await expect(viewDetailsButton).toBeVisible({ timeout: 10000 });
	});

	test('mobile: list panel opens fullscreen via toggle button', async ({ page }) => {
		// Mobile viewport
		await page.setViewportSize({ width: 375, height: 667 });

		// Navigate to map at high zoom where list would appear on desktop
		await page.goto('/map#17/42.2762511/42.7024218', { waitUntil: 'load' });
		await expect(page).toHaveTitle(/BTC Map/);

		// Wait for map to initialize
		const zoomInButton = page.getByRole('button', { name: 'Zoom in' });
		await expect(zoomInButton).toBeVisible();

		// Wait for markers to load
		await page.waitForFunction(
			() => {
				const markers = document.querySelectorAll('.leaflet-marker-pane > div');
				return markers.length > 0;
			},
			{ timeout: MARKER_LOAD_TIMEOUT }
		);

		// Toggle button IS visible on mobile (shared button for both mobile and desktop)
		const toggleButton = page.getByRole('button', { name: /merchant list/i });
		await expect(toggleButton).toBeVisible({ timeout: 15000 });

		// List panel should NOT be visible before clicking toggle
		const listPanel = page.locator('[role="complementary"][aria-label="Merchant list"]');
		await expect(listPanel).not.toBeVisible();

		// Click toggle to open fullscreen list on mobile
		await toggleButton.click();

		// List panel (unified component, fullscreen on mobile) should be visible
		await expect(listPanel).toBeVisible({ timeout: 5000 });

		// Should show "Nearby Merchants" heading
		await expect(listPanel.locator('h2:has-text("Nearby Merchants")')).toBeVisible();
	});

	test('mobile: selecting merchant closes list and opens drawer', async ({ page }) => {
		// Mobile viewport
		await page.setViewportSize({ width: 375, height: 667 });

		// Navigate to map at high zoom
		await page.goto('/map#17/42.2762511/42.7024218', { waitUntil: 'load' });
		await expect(page).toHaveTitle(/BTC Map/);

		// Wait for map to initialize
		const zoomInButton = page.getByRole('button', { name: 'Zoom in' });
		await expect(zoomInButton).toBeVisible();

		// Wait for markers to load
		await page.waitForFunction(
			() => {
				const markers = document.querySelectorAll('.leaflet-marker-pane > div');
				return markers.length > 0;
			},
			{ timeout: MARKER_LOAD_TIMEOUT }
		);

		// Open mobile list
		const toggleButton = page.getByRole('button', { name: /merchant list/i });
		await expect(toggleButton).toBeVisible({ timeout: 15000 });
		await toggleButton.click();

		// Wait for list panel to appear (unified component, fullscreen on mobile)
		const listPanel = page.locator('[role="complementary"][aria-label="Merchant list"]');
		await expect(listPanel).toBeVisible({ timeout: 5000 });

		// Find and click first merchant item (wait for items to load)
		const merchantItems = listPanel.locator('li button');
		const firstMerchant = merchantItems.first();
		await expect(firstMerchant).toBeVisible({ timeout: 15000 });
		await firstMerchant.click();

		// Wait for API call
		try {
			await page.waitForResponse(
				(response) =>
					response.url().includes('api.btcmap.org/v4/places/') && response.status() === 200,
				{ timeout: 10000 }
			);
		} catch (error) {
			console.error('API response wait failed, but continuing:', error);
		}

		// List panel should close
		await expect(listPanel).not.toBeVisible({ timeout: 5000 });

		// Mobile drawer should open in peek state (shows "Swipe up for details")
		const mobileDrawer = page.locator('text="Swipe up for details"');
		await expect(mobileDrawer).toBeVisible({ timeout: 10000 });
	});

	test('switches between Worldwide and Nearby modes', async ({ page }) => {
		// Desktop viewport
		await page.setViewportSize({ width: 1280, height: 720 });

		// Navigate to map
		await page.goto('/map#17/42.2762511/42.7024218', { waitUntil: 'load' });
		await expect(page).toHaveTitle(/BTC Map/);

		// Wait for map to initialize
		const zoomInButton = page.getByRole('button', { name: 'Zoom in' });
		await expect(zoomInButton).toBeVisible();

		// Wait for markers to load
		await page.waitForFunction(
			() => {
				const markers = document.querySelectorAll('.leaflet-marker-pane > div');
				return markers.length > 0;
			},
			{ timeout: MARKER_LOAD_TIMEOUT }
		);

		// Open the list panel
		const toggleButton = page.getByRole('button', { name: /merchant list/i });
		await expect(toggleButton).toBeVisible({ timeout: 15000 });
		await toggleButton.click();

		// Wait for list panel
		const listPanel = page.locator('[role="complementary"][aria-label="Merchant list"]');
		await expect(listPanel).toBeVisible({ timeout: 10000 });

		// Should start in Nearby mode - verify heading
		await expect(listPanel.locator('h2:has-text("Nearby Merchants")')).toBeVisible();

		// Click Worldwide button to switch to search mode
		const worldwideButton = listPanel.getByRole('radio', { name: 'Worldwide' });
		await expect(worldwideButton).toBeVisible();
		await worldwideButton.click();

		// Should show search input in search mode
		const searchInput = listPanel.locator('input[type="search"]');
		await expect(searchInput).toBeVisible({ timeout: 5000 });

		// Click Nearby button to switch back
		const nearbyButton = listPanel.getByRole('radio', { name: 'Nearby' });
		await nearbyButton.click();

		// Should show Nearby Merchants heading again
		await expect(listPanel.locator('h2:has-text("Nearby Merchants")')).toBeVisible({
			timeout: 5000
		});
	});
});



================================================
FILE: tests/verify-location.spec.ts
================================================
import { test, expect } from '@playwright/test';

test.describe('Verify Location Page', () => {
	test('loads page structure and basic form elements', async ({ page }) => {
		// Navigate to verify-location with a valid merchant ID
		await page.goto('/verify-location?id=node:9135176628');

		// Wait for page to load
		await page.waitForLoadState('domcontentloaded');

		// Check page title
		await expect(page).toHaveTitle(/BTC Map - Verify Location/);

		// Check main heading is visible
		const heading = page.getByRole('heading', { name: 'Verify Location' });
		await expect(heading).toBeVisible();

		// Check that basic form structure is present (don't wait for data loading)
		const merchantNameInput = page.getByPlaceholder(/Merchant Name/);
		await expect(merchantNameInput).toBeVisible();

		// Verify form elements are present (structure only, not functionality)
		await expect(page.getByText('Current information is correct')).toBeVisible();
		await expect(page.getByText('Outdated information')).toBeVisible();
		await expect(page.getByText('How did you verify this?')).toBeVisible();
		await expect(page.getByText('Bot protection')).toBeVisible();

		// Check submit button is present
		const submitButton = page.getByRole('button', { name: 'Submit Report' });
		await expect(submitButton).toBeVisible();

		// Check basic form elements exist (don't test if they're enabled - depends on data loading)
		const currentCheckbox = page.getByRole('checkbox', { name: 'Current information is correct' });
		await expect(currentCheckbox).toBeVisible();

		const verifyTextarea = page.getByPlaceholder('Please provide additional info here');
		await expect(verifyTextarea).toBeVisible();
	});

	test('shows error for missing ID parameter', async ({ page }) => {
		// Navigate to verify-location without ID parameter
		await page.goto('/verify-location');

		// Should get a 400 error page for missing ID
		await expect(page.getByText('400')).toBeVisible();
		await expect(page.getByText('Merchant ID parameter is required')).toBeVisible();
	});

	test('shows error for invalid merchant ID', async ({ page }) => {
		// Navigate to verify-location with invalid ID
		await page.goto('/verify-location?id=invalid-id-123');

		// Should get a 404 error page for invalid merchant
		await expect(page.getByText('404')).toBeVisible();
		await expect(page.getByText('Merchant Not Found')).toBeVisible();
	});
});



================================================
FILE: .github/copilot-instructions.md
================================================
# GitHub Copilot Instructions for BTC Map

## Project Overview

BTC Map is a progressive web app for finding Bitcoin-accepting merchants worldwide. The core architecture revolves around:

- **Interactive map** using Leaflet with clustered markers for merchants
- **Real-time data sync** from btcmap.org API with local caching via LocalForage
- **Community-driven content** with areas, users, events, and merchant verification
- **Mobile-first design** with PWA capabilities for offline usage

## Framework Stack

### Svelte/SvelteKit v4

- We use Svelte in version v4 - for reasons we do not upgrade to v5 yet
- Some code is not really written according to Svelte - if you notice a chance to be more idiomatic, please suggest it
- We use SvelteKit as our full-stack framework for routing, SSR, and build tooling
- Follow SvelteKit conventions for file-based routing in `src/routes/`
- Use SvelteKit's load functions for data fetching when appropriate
- Prefer SvelteKit's built-in features over external libraries when possible
- Organize API routes under `src/routes/api/` (e.g., `src/routes/api/merchants/+server.ts`) - though this project primarily uses client-side data syncing
- Use load functions for initial page data, API routes for client-side requests
- Use form actions for mutations and form submissions - see `src/routes/verify-location/` for examples
- Server-side data loading with `+page.server.ts` files for SEO-critical pages
- No traditional API routes - data syncing happens client-side from external API

### TailwindCSS v3

- We use TailwindCSS in version v3 - for reasons we do not upgrade to v4 yet
- Use TailwindCSS classes for styling components
- Prefer utility-first classes over custom CSS when possible
- Use TailwindCSS for responsive design and theming
- **Custom color palette**: Bitcoin orange/teal theme with custom classes like `text-bitcoin`, `bg-teal`, `text-mapButton`
- **Dark mode** support via `dark:` classes and theme detection
- **Responsive**: Mobile-first with `md:` breakpoints for desktop enhancements

### TypeScript

- We use TypeScript for type safety and better developer experience
- We would like to avoid `any` types - but i.e. some API results are not typed yet. You can suggest to create a type together with the user to establish a type-safe codebase
- Avoid `any` types - create proper interfaces in `src/lib/types.ts`
- OSM tag data often untyped - suggest creating `OSMTags` extensions
- Use provided types: `Element`, `Area`, `User`, `Event` for API data
- Leaflet types imported but some custom extensions needed for plugins

### HTML / Accessibility

- Use semantic HTML elements (e.g., `<header>`, `<main>`, `<footer>`, `<nav>`)
- Ensure accessibility (a11y) by using appropriate ARIA roles and attributes
- If you see a potential accessibility issue, suggest improvements
- If you see a potential invalid HTML, suggest improvements

## Map Architecture (Critical)

- **Leaflet** is the core mapping library with MapLibre GL integration
- **Marker clustering** via `leaflet.markercluster` for performance with thousands of markers
- **Dynamic icon generation** based on merchant category and boost status
- **Subgroup layers** for filtering (up-to-date, outdated, legacy payment methods)
- Map state persists via URL hash and LocalForage caching

```typescript
// Key pattern: Map initialization with custom controls
let markers = L.markerClusterGroup({ maxClusterRadius: 80 });
let upToDateLayer = leaflet.featureGroup.subGroup(markers);
// Layers are dynamically built based on merchant data and filters
```

## Data Architecture & Sync

### Store Pattern

- **Svelte stores** in `src/lib/store.ts` manage global state (elements, users, events, areas)
- **LocalForage** provides persistent client-side storage with IndexedDB fallback
- **Sync modules** in `src/lib/sync/` handle incremental data updates every 10 minutes

### Critical Data Flow

1. **Initial load**: `src/routes/+layout.svelte` orchestrates all data syncing
2. **Elements sync**: Merchants fetched in 5000-item batches with `updated_since` parameter
3. **Local caching**: Data persisted to avoid re-downloading on page refresh
4. **Real-time updates**: `$mapUpdates` store triggers UI refresh when new data available

```typescript
// Pattern: Sync functions return promises and update stores
export const elementsSync = async () => {
	// Always clear old table versions first
	clearTables(['elements', 'elements_v2', 'elements_v3']);
	// Check local cache, then API if needed
	await localforage.getItem<Place[]>('places_v4').then(async function (value) {
		/* sync logic */
	});
};
```

## Component Organization

### Component Library

- **Barrel exports**: All components exported from `src/lib/comp.ts`
- **Icon system**: Uses Material Design icons via Iconify + custom SVG spritesheets
- **Reusable patterns**: `Card`, `Icon`, `Boost` components used throughout

### Map-Specific Components

- **Map setup**: `src/lib/map/setup.ts` contains all Leaflet configuration and utilities
- **Custom controls**: Search, boost layer toggle, geolocation built as Leaflet controls
- **Popup generation**: Dynamic HTML popups with payment method icons and verification status

## Styling & Theming

### TailwindCSS v3

- **Utility-first** approach with custom color palette for Bitcoin orange/teal theme
- **Dark mode** support via `dark:` classes and theme detection
- **Custom classes**: `text-bitcoin`, `bg-teal`, `text-mapButton` for brand consistency
- **Responsive**: Mobile-first with `md:` breakpoints for desktop enhancements

## Development Workflow

### Key Commands

```bash
yarn dev          # Development server with HMR
yarn build        # Production build (requires .env from .env.example)
yarn format       # Prettier formatting (run before commits)
yarn lint         # ESLint with Svelte parser
yarn typecheck    # TypeScript validation
yarn playwright test  # E2E testing
```

### Important Files

- **Types**: `src/lib/types.ts` contains all TypeScript interfaces
- **Utils**: `src/lib/utils.ts` has theme detection, debouncing, error handling
- **PWA**: `src/service-worker.ts` enables offline functionality

## Patterns & Conventions

### URL Parameters for Map State

- Location: `?lat=40.7128&long=-74.0060` or hash `#15/40.71280/-74.00600`
- Filters: `?onchain=true&lightning=true&nfc=true&boosts=true`
- Legacy/outdated: `?legacy=true&outdated=true`

### Payment Method Integration

- **Payment URIs**: Lightning addresses, LNURL, on-chain addresses in `payment:uri` tags
- **Third-party apps**: Special handling for apps requiring companion software
- **Boost system**: Time-limited merchant highlighting with visual emphasis

### Error Handling

- **Toast notifications**: `@zerodevx/svelte-toast` for user feedback
- **Axios retry**: Automatic retry logic for API failures
- **Graceful degradation**: Map works offline with cached data

## TypeScript Guidelines

- Avoid `any` types - create proper interfaces in `src/lib/types.ts`
- OSM tag data often untyped - suggest creating `OSMTags` extensions
- Use provided types: `Element`, `Area`, `User`, `Event` for API data
- Leaflet types imported but some custom extensions needed for plugins

### Code Comments

- **Avoid JSDoc comments** (`/** */` with `@param`, `@returns`, `@description`, etc.)
- Use inline `//` comments for explaining complex logic
- Keep code self-documenting with clear variable and function names
- TypeScript types serve as documentation - explicit JSDoc is redundant

```typescript
// âŒ Don't use JSDoc
/**
 * Updates a single place in the store
 * @param placeId - The ID of the place
 * @returns The updated place or null
 */
export const updatePlace = async (placeId: string): Promise<Place | null> => {

// âœ… Do use inline comments when needed
export const updateSinglePlace = async (placeId: string | number): Promise<Place | null> => {
	// Fetch the updated place from the API
	const response = await axios.get<Place>(...);
```

## Testing & Deployment

- **Playwright E2E tests** in `tests/` directory cover critical user flows
- **Netlify deployment** with build caching and PWA optimization
- **Progressive enhancement**: Core functionality works without JavaScript



================================================
FILE: .github/dependabot.yml
================================================
version: 2
updates:
  - package-ecosystem: 'npm'
    directory: '/'
    schedule:
      interval: 'weekly'
    open-pull-requests-limit: 10
    groups:
      typescript-eslint:
        patterns:
          - '@typescript-eslint/*'
          - 'typescript-eslint'
      prettier:
        patterns:
          - '*prettier*'



================================================
FILE: .github/FUNDING.yml
================================================
custom: [btcmap.org/support-us]



================================================
FILE: .github/pull_request_template.md
================================================
**Does this PR address a related issue?**

**A description of the changes proposed in the pull request**

**Screenshots**

**Additional context**



================================================
FILE: .github/actions/setup/README.md
================================================
# Setup Composite Action

Shared setup steps used across all CI workflows (after checkout).

## Inputs

- `needs-env` (boolean, default: false) - Create .env file from .env.example
- `needs-sync` (boolean, default: false) - Run svelte-kit sync

## What it does

1. Sets up Node.js with yarn caching
2. Optionally creates .env file (if `needs-env: 'true'`)
3. Installs dependencies with `yarn`
4. Optionally runs `yarn svelte-kit sync` (if `needs-sync: 'true'`)

## Usage

**Important:** You must checkout the repository before using this action.

```yaml
steps:
  - uses: actions/checkout@v4

  - uses: ./.github/actions/setup
    with:
      needs-env: 'true'
      needs-sync: 'false'
```

## Environment

All workflows using this action set `NODE_OPTIONS: --max-old-space-size=4096` to prevent OOM errors in CI.



================================================
FILE: .github/actions/setup/action.yml
================================================
name: 'Setup Node and Dependencies'
description: 'Common setup steps for CI workflows (after checkout)'
inputs:
  needs-env:
    description: 'Create .env file from .env.example'
    required: false
    default: 'false'
  needs-sync:
    description: 'Run svelte-kit sync'
    required: false
    default: 'false'

runs:
  using: 'composite'
  steps:
    - uses: actions/setup-node@v4
      with:
        node-version: lts/*
        cache: 'yarn'

    - name: Create .env
      if: ${{ inputs.needs-env == 'true' }}
      shell: bash
      run: cp .env.example .env

    - name: Install dependencies
      shell: bash
      run: yarn

    - name: Sync SvelteKit
      if: ${{ inputs.needs-sync == 'true' }}
      shell: bash
      run: yarn svelte-kit sync



================================================
FILE: .github/ISSUE_TEMPLATE/bug_report.md
================================================
---
name: Bug report
about: Create a report to help us improve
title: ''
labels: bug
assignees: ''
---

**Describe the bug**

**To Reproduce**

**Expected behavior**

**Screenshots**

**Additional context**



================================================
FILE: .github/ISSUE_TEMPLATE/feature_request.md
================================================
---
name: Feature request
about: Suggest an idea for this project
title: ''
labels: feature request
assignees: ''
---

**Is your feature request related to a problem? Please describe.**

**Describe the solution you'd like**

**Describe alternatives you've considered**

**Additional context**



================================================
FILE: .github/workflows/build.yml
================================================
name: Build

on:
  push:
    branches: [main]
  pull_request:
    branches: ['**']

jobs:
  build:
    runs-on: ubuntu-latest
    env:
      NODE_OPTIONS: --max-old-space-size=4096
    steps:
      - uses: actions/checkout@v4

      - uses: ./.github/actions/setup
        with:
          needs-env: 'true'
          needs-sync: 'false'

      - name: Build app
        run: yarn run build



================================================
FILE: .github/workflows/e2e-tests.yml
================================================
name: E2E Tests

on:
  push:
    branches: [main]
  pull_request:
    branches: ['**']

jobs:
  e2e-tests:
    timeout-minutes: 20
    runs-on: ubuntu-latest
    env:
      NODE_OPTIONS: --max-old-space-size=4096
    steps:
      - uses: actions/checkout@v4

      - uses: ./.github/actions/setup
        with:
          needs-env: 'true'
          needs-sync: 'false'

      - name: Cache Playwright browsers
        id: playwright-cache
        uses: actions/cache@v3
        with:
          path: ~/.cache/ms-playwright
          key: playwright-chromium-${{ runner.os }}-${{ hashFiles('**/yarn.lock') }}
          restore-keys: |
            playwright-chromium-${{ runner.os }}-

      - name: Install Playwright Browsers
        if: steps.playwright-cache.outputs.cache-hit != 'true'
        run: yarn playwright install --with-deps chromium

      - name: Install Playwright Dependencies
        if: steps.playwright-cache.outputs.cache-hit == 'true'
        run: yarn playwright install-deps

      - name: Run Playwright tests
        run: yarn playwright test

      - uses: actions/upload-artifact@v4
        if: ${{ !cancelled() }}
        with:
          name: playwright-report
          path: playwright-report/
          retention-days: 30



================================================
FILE: .github/workflows/format-and-lint.yml
================================================
name: Format and Lint

on:
  push:
    branches: [main]
  pull_request:
    branches: ['**']

jobs:
  format-and-lint:
    runs-on: ubuntu-latest
    env:
      NODE_OPTIONS: --max-old-space-size=4096
    steps:
      - uses: actions/checkout@v4

      - uses: ./.github/actions/setup
        with:
          needs-env: 'false'
          needs-sync: 'true'

      - name: Run Prettier
        run: yarn run format

      - name: Run ESLint
        run: yarn run lint



================================================
FILE: .github/workflows/type-checks.yml
================================================
name: Type Checks

on:
  push:
    branches: [main]
  pull_request:
    branches: ['**']

jobs:
  type-checks:
    runs-on: ubuntu-latest
    env:
      NODE_OPTIONS: --max-old-space-size=4096
    steps:
      - uses: actions/checkout@v4

      - uses: ./.github/actions/setup
        with:
          needs-env: 'true'
          needs-sync: 'false'

      - name: Run Svelte check
        run: yarn run check

      - name: Run TypeScript type check
        run: yarn run typecheck



================================================
FILE: .github/workflows/unit-tests.yml
================================================
name: Unit Tests

on:
  push:
    branches: [main]
  pull_request:
    branches: ['**']

jobs:
  unit-tests:
    runs-on: ubuntu-latest
    env:
      NODE_OPTIONS: --max-old-space-size=4096
    steps:
      - uses: actions/checkout@v4

      - uses: ./.github/actions/setup
        with:
          needs-env: 'true'
          needs-sync: 'true'

      - name: Run Vitest tests
        run: yarn run test



================================================
FILE: .husky/pre-commit
================================================
if [ "$CI" = "true" ]; then
  exit 0
fi
npx lint-staged


