{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@cashu+cashu-ts@2.9.0/node_modules/@cashu/cashu-ts/lib/utils-CZmbiPUC.js","sources":["file:///home/maximoto/dev/sats-rover/node_modules/.pnpm/%40cashu%2Bcashu-ts%402.9.0/node_modules/%40cashu/cashu-ts/node_modules/%40noble/hashes/utils.js"],"sourcesContent":["/**\n * Utilities for hex, bytes, CSPRNG.\n * @module\n */\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */\nexport function isBytes(a) {\n    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n/** Asserts something is positive integer. */\nexport function anumber(n, title = '') {\n    if (!Number.isSafeInteger(n) || n < 0) {\n        const prefix = title && `\"${title}\" `;\n        throw new Error(`${prefix}expected integer >= 0, got ${n}`);\n    }\n}\n/** Asserts something is Uint8Array. */\nexport function abytes(value, length, title = '') {\n    const bytes = isBytes(value);\n    const len = value?.length;\n    const needsLen = length !== undefined;\n    if (!bytes || (needsLen && len !== length)) {\n        const prefix = title && `\"${title}\" `;\n        const ofLen = needsLen ? ` of length ${length}` : '';\n        const got = bytes ? `length=${len}` : `type=${typeof value}`;\n        throw new Error(prefix + 'expected Uint8Array' + ofLen + ', got ' + got);\n    }\n    return value;\n}\n/** Asserts something is hash */\nexport function ahash(h) {\n    if (typeof h !== 'function' || typeof h.create !== 'function')\n        throw new Error('Hash must wrapped by utils.createHasher');\n    anumber(h.outputLen);\n    anumber(h.blockLen);\n}\n/** Asserts a hash instance has not been destroyed / finished */\nexport function aexists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\n/** Asserts output is properly-sized byte array */\nexport function aoutput(out, instance) {\n    abytes(out, undefined, 'digestInto() output');\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error('\"digestInto() output\" expected to be of length >=' + min);\n    }\n}\n/** Cast u8 / u16 / u32 to u8. */\nexport function u8(arr) {\n    return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n/** Cast u8 / u16 / u32 to u32. */\nexport function u32(arr) {\n    return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n}\n/** Zeroize a byte array. Warning: JS provides no guarantees. */\nexport function clean(...arrays) {\n    for (let i = 0; i < arrays.length; i++) {\n        arrays[i].fill(0);\n    }\n}\n/** Create DataView of an array for easy byte-level manipulation. */\nexport function createView(arr) {\n    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n/** The rotate right (circular right shift) operation for uint32 */\nexport function rotr(word, shift) {\n    return (word << (32 - shift)) | (word >>> shift);\n}\n/** The rotate left (circular left shift) operation for uint32 */\nexport function rotl(word, shift) {\n    return (word << shift) | ((word >>> (32 - shift)) >>> 0);\n}\n/** Is current platform little-endian? Most are. Big-Endian platform: IBM */\nexport const isLE = /* @__PURE__ */ (() => new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();\n/** The byte swap operation for uint32 */\nexport function byteSwap(word) {\n    return (((word << 24) & 0xff000000) |\n        ((word << 8) & 0xff0000) |\n        ((word >>> 8) & 0xff00) |\n        ((word >>> 24) & 0xff));\n}\n/** Conditionally byte swap if on a big-endian platform */\nexport const swap8IfBE = isLE\n    ? (n) => n\n    : (n) => byteSwap(n);\n/** In place byte swap for Uint32Array */\nexport function byteSwap32(arr) {\n    for (let i = 0; i < arr.length; i++) {\n        arr[i] = byteSwap(arr[i]);\n    }\n    return arr;\n}\nexport const swap32IfBE = isLE\n    ? (u) => u\n    : byteSwap32;\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\nconst hasHexBuiltin = /* @__PURE__ */ (() => \n// @ts-ignore\ntypeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function')();\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * Convert byte array to hex string. Uses built-in function, when available.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes) {\n    abytes(bytes);\n    // @ts-ignore\n    if (hasHexBuiltin)\n        return bytes.toHex();\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };\nfunction asciiToBase16(ch) {\n    if (ch >= asciis._0 && ch <= asciis._9)\n        return ch - asciis._0; // '2' => 50-48\n    if (ch >= asciis.A && ch <= asciis.F)\n        return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n    if (ch >= asciis.a && ch <= asciis.f)\n        return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n    return;\n}\n/**\n * Convert hex string to byte array. Uses built-in function, when available.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    // @ts-ignore\n    if (hasHexBuiltin)\n        return Uint8Array.fromHex(hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n    }\n    return array;\n}\n/**\n * There is no setImmediate in browser and setTimeout is slow.\n * Call of async fn will return Promise, which will be fullfiled only on\n * next scheduler queue processing step and this is exactly what we need.\n */\nexport const nextTick = async () => { };\n/** Returns control to thread each 'tick' ms to avoid blocking. */\nexport async function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * Converts string to bytes using UTF8 encoding.\n * Built-in doesn't validate input to be string: we do the check.\n * @example utf8ToBytes('abc') // Uint8Array.from([97, 98, 99])\n */\nexport function utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error('string expected');\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Helper for KDFs: consumes uint8array or string.\n * When string is passed, does utf8 decoding, using TextDecoder.\n */\nexport function kdfInputToBytes(data, errorTitle = '') {\n    if (typeof data === 'string')\n        return utf8ToBytes(data);\n    return abytes(data, undefined, errorTitle);\n}\n/** Copies several Uint8Arrays into one. */\nexport function concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        abytes(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n/** Merges default options and passed options. */\nexport function checkOpts(defaults, opts) {\n    if (opts !== undefined && {}.toString.call(opts) !== '[object Object]')\n        throw new Error('options must be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\n/** Creates function with outputLen, blockLen, create properties from a class constructor. */\nexport function createHasher(hashCons, info = {}) {\n    const hashC = (msg, opts) => hashCons(opts).update(msg).digest();\n    const tmp = hashCons(undefined);\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    Object.assign(hashC, info);\n    return Object.freeze(hashC);\n}\n/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */\nexport function randomBytes(bytesLength = 32) {\n    const cr = typeof globalThis === 'object' ? globalThis.crypto : null;\n    if (typeof cr?.getRandomValues !== 'function')\n        throw new Error('crypto.getRandomValues must be defined');\n    return cr.getRandomValues(new Uint8Array(bytesLength));\n}\n/** Creates OID opts for NIST hashes, with prefix 06 09 60 86 48 01 65 03 04 02. */\nexport const oidNist = (suffix) => ({\n    oid: Uint8Array.from([0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, suffix]),\n});\n//# sourceMappingURL=utils.js.map"],"names":["isBytes","a","anumber","n","title","prefix","abytes","value","length","bytes","len","needsLen","ofLen","got","ahash","h","aexists","instance","checkFinished","aoutput","out","min","clean","arrays","i","createView","arr","rotr","word","shift","hasHexBuiltin","hexes","_","bytesToHex","hex","asciis","asciiToBase16","ch","hexToBytes","hl","al","array","ai","hi","n1","n2","char","concatBytes","sum","res","pad","createHasher","hashCons","info","hashC","msg","opts","tmp","randomBytes","bytesLength","cr","oidNist","suffix"],"mappings":"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"}},
    {"offset": {"line": 156, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@cashu+cashu-ts@2.9.0/node_modules/@cashu/cashu-ts/lib/secp256k1-0cl8VzGA.js","sources":["file:///home/maximoto/dev/sats-rover/node_modules/.pnpm/%40cashu%2Bcashu-ts%402.9.0/node_modules/%40cashu/cashu-ts/node_modules/%40noble/hashes/_md.js","file:///home/maximoto/dev/sats-rover/node_modules/.pnpm/%40cashu%2Bcashu-ts%402.9.0/node_modules/%40cashu/cashu-ts/node_modules/%40noble/hashes/sha2.js","file:///home/maximoto/dev/sats-rover/node_modules/.pnpm/%40cashu%2Bcashu-ts%402.9.0/node_modules/%40cashu/cashu-ts/node_modules/%40noble/curves/utils.js","file:///home/maximoto/dev/sats-rover/node_modules/.pnpm/%40cashu%2Bcashu-ts%402.9.0/node_modules/%40cashu/cashu-ts/node_modules/%40noble/curves/abstract/modular.js","file:///home/maximoto/dev/sats-rover/node_modules/.pnpm/%40cashu%2Bcashu-ts%402.9.0/node_modules/%40cashu/cashu-ts/node_modules/%40noble/curves/abstract/curve.js","file:///home/maximoto/dev/sats-rover/node_modules/.pnpm/%40cashu%2Bcashu-ts%402.9.0/node_modules/%40cashu/cashu-ts/node_modules/%40noble/hashes/hmac.js","file:///home/maximoto/dev/sats-rover/node_modules/.pnpm/%40cashu%2Bcashu-ts%402.9.0/node_modules/%40cashu/cashu-ts/node_modules/%40noble/curves/abstract/weierstrass.js","file:///home/maximoto/dev/sats-rover/node_modules/.pnpm/%40cashu%2Bcashu-ts%402.9.0/node_modules/%40cashu/cashu-ts/node_modules/%40noble/curves/secp256k1.js"],"sourcesContent":["/**\n * Internal Merkle-Damgard hash utils.\n * @module\n */\nimport { abytes, aexists, aoutput, clean, createView } from \"./utils.js\";\n/** Choice: a ? b : c */\nexport function Chi(a, b, c) {\n    return (a & b) ^ (~a & c);\n}\n/** Majority function, true if any two inputs is true. */\nexport function Maj(a, b, c) {\n    return (a & b) ^ (a & c) ^ (b & c);\n}\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */\nexport class HashMD {\n    blockLen;\n    outputLen;\n    padOffset;\n    isLE;\n    // For partial updates less than block size\n    buffer;\n    view;\n    finished = false;\n    length = 0;\n    pos = 0;\n    destroyed = false;\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = createView(this.buffer);\n    }\n    update(data) {\n        aexists(this);\n        abytes(data);\n        const { view, buffer, blockLen } = this;\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = createView(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        aexists(this);\n        aoutput(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        clean(this.buffer.subarray(pos));\n        // we have less than padOffset left in buffer, so we cannot put length in\n        // current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        view.setBigUint64(blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = createView(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which must be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen must be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to ||= new this.constructor();\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.destroyed = destroyed;\n        to.finished = finished;\n        to.length = length;\n        to.pos = pos;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n    clone() {\n        return this._cloneInto();\n    }\n}\n/**\n * Initial SHA-2 state: fractional parts of square roots of first 16 primes 2..53.\n * Check out `test/misc/sha2-gen-iv.js` for recomputation guide.\n */\n/** Initial SHA256 state. Bits 0..32 of frac part of sqrt of primes 2..19 */\nexport const SHA256_IV = /* @__PURE__ */ Uint32Array.from([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19,\n]);\n/** Initial SHA224 state. Bits 32..64 of frac part of sqrt of primes 23..53 */\nexport const SHA224_IV = /* @__PURE__ */ Uint32Array.from([\n    0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939, 0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4,\n]);\n/** Initial SHA384 state. Bits 0..64 of frac part of sqrt of primes 23..53 */\nexport const SHA384_IV = /* @__PURE__ */ Uint32Array.from([\n    0xcbbb9d5d, 0xc1059ed8, 0x629a292a, 0x367cd507, 0x9159015a, 0x3070dd17, 0x152fecd8, 0xf70e5939,\n    0x67332667, 0xffc00b31, 0x8eb44a87, 0x68581511, 0xdb0c2e0d, 0x64f98fa7, 0x47b5481d, 0xbefa4fa4,\n]);\n/** Initial SHA512 state. Bits 0..64 of frac part of sqrt of primes 2..19 */\nexport const SHA512_IV = /* @__PURE__ */ Uint32Array.from([\n    0x6a09e667, 0xf3bcc908, 0xbb67ae85, 0x84caa73b, 0x3c6ef372, 0xfe94f82b, 0xa54ff53a, 0x5f1d36f1,\n    0x510e527f, 0xade682d1, 0x9b05688c, 0x2b3e6c1f, 0x1f83d9ab, 0xfb41bd6b, 0x5be0cd19, 0x137e2179,\n]);\n//# sourceMappingURL=_md.js.map","/**\n * SHA2 hash function. A.k.a. sha256, sha384, sha512, sha512_224, sha512_256.\n * SHA256 is the fastest hash implementable in JS, even faster than Blake3.\n * Check out [RFC 4634](https://www.rfc-editor.org/rfc/rfc4634) and\n * [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).\n * @module\n */\nimport { Chi, HashMD, Maj, SHA224_IV, SHA256_IV, SHA384_IV, SHA512_IV } from \"./_md.js\";\nimport * as u64 from \"./_u64.js\";\nimport { clean, createHasher, oidNist, rotr } from \"./utils.js\";\n/**\n * Round constants:\n * First 32 bits of fractional parts of the cube roots of the first 64 primes 2..311)\n */\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ Uint32Array.from([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n/** Reusable temporary buffer. \"W\" comes straight from spec. */\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\n/** Internal 32-byte base SHA2 hash class. */\nclass SHA2_32B extends HashMD {\n    constructor(outputLen) {\n        super(64, outputLen, 8, false);\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ (W15 >>> 3);\n            const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);\n            const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);\n            const T2 = (sigma0 + Maj(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        clean(SHA256_W);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        clean(this.buffer);\n    }\n}\n/** Internal SHA2-256 hash class. */\nexport class _SHA256 extends SHA2_32B {\n    // We cannot use array here since array allows indexing by variable\n    // which means optimizer/compiler cannot use registers.\n    A = SHA256_IV[0] | 0;\n    B = SHA256_IV[1] | 0;\n    C = SHA256_IV[2] | 0;\n    D = SHA256_IV[3] | 0;\n    E = SHA256_IV[4] | 0;\n    F = SHA256_IV[5] | 0;\n    G = SHA256_IV[6] | 0;\n    H = SHA256_IV[7] | 0;\n    constructor() {\n        super(32);\n    }\n}\n/** Internal SHA2-224 hash class. */\nexport class _SHA224 extends SHA2_32B {\n    A = SHA224_IV[0] | 0;\n    B = SHA224_IV[1] | 0;\n    C = SHA224_IV[2] | 0;\n    D = SHA224_IV[3] | 0;\n    E = SHA224_IV[4] | 0;\n    F = SHA224_IV[5] | 0;\n    G = SHA224_IV[6] | 0;\n    H = SHA224_IV[7] | 0;\n    constructor() {\n        super(28);\n    }\n}\n// SHA2-512 is slower than sha256 in js because u64 operations are slow.\n// Round contants\n// First 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409\n// prettier-ignore\nconst K512 = /* @__PURE__ */ (() => u64.split([\n    '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',\n    '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',\n    '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',\n    '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',\n    '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',\n    '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',\n    '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',\n    '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',\n    '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',\n    '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',\n    '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',\n    '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',\n    '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',\n    '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',\n    '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',\n    '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',\n    '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',\n    '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',\n    '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',\n    '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'\n].map(n => BigInt(n))))();\nconst SHA512_Kh = /* @__PURE__ */ (() => K512[0])();\nconst SHA512_Kl = /* @__PURE__ */ (() => K512[1])();\n// Reusable temporary buffers\nconst SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);\nconst SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);\n/** Internal 64-byte base SHA2 hash class. */\nclass SHA2_64B extends HashMD {\n    constructor(outputLen) {\n        super(128, outputLen, 16, false);\n    }\n    // prettier-ignore\n    get() {\n        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];\n    }\n    // prettier-ignore\n    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {\n        this.Ah = Ah | 0;\n        this.Al = Al | 0;\n        this.Bh = Bh | 0;\n        this.Bl = Bl | 0;\n        this.Ch = Ch | 0;\n        this.Cl = Cl | 0;\n        this.Dh = Dh | 0;\n        this.Dl = Dl | 0;\n        this.Eh = Eh | 0;\n        this.El = El | 0;\n        this.Fh = Fh | 0;\n        this.Fl = Fl | 0;\n        this.Gh = Gh | 0;\n        this.Gl = Gl | 0;\n        this.Hh = Hh | 0;\n        this.Hl = Hl | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4) {\n            SHA512_W_H[i] = view.getUint32(offset);\n            SHA512_W_L[i] = view.getUint32((offset += 4));\n        }\n        for (let i = 16; i < 80; i++) {\n            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\n            const W15h = SHA512_W_H[i - 15] | 0;\n            const W15l = SHA512_W_L[i - 15] | 0;\n            const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);\n            const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);\n            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\n            const W2h = SHA512_W_H[i - 2] | 0;\n            const W2l = SHA512_W_L[i - 2] | 0;\n            const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);\n            const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);\n            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\n            const SUMl = u64.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n            const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n            SHA512_W_H[i] = SUMh | 0;\n            SHA512_W_L[i] = SUMl | 0;\n        }\n        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        // Compression function main loop, 80 rounds\n        for (let i = 0; i < 80; i++) {\n            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\n            const sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);\n            const sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);\n            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const CHIh = (Eh & Fh) ^ (~Eh & Gh);\n            const CHIl = (El & Fl) ^ (~El & Gl);\n            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\n            // prettier-ignore\n            const T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n            const T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n            const T1l = T1ll | 0;\n            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\n            const sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);\n            const sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);\n            const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);\n            const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);\n            Hh = Gh | 0;\n            Hl = Gl | 0;\n            Gh = Fh | 0;\n            Gl = Fl | 0;\n            Fh = Eh | 0;\n            Fl = El | 0;\n            ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n            Dh = Ch | 0;\n            Dl = Cl | 0;\n            Ch = Bh | 0;\n            Cl = Bl | 0;\n            Bh = Ah | 0;\n            Bl = Al | 0;\n            const All = u64.add3L(T1l, sigma0l, MAJl);\n            Ah = u64.add3H(All, T1h, sigma0h, MAJh);\n            Al = All | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        ({ h: Ah, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n        ({ h: Bh, l: Bl } = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n        ({ h: Ch, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n        ({ h: Dh, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n        ({ h: Eh, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n        ({ h: Fh, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n        ({ h: Gh, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n        ({ h: Hh, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n    }\n    roundClean() {\n        clean(SHA512_W_H, SHA512_W_L);\n    }\n    destroy() {\n        clean(this.buffer);\n        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    }\n}\n/** Internal SHA2-512 hash class. */\nexport class _SHA512 extends SHA2_64B {\n    Ah = SHA512_IV[0] | 0;\n    Al = SHA512_IV[1] | 0;\n    Bh = SHA512_IV[2] | 0;\n    Bl = SHA512_IV[3] | 0;\n    Ch = SHA512_IV[4] | 0;\n    Cl = SHA512_IV[5] | 0;\n    Dh = SHA512_IV[6] | 0;\n    Dl = SHA512_IV[7] | 0;\n    Eh = SHA512_IV[8] | 0;\n    El = SHA512_IV[9] | 0;\n    Fh = SHA512_IV[10] | 0;\n    Fl = SHA512_IV[11] | 0;\n    Gh = SHA512_IV[12] | 0;\n    Gl = SHA512_IV[13] | 0;\n    Hh = SHA512_IV[14] | 0;\n    Hl = SHA512_IV[15] | 0;\n    constructor() {\n        super(64);\n    }\n}\n/** Internal SHA2-384 hash class. */\nexport class _SHA384 extends SHA2_64B {\n    Ah = SHA384_IV[0] | 0;\n    Al = SHA384_IV[1] | 0;\n    Bh = SHA384_IV[2] | 0;\n    Bl = SHA384_IV[3] | 0;\n    Ch = SHA384_IV[4] | 0;\n    Cl = SHA384_IV[5] | 0;\n    Dh = SHA384_IV[6] | 0;\n    Dl = SHA384_IV[7] | 0;\n    Eh = SHA384_IV[8] | 0;\n    El = SHA384_IV[9] | 0;\n    Fh = SHA384_IV[10] | 0;\n    Fl = SHA384_IV[11] | 0;\n    Gh = SHA384_IV[12] | 0;\n    Gl = SHA384_IV[13] | 0;\n    Hh = SHA384_IV[14] | 0;\n    Hl = SHA384_IV[15] | 0;\n    constructor() {\n        super(48);\n    }\n}\n/**\n * Truncated SHA512/256 and SHA512/224.\n * SHA512_IV is XORed with 0xa5a5a5a5a5a5a5a5, then used as \"intermediary\" IV of SHA512/t.\n * Then t hashes string to produce result IV.\n * See `test/misc/sha2-gen-iv.js`.\n */\n/** SHA512/224 IV */\nconst T224_IV = /* @__PURE__ */ Uint32Array.from([\n    0x8c3d37c8, 0x19544da2, 0x73e19966, 0x89dcd4d6, 0x1dfab7ae, 0x32ff9c82, 0x679dd514, 0x582f9fcf,\n    0x0f6d2b69, 0x7bd44da8, 0x77e36f73, 0x04c48942, 0x3f9d85a8, 0x6a1d36c8, 0x1112e6ad, 0x91d692a1,\n]);\n/** SHA512/256 IV */\nconst T256_IV = /* @__PURE__ */ Uint32Array.from([\n    0x22312194, 0xfc2bf72c, 0x9f555fa3, 0xc84c64c2, 0x2393b86b, 0x6f53b151, 0x96387719, 0x5940eabd,\n    0x96283ee2, 0xa88effe3, 0xbe5e1e25, 0x53863992, 0x2b0199fc, 0x2c85b8aa, 0x0eb72ddc, 0x81c52ca2,\n]);\n/** Internal SHA2-512/224 hash class. */\nexport class _SHA512_224 extends SHA2_64B {\n    Ah = T224_IV[0] | 0;\n    Al = T224_IV[1] | 0;\n    Bh = T224_IV[2] | 0;\n    Bl = T224_IV[3] | 0;\n    Ch = T224_IV[4] | 0;\n    Cl = T224_IV[5] | 0;\n    Dh = T224_IV[6] | 0;\n    Dl = T224_IV[7] | 0;\n    Eh = T224_IV[8] | 0;\n    El = T224_IV[9] | 0;\n    Fh = T224_IV[10] | 0;\n    Fl = T224_IV[11] | 0;\n    Gh = T224_IV[12] | 0;\n    Gl = T224_IV[13] | 0;\n    Hh = T224_IV[14] | 0;\n    Hl = T224_IV[15] | 0;\n    constructor() {\n        super(28);\n    }\n}\n/** Internal SHA2-512/256 hash class. */\nexport class _SHA512_256 extends SHA2_64B {\n    Ah = T256_IV[0] | 0;\n    Al = T256_IV[1] | 0;\n    Bh = T256_IV[2] | 0;\n    Bl = T256_IV[3] | 0;\n    Ch = T256_IV[4] | 0;\n    Cl = T256_IV[5] | 0;\n    Dh = T256_IV[6] | 0;\n    Dl = T256_IV[7] | 0;\n    Eh = T256_IV[8] | 0;\n    El = T256_IV[9] | 0;\n    Fh = T256_IV[10] | 0;\n    Fl = T256_IV[11] | 0;\n    Gh = T256_IV[12] | 0;\n    Gl = T256_IV[13] | 0;\n    Hh = T256_IV[14] | 0;\n    Hl = T256_IV[15] | 0;\n    constructor() {\n        super(32);\n    }\n}\n/**\n * SHA2-256 hash function from RFC 4634. In JS it's the fastest: even faster than Blake3. Some info:\n *\n * - Trying 2^128 hashes would get 50% chance of collision, using birthday attack.\n * - BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.\n * - Each sha256 hash is executing 2^18 bit operations.\n * - Good 2024 ASICs can do 200Th/sec with 3500 watts of power, corresponding to 2^36 hashes/joule.\n */\nexport const sha256 = /* @__PURE__ */ createHasher(() => new _SHA256(), \n/* @__PURE__ */ oidNist(0x01));\n/** SHA2-224 hash function from RFC 4634 */\nexport const sha224 = /* @__PURE__ */ createHasher(() => new _SHA224(), \n/* @__PURE__ */ oidNist(0x04));\n/** SHA2-512 hash function from RFC 4634. */\nexport const sha512 = /* @__PURE__ */ createHasher(() => new _SHA512(), \n/* @__PURE__ */ oidNist(0x03));\n/** SHA2-384 hash function from RFC 4634. */\nexport const sha384 = /* @__PURE__ */ createHasher(() => new _SHA384(), \n/* @__PURE__ */ oidNist(0x02));\n/**\n * SHA2-512/256 \"truncated\" hash function, with improved resistance to length extension attacks.\n * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).\n */\nexport const sha512_256 = /* @__PURE__ */ createHasher(() => new _SHA512_256(), \n/* @__PURE__ */ oidNist(0x06));\n/**\n * SHA2-512/224 \"truncated\" hash function, with improved resistance to length extension attacks.\n * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).\n */\nexport const sha512_224 = /* @__PURE__ */ createHasher(() => new _SHA512_224(), \n/* @__PURE__ */ oidNist(0x05));\n//# sourceMappingURL=sha2.js.map","/**\n * Hex, bytes and number utilities.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { abytes as abytes_, anumber, bytesToHex as bytesToHex_, concatBytes as concatBytes_, hexToBytes as hexToBytes_, } from '@noble/hashes/utils.js';\nexport { abytes, anumber, bytesToHex, concatBytes, hexToBytes, isBytes, randomBytes, } from '@noble/hashes/utils.js';\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nexport function abool(value, title = '') {\n    if (typeof value !== 'boolean') {\n        const prefix = title && `\"${title}\" `;\n        throw new Error(prefix + 'expected boolean, got type=' + typeof value);\n    }\n    return value;\n}\n// Used in weierstrass, der\nfunction abignumber(n) {\n    if (typeof n === 'bigint') {\n        if (!isPosBig(n))\n            throw new Error('positive bigint expected, got ' + n);\n    }\n    else\n        anumber(n);\n    return n;\n}\nexport function asafenumber(value, title = '') {\n    if (!Number.isSafeInteger(value)) {\n        const prefix = title && `\"${title}\" `;\n        throw new Error(prefix + 'expected safe integer, got type=' + typeof value);\n    }\n}\nexport function numberToHexUnpadded(num) {\n    const hex = abignumber(num).toString(16);\n    return hex.length & 1 ? '0' + hex : hex;\n}\nexport function hexToNumber(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    return hex === '' ? _0n : BigInt('0x' + hex); // Big Endian\n}\n// BE: Big Endian, LE: Little Endian\nexport function bytesToNumberBE(bytes) {\n    return hexToNumber(bytesToHex_(bytes));\n}\nexport function bytesToNumberLE(bytes) {\n    return hexToNumber(bytesToHex_(copyBytes(abytes_(bytes)).reverse()));\n}\nexport function numberToBytesBE(n, len) {\n    anumber(len);\n    n = abignumber(n);\n    const res = hexToBytes_(n.toString(16).padStart(len * 2, '0'));\n    if (res.length !== len)\n        throw new Error('number too large');\n    return res;\n}\nexport function numberToBytesLE(n, len) {\n    return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nexport function numberToVarBytesBE(n) {\n    return hexToBytes_(numberToHexUnpadded(abignumber(n)));\n}\n// Compares 2 u8a-s in kinda constant time\nexport function equalBytes(a, b) {\n    if (a.length !== b.length)\n        return false;\n    let diff = 0;\n    for (let i = 0; i < a.length; i++)\n        diff |= a[i] ^ b[i];\n    return diff === 0;\n}\n/**\n * Copies Uint8Array. We can't use u8a.slice(), because u8a can be Buffer,\n * and Buffer#slice creates mutable copy. Never use Buffers!\n */\nexport function copyBytes(bytes) {\n    return Uint8Array.from(bytes);\n}\n/**\n * Decodes 7-bit ASCII string to Uint8Array, throws on non-ascii symbols\n * Should be safe to use for things expected to be ASCII.\n * Returns exact same result as `TextEncoder` for ASCII or throws.\n */\nexport function asciiToBytes(ascii) {\n    return Uint8Array.from(ascii, (c, i) => {\n        const charCode = c.charCodeAt(0);\n        if (c.length !== 1 || charCode > 127) {\n            throw new Error(`string contains non-ASCII character \"${ascii[i]}\" with code ${charCode} at position ${i}`);\n        }\n        return charCode;\n    });\n}\n// Is positive bigint\nconst isPosBig = (n) => typeof n === 'bigint' && _0n <= n;\nexport function inRange(n, min, max) {\n    return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;\n}\n/**\n * Asserts min <= n < max. NOTE: It's < max and not <= max.\n * @example\n * aInRange('x', x, 1n, 256n); // would assume x is in (1n..255n)\n */\nexport function aInRange(title, n, min, max) {\n    // Why min <= n < max and not a (min < n < max) OR b (min <= n <= max)?\n    // consider P=256n, min=0n, max=P\n    // - a for min=0 would require -1:          `inRange('x', x, -1n, P)`\n    // - b would commonly require subtraction:  `inRange('x', x, 0n, P - 1n)`\n    // - our way is the cleanest:               `inRange('x', x, 0n, P)\n    if (!inRange(n, min, max))\n        throw new Error('expected valid ' + title + ': ' + min + ' <= n < ' + max + ', got ' + n);\n}\n// Bit operations\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n * TODO: merge with nLength in modular\n */\nexport function bitLen(n) {\n    let len;\n    for (len = 0; n > _0n; n >>= _1n, len += 1)\n        ;\n    return len;\n}\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */\nexport function bitGet(n, pos) {\n    return (n >> BigInt(pos)) & _1n;\n}\n/**\n * Sets single bit at position.\n */\nexport function bitSet(n, pos, value) {\n    return n | ((value ? _1n : _0n) << BigInt(pos));\n}\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */\nexport const bitMask = (n) => (_1n << BigInt(n)) - _1n;\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */\nexport function createHmacDrbg(hashLen, qByteLen, hmacFn) {\n    anumber(hashLen, 'hashLen');\n    anumber(qByteLen, 'qByteLen');\n    if (typeof hmacFn !== 'function')\n        throw new Error('hmacFn must be a function');\n    const u8n = (len) => new Uint8Array(len); // creates Uint8Array\n    const NULL = Uint8Array.of();\n    const byte0 = Uint8Array.of(0x00);\n    const byte1 = Uint8Array.of(0x01);\n    const _maxDrbgIters = 1000;\n    // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n    let i = 0; // Iterations counter, will throw when over 1000\n    const reset = () => {\n        v.fill(1);\n        k.fill(0);\n        i = 0;\n    };\n    const h = (...msgs) => hmacFn(k, concatBytes_(v, ...msgs)); // hmac(k)(v, ...values)\n    const reseed = (seed = NULL) => {\n        // HMAC-DRBG reseed() function. Steps D-G\n        k = h(byte0, seed); // k = hmac(k || v || 0x00 || seed)\n        v = h(); // v = hmac(k || v)\n        if (seed.length === 0)\n            return;\n        k = h(byte1, seed); // k = hmac(k || v || 0x01 || seed)\n        v = h(); // v = hmac(k || v)\n    };\n    const gen = () => {\n        // HMAC-DRBG generate() function\n        if (i++ >= _maxDrbgIters)\n            throw new Error('drbg: tried max amount of iterations');\n        let len = 0;\n        const out = [];\n        while (len < qByteLen) {\n            v = h();\n            const sl = v.slice();\n            out.push(sl);\n            len += v.length;\n        }\n        return concatBytes_(...out);\n    };\n    const genUntil = (seed, pred) => {\n        reset();\n        reseed(seed); // Steps D-G\n        let res = undefined; // Step H: grind until k is in [1..n-1]\n        while (!(res = pred(gen())))\n            reseed();\n        reset();\n        return res;\n    };\n    return genUntil;\n}\nexport function validateObject(object, fields = {}, optFields = {}) {\n    if (!object || typeof object !== 'object')\n        throw new Error('expected valid options object');\n    function checkField(fieldName, expectedType, isOpt) {\n        const val = object[fieldName];\n        if (isOpt && val === undefined)\n            return;\n        const current = typeof val;\n        if (current !== expectedType || val === null)\n            throw new Error(`param \"${fieldName}\" is invalid: expected ${expectedType}, got ${current}`);\n    }\n    const iter = (f, isOpt) => Object.entries(f).forEach(([k, v]) => checkField(k, v, isOpt));\n    iter(fields, false);\n    iter(optFields, true);\n}\n/**\n * throws not implemented error\n */\nexport const notImplemented = () => {\n    throw new Error('not implemented');\n};\n/**\n * Memoizes (caches) computation result.\n * Uses WeakMap: the value is going auto-cleaned by GC after last reference is removed.\n */\nexport function memoized(fn) {\n    const map = new WeakMap();\n    return (arg, ...args) => {\n        const val = map.get(arg);\n        if (val !== undefined)\n            return val;\n        const computed = fn(arg, ...args);\n        map.set(arg, computed);\n        return computed;\n    };\n}\n//# sourceMappingURL=utils.js.map","/**\n * Utils for modular division and fields.\n * Field over 11 is a finite (Galois) field is integer number operations `mod 11`.\n * There is no division: it is replaced by modular multiplicative inverse.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { abytes, anumber, bytesToNumberBE, bytesToNumberLE, numberToBytesBE, numberToBytesLE, validateObject, } from \"../utils.js\";\n// Numbers aren't used in x25519 / x448 builds\n// prettier-ignore\nconst _0n = /* @__PURE__ */ BigInt(0), _1n = /* @__PURE__ */ BigInt(1), _2n = /* @__PURE__ */ BigInt(2);\n// prettier-ignore\nconst _3n = /* @__PURE__ */ BigInt(3), _4n = /* @__PURE__ */ BigInt(4), _5n = /* @__PURE__ */ BigInt(5);\n// prettier-ignore\nconst _7n = /* @__PURE__ */ BigInt(7), _8n = /* @__PURE__ */ BigInt(8), _9n = /* @__PURE__ */ BigInt(9);\nconst _16n = /* @__PURE__ */ BigInt(16);\n// Calculates a modulo b\nexport function mod(a, b) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */\nexport function pow(num, power, modulo) {\n    return FpPow(Field(modulo), num, power);\n}\n/** Does `x^(2^power)` mod p. `pow2(30, 4)` == `30^(2^4)` */\nexport function pow2(x, power, modulo) {\n    let res = x;\n    while (power-- > _0n) {\n        res *= res;\n        res %= modulo;\n    }\n    return res;\n}\n/**\n * Inverses number over modulo.\n * Implemented using [Euclidean GCD](https://brilliant.org/wiki/extended-euclidean-algorithm/).\n */\nexport function invert(number, modulo) {\n    if (number === _0n)\n        throw new Error('invert: expected non-zero number');\n    if (modulo <= _0n)\n        throw new Error('invert: expected positive modulus, got ' + modulo);\n    // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n    let a = mod(number, modulo);\n    let b = modulo;\n    // prettier-ignore\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while (a !== _0n) {\n        // JIT applies optimization if those two lines follow each other\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        // prettier-ignore\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n)\n        throw new Error('invert: does not exist');\n    return mod(x, modulo);\n}\nfunction assertIsSquare(Fp, root, n) {\n    if (!Fp.eql(Fp.sqr(root), n))\n        throw new Error('Cannot find square root');\n}\n// Not all roots are possible! Example which will throw:\n// const NUM =\n// n = 72057594037927816n;\n// Fp = Field(BigInt('0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab'));\nfunction sqrt3mod4(Fp, n) {\n    const p1div4 = (Fp.ORDER + _1n) / _4n;\n    const root = Fp.pow(n, p1div4);\n    assertIsSquare(Fp, root, n);\n    return root;\n}\nfunction sqrt5mod8(Fp, n) {\n    const p5div8 = (Fp.ORDER - _5n) / _8n;\n    const n2 = Fp.mul(n, _2n);\n    const v = Fp.pow(n2, p5div8);\n    const nv = Fp.mul(n, v);\n    const i = Fp.mul(Fp.mul(nv, _2n), v);\n    const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n    assertIsSquare(Fp, root, n);\n    return root;\n}\n// Based on RFC9380, Kong algorithm\n// prettier-ignore\nfunction sqrt9mod16(P) {\n    const Fp_ = Field(P);\n    const tn = tonelliShanks(P);\n    const c1 = tn(Fp_, Fp_.neg(Fp_.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n    const c2 = tn(Fp_, c1); //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n    const c3 = tn(Fp_, Fp_.neg(c1)); //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n    const c4 = (P + _7n) / _16n; //  4. c4 = (q + 7) / 16        # Integer arithmetic\n    return (Fp, n) => {\n        let tv1 = Fp.pow(n, c4); //  1. tv1 = x^c4\n        let tv2 = Fp.mul(tv1, c1); //  2. tv2 = c1 * tv1\n        const tv3 = Fp.mul(tv1, c2); //  3. tv3 = c2 * tv1\n        const tv4 = Fp.mul(tv1, c3); //  4. tv4 = c3 * tv1\n        const e1 = Fp.eql(Fp.sqr(tv2), n); //  5.  e1 = (tv2^2) == x\n        const e2 = Fp.eql(Fp.sqr(tv3), n); //  6.  e2 = (tv3^2) == x\n        tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n        tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n        const e3 = Fp.eql(Fp.sqr(tv2), n); //  9.  e3 = (tv2^2) == x\n        const root = Fp.cmov(tv1, tv2, e3); // 10.  z = CMOV(tv1, tv2, e3)   # Select sqrt from tv1 & tv2\n        assertIsSquare(Fp, root, n);\n        return root;\n    };\n}\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */\nexport function tonelliShanks(P) {\n    // Initialization (precomputation).\n    // Caching initialization could boost perf by 7%.\n    if (P < _3n)\n        throw new Error('sqrt is not defined for small field');\n    // Factor P - 1 = Q * 2^S, where Q is odd\n    let Q = P - _1n;\n    let S = 0;\n    while (Q % _2n === _0n) {\n        Q /= _2n;\n        S++;\n    }\n    // Find the first quadratic non-residue Z >= 2\n    let Z = _2n;\n    const _Fp = Field(P);\n    while (FpLegendre(_Fp, Z) === 1) {\n        // Basic primality test for P. After x iterations, chance of\n        // not finding quadratic non-residue is 2^x, so 2^1000.\n        if (Z++ > 1000)\n            throw new Error('Cannot find square root: probably non-prime P');\n    }\n    // Fast-path; usually done before Z, but we do \"primality test\".\n    if (S === 1)\n        return sqrt3mod4;\n    // Slow-path\n    // TODO: test on Fp2 and others\n    let cc = _Fp.pow(Z, Q); // c = z^Q\n    const Q1div2 = (Q + _1n) / _2n;\n    return function tonelliSlow(Fp, n) {\n        if (Fp.is0(n))\n            return n;\n        // Check if n is a quadratic residue using Legendre symbol\n        if (FpLegendre(Fp, n) !== 1)\n            throw new Error('Cannot find square root');\n        // Initialize variables for the main loop\n        let M = S;\n        let c = Fp.mul(Fp.ONE, cc); // c = z^Q, move cc from field _Fp into field Fp\n        let t = Fp.pow(n, Q); // t = n^Q, first guess at the fudge factor\n        let R = Fp.pow(n, Q1div2); // R = n^((Q+1)/2), first guess at the square root\n        // Main loop\n        // while t != 1\n        while (!Fp.eql(t, Fp.ONE)) {\n            if (Fp.is0(t))\n                return Fp.ZERO; // if t=0 return R=0\n            let i = 1;\n            // Find the smallest i >= 1 such that t^(2^i)  1 (mod P)\n            let t_tmp = Fp.sqr(t); // t^(2^1)\n            while (!Fp.eql(t_tmp, Fp.ONE)) {\n                i++;\n                t_tmp = Fp.sqr(t_tmp); // t^(2^2)...\n                if (i === M)\n                    throw new Error('Cannot find square root');\n            }\n            // Calculate the exponent for b: 2^(M - i - 1)\n            const exponent = _1n << BigInt(M - i - 1); // bigint is important\n            const b = Fp.pow(c, exponent); // b = 2^(M - i - 1)\n            // Update variables\n            M = i;\n            c = Fp.sqr(b); // c = b^2\n            t = Fp.mul(t, c); // t = (t * b^2)\n            R = Fp.mul(R, b); // R = R*b\n        }\n        return R;\n    };\n}\n/**\n * Square root for a finite field. Will try optimized versions first:\n *\n * 1. P  3 (mod 4)\n * 2. P  5 (mod 8)\n * 3. P  9 (mod 16)\n * 4. Tonelli-Shanks algorithm\n *\n * Different algorithms can give different roots, it is up to user to decide which one they want.\n * For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n */\nexport function FpSqrt(P) {\n    // P  3 (mod 4) => n = n^((P+1)/4)\n    if (P % _4n === _3n)\n        return sqrt3mod4;\n    // P  5 (mod 8) => Atkin algorithm, page 10 of https://eprint.iacr.org/2012/685.pdf\n    if (P % _8n === _5n)\n        return sqrt5mod8;\n    // P  9 (mod 16) => Kong algorithm, page 11 of https://eprint.iacr.org/2012/685.pdf (algorithm 4)\n    if (P % _16n === _9n)\n        return sqrt9mod16(P);\n    // Tonelli-Shanks algorithm\n    return tonelliShanks(P);\n}\n// Little-endian check for first LE bit (last BE bit);\nexport const isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;\n// prettier-ignore\nconst FIELD_FIELDS = [\n    'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',\n    'eql', 'add', 'sub', 'mul', 'pow', 'div',\n    'addN', 'subN', 'mulN', 'sqrN'\n];\nexport function validateField(field) {\n    const initial = {\n        ORDER: 'bigint',\n        BYTES: 'number',\n        BITS: 'number',\n    };\n    const opts = FIELD_FIELDS.reduce((map, val) => {\n        map[val] = 'function';\n        return map;\n    }, initial);\n    validateObject(field, opts);\n    // const max = 16384;\n    // if (field.BYTES < 1 || field.BYTES > max) throw new Error('invalid field');\n    // if (field.BITS < 1 || field.BITS > 8 * max) throw new Error('invalid field');\n    return field;\n}\n// Generic field functions\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */\nexport function FpPow(Fp, num, power) {\n    if (power < _0n)\n        throw new Error('invalid exponent, negatives unsupported');\n    if (power === _0n)\n        return Fp.ONE;\n    if (power === _1n)\n        return num;\n    let p = Fp.ONE;\n    let d = num;\n    while (power > _0n) {\n        if (power & _1n)\n            p = Fp.mul(p, d);\n        d = Fp.sqr(d);\n        power >>= _1n;\n    }\n    return p;\n}\n/**\n * Efficiently invert an array of Field elements.\n * Exception-free. Will return `undefined` for 0 elements.\n * @param passZero map 0 to 0 (instead of undefined)\n */\nexport function FpInvertBatch(Fp, nums, passZero = false) {\n    const inverted = new Array(nums.length).fill(passZero ? Fp.ZERO : undefined);\n    // Walk from first to last, multiply them by each other MOD p\n    const multipliedAcc = nums.reduce((acc, num, i) => {\n        if (Fp.is0(num))\n            return acc;\n        inverted[i] = acc;\n        return Fp.mul(acc, num);\n    }, Fp.ONE);\n    // Invert last element\n    const invertedAcc = Fp.inv(multipliedAcc);\n    // Walk from last to first, multiply them by inverted each other MOD p\n    nums.reduceRight((acc, num, i) => {\n        if (Fp.is0(num))\n            return acc;\n        inverted[i] = Fp.mul(acc, inverted[i]);\n        return Fp.mul(acc, num);\n    }, invertedAcc);\n    return inverted;\n}\n// TODO: remove\nexport function FpDiv(Fp, lhs, rhs) {\n    return Fp.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, Fp.ORDER) : Fp.inv(rhs));\n}\n/**\n * Legendre symbol.\n * Legendre constant is used to calculate Legendre symbol (a | p)\n * which denotes the value of a^((p-1)/2) (mod p).\n *\n * * (a | p)  1    if a is a square (mod p), quadratic residue\n * * (a | p)  -1   if a is not a square (mod p), quadratic non residue\n * * (a | p)  0    if a  0 (mod p)\n */\nexport function FpLegendre(Fp, n) {\n    // We can use 3rd argument as optional cache of this value\n    // but seems unneeded for now. The operation is very fast.\n    const p1mod2 = (Fp.ORDER - _1n) / _2n;\n    const powered = Fp.pow(n, p1mod2);\n    const yes = Fp.eql(powered, Fp.ONE);\n    const zero = Fp.eql(powered, Fp.ZERO);\n    const no = Fp.eql(powered, Fp.neg(Fp.ONE));\n    if (!yes && !zero && !no)\n        throw new Error('invalid Legendre symbol result');\n    return yes ? 1 : zero ? 0 : -1;\n}\n// This function returns True whenever the value x is a square in the field F.\nexport function FpIsSquare(Fp, n) {\n    const l = FpLegendre(Fp, n);\n    return l === 1;\n}\n// CURVE.n lengths\nexport function nLength(n, nBitLength) {\n    // Bit size, byte size of CURVE.n\n    if (nBitLength !== undefined)\n        anumber(nBitLength);\n    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n    const nByteLength = Math.ceil(_nBitLength / 8);\n    return { nBitLength: _nBitLength, nByteLength };\n}\nclass _Field {\n    ORDER;\n    BITS;\n    BYTES;\n    isLE;\n    ZERO = _0n;\n    ONE = _1n;\n    _lengths;\n    _sqrt; // cached sqrt\n    _mod;\n    constructor(ORDER, opts = {}) {\n        if (ORDER <= _0n)\n            throw new Error('invalid field: expected ORDER > 0, got ' + ORDER);\n        let _nbitLength = undefined;\n        this.isLE = false;\n        if (opts != null && typeof opts === 'object') {\n            if (typeof opts.BITS === 'number')\n                _nbitLength = opts.BITS;\n            if (typeof opts.sqrt === 'function')\n                this.sqrt = opts.sqrt;\n            if (typeof opts.isLE === 'boolean')\n                this.isLE = opts.isLE;\n            if (opts.allowedLengths)\n                this._lengths = opts.allowedLengths?.slice();\n            if (typeof opts.modFromBytes === 'boolean')\n                this._mod = opts.modFromBytes;\n        }\n        const { nBitLength, nByteLength } = nLength(ORDER, _nbitLength);\n        if (nByteLength > 2048)\n            throw new Error('invalid field: expected ORDER of <= 2048 bytes');\n        this.ORDER = ORDER;\n        this.BITS = nBitLength;\n        this.BYTES = nByteLength;\n        this._sqrt = undefined;\n        Object.preventExtensions(this);\n    }\n    create(num) {\n        return mod(num, this.ORDER);\n    }\n    isValid(num) {\n        if (typeof num !== 'bigint')\n            throw new Error('invalid field element: expected bigint, got ' + typeof num);\n        return _0n <= num && num < this.ORDER; // 0 is valid element, but it's not invertible\n    }\n    is0(num) {\n        return num === _0n;\n    }\n    // is valid and invertible\n    isValidNot0(num) {\n        return !this.is0(num) && this.isValid(num);\n    }\n    isOdd(num) {\n        return (num & _1n) === _1n;\n    }\n    neg(num) {\n        return mod(-num, this.ORDER);\n    }\n    eql(lhs, rhs) {\n        return lhs === rhs;\n    }\n    sqr(num) {\n        return mod(num * num, this.ORDER);\n    }\n    add(lhs, rhs) {\n        return mod(lhs + rhs, this.ORDER);\n    }\n    sub(lhs, rhs) {\n        return mod(lhs - rhs, this.ORDER);\n    }\n    mul(lhs, rhs) {\n        return mod(lhs * rhs, this.ORDER);\n    }\n    pow(num, power) {\n        return FpPow(this, num, power);\n    }\n    div(lhs, rhs) {\n        return mod(lhs * invert(rhs, this.ORDER), this.ORDER);\n    }\n    // Same as above, but doesn't normalize\n    sqrN(num) {\n        return num * num;\n    }\n    addN(lhs, rhs) {\n        return lhs + rhs;\n    }\n    subN(lhs, rhs) {\n        return lhs - rhs;\n    }\n    mulN(lhs, rhs) {\n        return lhs * rhs;\n    }\n    inv(num) {\n        return invert(num, this.ORDER);\n    }\n    sqrt(num) {\n        // Caching _sqrt speeds up sqrt9mod16 by 5x and tonneli-shanks by 10%\n        if (!this._sqrt)\n            this._sqrt = FpSqrt(this.ORDER);\n        return this._sqrt(this, num);\n    }\n    toBytes(num) {\n        return this.isLE ? numberToBytesLE(num, this.BYTES) : numberToBytesBE(num, this.BYTES);\n    }\n    fromBytes(bytes, skipValidation = false) {\n        abytes(bytes);\n        const { _lengths: allowedLengths, BYTES, isLE, ORDER, _mod: modFromBytes } = this;\n        if (allowedLengths) {\n            if (!allowedLengths.includes(bytes.length) || bytes.length > BYTES) {\n                throw new Error('Field.fromBytes: expected ' + allowedLengths + ' bytes, got ' + bytes.length);\n            }\n            const padded = new Uint8Array(BYTES);\n            // isLE add 0 to right, !isLE to the left.\n            padded.set(bytes, isLE ? 0 : padded.length - bytes.length);\n            bytes = padded;\n        }\n        if (bytes.length !== BYTES)\n            throw new Error('Field.fromBytes: expected ' + BYTES + ' bytes, got ' + bytes.length);\n        let scalar = isLE ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);\n        if (modFromBytes)\n            scalar = mod(scalar, ORDER);\n        if (!skipValidation)\n            if (!this.isValid(scalar))\n                throw new Error('invalid field element: outside of range 0..ORDER');\n        // NOTE: we don't validate scalar here, please use isValid. This done such way because some\n        // protocol may allow non-reduced scalar that reduced later or changed some other way.\n        return scalar;\n    }\n    // TODO: we don't need it here, move out to separate fn\n    invertBatch(lst) {\n        return FpInvertBatch(this, lst);\n    }\n    // We can't move this out because Fp6, Fp12 implement it\n    // and it's unclear what to return in there.\n    cmov(a, b, condition) {\n        return condition ? b : a;\n    }\n}\n/**\n * Creates a finite field. Major performance optimizations:\n * * 1. Denormalized operations like mulN instead of mul.\n * * 2. Identical object shape: never add or remove keys.\n * * 3. `Object.freeze`.\n * Fragile: always run a benchmark on a change.\n * Security note: operations don't check 'isValid' for all elements for performance reasons,\n * it is caller responsibility to check this.\n * This is low-level code, please make sure you know what you're doing.\n *\n * Note about field properties:\n * * CHARACTERISTIC p = prime number, number of elements in main subgroup.\n * * ORDER q = similar to cofactor in curves, may be composite `q = p^m`.\n *\n * @param ORDER field order, probably prime, or could be composite\n * @param bitLen how many bits the field consumes\n * @param isLE (default: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */\nexport function Field(ORDER, opts = {}) {\n    return new _Field(ORDER, opts);\n}\n// Generic random scalar, we can do same for other fields if via Fp2.mul(Fp2.ONE, Fp2.random)?\n// This allows unsafe methods like ignore bias or zero. These unsafe, but often used in different protocols (if deterministic RNG).\n// which mean we cannot force this via opts.\n// Not sure what to do with randomBytes, we can accept it inside opts if wanted.\n// Probably need to export getMinHashLength somewhere?\n// random(bytes?: Uint8Array, unsafeAllowZero = false, unsafeAllowBias = false) {\n//   const LEN = !unsafeAllowBias ? getMinHashLength(ORDER) : BYTES;\n//   if (bytes === undefined) bytes = randomBytes(LEN); // _opts.randomBytes?\n//   const num = isLE ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);\n//   // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n//   const reduced = unsafeAllowZero ? mod(num, ORDER) : mod(num, ORDER - _1n) + _1n;\n//   return reduced;\n// },\nexport function FpSqrtOdd(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(\"Field doesn't have isOdd\");\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? root : Fp.neg(root);\n}\nexport function FpSqrtEven(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(\"Field doesn't have isOdd\");\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */\nexport function getFieldBytesLength(fieldOrder) {\n    if (typeof fieldOrder !== 'bigint')\n        throw new Error('field order must be bigint');\n    const bitLength = fieldOrder.toString(2).length;\n    return Math.ceil(bitLength / 8);\n}\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */\nexport function getMinHashLength(fieldOrder) {\n    const length = getFieldBytesLength(fieldOrder);\n    return length + Math.ceil(length / 2);\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.Point.Fn.ORDER)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */\nexport function mapHashToField(key, fieldOrder, isLE = false) {\n    abytes(key);\n    const len = key.length;\n    const fieldLen = getFieldBytesLength(fieldOrder);\n    const minLen = getMinHashLength(fieldOrder);\n    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n    if (len < 16 || len < minLen || len > 1024)\n        throw new Error('expected ' + minLen + '-1024 bytes of input, got ' + len);\n    const num = isLE ? bytesToNumberLE(key) : bytesToNumberBE(key);\n    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n    const reduced = mod(num, fieldOrder - _1n) + _1n;\n    return isLE ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);\n}\n//# sourceMappingURL=modular.js.map","/**\n * Methods for elliptic curve multiplication by scalars.\n * Contains wNAF, pippenger.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { bitLen, bitMask } from \"../utils.js\";\nimport { Field, FpInvertBatch, validateField } from \"./modular.js\";\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nexport function negateCt(condition, item) {\n    const neg = item.negate();\n    return condition ? neg : item;\n}\n/**\n * Takes a bunch of Projective Points but executes only one\n * inversion on all of them. Inversion is very slow operation,\n * so this improves performance massively.\n * Optimization: converts a list of projective points to a list of identical points with Z=1.\n */\nexport function normalizeZ(c, points) {\n    const invertedZs = FpInvertBatch(c.Fp, points.map((p) => p.Z));\n    return points.map((p, i) => c.fromAffine(p.toAffine(invertedZs[i])));\n}\nfunction validateW(W, bits) {\n    if (!Number.isSafeInteger(W) || W <= 0 || W > bits)\n        throw new Error('invalid window size, expected [1..' + bits + '], got W=' + W);\n}\nfunction calcWOpts(W, scalarBits) {\n    validateW(W, scalarBits);\n    const windows = Math.ceil(scalarBits / W) + 1; // W=8 33. Not 32, because we skip zero\n    const windowSize = 2 ** (W - 1); // W=8 128. Not 256, because we skip zero\n    const maxNumber = 2 ** W; // W=8 256\n    const mask = bitMask(W); // W=8 255 == mask 0b11111111\n    const shiftBy = BigInt(W); // W=8 8\n    return { windows, windowSize, mask, maxNumber, shiftBy };\n}\nfunction calcOffsets(n, window, wOpts) {\n    const { windowSize, mask, maxNumber, shiftBy } = wOpts;\n    let wbits = Number(n & mask); // extract W bits.\n    let nextN = n >> shiftBy; // shift number by W bits.\n    // What actually happens here:\n    // const highestBit = Number(mask ^ (mask >> 1n));\n    // let wbits2 = wbits - 1; // skip zero\n    // if (wbits2 & highestBit) { wbits2 ^= Number(mask); // (~);\n    // split if bits > max: +224 => 256-32\n    if (wbits > windowSize) {\n        // we skip zero, which means instead of `>= size-1`, we do `> size`\n        wbits -= maxNumber; // -32, can be maxNumber - wbits, but then we need to set isNeg here.\n        nextN += _1n; // +256 (carry)\n    }\n    const offsetStart = window * windowSize;\n    const offset = offsetStart + Math.abs(wbits) - 1; // -1 because we skip zero\n    const isZero = wbits === 0; // is current window slice a 0?\n    const isNeg = wbits < 0; // is current window slice negative?\n    const isNegF = window % 2 !== 0; // fake random statement for noise\n    const offsetF = offsetStart; // fake offset for noise\n    return { nextN, offset, isZero, isNeg, isNegF, offsetF };\n}\nfunction validateMSMPoints(points, c) {\n    if (!Array.isArray(points))\n        throw new Error('array expected');\n    points.forEach((p, i) => {\n        if (!(p instanceof c))\n            throw new Error('invalid point at index ' + i);\n    });\n}\nfunction validateMSMScalars(scalars, field) {\n    if (!Array.isArray(scalars))\n        throw new Error('array of scalars expected');\n    scalars.forEach((s, i) => {\n        if (!field.isValid(s))\n            throw new Error('invalid scalar at index ' + i);\n    });\n}\n// Since points in different groups cannot be equal (different object constructor),\n// we can have single place to store precomputes.\n// Allows to make points frozen / immutable.\nconst pointPrecomputes = new WeakMap();\nconst pointWindowSizes = new WeakMap();\nfunction getW(P) {\n    // To disable precomputes:\n    // return 1;\n    return pointWindowSizes.get(P) || 1;\n}\nfunction assert0(n) {\n    if (n !== _0n)\n        throw new Error('invalid wNAF');\n}\n/**\n * Elliptic curve multiplication of Point by scalar. Fragile.\n * Table generation takes **30MB of ram and 10ms on high-end CPU**,\n * but may take much longer on slow devices. Actual generation will happen on\n * first call of `multiply()`. By default, `BASE` point is precomputed.\n *\n * Scalars should always be less than curve order: this should be checked inside of a curve itself.\n * Creates precomputation tables for fast multiplication:\n * - private scalar is split by fixed size windows of W bits\n * - every window point is collected from window's table & added to accumulator\n * - since windows are different, same point inside tables won't be accessed more than once per calc\n * - each multiplication is 'Math.ceil(CURVE_ORDER / ) + 1' point additions (fixed for any scalar)\n * - +1 window is neccessary for wNAF\n * - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n *\n * @todo Research returning 2d JS array of windows, instead of a single window.\n * This would allow windows to be in different memory locations\n */\nexport class wNAF {\n    BASE;\n    ZERO;\n    Fn;\n    bits;\n    // Parametrized with a given Point class (not individual point)\n    constructor(Point, bits) {\n        this.BASE = Point.BASE;\n        this.ZERO = Point.ZERO;\n        this.Fn = Point.Fn;\n        this.bits = bits;\n    }\n    // non-const time multiplication ladder\n    _unsafeLadder(elm, n, p = this.ZERO) {\n        let d = elm;\n        while (n > _0n) {\n            if (n & _1n)\n                p = p.add(d);\n            d = d.double();\n            n >>= _1n;\n        }\n        return p;\n    }\n    /**\n     * Creates a wNAF precomputation window. Used for caching.\n     * Default window size is set by `utils.precompute()` and is equal to 8.\n     * Number of precomputed points depends on the curve size:\n     * 2^(1) * (Math.ceil( / ) + 1), where:\n     * -  is the window size\n     * -  is the bitlength of the curve order.\n     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n     * @param point Point instance\n     * @param W window size\n     * @returns precomputed point tables flattened to a single array\n     */\n    precomputeWindow(point, W) {\n        const { windows, windowSize } = calcWOpts(W, this.bits);\n        const points = [];\n        let p = point;\n        let base = p;\n        for (let window = 0; window < windows; window++) {\n            base = p;\n            points.push(base);\n            // i=1, bc we skip 0\n            for (let i = 1; i < windowSize; i++) {\n                base = base.add(p);\n                points.push(base);\n            }\n            p = base.double();\n        }\n        return points;\n    }\n    /**\n     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n     * More compact implementation:\n     * https://github.com/paulmillr/noble-secp256k1/blob/47cb1669b6e506ad66b35fe7d76132ae97465da2/index.ts#L502-L541\n     * @returns real and fake (for const-time) points\n     */\n    wNAF(W, precomputes, n) {\n        // Scalar should be smaller than field order\n        if (!this.Fn.isValid(n))\n            throw new Error('invalid scalar');\n        // Accumulators\n        let p = this.ZERO;\n        let f = this.BASE;\n        // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n        // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n        // there is negate now: it is possible that negated element from low value\n        // would be the same as high element, which will create carry into next window.\n        // It's not obvious how this can fail, but still worth investigating later.\n        const wo = calcWOpts(W, this.bits);\n        for (let window = 0; window < wo.windows; window++) {\n            // (n === _0n) is handled and not early-exited. isEven and offsetF are used for noise\n            const { nextN, offset, isZero, isNeg, isNegF, offsetF } = calcOffsets(n, window, wo);\n            n = nextN;\n            if (isZero) {\n                // bits are 0: add garbage to fake point\n                // Important part for const-time getPublicKey: add random \"noise\" point to f.\n                f = f.add(negateCt(isNegF, precomputes[offsetF]));\n            }\n            else {\n                // bits are 1: add to result point\n                p = p.add(negateCt(isNeg, precomputes[offset]));\n            }\n        }\n        assert0(n);\n        // Return both real and fake points: JIT won't eliminate f.\n        // At this point there is a way to F be infinity-point even if p is not,\n        // which makes it less const-time: around 1 bigint multiply.\n        return { p, f };\n    }\n    /**\n     * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.\n     * @param acc accumulator point to add result of multiplication\n     * @returns point\n     */\n    wNAFUnsafe(W, precomputes, n, acc = this.ZERO) {\n        const wo = calcWOpts(W, this.bits);\n        for (let window = 0; window < wo.windows; window++) {\n            if (n === _0n)\n                break; // Early-exit, skip 0 value\n            const { nextN, offset, isZero, isNeg } = calcOffsets(n, window, wo);\n            n = nextN;\n            if (isZero) {\n                // Window bits are 0: skip processing.\n                // Move to next window.\n                continue;\n            }\n            else {\n                const item = precomputes[offset];\n                acc = acc.add(isNeg ? item.negate() : item); // Re-using acc allows to save adds in MSM\n            }\n        }\n        assert0(n);\n        return acc;\n    }\n    getPrecomputes(W, point, transform) {\n        // Calculate precomputes on a first run, reuse them after\n        let comp = pointPrecomputes.get(point);\n        if (!comp) {\n            comp = this.precomputeWindow(point, W);\n            if (W !== 1) {\n                // Doing transform outside of if brings 15% perf hit\n                if (typeof transform === 'function')\n                    comp = transform(comp);\n                pointPrecomputes.set(point, comp);\n            }\n        }\n        return comp;\n    }\n    cached(point, scalar, transform) {\n        const W = getW(point);\n        return this.wNAF(W, this.getPrecomputes(W, point, transform), scalar);\n    }\n    unsafe(point, scalar, transform, prev) {\n        const W = getW(point);\n        if (W === 1)\n            return this._unsafeLadder(point, scalar, prev); // For W=1 ladder is ~x2 faster\n        return this.wNAFUnsafe(W, this.getPrecomputes(W, point, transform), scalar, prev);\n    }\n    // We calculate precomputes for elliptic curve point multiplication\n    // using windowed method. This specifies window size and\n    // stores precomputed values. Usually only base point would be precomputed.\n    createCache(P, W) {\n        validateW(W, this.bits);\n        pointWindowSizes.set(P, W);\n        pointPrecomputes.delete(P);\n    }\n    hasCache(elm) {\n        return getW(elm) !== 1;\n    }\n}\n/**\n * Endomorphism-specific multiplication for Koblitz curves.\n * Cost: 128 dbl, 0-256 adds.\n */\nexport function mulEndoUnsafe(Point, point, k1, k2) {\n    let acc = point;\n    let p1 = Point.ZERO;\n    let p2 = Point.ZERO;\n    while (k1 > _0n || k2 > _0n) {\n        if (k1 & _1n)\n            p1 = p1.add(acc);\n        if (k2 & _1n)\n            p2 = p2.add(acc);\n        acc = acc.double();\n        k1 >>= _1n;\n        k2 >>= _1n;\n    }\n    return { p1, p2 };\n}\n/**\n * Pippenger algorithm for multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * 30x faster vs naive addition on L=4096, 10x faster than precomputes.\n * For N=254bit, L=1, it does: 1024 ADD + 254 DBL. For L=5: 1536 ADD + 254 DBL.\n * Algorithmically constant-time (for same L), even when 1 point + scalar, or when scalar = 0.\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @param scalars array of L scalars (aka secret keys / bigints)\n */\nexport function pippenger(c, points, scalars) {\n    // If we split scalars by some window (let's say 8 bits), every chunk will only\n    // take 256 buckets even if there are 4096 scalars, also re-uses double.\n    // TODO:\n    // - https://eprint.iacr.org/2024/750.pdf\n    // - https://tches.iacr.org/index.php/TCHES/article/view/10287\n    // 0 is accepted in scalars\n    const fieldN = c.Fn;\n    validateMSMPoints(points, c);\n    validateMSMScalars(scalars, fieldN);\n    const plength = points.length;\n    const slength = scalars.length;\n    if (plength !== slength)\n        throw new Error('arrays of points and scalars must have equal length');\n    // if (plength === 0) throw new Error('array must be of length >= 2');\n    const zero = c.ZERO;\n    const wbits = bitLen(BigInt(plength));\n    let windowSize = 1; // bits\n    if (wbits > 12)\n        windowSize = wbits - 3;\n    else if (wbits > 4)\n        windowSize = wbits - 2;\n    else if (wbits > 0)\n        windowSize = 2;\n    const MASK = bitMask(windowSize);\n    const buckets = new Array(Number(MASK) + 1).fill(zero); // +1 for zero array\n    const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;\n    let sum = zero;\n    for (let i = lastBits; i >= 0; i -= windowSize) {\n        buckets.fill(zero);\n        for (let j = 0; j < slength; j++) {\n            const scalar = scalars[j];\n            const wbits = Number((scalar >> BigInt(i)) & MASK);\n            buckets[wbits] = buckets[wbits].add(points[j]);\n        }\n        let resI = zero; // not using this will do small speed-up, but will lose ct\n        // Skip first bucket, because it is zero\n        for (let j = buckets.length - 1, sumI = zero; j > 0; j--) {\n            sumI = sumI.add(buckets[j]);\n            resI = resI.add(sumI);\n        }\n        sum = sum.add(resI);\n        if (i !== 0)\n            for (let j = 0; j < windowSize; j++)\n                sum = sum.double();\n    }\n    return sum;\n}\n/**\n * Precomputed multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @returns function which multiplies points with scaars\n */\nexport function precomputeMSMUnsafe(c, points, windowSize) {\n    /**\n     * Performance Analysis of Window-based Precomputation\n     *\n     * Base Case (256-bit scalar, 8-bit window):\n     * - Standard precomputation requires:\n     *   - 31 additions per scalar  256 scalars = 7,936 ops\n     *   - Plus 255 summary additions = 8,191 total ops\n     *   Note: Summary additions can be optimized via accumulator\n     *\n     * Chunked Precomputation Analysis:\n     * - Using 32 chunks requires:\n     *   - 255 additions per chunk\n     *   - 256 doublings\n     *   - Total: (255  32) + 256 = 8,416 ops\n     *\n     * Memory Usage Comparison:\n     * Window Size | Standard Points | Chunked Points\n     * ------------|-----------------|---------------\n     *     4-bit   |     520         |      15\n     *     8-bit   |    4,224        |     255\n     *    10-bit   |   13,824        |   1,023\n     *    16-bit   |  557,056        |  65,535\n     *\n     * Key Advantages:\n     * 1. Enables larger window sizes due to reduced memory overhead\n     * 2. More efficient for smaller scalar counts:\n     *    - 16 chunks: (16  255) + 256 = 4,336 ops\n     *    - ~2x faster than standard 8,191 ops\n     *\n     * Limitations:\n     * - Not suitable for plain precomputes (requires 256 constant doublings)\n     * - Performance degrades with larger scalar counts:\n     *   - Optimal for ~256 scalars\n     *   - Less efficient for 4096+ scalars (Pippenger preferred)\n     */\n    const fieldN = c.Fn;\n    validateW(windowSize, fieldN.BITS);\n    validateMSMPoints(points, c);\n    const zero = c.ZERO;\n    const tableSize = 2 ** windowSize - 1; // table size (without zero)\n    const chunks = Math.ceil(fieldN.BITS / windowSize); // chunks of item\n    const MASK = bitMask(windowSize);\n    const tables = points.map((p) => {\n        const res = [];\n        for (let i = 0, acc = p; i < tableSize; i++) {\n            res.push(acc);\n            acc = acc.add(p);\n        }\n        return res;\n    });\n    return (scalars) => {\n        validateMSMScalars(scalars, fieldN);\n        if (scalars.length > points.length)\n            throw new Error('array of scalars must be smaller than array of points');\n        let res = zero;\n        for (let i = 0; i < chunks; i++) {\n            // No need to double if accumulator is still zero.\n            if (res !== zero)\n                for (let j = 0; j < windowSize; j++)\n                    res = res.double();\n            const shiftBy = BigInt(chunks * windowSize - (i + 1) * windowSize);\n            for (let j = 0; j < scalars.length; j++) {\n                const n = scalars[j];\n                const curr = Number((n >> shiftBy) & MASK);\n                if (!curr)\n                    continue; // skip zero scalars chunks\n                res = res.add(tables[j][curr - 1]);\n            }\n        }\n        return res;\n    };\n}\nfunction createField(order, field, isLE) {\n    if (field) {\n        if (field.ORDER !== order)\n            throw new Error('Field.ORDER must match order: Fp == p, Fn == n');\n        validateField(field);\n        return field;\n    }\n    else {\n        return Field(order, { isLE });\n    }\n}\n/** Validates CURVE opts and creates fields */\nexport function createCurveFields(type, CURVE, curveOpts = {}, FpFnLE) {\n    if (FpFnLE === undefined)\n        FpFnLE = type === 'edwards';\n    if (!CURVE || typeof CURVE !== 'object')\n        throw new Error(`expected valid ${type} CURVE object`);\n    for (const p of ['p', 'n', 'h']) {\n        const val = CURVE[p];\n        if (!(typeof val === 'bigint' && val > _0n))\n            throw new Error(`CURVE.${p} must be positive bigint`);\n    }\n    const Fp = createField(CURVE.p, curveOpts.Fp, FpFnLE);\n    const Fn = createField(CURVE.n, curveOpts.Fn, FpFnLE);\n    const _b = type === 'weierstrass' ? 'b' : 'd';\n    const params = ['Gx', 'Gy', 'a', _b];\n    for (const p of params) {\n        // @ts-ignore\n        if (!Fp.isValid(CURVE[p]))\n            throw new Error(`CURVE.${p} must be valid field element of CURVE.Fp`);\n    }\n    CURVE = Object.freeze(Object.assign({}, CURVE));\n    return { CURVE, Fp, Fn };\n}\nexport function createKeygen(randomSecretKey, getPublicKey) {\n    return function keygen(seed) {\n        const secretKey = randomSecretKey(seed);\n        return { secretKey, publicKey: getPublicKey(secretKey) };\n    };\n}\n//# sourceMappingURL=curve.js.map","/**\n * HMAC: RFC2104 message authentication code.\n * @module\n */\nimport { abytes, aexists, ahash, clean } from \"./utils.js\";\n/** Internal class for HMAC. */\nexport class _HMAC {\n    oHash;\n    iHash;\n    blockLen;\n    outputLen;\n    finished = false;\n    destroyed = false;\n    constructor(hash, key) {\n        ahash(hash);\n        abytes(key, undefined, 'key');\n        this.iHash = hash.create();\n        if (typeof this.iHash.update !== 'function')\n            throw new Error('Expected instance of class which extends utils.Hash');\n        this.blockLen = this.iHash.blockLen;\n        this.outputLen = this.iHash.outputLen;\n        const blockLen = this.blockLen;\n        const pad = new Uint8Array(blockLen);\n        // blockLen can be bigger than outputLen\n        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n        this.oHash = hash.create();\n        // Undo internal XOR && apply outer XOR\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36 ^ 0x5c;\n        this.oHash.update(pad);\n        clean(pad);\n    }\n    update(buf) {\n        aexists(this);\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        aexists(this);\n        abytes(out, this.outputLen, 'output');\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        // Create new instance without calling constructor since key already in state and we don't know it.\n        to ||= Object.create(Object.getPrototypeOf(this), {});\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n        to = to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash);\n        to.iHash = iHash._cloneInto(to.iHash);\n        return to;\n    }\n    clone() {\n        return this._cloneInto();\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n}\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n * @example\n * import { hmac } from '@noble/hashes/hmac';\n * import { sha256 } from '@noble/hashes/sha2';\n * const mac1 = hmac(sha256, 'key', 'message');\n */\nexport const hmac = (hash, key, message) => new _HMAC(hash, key).update(message).digest();\nhmac.create = (hash, key) => new _HMAC(hash, key);\n//# sourceMappingURL=hmac.js.map","/**\n * Short Weierstrass curve methods. The formula is: y = x + ax + b.\n *\n * ### Design rationale for types\n *\n * * Interaction between classes from different curves should fail:\n *   `k256.Point.BASE.add(p256.Point.BASE)`\n * * For this purpose we want to use `instanceof` operator, which is fast and works during runtime\n * * Different calls of `curve()` would return different classes -\n *   `curve(params) !== curve(params)`: if somebody decided to monkey-patch their curve,\n *   it won't affect others\n *\n * TypeScript can't infer types for classes created inside a function. Classes is one instance\n * of nominative types in TypeScript and interfaces only check for shape, so it's hard to create\n * unique type for every function call.\n *\n * We can use generic types via some param, like curve opts, but that would:\n *     1. Enable interaction between `curve(params)` and `curve(params)` (curves of same params)\n *     which is hard to debug.\n *     2. Params can be generic and we can't enforce them to be constant value:\n *     if somebody creates curve from non-constant params,\n *     it would be allowed to interact with other curves with non-constant params\n *\n * @todo https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-7.html#unique-symbol\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { hmac as nobleHmac } from '@noble/hashes/hmac.js';\nimport { ahash } from '@noble/hashes/utils.js';\nimport { abool, abytes, aInRange, bitLen, bitMask, bytesToHex, bytesToNumberBE, concatBytes, createHmacDrbg, hexToBytes, isBytes, memoized, numberToHexUnpadded, validateObject, randomBytes as wcRandomBytes, } from \"../utils.js\";\nimport { createCurveFields, createKeygen, mulEndoUnsafe, negateCt, normalizeZ, wNAF, } from \"./curve.js\";\nimport { FpInvertBatch, getMinHashLength, mapHashToField, validateField, } from \"./modular.js\";\n// We construct basis in such way that den is always positive and equals n, but num sign depends on basis (not on secret value)\nconst divNearest = (num, den) => (num + (num >= 0 ? den : -den) / _2n) / den;\n/**\n * Splits scalar for GLV endomorphism.\n */\nexport function _splitEndoScalar(k, basis, n) {\n    // Split scalar into two such that part is ~half bits: `abs(part) < sqrt(N)`\n    // Since part can be negative, we need to do this on point.\n    // TODO: verifyScalar function which consumes lambda\n    const [[a1, b1], [a2, b2]] = basis;\n    const c1 = divNearest(b2 * k, n);\n    const c2 = divNearest(-b1 * k, n);\n    // |k1|/|k2| is < sqrt(N), but can be negative.\n    // If we do `k1 mod N`, we'll get big scalar (`> sqrt(N)`): so, we do cheaper negation instead.\n    let k1 = k - c1 * a1 - c2 * a2;\n    let k2 = -c1 * b1 - c2 * b2;\n    const k1neg = k1 < _0n;\n    const k2neg = k2 < _0n;\n    if (k1neg)\n        k1 = -k1;\n    if (k2neg)\n        k2 = -k2;\n    // Double check that resulting scalar less than half bits of N: otherwise wNAF will fail.\n    // This should only happen on wrong basises. Also, math inside is too complex and I don't trust it.\n    const MAX_NUM = bitMask(Math.ceil(bitLen(n) / 2)) + _1n; // Half bits of N\n    if (k1 < _0n || k1 >= MAX_NUM || k2 < _0n || k2 >= MAX_NUM) {\n        throw new Error('splitScalar (endomorphism): failed, k=' + k);\n    }\n    return { k1neg, k1, k2neg, k2 };\n}\nfunction validateSigFormat(format) {\n    if (!['compact', 'recovered', 'der'].includes(format))\n        throw new Error('Signature format must be \"compact\", \"recovered\", or \"der\"');\n    return format;\n}\nfunction validateSigOpts(opts, def) {\n    const optsn = {};\n    for (let optName of Object.keys(def)) {\n        // @ts-ignore\n        optsn[optName] = opts[optName] === undefined ? def[optName] : opts[optName];\n    }\n    abool(optsn.lowS, 'lowS');\n    abool(optsn.prehash, 'prehash');\n    if (optsn.format !== undefined)\n        validateSigFormat(optsn.format);\n    return optsn;\n}\nexport class DERErr extends Error {\n    constructor(m = '') {\n        super(m);\n    }\n}\n/**\n * ASN.1 DER encoding utilities. ASN is very complex & fragile. Format:\n *\n *     [0x30 (SEQUENCE), bytelength, 0x02 (INTEGER), intLength, R, 0x02 (INTEGER), intLength, S]\n *\n * Docs: https://letsencrypt.org/docs/a-warm-welcome-to-asn1-and-der/, https://luca.ntop.org/Teaching/Appunti/asn1.html\n */\nexport const DER = {\n    // asn.1 DER encoding utils\n    Err: DERErr,\n    // Basic building block is TLV (Tag-Length-Value)\n    _tlv: {\n        encode: (tag, data) => {\n            const { Err: E } = DER;\n            if (tag < 0 || tag > 256)\n                throw new E('tlv.encode: wrong tag');\n            if (data.length & 1)\n                throw new E('tlv.encode: unpadded data');\n            const dataLen = data.length / 2;\n            const len = numberToHexUnpadded(dataLen);\n            if ((len.length / 2) & 0b1000_0000)\n                throw new E('tlv.encode: long form length too big');\n            // length of length with long form flag\n            const lenLen = dataLen > 127 ? numberToHexUnpadded((len.length / 2) | 0b1000_0000) : '';\n            const t = numberToHexUnpadded(tag);\n            return t + lenLen + len + data;\n        },\n        // v - value, l - left bytes (unparsed)\n        decode(tag, data) {\n            const { Err: E } = DER;\n            let pos = 0;\n            if (tag < 0 || tag > 256)\n                throw new E('tlv.encode: wrong tag');\n            if (data.length < 2 || data[pos++] !== tag)\n                throw new E('tlv.decode: wrong tlv');\n            const first = data[pos++];\n            const isLong = !!(first & 0b1000_0000); // First bit of first length byte is flag for short/long form\n            let length = 0;\n            if (!isLong)\n                length = first;\n            else {\n                // Long form: [longFlag(1bit), lengthLength(7bit), length (BE)]\n                const lenLen = first & 0b0111_1111;\n                if (!lenLen)\n                    throw new E('tlv.decode(long): indefinite length not supported');\n                if (lenLen > 4)\n                    throw new E('tlv.decode(long): byte length is too big'); // this will overflow u32 in js\n                const lengthBytes = data.subarray(pos, pos + lenLen);\n                if (lengthBytes.length !== lenLen)\n                    throw new E('tlv.decode: length bytes not complete');\n                if (lengthBytes[0] === 0)\n                    throw new E('tlv.decode(long): zero leftmost byte');\n                for (const b of lengthBytes)\n                    length = (length << 8) | b;\n                pos += lenLen;\n                if (length < 128)\n                    throw new E('tlv.decode(long): not minimal encoding');\n            }\n            const v = data.subarray(pos, pos + length);\n            if (v.length !== length)\n                throw new E('tlv.decode: wrong value length');\n            return { v, l: data.subarray(pos + length) };\n        },\n    },\n    // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n    // since we always use positive integers here. It must always be empty:\n    // - add zero byte if exists\n    // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n    _int: {\n        encode(num) {\n            const { Err: E } = DER;\n            if (num < _0n)\n                throw new E('integer: negative integers are not allowed');\n            let hex = numberToHexUnpadded(num);\n            // Pad with zero byte if negative flag is present\n            if (Number.parseInt(hex[0], 16) & 0b1000)\n                hex = '00' + hex;\n            if (hex.length & 1)\n                throw new E('unexpected DER parsing assertion: unpadded hex');\n            return hex;\n        },\n        decode(data) {\n            const { Err: E } = DER;\n            if (data[0] & 0b1000_0000)\n                throw new E('invalid signature integer: negative');\n            if (data[0] === 0x00 && !(data[1] & 0b1000_0000))\n                throw new E('invalid signature integer: unnecessary leading zero');\n            return bytesToNumberBE(data);\n        },\n    },\n    toSig(bytes) {\n        // parse DER signature\n        const { Err: E, _int: int, _tlv: tlv } = DER;\n        const data = abytes(bytes, undefined, 'signature');\n        const { v: seqBytes, l: seqLeftBytes } = tlv.decode(0x30, data);\n        if (seqLeftBytes.length)\n            throw new E('invalid signature: left bytes after parsing');\n        const { v: rBytes, l: rLeftBytes } = tlv.decode(0x02, seqBytes);\n        const { v: sBytes, l: sLeftBytes } = tlv.decode(0x02, rLeftBytes);\n        if (sLeftBytes.length)\n            throw new E('invalid signature: left bytes after parsing');\n        return { r: int.decode(rBytes), s: int.decode(sBytes) };\n    },\n    hexFromSig(sig) {\n        const { _tlv: tlv, _int: int } = DER;\n        const rs = tlv.encode(0x02, int.encode(sig.r));\n        const ss = tlv.encode(0x02, int.encode(sig.s));\n        const seq = rs + ss;\n        return tlv.encode(0x30, seq);\n    },\n};\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\n/**\n * Creates weierstrass Point constructor, based on specified curve options.\n *\n * See {@link WeierstrassOpts}.\n *\n * @example\n```js\nconst opts = {\n  p: 0xfffffffffffffffffffffffffffffffeffffac73n,\n  n: 0x100000000000000000001b8fa16dfab9aca16b6b3n,\n  h: 1n,\n  a: 0n,\n  b: 7n,\n  Gx: 0x3b4c382ce37aa192a4019e763036f4f5dd4d7ebbn,\n  Gy: 0x938cf935318fdced6bc28286531733c3f03c4feen,\n};\nconst secp160k1_Point = weierstrass(opts);\n```\n */\nexport function weierstrass(params, extraOpts = {}) {\n    const validated = createCurveFields('weierstrass', params, extraOpts);\n    const { Fp, Fn } = validated;\n    let CURVE = validated.CURVE;\n    const { h: cofactor, n: CURVE_ORDER } = CURVE;\n    validateObject(extraOpts, {}, {\n        allowInfinityPoint: 'boolean',\n        clearCofactor: 'function',\n        isTorsionFree: 'function',\n        fromBytes: 'function',\n        toBytes: 'function',\n        endo: 'object',\n    });\n    const { endo } = extraOpts;\n    if (endo) {\n        // validateObject(endo, { beta: 'bigint', splitScalar: 'function' });\n        if (!Fp.is0(CURVE.a) || typeof endo.beta !== 'bigint' || !Array.isArray(endo.basises)) {\n            throw new Error('invalid endo: expected \"beta\": bigint and \"basises\": array');\n        }\n    }\n    const lengths = getWLengths(Fp, Fn);\n    function assertCompressionIsSupported() {\n        if (!Fp.isOdd)\n            throw new Error('compression is not supported: Field does not have .isOdd()');\n    }\n    // Implements IEEE P1363 point encoding\n    function pointToBytes(_c, point, isCompressed) {\n        const { x, y } = point.toAffine();\n        const bx = Fp.toBytes(x);\n        abool(isCompressed, 'isCompressed');\n        if (isCompressed) {\n            assertCompressionIsSupported();\n            const hasEvenY = !Fp.isOdd(y);\n            return concatBytes(pprefix(hasEvenY), bx);\n        }\n        else {\n            return concatBytes(Uint8Array.of(0x04), bx, Fp.toBytes(y));\n        }\n    }\n    function pointFromBytes(bytes) {\n        abytes(bytes, undefined, 'Point');\n        const { publicKey: comp, publicKeyUncompressed: uncomp } = lengths; // e.g. for 32-byte: 33, 65\n        const length = bytes.length;\n        const head = bytes[0];\n        const tail = bytes.subarray(1);\n        // No actual validation is done here: use .assertValidity()\n        if (length === comp && (head === 0x02 || head === 0x03)) {\n            const x = Fp.fromBytes(tail);\n            if (!Fp.isValid(x))\n                throw new Error('bad point: is not on curve, wrong x');\n            const y2 = weierstrassEquation(x); // y = x + ax + b\n            let y;\n            try {\n                y = Fp.sqrt(y2); // y = y ^ (p+1)/4\n            }\n            catch (sqrtError) {\n                const err = sqrtError instanceof Error ? ': ' + sqrtError.message : '';\n                throw new Error('bad point: is not on curve, sqrt error' + err);\n            }\n            assertCompressionIsSupported();\n            const evenY = Fp.isOdd(y);\n            const evenH = (head & 1) === 1; // ECDSA-specific\n            if (evenH !== evenY)\n                y = Fp.neg(y);\n            return { x, y };\n        }\n        else if (length === uncomp && head === 0x04) {\n            // TODO: more checks\n            const L = Fp.BYTES;\n            const x = Fp.fromBytes(tail.subarray(0, L));\n            const y = Fp.fromBytes(tail.subarray(L, L * 2));\n            if (!isValidXY(x, y))\n                throw new Error('bad point: is not on curve');\n            return { x, y };\n        }\n        else {\n            throw new Error(`bad point: got length ${length}, expected compressed=${comp} or uncompressed=${uncomp}`);\n        }\n    }\n    const encodePoint = extraOpts.toBytes || pointToBytes;\n    const decodePoint = extraOpts.fromBytes || pointFromBytes;\n    function weierstrassEquation(x) {\n        const x2 = Fp.sqr(x); // x * x\n        const x3 = Fp.mul(x2, x); // x * x\n        return Fp.add(Fp.add(x3, Fp.mul(x, CURVE.a)), CURVE.b); // x + a * x + b\n    }\n    // TODO: move top-level\n    /** Checks whether equation holds for given x, y: y == x + ax + b */\n    function isValidXY(x, y) {\n        const left = Fp.sqr(y); // y\n        const right = weierstrassEquation(x); // x + ax + b\n        return Fp.eql(left, right);\n    }\n    // Validate whether the passed curve params are valid.\n    // Test 1: equation y = x + ax + b should work for generator point.\n    if (!isValidXY(CURVE.Gx, CURVE.Gy))\n        throw new Error('bad curve params: generator point');\n    // Test 2: discriminant  part should be non-zero: 4a + 27b != 0.\n    // Guarantees curve is genus-1, smooth (non-singular).\n    const _4a3 = Fp.mul(Fp.pow(CURVE.a, _3n), _4n);\n    const _27b2 = Fp.mul(Fp.sqr(CURVE.b), BigInt(27));\n    if (Fp.is0(Fp.add(_4a3, _27b2)))\n        throw new Error('bad curve params: a or b');\n    /** Asserts coordinate is valid: 0 <= n < Fp.ORDER. */\n    function acoord(title, n, banZero = false) {\n        if (!Fp.isValid(n) || (banZero && Fp.is0(n)))\n            throw new Error(`bad point coordinate ${title}`);\n        return n;\n    }\n    function aprjpoint(other) {\n        if (!(other instanceof Point))\n            throw new Error('Weierstrass Point expected');\n    }\n    function splitEndoScalarN(k) {\n        if (!endo || !endo.basises)\n            throw new Error('no endo');\n        return _splitEndoScalar(k, endo.basises, Fn.ORDER);\n    }\n    // Memoized toAffine / validity check. They are heavy. Points are immutable.\n    // Converts Projective point to affine (x, y) coordinates.\n    // Can accept precomputed Z^-1 - for example, from invertBatch.\n    // (X, Y, Z)  (x=X/Z, y=Y/Z)\n    const toAffineMemo = memoized((p, iz) => {\n        const { X, Y, Z } = p;\n        // Fast-path for normalized points\n        if (Fp.eql(Z, Fp.ONE))\n            return { x: X, y: Y };\n        const is0 = p.is0();\n        // If invZ was 0, we return zero point. However we still want to execute\n        // all operations, so we replace invZ with a random number, 1.\n        if (iz == null)\n            iz = is0 ? Fp.ONE : Fp.inv(Z);\n        const x = Fp.mul(X, iz);\n        const y = Fp.mul(Y, iz);\n        const zz = Fp.mul(Z, iz);\n        if (is0)\n            return { x: Fp.ZERO, y: Fp.ZERO };\n        if (!Fp.eql(zz, Fp.ONE))\n            throw new Error('invZ was invalid');\n        return { x, y };\n    });\n    // NOTE: on exception this will crash 'cached' and no value will be set.\n    // Otherwise true will be return\n    const assertValidMemo = memoized((p) => {\n        if (p.is0()) {\n            // (0, 1, 0) aka ZERO is invalid in most contexts.\n            // In BLS, ZERO can be serialized, so we allow it.\n            // (0, 0, 0) is invalid representation of ZERO.\n            if (extraOpts.allowInfinityPoint && !Fp.is0(p.Y))\n                return;\n            throw new Error('bad point: ZERO');\n        }\n        // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\n        const { x, y } = p.toAffine();\n        if (!Fp.isValid(x) || !Fp.isValid(y))\n            throw new Error('bad point: x or y not field elements');\n        if (!isValidXY(x, y))\n            throw new Error('bad point: equation left != right');\n        if (!p.isTorsionFree())\n            throw new Error('bad point: not in prime-order subgroup');\n        return true;\n    });\n    function finishEndo(endoBeta, k1p, k2p, k1neg, k2neg) {\n        k2p = new Point(Fp.mul(k2p.X, endoBeta), k2p.Y, k2p.Z);\n        k1p = negateCt(k1neg, k1p);\n        k2p = negateCt(k2neg, k2p);\n        return k1p.add(k2p);\n    }\n    /**\n     * Projective Point works in 3d / projective (homogeneous) coordinates:(X, Y, Z)  (x=X/Z, y=Y/Z).\n     * Default Point works in 2d / affine coordinates: (x, y).\n     * We're doing calculations in projective, because its operations don't require costly inversion.\n     */\n    class Point {\n        // base / generator point\n        static BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\n        // zero / infinity / identity point\n        static ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO); // 0, 1, 0\n        // math field\n        static Fp = Fp;\n        // scalar field\n        static Fn = Fn;\n        X;\n        Y;\n        Z;\n        /** Does NOT validate if the point is valid. Use `.assertValidity()`. */\n        constructor(X, Y, Z) {\n            this.X = acoord('x', X);\n            this.Y = acoord('y', Y, true);\n            this.Z = acoord('z', Z);\n            Object.freeze(this);\n        }\n        static CURVE() {\n            return CURVE;\n        }\n        /** Does NOT validate if the point is valid. Use `.assertValidity()`. */\n        static fromAffine(p) {\n            const { x, y } = p || {};\n            if (!p || !Fp.isValid(x) || !Fp.isValid(y))\n                throw new Error('invalid affine point');\n            if (p instanceof Point)\n                throw new Error('projective point not allowed');\n            // (0, 0) would've produced (0, 0, 1) - instead, we need (0, 1, 0)\n            if (Fp.is0(x) && Fp.is0(y))\n                return Point.ZERO;\n            return new Point(x, y, Fp.ONE);\n        }\n        static fromBytes(bytes) {\n            const P = Point.fromAffine(decodePoint(abytes(bytes, undefined, 'point')));\n            P.assertValidity();\n            return P;\n        }\n        static fromHex(hex) {\n            return Point.fromBytes(hexToBytes(hex));\n        }\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        /**\n         *\n         * @param windowSize\n         * @param isLazy true will defer table computation until the first multiplication\n         * @returns\n         */\n        precompute(windowSize = 8, isLazy = true) {\n            wnaf.createCache(this, windowSize);\n            if (!isLazy)\n                this.multiply(_3n); // random number\n            return this;\n        }\n        // TODO: return `this`\n        /** A point on curve is valid if it conforms to equation. */\n        assertValidity() {\n            assertValidMemo(this);\n        }\n        hasEvenY() {\n            const { y } = this.toAffine();\n            if (!Fp.isOdd)\n                throw new Error(\"Field doesn't support isOdd\");\n            return !Fp.isOdd(y);\n        }\n        /** Compare one point to another. */\n        equals(other) {\n            aprjpoint(other);\n            const { X: X1, Y: Y1, Z: Z1 } = this;\n            const { X: X2, Y: Y2, Z: Z2 } = other;\n            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\n            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\n            return U1 && U2;\n        }\n        /** Flips point to one corresponding to (x, -y) in Affine coordinates. */\n        negate() {\n            return new Point(this.X, Fp.neg(this.Y), this.Z);\n        }\n        // Renes-Costello-Batina exception-free doubling formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 3\n        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n        double() {\n            const { a, b } = CURVE;\n            const b3 = Fp.mul(b, _3n);\n            const { X: X1, Y: Y1, Z: Z1 } = this;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            let t0 = Fp.mul(X1, X1); // step 1\n            let t1 = Fp.mul(Y1, Y1);\n            let t2 = Fp.mul(Z1, Z1);\n            let t3 = Fp.mul(X1, Y1);\n            t3 = Fp.add(t3, t3); // step 5\n            Z3 = Fp.mul(X1, Z1);\n            Z3 = Fp.add(Z3, Z3);\n            X3 = Fp.mul(a, Z3);\n            Y3 = Fp.mul(b3, t2);\n            Y3 = Fp.add(X3, Y3); // step 10\n            X3 = Fp.sub(t1, Y3);\n            Y3 = Fp.add(t1, Y3);\n            Y3 = Fp.mul(X3, Y3);\n            X3 = Fp.mul(t3, X3);\n            Z3 = Fp.mul(b3, Z3); // step 15\n            t2 = Fp.mul(a, t2);\n            t3 = Fp.sub(t0, t2);\n            t3 = Fp.mul(a, t3);\n            t3 = Fp.add(t3, Z3);\n            Z3 = Fp.add(t0, t0); // step 20\n            t0 = Fp.add(Z3, t0);\n            t0 = Fp.add(t0, t2);\n            t0 = Fp.mul(t0, t3);\n            Y3 = Fp.add(Y3, t0);\n            t2 = Fp.mul(Y1, Z1); // step 25\n            t2 = Fp.add(t2, t2);\n            t0 = Fp.mul(t2, t3);\n            X3 = Fp.sub(X3, t0);\n            Z3 = Fp.mul(t2, t1);\n            Z3 = Fp.add(Z3, Z3); // step 30\n            Z3 = Fp.add(Z3, Z3);\n            return new Point(X3, Y3, Z3);\n        }\n        // Renes-Costello-Batina exception-free addition formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 1\n        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n        add(other) {\n            aprjpoint(other);\n            const { X: X1, Y: Y1, Z: Z1 } = this;\n            const { X: X2, Y: Y2, Z: Z2 } = other;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            const a = CURVE.a;\n            const b3 = Fp.mul(CURVE.b, _3n);\n            let t0 = Fp.mul(X1, X2); // step 1\n            let t1 = Fp.mul(Y1, Y2);\n            let t2 = Fp.mul(Z1, Z2);\n            let t3 = Fp.add(X1, Y1);\n            let t4 = Fp.add(X2, Y2); // step 5\n            t3 = Fp.mul(t3, t4);\n            t4 = Fp.add(t0, t1);\n            t3 = Fp.sub(t3, t4);\n            t4 = Fp.add(X1, Z1);\n            let t5 = Fp.add(X2, Z2); // step 10\n            t4 = Fp.mul(t4, t5);\n            t5 = Fp.add(t0, t2);\n            t4 = Fp.sub(t4, t5);\n            t5 = Fp.add(Y1, Z1);\n            X3 = Fp.add(Y2, Z2); // step 15\n            t5 = Fp.mul(t5, X3);\n            X3 = Fp.add(t1, t2);\n            t5 = Fp.sub(t5, X3);\n            Z3 = Fp.mul(a, t4);\n            X3 = Fp.mul(b3, t2); // step 20\n            Z3 = Fp.add(X3, Z3);\n            X3 = Fp.sub(t1, Z3);\n            Z3 = Fp.add(t1, Z3);\n            Y3 = Fp.mul(X3, Z3);\n            t1 = Fp.add(t0, t0); // step 25\n            t1 = Fp.add(t1, t0);\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.mul(b3, t4);\n            t1 = Fp.add(t1, t2);\n            t2 = Fp.sub(t0, t2); // step 30\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.add(t4, t2);\n            t0 = Fp.mul(t1, t4);\n            Y3 = Fp.add(Y3, t0);\n            t0 = Fp.mul(t5, t4); // step 35\n            X3 = Fp.mul(t3, X3);\n            X3 = Fp.sub(X3, t0);\n            t0 = Fp.mul(t3, t1);\n            Z3 = Fp.mul(t5, Z3);\n            Z3 = Fp.add(Z3, t0); // step 40\n            return new Point(X3, Y3, Z3);\n        }\n        subtract(other) {\n            return this.add(other.negate());\n        }\n        is0() {\n            return this.equals(Point.ZERO);\n        }\n        /**\n         * Constant time multiplication.\n         * Uses wNAF method. Windowed method may be 10% faster,\n         * but takes 2x longer to generate and consumes 2x memory.\n         * Uses precomputes when available.\n         * Uses endomorphism for Koblitz curves.\n         * @param scalar by which the point would be multiplied\n         * @returns New point\n         */\n        multiply(scalar) {\n            const { endo } = extraOpts;\n            if (!Fn.isValidNot0(scalar))\n                throw new Error('invalid scalar: out of range'); // 0 is invalid\n            let point, fake; // Fake point is used to const-time mult\n            const mul = (n) => wnaf.cached(this, n, (p) => normalizeZ(Point, p));\n            /** See docs for {@link EndomorphismOpts} */\n            if (endo) {\n                const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(scalar);\n                const { p: k1p, f: k1f } = mul(k1);\n                const { p: k2p, f: k2f } = mul(k2);\n                fake = k1f.add(k2f);\n                point = finishEndo(endo.beta, k1p, k2p, k1neg, k2neg);\n            }\n            else {\n                const { p, f } = mul(scalar);\n                point = p;\n                fake = f;\n            }\n            // Normalize `z` for both points, but return only real one\n            return normalizeZ(Point, [point, fake])[0];\n        }\n        /**\n         * Non-constant-time multiplication. Uses double-and-add algorithm.\n         * It's faster, but should only be used when you don't care about\n         * an exposed secret key e.g. sig verification, which works over *public* keys.\n         */\n        multiplyUnsafe(sc) {\n            const { endo } = extraOpts;\n            const p = this;\n            if (!Fn.isValid(sc))\n                throw new Error('invalid scalar: out of range'); // 0 is valid\n            if (sc === _0n || p.is0())\n                return Point.ZERO; // 0\n            if (sc === _1n)\n                return p; // 1\n            if (wnaf.hasCache(this))\n                return this.multiply(sc); // precomputes\n            // We don't have method for double scalar multiplication (aP + bQ):\n            // Even with using Strauss-Shamir trick, it's 35% slower than nave mul+add.\n            if (endo) {\n                const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(sc);\n                const { p1, p2 } = mulEndoUnsafe(Point, p, k1, k2); // 30% faster vs wnaf.unsafe\n                return finishEndo(endo.beta, p1, p2, k1neg, k2neg);\n            }\n            else {\n                return wnaf.unsafe(p, sc);\n            }\n        }\n        /**\n         * Converts Projective point to affine (x, y) coordinates.\n         * @param invertedZ Z^-1 (inverted zero) - optional, precomputation is useful for invertBatch\n         */\n        toAffine(invertedZ) {\n            return toAffineMemo(this, invertedZ);\n        }\n        /**\n         * Checks whether Point is free of torsion elements (is in prime subgroup).\n         * Always torsion-free for cofactor=1 curves.\n         */\n        isTorsionFree() {\n            const { isTorsionFree } = extraOpts;\n            if (cofactor === _1n)\n                return true;\n            if (isTorsionFree)\n                return isTorsionFree(Point, this);\n            return wnaf.unsafe(this, CURVE_ORDER).is0();\n        }\n        clearCofactor() {\n            const { clearCofactor } = extraOpts;\n            if (cofactor === _1n)\n                return this; // Fast-path\n            if (clearCofactor)\n                return clearCofactor(Point, this);\n            return this.multiplyUnsafe(cofactor);\n        }\n        isSmallOrder() {\n            // can we use this.clearCofactor()?\n            return this.multiplyUnsafe(cofactor).is0();\n        }\n        toBytes(isCompressed = true) {\n            abool(isCompressed, 'isCompressed');\n            this.assertValidity();\n            return encodePoint(Point, this, isCompressed);\n        }\n        toHex(isCompressed = true) {\n            return bytesToHex(this.toBytes(isCompressed));\n        }\n        toString() {\n            return `<Point ${this.is0() ? 'ZERO' : this.toHex()}>`;\n        }\n    }\n    const bits = Fn.BITS;\n    const wnaf = new wNAF(Point, extraOpts.endo ? Math.ceil(bits / 2) : bits);\n    Point.BASE.precompute(8); // Enable precomputes. Slows down first publicKey computation by 20ms.\n    return Point;\n}\n// Points start with byte 0x02 when y is even; otherwise 0x03\nfunction pprefix(hasEvenY) {\n    return Uint8Array.of(hasEvenY ? 0x02 : 0x03);\n}\n/**\n * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.\n * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.\n * b = True and y = sqrt(u / v) if (u / v) is square in F, and\n * b = False and y = sqrt(Z * (u / v)) otherwise.\n * @param Fp\n * @param Z\n * @returns\n */\nexport function SWUFpSqrtRatio(Fp, Z) {\n    // Generic implementation\n    const q = Fp.ORDER;\n    let l = _0n;\n    for (let o = q - _1n; o % _2n === _0n; o /= _2n)\n        l += _1n;\n    const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\n    // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.\n    // 2n ** c1 == 2n << (c1-1)\n    const _2n_pow_c1_1 = _2n << (c1 - _1n - _1n);\n    const _2n_pow_c1 = _2n_pow_c1_1 * _2n;\n    const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic\n    const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\n    const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\n    const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic\n    const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\n    const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)\n    let sqrtRatio = (u, v) => {\n        let tv1 = c6; // 1. tv1 = c6\n        let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\n        let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\n        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\n        let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\n        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\n        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\n        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\n        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\n        let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\n        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\n        let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\n        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\n        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\n        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\n        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\n        // 17. for i in (c1, c1 - 1, ..., 2):\n        for (let i = c1; i > _1n; i--) {\n            let tv5 = i - _2n; // 18.    tv5 = i - 2\n            tv5 = _2n << (tv5 - _1n); // 19.    tv5 = 2^tv5\n            let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\n            const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\n            tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\n            tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\n            tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\n            tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\n            tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\n        }\n        return { isValid: isQR, value: tv3 };\n    };\n    if (Fp.ORDER % _4n === _3n) {\n        // sqrt_ratio_3mod4(u, v)\n        const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\n        const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\n        sqrtRatio = (u, v) => {\n            let tv1 = Fp.sqr(v); // 1. tv1 = v^2\n            const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\n            tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\n            let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\n            y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\n            const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\n            const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\n            const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\n            let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\n            return { isValid: isQR, value: y }; // 11. return (isQR, y) isQR ? y : y*c2\n        };\n    }\n    // No curves uses that\n    // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\n    return sqrtRatio;\n}\n/**\n * Simplified Shallue-van de Woestijne-Ulas Method\n * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2\n */\nexport function mapToCurveSimpleSWU(Fp, opts) {\n    validateField(Fp);\n    const { A, B, Z } = opts;\n    if (!Fp.isValid(A) || !Fp.isValid(B) || !Fp.isValid(Z))\n        throw new Error('mapToCurveSimpleSWU: invalid opts');\n    const sqrtRatio = SWUFpSqrtRatio(Fp, Z);\n    if (!Fp.isOdd)\n        throw new Error('Field does not have .isOdd()');\n    // Input: u, an element of F.\n    // Output: (x, y), a point on E.\n    return (u) => {\n        // prettier-ignore\n        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\n        tv1 = Fp.sqr(u); // 1.  tv1 = u^2\n        tv1 = Fp.mul(tv1, Z); // 2.  tv1 = Z * tv1\n        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\n        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\n        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\n        tv3 = Fp.mul(tv3, B); // 6.  tv3 = B * tv3\n        tv4 = Fp.cmov(Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\n        tv4 = Fp.mul(tv4, A); // 8.  tv4 = A * tv4\n        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\n        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\n        tv5 = Fp.mul(tv6, A); // 11. tv5 = A * tv6\n        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\n        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\n        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\n        tv5 = Fp.mul(tv6, B); // 15. tv5 = B * tv6\n        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\n        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\n        const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\n        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\n        y = Fp.mul(y, value); // 20.   y = y * y1\n        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\n        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\n        const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)\n        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\n        const tv4_inv = FpInvertBatch(Fp, [tv4], true)[0];\n        x = Fp.mul(x, tv4_inv); // 25.   x = x / tv4\n        return { x, y };\n    };\n}\nfunction getWLengths(Fp, Fn) {\n    return {\n        secretKey: Fn.BYTES,\n        publicKey: 1 + Fp.BYTES,\n        publicKeyUncompressed: 1 + 2 * Fp.BYTES,\n        publicKeyHasPrefix: true,\n        signature: 2 * Fn.BYTES,\n    };\n}\n/**\n * Sometimes users only need getPublicKey, getSharedSecret, and secret key handling.\n * This helper ensures no signature functionality is present. Less code, smaller bundle size.\n */\nexport function ecdh(Point, ecdhOpts = {}) {\n    const { Fn } = Point;\n    const randomBytes_ = ecdhOpts.randomBytes || wcRandomBytes;\n    const lengths = Object.assign(getWLengths(Point.Fp, Fn), { seed: getMinHashLength(Fn.ORDER) });\n    function isValidSecretKey(secretKey) {\n        try {\n            const num = Fn.fromBytes(secretKey);\n            return Fn.isValidNot0(num);\n        }\n        catch (error) {\n            return false;\n        }\n    }\n    function isValidPublicKey(publicKey, isCompressed) {\n        const { publicKey: comp, publicKeyUncompressed } = lengths;\n        try {\n            const l = publicKey.length;\n            if (isCompressed === true && l !== comp)\n                return false;\n            if (isCompressed === false && l !== publicKeyUncompressed)\n                return false;\n            return !!Point.fromBytes(publicKey);\n        }\n        catch (error) {\n            return false;\n        }\n    }\n    /**\n     * Produces cryptographically secure secret key from random of size\n     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.\n     */\n    function randomSecretKey(seed = randomBytes_(lengths.seed)) {\n        return mapHashToField(abytes(seed, lengths.seed, 'seed'), Fn.ORDER);\n    }\n    /**\n     * Computes public key for a secret key. Checks for validity of the secret key.\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns Public key, full when isCompressed=false; short when isCompressed=true\n     */\n    function getPublicKey(secretKey, isCompressed = true) {\n        return Point.BASE.multiply(Fn.fromBytes(secretKey)).toBytes(isCompressed);\n    }\n    /**\n     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\n     */\n    function isProbPub(item) {\n        const { secretKey, publicKey, publicKeyUncompressed } = lengths;\n        if (!isBytes(item))\n            return undefined;\n        if (('_lengths' in Fn && Fn._lengths) || secretKey === publicKey)\n            return undefined;\n        const l = abytes(item, undefined, 'key').length;\n        return l === publicKey || l === publicKeyUncompressed;\n    }\n    /**\n     * ECDH (Elliptic Curve Diffie Hellman).\n     * Computes shared public key from secret key A and public key B.\n     * Checks: 1) secret key validity 2) shared key is on-curve.\n     * Does NOT hash the result.\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns shared public key\n     */\n    function getSharedSecret(secretKeyA, publicKeyB, isCompressed = true) {\n        if (isProbPub(secretKeyA) === true)\n            throw new Error('first arg must be private key');\n        if (isProbPub(publicKeyB) === false)\n            throw new Error('second arg must be public key');\n        const s = Fn.fromBytes(secretKeyA);\n        const b = Point.fromBytes(publicKeyB); // checks for being on-curve\n        return b.multiply(s).toBytes(isCompressed);\n    }\n    const utils = {\n        isValidSecretKey,\n        isValidPublicKey,\n        randomSecretKey,\n    };\n    const keygen = createKeygen(randomSecretKey, getPublicKey);\n    return Object.freeze({ getPublicKey, getSharedSecret, keygen, Point, utils, lengths });\n}\n/**\n * Creates ECDSA signing interface for given elliptic curve `Point` and `hash` function.\n *\n * @param Point created using {@link weierstrass} function\n * @param hash used for 1) message prehash-ing 2) k generation in `sign`, using hmac_drbg(hash)\n * @param ecdsaOpts rarely needed, see {@link ECDSAOpts}\n *\n * @example\n * ```js\n * const p256_Point = weierstrass(...);\n * const p256_sha256 = ecdsa(p256_Point, sha256);\n * const p256_sha224 = ecdsa(p256_Point, sha224);\n * const p256_sha224_r = ecdsa(p256_Point, sha224, { randomBytes: (length) => { ... } });\n * ```\n */\nexport function ecdsa(Point, hash, ecdsaOpts = {}) {\n    ahash(hash);\n    validateObject(ecdsaOpts, {}, {\n        hmac: 'function',\n        lowS: 'boolean',\n        randomBytes: 'function',\n        bits2int: 'function',\n        bits2int_modN: 'function',\n    });\n    ecdsaOpts = Object.assign({}, ecdsaOpts);\n    const randomBytes = ecdsaOpts.randomBytes || wcRandomBytes;\n    const hmac = ecdsaOpts.hmac || ((key, msg) => nobleHmac(hash, key, msg));\n    const { Fp, Fn } = Point;\n    const { ORDER: CURVE_ORDER, BITS: fnBits } = Fn;\n    const { keygen, getPublicKey, getSharedSecret, utils, lengths } = ecdh(Point, ecdsaOpts);\n    const defaultSigOpts = {\n        prehash: true,\n        lowS: typeof ecdsaOpts.lowS === 'boolean' ? ecdsaOpts.lowS : true,\n        format: 'compact',\n        extraEntropy: false,\n    };\n    const hasLargeCofactor = CURVE_ORDER * _2n < Fp.ORDER; // Won't CURVE().h > 2n be more effective?\n    function isBiggerThanHalfOrder(number) {\n        const HALF = CURVE_ORDER >> _1n;\n        return number > HALF;\n    }\n    function validateRS(title, num) {\n        if (!Fn.isValidNot0(num))\n            throw new Error(`invalid signature ${title}: out of range 1..Point.Fn.ORDER`);\n        return num;\n    }\n    function assertSmallCofactor() {\n        // ECDSA recovery is hard for cofactor > 1 curves.\n        // In sign, `r = q.x mod n`, and here we recover q.x from r.\n        // While recovering q.x >= n, we need to add r+n for cofactor=1 curves.\n        // However, for cofactor>1, r+n may not get q.x:\n        // r+n*i would need to be done instead where i is unknown.\n        // To easily get i, we either need to:\n        // a. increase amount of valid recid values (4, 5...); OR\n        // b. prohibit non-prime-order signatures (recid > 1).\n        if (hasLargeCofactor)\n            throw new Error('\"recovered\" sig type is not supported for cofactor >2 curves');\n    }\n    function validateSigLength(bytes, format) {\n        validateSigFormat(format);\n        const size = lengths.signature;\n        const sizer = format === 'compact' ? size : format === 'recovered' ? size + 1 : undefined;\n        return abytes(bytes, sizer);\n    }\n    /**\n     * ECDSA signature with its (r, s) properties. Supports compact, recovered & DER representations.\n     */\n    class Signature {\n        r;\n        s;\n        recovery;\n        constructor(r, s, recovery) {\n            this.r = validateRS('r', r); // r in [1..N-1];\n            this.s = validateRS('s', s); // s in [1..N-1];\n            if (recovery != null) {\n                assertSmallCofactor();\n                if (![0, 1, 2, 3].includes(recovery))\n                    throw new Error('invalid recovery id');\n                this.recovery = recovery;\n            }\n            Object.freeze(this);\n        }\n        static fromBytes(bytes, format = defaultSigOpts.format) {\n            validateSigLength(bytes, format);\n            let recid;\n            if (format === 'der') {\n                const { r, s } = DER.toSig(abytes(bytes));\n                return new Signature(r, s);\n            }\n            if (format === 'recovered') {\n                recid = bytes[0];\n                format = 'compact';\n                bytes = bytes.subarray(1);\n            }\n            const L = lengths.signature / 2;\n            const r = bytes.subarray(0, L);\n            const s = bytes.subarray(L, L * 2);\n            return new Signature(Fn.fromBytes(r), Fn.fromBytes(s), recid);\n        }\n        static fromHex(hex, format) {\n            return this.fromBytes(hexToBytes(hex), format);\n        }\n        assertRecovery() {\n            const { recovery } = this;\n            if (recovery == null)\n                throw new Error('invalid recovery id: must be present');\n            return recovery;\n        }\n        addRecoveryBit(recovery) {\n            return new Signature(this.r, this.s, recovery);\n        }\n        recoverPublicKey(messageHash) {\n            const { r, s } = this;\n            const recovery = this.assertRecovery();\n            const radj = recovery === 2 || recovery === 3 ? r + CURVE_ORDER : r;\n            if (!Fp.isValid(radj))\n                throw new Error('invalid recovery id: sig.r+curve.n != R.x');\n            const x = Fp.toBytes(radj);\n            const R = Point.fromBytes(concatBytes(pprefix((recovery & 1) === 0), x));\n            const ir = Fn.inv(radj); // r^-1\n            const h = bits2int_modN(abytes(messageHash, undefined, 'msgHash')); // Truncate hash\n            const u1 = Fn.create(-h * ir); // -hr^-1\n            const u2 = Fn.create(s * ir); // sr^-1\n            // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1). unsafe is fine: there is no private data.\n            const Q = Point.BASE.multiplyUnsafe(u1).add(R.multiplyUnsafe(u2));\n            if (Q.is0())\n                throw new Error('invalid recovery: point at infinify');\n            Q.assertValidity();\n            return Q;\n        }\n        // Signatures should be low-s, to prevent malleability.\n        hasHighS() {\n            return isBiggerThanHalfOrder(this.s);\n        }\n        toBytes(format = defaultSigOpts.format) {\n            validateSigFormat(format);\n            if (format === 'der')\n                return hexToBytes(DER.hexFromSig(this));\n            const { r, s } = this;\n            const rb = Fn.toBytes(r);\n            const sb = Fn.toBytes(s);\n            if (format === 'recovered') {\n                assertSmallCofactor();\n                return concatBytes(Uint8Array.of(this.assertRecovery()), rb, sb);\n            }\n            return concatBytes(rb, sb);\n        }\n        toHex(format) {\n            return bytesToHex(this.toBytes(format));\n        }\n    }\n    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\n    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\n    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\n    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\n    const bits2int = ecdsaOpts.bits2int ||\n        function bits2int_def(bytes) {\n            // Our custom check \"just in case\", for protection against DoS\n            if (bytes.length > 8192)\n                throw new Error('input is too large');\n            // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\n            // for some cases, since bytes.length * 8 is not actual bitLength.\n            const num = bytesToNumberBE(bytes); // check for == u8 done here\n            const delta = bytes.length * 8 - fnBits; // truncate to nBitLength leftmost bits\n            return delta > 0 ? num >> BigInt(delta) : num;\n        };\n    const bits2int_modN = ecdsaOpts.bits2int_modN ||\n        function bits2int_modN_def(bytes) {\n            return Fn.create(bits2int(bytes)); // can't use bytesToNumberBE here\n        };\n    // Pads output with zero as per spec\n    const ORDER_MASK = bitMask(fnBits);\n    /** Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`. */\n    function int2octets(num) {\n        // IMPORTANT: the check ensures working for case `Fn.BYTES != Fn.BITS * 8`\n        aInRange('num < 2^' + fnBits, num, _0n, ORDER_MASK);\n        return Fn.toBytes(num);\n    }\n    function validateMsgAndHash(message, prehash) {\n        abytes(message, undefined, 'message');\n        return prehash ? abytes(hash(message), undefined, 'prehashed message') : message;\n    }\n    /**\n     * Steps A, D of RFC6979 3.2.\n     * Creates RFC6979 seed; converts msg/privKey to numbers.\n     * Used only in sign, not in verify.\n     *\n     * Warning: we cannot assume here that message has same amount of bytes as curve order,\n     * this will be invalid at least for P521. Also it can be bigger for P224 + SHA256.\n     */\n    function prepSig(message, secretKey, opts) {\n        const { lowS, prehash, extraEntropy } = validateSigOpts(opts, defaultSigOpts);\n        message = validateMsgAndHash(message, prehash); // RFC6979 3.2 A: h1 = H(m)\n        // We can't later call bits2octets, since nested bits2int is broken for curves\n        // with fnBits % 8 !== 0. Because of that, we unwrap it here as int2octets call.\n        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\n        const h1int = bits2int_modN(message);\n        const d = Fn.fromBytes(secretKey); // validate secret key, convert to bigint\n        if (!Fn.isValidNot0(d))\n            throw new Error('invalid private key');\n        const seedArgs = [int2octets(d), int2octets(h1int)];\n        // extraEntropy. RFC6979 3.6: additional k' (optional).\n        if (extraEntropy != null && extraEntropy !== false) {\n            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n            // gen random bytes OR pass as-is\n            const e = extraEntropy === true ? randomBytes(lengths.secretKey) : extraEntropy;\n            seedArgs.push(abytes(e, undefined, 'extraEntropy')); // check for being bytes\n        }\n        const seed = concatBytes(...seedArgs); // Step D of RFC6979 3.2\n        const m = h1int; // no need to call bits2int second time here, it is inside truncateHash!\n        // Converts signature params into point w r/s, checks result for validity.\n        // To transform k => Signature:\n        // q = kG\n        // r = q.x mod n\n        // s = k^-1(m + rd) mod n\n        // Can use scalar blinding b^-1(bm + bdr) where b  [1,q1] according to\n        // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\n        // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\n        function k2sig(kBytes) {\n            // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n            // Important: all mod() calls here must be done over N\n            const k = bits2int(kBytes); // Cannot use fields methods, since it is group element\n            if (!Fn.isValidNot0(k))\n                return; // Valid scalars (including k) must be in 1..N-1\n            const ik = Fn.inv(k); // k^-1 mod n\n            const q = Point.BASE.multiply(k).toAffine(); // q = kG\n            const r = Fn.create(q.x); // r = q.x mod n\n            if (r === _0n)\n                return;\n            const s = Fn.create(ik * Fn.create(m + r * d)); // s = k^-1(m + rd) mod n\n            if (s === _0n)\n                return;\n            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3 when q.x>n)\n            let normS = s;\n            if (lowS && isBiggerThanHalfOrder(s)) {\n                normS = Fn.neg(s); // if lowS was passed, ensure s is always in the bottom half of N\n                recovery ^= 1;\n            }\n            return new Signature(r, normS, hasLargeCofactor ? undefined : recovery);\n        }\n        return { seed, k2sig };\n    }\n    /**\n     * Signs message hash with a secret key.\n     *\n     * ```\n     * sign(m, d) where\n     *   k = rfc6979_hmac_drbg(m, d)\n     *   (x, y) = G  k\n     *   r = x mod n\n     *   s = (m + dr) / k mod n\n     * ```\n     */\n    function sign(message, secretKey, opts = {}) {\n        const { seed, k2sig } = prepSig(message, secretKey, opts); // Steps A, D of RFC6979 3.2.\n        const drbg = createHmacDrbg(hash.outputLen, Fn.BYTES, hmac);\n        const sig = drbg(seed, k2sig); // Steps B, C, D, E, F, G\n        return sig.toBytes(opts.format);\n    }\n    /**\n     * Verifies a signature against message and public key.\n     * Rejects lowS signatures by default: see {@link ECDSAVerifyOpts}.\n     * Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\n     *\n     * ```\n     * verify(r, s, h, P) where\n     *   u1 = hs^-1 mod n\n     *   u2 = rs^-1 mod n\n     *   R = u1G + u2P\n     *   mod(R.x, n) == r\n     * ```\n     */\n    function verify(signature, message, publicKey, opts = {}) {\n        const { lowS, prehash, format } = validateSigOpts(opts, defaultSigOpts);\n        publicKey = abytes(publicKey, undefined, 'publicKey');\n        message = validateMsgAndHash(message, prehash);\n        if (!isBytes(signature)) {\n            const end = signature instanceof Signature ? ', use sig.toBytes()' : '';\n            throw new Error('verify expects Uint8Array signature' + end);\n        }\n        validateSigLength(signature, format); // execute this twice because we want loud error\n        try {\n            const sig = Signature.fromBytes(signature, format);\n            const P = Point.fromBytes(publicKey);\n            if (lowS && sig.hasHighS())\n                return false;\n            const { r, s } = sig;\n            const h = bits2int_modN(message); // mod n, not mod p\n            const is = Fn.inv(s); // s^-1 mod n\n            const u1 = Fn.create(h * is); // u1 = hs^-1 mod n\n            const u2 = Fn.create(r * is); // u2 = rs^-1 mod n\n            const R = Point.BASE.multiplyUnsafe(u1).add(P.multiplyUnsafe(u2)); // u1G + u2P\n            if (R.is0())\n                return false;\n            const v = Fn.create(R.x); // v = r.x mod n\n            return v === r;\n        }\n        catch (e) {\n            return false;\n        }\n    }\n    function recoverPublicKey(signature, message, opts = {}) {\n        const { prehash } = validateSigOpts(opts, defaultSigOpts);\n        message = validateMsgAndHash(message, prehash);\n        return Signature.fromBytes(signature, 'recovered').recoverPublicKey(message).toBytes();\n    }\n    return Object.freeze({\n        keygen,\n        getPublicKey,\n        getSharedSecret,\n        utils,\n        lengths,\n        Point,\n        sign,\n        verify,\n        recoverPublicKey,\n        Signature,\n        hash,\n    });\n}\n//# sourceMappingURL=weierstrass.js.map","/**\n * SECG secp256k1. See [pdf](https://www.secg.org/sec2-v2.pdf).\n *\n * Belongs to Koblitz curves: it has efficiently-computable GLV endomorphism ,\n * check out {@link EndomorphismOpts}. Seems to be rigid (not backdoored).\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { sha256 } from '@noble/hashes/sha2.js';\nimport { randomBytes } from '@noble/hashes/utils.js';\nimport { createKeygen } from \"./abstract/curve.js\";\nimport { createHasher, isogenyMap } from \"./abstract/hash-to-curve.js\";\nimport { Field, mapHashToField, pow2 } from \"./abstract/modular.js\";\nimport { ecdsa, mapToCurveSimpleSWU, weierstrass, } from \"./abstract/weierstrass.js\";\nimport { abytes, asciiToBytes, bytesToNumberBE, concatBytes } from \"./utils.js\";\n// Seems like generator was produced from some seed:\n// `Pointk1.BASE.multiply(Pointk1.Fn.inv(2n, N)).toAffine().x`\n// // gives short x 0x3b78ce563f89a0ed9414f5aa28ad0d96d6795f9c63n\nconst secp256k1_CURVE = {\n    p: BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f'),\n    n: BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141'),\n    h: BigInt(1),\n    a: BigInt(0),\n    b: BigInt(7),\n    Gx: BigInt('0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'),\n    Gy: BigInt('0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8'),\n};\nconst secp256k1_ENDO = {\n    beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\n    basises: [\n        [BigInt('0x3086d221a7d46bcde86c90e49284eb15'), -BigInt('0xe4437ed6010e88286f547fa90abfe4c3')],\n        [BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8'), BigInt('0x3086d221a7d46bcde86c90e49284eb15')],\n    ],\n};\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _2n = /* @__PURE__ */ BigInt(2);\n/**\n * n = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.\n * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]\n */\nfunction sqrtMod(y) {\n    const P = secp256k1_CURVE.p;\n    // prettier-ignore\n    const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);\n    // prettier-ignore\n    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);\n    const b2 = (y * y * y) % P; // x^3, 11\n    const b3 = (b2 * b2 * y) % P; // x^7\n    const b6 = (pow2(b3, _3n, P) * b3) % P;\n    const b9 = (pow2(b6, _3n, P) * b3) % P;\n    const b11 = (pow2(b9, _2n, P) * b2) % P;\n    const b22 = (pow2(b11, _11n, P) * b11) % P;\n    const b44 = (pow2(b22, _22n, P) * b22) % P;\n    const b88 = (pow2(b44, _44n, P) * b44) % P;\n    const b176 = (pow2(b88, _88n, P) * b88) % P;\n    const b220 = (pow2(b176, _44n, P) * b44) % P;\n    const b223 = (pow2(b220, _3n, P) * b3) % P;\n    const t1 = (pow2(b223, _23n, P) * b22) % P;\n    const t2 = (pow2(t1, _6n, P) * b2) % P;\n    const root = pow2(t2, _2n, P);\n    if (!Fpk1.eql(Fpk1.sqr(root), y))\n        throw new Error('Cannot find square root');\n    return root;\n}\nconst Fpk1 = Field(secp256k1_CURVE.p, { sqrt: sqrtMod });\nconst Pointk1 = /* @__PURE__ */ weierstrass(secp256k1_CURVE, {\n    Fp: Fpk1,\n    endo: secp256k1_ENDO,\n});\n/**\n * secp256k1 curve: ECDSA and ECDH methods.\n *\n * Uses sha256 to hash messages. To use a different hash,\n * pass `{ prehash: false }` to sign / verify.\n *\n * @example\n * ```js\n * import { secp256k1 } from '@noble/curves/secp256k1.js';\n * const { secretKey, publicKey } = secp256k1.keygen();\n * // const publicKey = secp256k1.getPublicKey(secretKey);\n * const msg = new TextEncoder().encode('hello noble');\n * const sig = secp256k1.sign(msg, secretKey);\n * const isValid = secp256k1.verify(sig, msg, publicKey);\n * // const sigKeccak = secp256k1.sign(keccak256(msg), secretKey, { prehash: false });\n * ```\n */\nexport const secp256k1 = /* @__PURE__ */ ecdsa(Pointk1, sha256);\n// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.\n// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\n/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */\nconst TAGGED_HASH_PREFIXES = {};\nfunction taggedHash(tag, ...messages) {\n    let tagP = TAGGED_HASH_PREFIXES[tag];\n    if (tagP === undefined) {\n        const tagH = sha256(asciiToBytes(tag));\n        tagP = concatBytes(tagH, tagH);\n        TAGGED_HASH_PREFIXES[tag] = tagP;\n    }\n    return sha256(concatBytes(tagP, ...messages));\n}\n// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03\nconst pointToBytes = (point) => point.toBytes(true).slice(1);\nconst hasEven = (y) => y % _2n === _0n;\n// Calculate point, scalar and bytes\nfunction schnorrGetExtPubKey(priv) {\n    const { Fn, BASE } = Pointk1;\n    const d_ = Fn.fromBytes(priv);\n    const p = BASE.multiply(d_); // P = d'G; 0 < d' < n check is done inside\n    const scalar = hasEven(p.y) ? d_ : Fn.neg(d_);\n    return { scalar, bytes: pointToBytes(p) };\n}\n/**\n * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.\n * @returns valid point checked for being on-curve\n */\nfunction lift_x(x) {\n    const Fp = Fpk1;\n    if (!Fp.isValidNot0(x))\n        throw new Error('invalid x: Fail if x  p');\n    const xx = Fp.create(x * x);\n    const c = Fp.create(xx * x + BigInt(7)); // Let c = x + 7 mod p.\n    let y = Fp.sqrt(c); // Let y = c^(p+1)/4 mod p. Same as sqrt().\n    // Return the unique point P such that x(P) = x and\n    // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.\n    if (!hasEven(y))\n        y = Fp.neg(y);\n    const p = Pointk1.fromAffine({ x, y });\n    p.assertValidity();\n    return p;\n}\nconst num = bytesToNumberBE;\n/**\n * Create tagged hash, convert it to bigint, reduce modulo-n.\n */\nfunction challenge(...args) {\n    return Pointk1.Fn.create(num(taggedHash('BIP0340/challenge', ...args)));\n}\n/**\n * Schnorr public key is just `x` coordinate of Point as per BIP340.\n */\nfunction schnorrGetPublicKey(secretKey) {\n    return schnorrGetExtPubKey(secretKey).bytes; // d'=int(sk). Fail if d'=0 or d'n. Ret bytes(d'G)\n}\n/**\n * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.\n * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.\n */\nfunction schnorrSign(message, secretKey, auxRand = randomBytes(32)) {\n    const { Fn } = Pointk1;\n    const m = abytes(message, undefined, 'message');\n    const { bytes: px, scalar: d } = schnorrGetExtPubKey(secretKey); // checks for isWithinCurveOrder\n    const a = abytes(auxRand, 32, 'auxRand'); // Auxiliary random data a: a 32-byte array\n    const t = Fn.toBytes(d ^ num(taggedHash('BIP0340/aux', a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)\n    const rand = taggedHash('BIP0340/nonce', t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)\n    // Let k' = int(rand) mod n. Fail if k' = 0. Let R = k'G\n    const { bytes: rx, scalar: k } = schnorrGetExtPubKey(rand);\n    const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.\n    const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).\n    sig.set(rx, 0);\n    sig.set(Fn.toBytes(Fn.create(k + e * d)), 32);\n    // If Verify(bytes(P), m, sig) (see below) returns failure, abort\n    if (!schnorrVerify(sig, m, px))\n        throw new Error('sign: Invalid signature produced');\n    return sig;\n}\n/**\n * Verifies Schnorr signature.\n * Will swallow errors & return false except for initial type validation of arguments.\n */\nfunction schnorrVerify(signature, message, publicKey) {\n    const { Fp, Fn, BASE } = Pointk1;\n    const sig = abytes(signature, 64, 'signature');\n    const m = abytes(message, undefined, 'message');\n    const pub = abytes(publicKey, 32, 'publicKey');\n    try {\n        const P = lift_x(num(pub)); // P = lift_x(int(pk)); fail if that fails\n        const r = num(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r  p.\n        if (!Fp.isValidNot0(r))\n            return false;\n        const s = num(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s  n.\n        if (!Fn.isValidNot0(s))\n            return false;\n        const e = challenge(Fn.toBytes(r), pointToBytes(P), m); // int(challenge(bytes(r)||bytes(P)||m))%n\n        // R = sG - eP, where -eP == (n-e)P\n        const R = BASE.multiplyUnsafe(s).add(P.multiplyUnsafe(Fn.neg(e)));\n        const { x, y } = R.toAffine();\n        // Fail if is_infinite(R) / not has_even_y(R) / x(R)  r.\n        if (R.is0() || !hasEven(y) || x !== r)\n            return false;\n        return true;\n    }\n    catch (error) {\n        return false;\n    }\n}\n/**\n * Schnorr signatures over secp256k1.\n * https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\n * @example\n * ```js\n * import { schnorr } from '@noble/curves/secp256k1.js';\n * const { secretKey, publicKey } = schnorr.keygen();\n * // const publicKey = schnorr.getPublicKey(secretKey);\n * const msg = new TextEncoder().encode('hello');\n * const sig = schnorr.sign(msg, secretKey);\n * const isValid = schnorr.verify(sig, msg, publicKey);\n * ```\n */\nexport const schnorr = /* @__PURE__ */ (() => {\n    const size = 32;\n    const seedLength = 48;\n    const randomSecretKey = (seed = randomBytes(seedLength)) => {\n        return mapHashToField(seed, secp256k1_CURVE.n);\n    };\n    return {\n        keygen: createKeygen(randomSecretKey, schnorrGetPublicKey),\n        getPublicKey: schnorrGetPublicKey,\n        sign: schnorrSign,\n        verify: schnorrVerify,\n        Point: Pointk1,\n        utils: {\n            randomSecretKey,\n            taggedHash,\n            lift_x,\n            pointToBytes,\n        },\n        lengths: {\n            secretKey: size,\n            publicKey: size,\n            publicKeyHasPrefix: false,\n            signature: size * 2,\n            seed: seedLength,\n        },\n    };\n})();\nconst isoMap = /* @__PURE__ */ (() => isogenyMap(Fpk1, [\n    // xNum\n    [\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7',\n        '0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581',\n        '0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262',\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c',\n    ],\n    // xDen\n    [\n        '0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b',\n        '0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n    // yNum\n    [\n        '0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c',\n        '0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3',\n        '0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931',\n        '0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84',\n    ],\n    // yDen\n    [\n        '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b',\n        '0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573',\n        '0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n].map((i) => i.map((j) => BigInt(j)))))();\nconst mapSWU = /* @__PURE__ */ (() => mapToCurveSimpleSWU(Fpk1, {\n    A: BigInt('0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533'),\n    B: BigInt('1771'),\n    Z: Fpk1.create(BigInt('-11')),\n}))();\n/** Hashing / encoding to secp256k1 points / field. RFC 9380 methods. */\nexport const secp256k1_hasher = /* @__PURE__ */ (() => createHasher(Pointk1, (scalars) => {\n    const { x, y } = mapSWU(Fpk1.create(scalars[0]));\n    return isoMap(x, y);\n}, {\n    DST: 'secp256k1_XMD:SHA-256_SSWU_RO_',\n    encodeDST: 'secp256k1_XMD:SHA-256_SSWU_NU_',\n    p: Fpk1.ORDER,\n    m: 1,\n    k: 128,\n    expand: 'xmd',\n    hash: sha256,\n}))();\n//# sourceMappingURL=secp256k1.js.map"],"names":["Chi","a","b","c","Maj","HashMD","blockLen","outputLen","padOffset","isLE","__publicField","createView","data","aexists","abytes","view","buffer","len","pos","take","dataView","out","aoutput","clean","i","oview","outLen","state","res","to","length","finished","destroyed","SHA256_IV","SHA256_K","SHA256_W","SHA2_32B","A","B","C","D","E","F","G","H","offset","W15","W2","s0","rotr","s1","sigma1","T1","T2","_SHA256","sha256","createHasher","oidNist","_0n","_1n","abool","value","title","prefix","abignumber","isPosBig","anumber","numberToHexUnpadded","num","hex","hexToNumber","bytesToNumberBE","bytes","bytesToHex_","bytesToNumberLE","copyBytes","abytes_","numberToBytesBE","hexToBytes_","numberToBytesLE","asciiToBytes","ascii","charCode","inRange","min","max","aInRange","n","bitLen","bitMask","createHmacDrbg","hashLen","qByteLen","hmacFn","u8n","NULL","byte0","byte1","_maxDrbgIters","v","k","reset","h","msgs","concatBytes_","reseed","seed","gen","sl","pred","validateObject","object","fields","optFields","checkField","fieldName","expectedType","isOpt","val","current","iter","f","memoized","fn","map","arg","args","computed","_2n","_3n","_4n","_5n","_7n","_8n","_9n","_16n","mod","result","pow2","x","power","modulo","invert","number","u","q","r","m","assertIsSquare","Fp","root","sqrt3mod4","p1div4","sqrt5mod8","p5div8","n2","nv","sqrt9mod16","P","Fp_","Field","tn","tonelliShanks","c1","c2","c3","c4","tv1","tv2","tv3","tv4","e1","e2","e3","Q","S","Z","_Fp","FpLegendre","cc","Q1div2","M","t","R","t_tmp","exponent","FpSqrt","FIELD_FIELDS","validateField","field","initial","opts","FpPow","p","d","FpInvertBatch","nums","passZero","inverted","multipliedAcc","acc","invertedAcc","p1mod2","powered","yes","zero","no","nLength","nBitLength","_nBitLength","nByteLength","_Field","ORDER","_nbitLength","lhs","rhs","skipValidation","allowedLengths","BYTES","modFromBytes","padded","scalar","lst","condition","getFieldBytesLength","fieldOrder","bitLength","getMinHashLength","mapHashToField","key","fieldLen","minLen","reduced","negateCt","item","neg","normalizeZ","points","invertedZs","validateW","W","bits","calcWOpts","scalarBits","windows","windowSize","maxNumber","mask","shiftBy","calcOffsets","window","wOpts","wbits","nextN","offsetStart","isZero","isNeg","isNegF","pointPrecomputes","pointWindowSizes","getW","assert0","wNAF","Point","elm","point","base","precomputes","wo","offsetF","transform","comp","prev","mulEndoUnsafe","k1","k2","p1","p2","createField","order","createCurveFields","type","CURVE","curveOpts","FpFnLE","Fn","params","createKeygen","randomSecretKey","getPublicKey","secretKey","_HMAC","hash","ahash","pad","buf","oHash","iHash","hmac","message","divNearest","den","_splitEndoScalar","basis","a1","b1","a2","b2","k1neg","k2neg","MAX_NUM","validateSigFormat","format","validateSigOpts","def","optsn","optName","DERErr","DER","tag","dataLen","lenLen","first","isLong","lengthBytes","int","tlv","seqBytes","seqLeftBytes","rBytes","rLeftBytes","sBytes","sLeftBytes","sig","rs","ss","seq","weierstrass","extraOpts","validated","cofactor","CURVE_ORDER","endo","lengths","getWLengths","assertCompressionIsSupported","pointToBytes","_c","isCompressed","bx","hasEvenY","concatBytes","pprefix","pointFromBytes","uncomp","head","tail","y2","weierstrassEquation","y","sqrtError","err","evenY","L","isValidXY","encodePoint","decodePoint","x2","x3","left","right","_4a3","_27b2","acoord","banZero","aprjpoint","other","splitEndoScalarN","toAffineMemo","iz","X","Y","is0","zz","assertValidMemo","finishEndo","endoBeta","k1p","k2p","_Point","hexToBytes","isLazy","wnaf","X1","Y1","Z1","X2","Y2","Z2","U1","U2","b3","X3","Y3","Z3","t0","t1","t2","t3","t4","t5","fake","mul","k1f","k2f","sc","invertedZ","isTorsionFree","clearCofactor","bytesToHex","ecdh","ecdhOpts","randomBytes_","wcRandomBytes","isValidSecretKey","isValidPublicKey","publicKey","publicKeyUncompressed","l","isProbPub","isBytes","getSharedSecret","secretKeyA","publicKeyB","s","utils","keygen","ecdsa","ecdsaOpts","randomBytes","msg","nobleHmac","fnBits","defaultSigOpts","hasLargeCofactor","isBiggerThanHalfOrder","HALF","validateRS","assertSmallCofactor","validateSigLength","size","sizer","Signature","recovery","recid","messageHash","radj","ir","bits2int_modN","u1","u2","rb","sb","bits2int","delta","ORDER_MASK","int2octets","validateMsgAndHash","prehash","prepSig","lowS","extraEntropy","h1int","seedArgs","e","k2sig","kBytes","ik","normS","sign","verify","signature","end","is","recoverPublicKey","secp256k1_CURVE","secp256k1_ENDO","sqrtMod","_6n","_11n","_22n","_23n","_44n","_88n","b6","b9","b11","b22","b44","b88","b176","b220","b223","Fpk1","Pointk1","secp256k1","TAGGED_HASH_PREFIXES","taggedHash","messages","tagP","tagH","hasEven","schnorrGetExtPubKey","priv","BASE","d_","lift_x","xx","challenge","schnorrGetPublicKey","schnorrSign","auxRand","px","rand","rx","schnorrVerify","pub","schnorr"],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAMO,SAASA,GAAIC,CAAAA,EAAGC,CAAAA,EAAGC,CAAAA,EAAG;IACzB,OAAQF,IAAIC,IAAM,CAACD,IAAIE;AAC3B;AAEO,SAASC,GAAIH,CAAAA,EAAGC,CAAAA,EAAGC,CAAAA,EAAG;IACzB,OAAQF,IAAIC,IAAMD,IAAIE,IAAMD,IAAIC;AACpC;AAKO,MAAME,GAAO;IAYhB,YAAYC,CAAAA,EAAUC,CAAAA,EAAWC,CAAAA,EAAWC,CAAAA,CAAM;QAXlDC,EAAA,IAAA,EAAA;QACAA,EAAA,IAAA,EAAA;QACAA,EAAA,IAAA,EAAA;QACAA,EAAA,IAAA,EAAA;QAEA,2CAAA;QAAAA,EAAA,IAAA,EAAA;QACAA,EAAA,IAAA,EAAA;QACAA,EAAA,IAAA,EAAA,YAAW,CAAA;QACXA,EAAA,IAAA,EAAA,UAAS;QACTA,EAAA,IAAA,EAAA,OAAM;QACNA,EAAA,IAAA,EAAA,aAAY,CAAA;QAER,IAAA,CAAK,QAAA,GAAWJ,GAChB,IAAA,CAAK,SAAA,GAAYC,GACjB,IAAA,CAAK,SAAA,GAAYC,GACjB,IAAA,CAAK,IAAA,GAAOC,GACZ,IAAA,CAAK,MAAA,GAAS,IAAI,WAAWH,CAAQ,GACrC,IAAA,CAAK,IAAA,OAAOK,6OAAAA,EAAW,IAAA,CAAK,MAAM;IACtC;IACA,OAAOC,CAAAA,EAAM;YACTC,6OAAAA,EAAQ,IAAI,OACZC,6OAAAA,EAAOF,CAAI;QACX,MAAM,EAAE,MAAAG,CAAAA,EAAM,QAAAC,CAAAA,EAAQ,UAAAV,CAAAA,CAAQ,CAAA,GAAK,IAAA,EAC7BW,IAAML,EAAK,MAAA;QACjB,IAAA,IAASM,IAAM,GAAGA,IAAMD,GAAM;YAC1B,MAAME,IAAO,KAAK,GAAA,CAAIb,IAAW,IAAA,CAAK,GAAA,EAAKW,IAAMC,CAAG;YAEpD,IAAIC,MAASb,GAAU;gBACnB,MAAMc,QAAWT,6OAAAA,EAAWC,CAAI;gBAChC,MAAON,KAAYW,IAAMC,GAAKA,KAAOZ,EACjC,IAAA,CAAK,OAAA,CAAQc,GAAUF,CAAG;gBAC9B;YACJ;YACAF,EAAO,GAAA,CAAIJ,EAAK,QAAA,CAASM,GAAKA,IAAMC,CAAI,GAAG,IAAA,CAAK,GAAG,GACnD,IAAA,CAAK,GAAA,IAAOA,GACZD,KAAOC,GACH,IAAA,CAAK,GAAA,KAAQb,KAAAA,CACb,IAAA,CAAK,OAAA,CAAQS,GAAM,CAAC,GACpB,IAAA,CAAK,GAAA,GAAM,CAAA;QAEnB;QACA,OAAA,IAAA,CAAK,MAAA,IAAUH,EAAK,MAAA,EACpB,IAAA,CAAK,UAAA,CAAU,GACR,IAAA;IACX;IACA,WAAWS,CAAAA,EAAK;YACZR,6OAAAA,EAAQ,IAAI,OACZS,6OAAAA,EAAQD,GAAK,IAAI,GACjB,IAAA,CAAK,QAAA,GAAW,CAAA;QAIhB,MAAM,EAAE,QAAAL,CAAAA,EAAQ,MAAAD,CAAAA,EAAM,UAAAT,CAAAA,EAAU,MAAAG,CAAAA,CAAI,CAAA,GAAK,IAAA;QACzC,IAAI,EAAE,KAAAS,CAAAA,CAAG,CAAA,GAAK,IAAA;QAEdF,CAAAA,CAAOE,GAAK,CAAA,GAAI,SAChBK,6OAAAA,EAAM,IAAA,CAAK,MAAA,CAAO,QAAA,CAASL,CAAG,CAAC,GAG3B,IAAA,CAAK,SAAA,GAAYZ,IAAWY,KAAAA,CAC5B,IAAA,CAAK,OAAA,CAAQH,GAAM,CAAC,GACpBG,IAAM,CAAA;QAGV,IAAA,IAASM,IAAIN,GAAKM,IAAIlB,GAAUkB,IAC5BR,CAAAA,CAAOQ,CAAC,CAAA,GAAI;QAIhBT,EAAK,YAAA,CAAaT,IAAW,GAAG,OAAO,IAAA,CAAK,MAAA,GAAS,CAAC,GAAGG,CAAI,GAC7D,IAAA,CAAK,OAAA,CAAQM,GAAM,CAAC;QACpB,MAAMU,QAAQd,6OAAAA,EAAWU,CAAG,GACtBJ,IAAM,IAAA,CAAK,SAAA;QAEjB,IAAIA,IAAM,GACN,MAAM,IAAI,MAAM,2CAA2C;QAC/D,MAAMS,IAAST,IAAM,GACfU,IAAQ,IAAA,CAAK,GAAA,CAAG;QACtB,IAAID,IAASC,EAAM,MAAA,EACf,MAAM,IAAI,MAAM,oCAAoC;QACxD,IAAA,IAASH,IAAI,GAAGA,IAAIE,GAAQF,IACxBC,EAAM,SAAA,CAAU,IAAID,GAAGG,CAAAA,CAAMH,CAAC,CAAA,EAAGf,CAAI;IAC7C;IACA,SAAS;QACL,MAAM,EAAE,QAAAO,CAAAA,EAAQ,WAAAT,CAAAA,CAAS,CAAA,GAAK,IAAA;QAC9B,IAAA,CAAK,UAAA,CAAWS,CAAM;QACtB,MAAMY,IAAMZ,EAAO,KAAA,CAAM,GAAGT,CAAS;QACrC,OAAA,IAAA,CAAK,OAAA,CAAO,GACLqB;IACX;IACA,WAAWC,CAAAA,EAAI;QACXA,KAAAA,CAAAA,IAAO,IAAI,IAAA,CAAK,WAAA,CAAW,CAAA,GAC3BA,EAAG,GAAA,CAAI,GAAG,IAAA,CAAK,GAAA,CAAG,CAAE;QACpB,MAAM,EAAE,UAAAvB,CAAAA,EAAU,QAAAU,CAAAA,EAAQ,QAAAc,CAAAA,EAAQ,UAAAC,CAAAA,EAAU,WAAAC,CAAAA,EAAW,KAAAd,CAAAA,CAAG,CAAA,GAAK,IAAA;QAC/D,OAAAW,EAAG,SAAA,GAAYG,GACfH,EAAG,QAAA,GAAWE,GACdF,EAAG,MAAA,GAASC,GACZD,EAAG,GAAA,GAAMX,GACLY,IAASxB,KACTuB,EAAG,MAAA,CAAO,GAAA,CAAIb,CAAM,GACjBa;IACX;IACA,QAAQ;QACJ,OAAO,IAAA,CAAK,UAAA,CAAU;IAC1B;AACJ;AAMO,MAAMI,IAA4B,aAAA,GAAA,YAAY,IAAA,CAAK;IACtD;IAAY;IAAY;IAAY;IAAY;IAAY;IAAY;IAAY;CACvF,GCpHKC,KAA2B,aAAA,GAAA,YAAY,IAAA,CAAK;IAC9C;IAAY;IAAY;IAAY;IAAY;IAAY;IAAY;IAAY;IACpF;IAAY;IAAY;IAAY;IAAY;IAAY;IAAY;IAAY;IACpF;IAAY;IAAY;IAAY;IAAY;IAAY;IAAY;IAAY;IACpF;IAAY;IAAY;IAAY;IAAY;IAAY;IAAY;IAAY;IACpF;IAAY;IAAY;IAAY;IAAY;IAAY;IAAY;IAAY;IACpF;IAAY;IAAY;IAAY;IAAY;IAAY;IAAY;IAAY;IACpF;IAAY;IAAY;IAAY;IAAY;IAAY;IAAY;IAAY;IACpF;IAAY;IAAY;IAAY;IAAY;IAAY;IAAY;IAAY;CACvF,GAEKC,IAA2B,aAAA,GAAA,IAAI,YAAY,EAAE;AAEnD,MAAMC,WAAiB/B,GAAO;IAC1B,YAAYE,CAAAA,CAAW;QACnB,KAAA,CAAM,IAAIA,GAAW,GAAG,CAAA,CAAK;IACjC;IACA,MAAM;QACF,MAAM,EAAE,GAAA8B,CAAAA,EAAG,GAAAC,CAAAA,EAAG,GAAAC,CAAAA,EAAG,GAAAC,CAAAA,EAAG,GAAAC,CAAAA,EAAG,GAAAC,CAAAA,EAAG,GAAAC,CAAAA,EAAG,GAAAC,CAAAA,CAAC,CAAA,GAAK,IAAA;QACnC,OAAO;YAACP;YAAGC;YAAGC;YAAGC;YAAGC;YAAGC;YAAGC;YAAGC,CAAC;SAAA;IAClC;IAAA,kBAAA;IAEA,IAAIP,CAAAA,EAAGC,CAAAA,EAAGC,CAAAA,EAAGC,CAAAA,EAAGC,CAAAA,EAAGC,CAAAA,EAAGC,CAAAA,EAAGC,CAAAA,EAAG;QACxB,IAAA,CAAK,CAAA,GAAIP,IAAI,GACb,IAAA,CAAK,CAAA,GAAIC,IAAI,GACb,IAAA,CAAK,CAAA,GAAIC,IAAI,GACb,IAAA,CAAK,CAAA,GAAIC,IAAI,GACb,IAAA,CAAK,CAAA,GAAIC,IAAI,GACb,IAAA,CAAK,CAAA,GAAIC,IAAI,GACb,IAAA,CAAK,CAAA,GAAIC,IAAI,GACb,IAAA,CAAK,CAAA,GAAIC,IAAI;IACjB;IACA,QAAQ7B,CAAAA,EAAM8B,CAAAA,EAAQ;QAElB,IAAA,IAASrB,IAAI,GAAGA,IAAI,IAAIA,KAAKqB,KAAU,EACnCV,CAAAA,CAASX,CAAC,CAAA,GAAIT,EAAK,SAAA,CAAU8B,GAAQ,CAAA,CAAK;QAC9C,IAAA,IAASrB,IAAI,IAAIA,IAAI,IAAIA,IAAK;YAC1B,MAAMsB,IAAMX,CAAAA,CAASX,IAAI,EAAE,CAAA,EACrBuB,IAAKZ,CAAAA,CAASX,IAAI,CAAC,CAAA,EACnBwB,QAAKC,6OAAAA,EAAKH,GAAK,CAAC,QAAIG,6OAAAA,EAAKH,GAAK,EAAE,IAAKA,MAAQ,GAC7CI,QAAKD,6OAAAA,EAAKF,GAAI,EAAE,QAAIE,6OAAAA,EAAKF,GAAI,EAAE,IAAKA,MAAO;YACjDZ,CAAAA,CAASX,CAAC,CAAA,GAAK0B,IAAKf,CAAAA,CAASX,IAAI,CAAC,CAAA,GAAIwB,IAAKb,CAAAA,CAASX,IAAI,EAAE,CAAA,GAAK;QACnE;QAEA,IAAI,EAAE,GAAAa,CAAAA,EAAG,GAAAC,CAAAA,EAAG,GAAAC,CAAAA,EAAG,GAAAC,CAAAA,EAAG,GAAAC,CAAAA,EAAG,GAAAC,CAAAA,EAAG,GAAAC,CAAAA,EAAG,GAAAC,CAAAA,CAAC,CAAA,GAAK,IAAA;QACjC,IAAA,IAASpB,IAAI,GAAGA,IAAI,IAAIA,IAAK;YACzB,MAAM2B,QAASF,6OAAAA,EAAKR,GAAG,CAAC,QAAIQ,6OAAAA,EAAKR,GAAG,EAAE,QAAIQ,6OAAAA,EAAKR,GAAG,EAAE,GAC9CW,IAAMR,IAAIO,IAASnD,GAAIyC,GAAGC,GAAGC,CAAC,IAAIT,EAAAA,CAASV,CAAC,CAAA,GAAIW,CAAAA,CAASX,CAAC,CAAA,GAAK,GAE/D6B,IAAAA,KADSJ,6OAAAA,EAAKZ,GAAG,CAAC,QAAIY,6OAAAA,EAAKZ,GAAG,EAAE,QAAIY,6OAAAA,EAAKZ,GAAG,EAAE,CAAA,IAC/BjC,GAAIiC,GAAGC,GAAGC,CAAC,IAAK;YACrCK,IAAID,GACJA,IAAID,GACJA,IAAID,GACJA,IAAKD,IAAIY,IAAM,GACfZ,IAAID,GACJA,IAAID,GACJA,IAAID,GACJA,IAAKe,IAAKC,IAAM;QACpB;QAEAhB,IAAKA,IAAI,IAAA,CAAK,CAAA,GAAK,GACnBC,IAAKA,IAAI,IAAA,CAAK,CAAA,GAAK,GACnBC,IAAKA,IAAI,IAAA,CAAK,CAAA,GAAK,GACnBC,IAAKA,IAAI,IAAA,CAAK,CAAA,GAAK,GACnBC,IAAKA,IAAI,IAAA,CAAK,CAAA,GAAK,GACnBC,IAAKA,IAAI,IAAA,CAAK,CAAA,GAAK,GACnBC,IAAKA,IAAI,IAAA,CAAK,CAAA,GAAK,GACnBC,IAAKA,IAAI,IAAA,CAAK,CAAA,GAAK,GACnB,IAAA,CAAK,GAAA,CAAIP,GAAGC,GAAGC,GAAGC,GAAGC,GAAGC,GAAGC,GAAGC,CAAC;IACnC;IACA,aAAa;YACTrB,6OAAAA,EAAMY,CAAQ;IAClB;IACA,UAAU;QACN,IAAA,CAAK,GAAA,CAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,CAAC,OAC/BZ,6OAAAA,EAAM,IAAA,CAAK,MAAM;IACrB;AACJ;AAEO,MAAM+B,WAAgBlB,GAAS;IAWlC,aAAc;QACV,KAAA,CAAM,EAAE;QATZ,mEAAA;QAAA,uDAAA;QAAA1B,EAAA,IAAA,EAAA,KAAIuB,CAAAA,CAAU,CAAC,CAAA,GAAI;QACnBvB,EAAA,IAAA,EAAA,KAAIuB,CAAAA,CAAU,CAAC,CAAA,GAAI;QACnBvB,EAAA,IAAA,EAAA,KAAIuB,CAAAA,CAAU,CAAC,CAAA,GAAI;QACnBvB,EAAA,IAAA,EAAA,KAAIuB,CAAAA,CAAU,CAAC,CAAA,GAAI;QACnBvB,EAAA,IAAA,EAAA,KAAIuB,CAAAA,CAAU,CAAC,CAAA,GAAI;QACnBvB,EAAA,IAAA,EAAA,KAAIuB,CAAAA,CAAU,CAAC,CAAA,GAAI;QACnBvB,EAAA,IAAA,EAAA,KAAIuB,CAAAA,CAAU,CAAC,CAAA,GAAI;QACnBvB,EAAA,IAAA,EAAA,KAAIuB,CAAAA,CAAU,CAAC,CAAA,GAAI;IAGnB;AACJ;AAyQY,MAACsB,KAAyB,aAAA,OAAAC,6OAAAA,EAAa,IAAM,IAAIF,GAAO,GACpD,aAAA,GAAAG,iPAAAA,EAAQ,CAAI;AClX5B,oEAAA,GAGA,MAAMC,KAAsB,aAAA,GAAA,OAAO,CAAC,GAC9BC,KAAsB,aAAA,GAAA,OAAO,CAAC;AAC7B,SAASC,GAAMC,CAAAA,EAAOC,IAAQ,EAAA,EAAI;IACrC,IAAI,OAAOD,KAAU,WAAW;QAC5B,MAAME,IAASD,KAAS,CAAA,CAAA,EAAIA,CAAK,CAAA,EAAA,CAAA;QACjC,MAAM,IAAI,MAAMC,IAAS,gCAAgC,OAAOF,CAAK;IACzE;IACA,OAAOA;AACX;AAEA,SAASG,GAAW,CAAA,EAAG;IACnB,IAAI,OAAO,KAAM,UAAA;QACb,IAAI,CAACC,GAAS,CAAC,GACX,MAAM,IAAI,MAAM,mCAAmC,CAAC;IAAA,WAGxDC,6OAAAA,EAAQ,CAAC;IACb,OAAO;AACX;AAOO,SAASC,GAAoBC,CAAAA,EAAK;IACrC,MAAMC,IAAML,GAAWI,CAAG,EAAE,QAAA,CAAS,EAAE;IACvC,OAAOC,EAAI,MAAA,GAAS,IAAI,MAAMA,IAAMA;AACxC;AACO,SAASC,GAAYD,CAAAA,EAAK;IAC7B,IAAI,OAAOA,KAAQ,UACf,MAAM,IAAI,MAAM,8BAA8B,OAAOA,CAAG;IAC5D,OAAOA,MAAQ,KAAKX,KAAM,OAAO,OAAOW,CAAG;AAC/C;AAEO,SAASE,GAAgBC,CAAAA,EAAO;IACnC,OAAOF,OAAYG,6OAAAA,EAAYD,CAAK,CAAC;AACzC;AACO,SAASE,GAAgBF,CAAAA,EAAO;IACnC,OAAOF,OAAYG,6OAAAA,EAAYE,OAAUC,6OAAAA,EAAQJ,CAAK,CAAC,EAAE,OAAA,CAAO,CAAE,CAAC;AACvE;AACO,SAASK,GAAgB,CAAA,EAAG5D,CAAAA,EAAK;QACpCiD,6OAAAA,EAAQjD,CAAG,GACX,IAAI+C,GAAW,CAAC;IAChB,MAAMpC,QAAMkD,6OAAAA,EAAY,EAAE,QAAA,CAAS,EAAE,EAAE,QAAA,CAAS7D,IAAM,GAAG,GAAG,CAAC;IAC7D,IAAIW,EAAI,MAAA,KAAWX,GACf,MAAM,IAAI,MAAM,kBAAkB;IACtC,OAAOW;AACX;AACO,SAASmD,GAAgB,CAAA,EAAG9D,CAAAA,EAAK;IACpC,OAAO4D,GAAgB,GAAG5D,CAAG,EAAE,OAAA,CAAO;AAC1C;AAkBO,SAAS0D,GAAUH,CAAAA,EAAO;IAC7B,OAAO,WAAW,IAAA,CAAKA,CAAK;AAChC;AAMO,SAASQ,GAAaC,CAAAA,EAAO;IAChC,OAAO,WAAW,IAAA,CAAKA,GAAO,CAAC9E,GAAGqB,MAAM;QACpC,MAAM0D,IAAW/E,EAAE,UAAA,CAAW,CAAC;QAC/B,IAAIA,EAAE,MAAA,KAAW,KAAK+E,IAAW,KAC7B,MAAM,IAAI,MAAM,CAAA,qCAAA,EAAwCD,CAAAA,CAAMzD,CAAC,CAAC,CAAA,YAAA,EAAe0D,CAAQ,CAAA,aAAA,EAAgB1D,CAAC,EAAE;QAE9G,OAAO0D;IACX,CAAC;AACL;AAEA,MAAMjB,KAAW,CAAC,IAAM,OAAO,KAAM,YAAYP,MAAO;AACjD,SAASyB,GAAQ,CAAA,EAAGC,CAAAA,EAAKC,CAAAA,EAAK;IACjC,OAAOpB,GAAS,CAAC,KAAKA,GAASmB,CAAG,KAAKnB,GAASoB,CAAG,KAAKD,KAAO,KAAK,IAAIC;AAC5E;AAMO,SAASC,GAASxB,CAAAA,EAAOyB,CAAAA,EAAGH,CAAAA,EAAKC,CAAAA,EAAK;IAMzC,IAAI,CAACF,GAAQI,GAAGH,GAAKC,CAAG,GACpB,MAAM,IAAI,MAAM,oBAAoBvB,IAAQ,OAAOsB,IAAM,aAAaC,IAAM,WAAWE,CAAC;AAChG;AAOO,SAASC,GAAO,CAAA,EAAG;IACtB,IAAIvE;IACJ,IAAKA,IAAM,GAAG,IAAIyC,IAAK,MAAMC,IAAK1C,KAAO;IAEzC,OAAOA;AACX;AAmBO,MAAMwE,KAAU,CAAC,IAAA,CAAO9B,MAAO,OAAO,CAAC,CAAA,IAAKA;AAQ5C,SAAS+B,GAAeC,CAAAA,EAASC,CAAAA,EAAUC,CAAAA,EAAQ;IAGtD,QAFA3B,6OAAAA,EAAQyB,GAAS,SAAS,OAC1BzB,6OAAAA,EAAQ0B,GAAU,UAAU,GACxB,OAAOC,KAAW,YAClB,MAAM,IAAI,MAAM,2BAA2B;IAC/C,MAAMC,IAAM,CAAC7E,IAAQ,IAAI,WAAWA,CAAG,GACjC8E,IAAO,WAAW,EAAA,CAAE,GACpBC,IAAQ,WAAW,EAAA,CAAG,CAAI,GAC1BC,IAAQ,WAAW,EAAA,CAAG,CAAI,GAC1BC,IAAgB;IAEtB,IAAIC,IAAIL,EAAIH,CAAO,GACfS,IAAIN,EAAIH,CAAO,GACfnE,IAAI;IACR,MAAM6E,IAAQ,MAAM;QAChBF,EAAE,IAAA,CAAK,CAAC,GACRC,EAAE,IAAA,CAAK,CAAC,GACR5E,IAAI;IACR,GACM8E,IAAI,CAAA,GAAIC,IAASV,EAAOO,OAAGI,6OAAAA,EAAaL,GAAG,GAAGI,CAAI,CAAC,GACnDE,IAAS,CAACC,IAAOX,CAAAA,KAAS;QAE5BK,IAAIE,EAAEN,GAAOU,CAAI,GACjBP,IAAIG,EAAC,GACDI,EAAK,MAAA,KAAW,KAAA,CAEpBN,IAAIE,EAAEL,GAAOS,CAAI,GACjBP,IAAIG,EAAC,CAAA;IACT,GACMK,IAAM,MAAM;QAEd,IAAInF,OAAO0E,GACP,MAAM,IAAI,MAAM,sCAAsC;QAC1D,IAAIjF,IAAM;QACV,MAAMI,IAAM,CAAA,CAAA;QACZ,MAAOJ,IAAM2E,GAAU;YACnBO,IAAIG,EAAC;YACL,MAAMM,IAAKT,EAAE,KAAA,CAAK;YAClB9E,EAAI,IAAA,CAAKuF,CAAE,GACX3F,KAAOkF,EAAE,MAAA;QACb;QACA,WAAOK,6OAAAA,CAAa,IAAGnF,CAAG;IAC9B;IAUA,OATiB,CAACqF,GAAMG,MAAS;QAC7BR,EAAK,GACLI,EAAOC,CAAI;QACX,IAAI9E;QACJ,MAAO,CAAA,CAAEA,IAAMiF,EAAKF,EAAG,CAAE,CAAA,GACrBF,EAAM;QACV,OAAAJ,EAAK,GACEzE;IACX;AAEJ;AACO,SAASkF,GAAeC,CAAAA,EAAQC,IAAS,CAAA,CAAA,EAAIC,IAAY,CAAA,CAAA,EAAI;IAChE,IAAI,CAACF,KAAU,OAAOA,KAAW,UAC7B,MAAM,IAAI,MAAM,+BAA+B;IACnD,SAASG,EAAWC,CAAAA,EAAWC,CAAAA,EAAcC,CAAAA,EAAO;QAChD,MAAMC,IAAMP,CAAAA,CAAOI,CAAS,CAAA;QAC5B,IAAIE,KAASC,MAAQ,KAAA,GACjB;QACJ,MAAMC,IAAU,OAAOD;QACvB,IAAIC,MAAYH,KAAgBE,MAAQ,MACpC,MAAM,IAAI,MAAM,CAAA,OAAA,EAAUH,CAAS,CAAA,uBAAA,EAA0BC,CAAY,CAAA,MAAA,EAASG,CAAO,EAAE;IACnG;IACA,MAAMC,IAAO,CAACC,GAAGJ,IAAU,OAAO,OAAA,CAAQI,CAAC,EAAE,OAAA,CAAQ,CAAC,CAACrB,GAAGD,CAAC,CAAA,GAAMe,EAAWd,GAAGD,GAAGkB,CAAK,CAAC;IACxFG,EAAKR,GAAQ,CAAA,CAAK,GAClBQ,EAAKP,GAAW,CAAA,CAAI;AACxB;AAWO,SAASS,GAASC,CAAAA,EAAI;IACzB,MAAMC,IAAM,aAAA,GAAA,IAAI,QAAO;IACvB,OAAO,CAACC,GAAAA,GAAQC,MAAS;QACrB,MAAMR,IAAMM,EAAI,GAAA,CAAIC,CAAG;QACvB,IAAIP,MAAQ,KAAA,GACR,OAAOA;QACX,MAAMS,IAAWJ,EAAGE,GAAK,GAAGC,CAAI;QAChC,OAAAF,EAAI,GAAA,CAAIC,GAAKE,CAAQ,GACdA;IACX;AACJ;ACzOA,oEAAA,GAIA,MAAMrE,IAAsB,aAAA,GAAA,OAAO,CAAC,GAAGC,IAAsB,aAAA,GAAA,OAAO,CAAC,GAAGqE,KAAsB,aAAA,GAAA,OAAO,CAAC,GAEhGC,KAAsB,aAAA,GAAA,OAAO,CAAC,GAAGC,KAAsB,aAAA,GAAA,OAAO,CAAC,GAAGC,KAAsB,aAAA,GAAA,OAAO,CAAC,GAEhGC,KAAsB,aAAA,GAAA,OAAO,CAAC,GAAGC,KAAsB,aAAA,GAAA,OAAO,CAAC,GAAGC,KAAsB,aAAA,GAAA,OAAO,CAAC,GAChGC,KAAuB,aAAA,GAAA,OAAO,EAAE;AAE/B,SAASC,EAAIvI,CAAAA,EAAGC,CAAAA,EAAG;IACtB,MAAMuI,IAASxI,IAAIC;IACnB,OAAOuI,KAAU/E,IAAM+E,IAASvI,IAAIuI;AACxC;AAWO,SAASC,EAAKC,CAAAA,EAAGC,CAAAA,EAAOC,CAAAA,EAAQ;IACnC,IAAIjH,IAAM+G;IACV,MAAOC,MAAUlF,GACb9B,KAAOA,GACPA,KAAOiH;IAEX,OAAOjH;AACX;AAKO,SAASkH,GAAOC,CAAAA,EAAQF,CAAAA,EAAQ;IACnC,IAAIE,MAAWrF,GACX,MAAM,IAAI,MAAM,kCAAkC;IACtD,IAAImF,KAAUnF,GACV,MAAM,IAAI,MAAM,4CAA4CmF,CAAM;IAEtE,IAAI5I,IAAIuI,EAAIO,GAAQF,CAAM,GACtB3I,IAAI2I,GAEJF,IAAIjF,GAAcsF,IAAIrF;IAC1B,MAAO1D,MAAMyD,GAAK;QAEd,MAAMuF,IAAI/I,IAAID,GACRiJ,IAAIhJ,IAAID,GACRkJ,IAAIR,IAAIK,IAAIC;QAGlB/I,IAAID,GAAGA,IAAIiJ,GAAGP,IAAIK,GAAUA,IAAIG;IACpC;IAEA,IADYjJ,MACAyD,GACR,MAAM,IAAI,MAAM,wBAAwB;IAC5C,OAAO6E,EAAIG,GAAGE,CAAM;AACxB;AACA,SAASO,GAAeC,CAAAA,EAAIC,CAAAA,EAAM/D,CAAAA,EAAG;IACjC,IAAI,CAAC8D,EAAG,GAAA,CAAIA,EAAG,GAAA,CAAIC,CAAI,GAAG/D,CAAC,GACvB,MAAM,IAAI,MAAM,yBAAyB;AACjD;AAKA,SAASgE,GAAUF,CAAAA,EAAI9D,CAAAA,EAAG;IACtB,MAAMiE,IAAAA,CAAUH,EAAG,KAAA,GAAQ1F,CAAAA,IAAOuE,IAC5BoB,IAAOD,EAAG,GAAA,CAAI9D,GAAGiE,CAAM;IAC7B,OAAAJ,GAAeC,GAAIC,GAAM/D,CAAC,GACnB+D;AACX;AACA,SAASG,GAAUJ,CAAAA,EAAI9D,CAAAA,EAAG;IACtB,MAAMmE,IAAAA,CAAUL,EAAG,KAAA,GAAQlB,EAAAA,IAAOE,IAC5BsB,IAAKN,EAAG,GAAA,CAAI9D,GAAGyC,EAAG,GAClB7B,IAAIkD,EAAG,GAAA,CAAIM,GAAID,CAAM,GACrBE,IAAKP,EAAG,GAAA,CAAI9D,GAAGY,CAAC,GAChB,IAAIkD,EAAG,GAAA,CAAIA,EAAG,GAAA,CAAIO,GAAI5B,EAAG,GAAG7B,CAAC,GAC7BmD,IAAOD,EAAG,GAAA,CAAIO,GAAIP,EAAG,GAAA,CAAI,GAAGA,EAAG,GAAG,CAAC;IACzC,OAAAD,GAAeC,GAAIC,GAAM/D,CAAC,GACnB+D;AACX;AAGA,SAASO,GAAWC,CAAAA,EAAG;IACnB,MAAMC,IAAMC,GAAMF,CAAC,GACbG,IAAKC,GAAcJ,CAAC,GACpBK,IAAKF,EAAGF,GAAKA,EAAI,GAAA,CAAIA,EAAI,GAAG,CAAC,GAC7BK,IAAKH,EAAGF,GAAKI,CAAE,GACfE,IAAKJ,EAAGF,GAAKA,EAAI,GAAA,CAAII,CAAE,CAAC,GACxBG,IAAAA,CAAMR,IAAI1B,EAAAA,IAAOG;IACvB,OAAO,CAACc,GAAI9D,MAAM;QACd,IAAIgF,IAAMlB,EAAG,GAAA,CAAI9D,GAAG+E,CAAE,GAClBE,IAAMnB,EAAG,GAAA,CAAIkB,GAAKJ,CAAE;QACxB,MAAMM,IAAMpB,EAAG,GAAA,CAAIkB,GAAKH,CAAE,GACpBM,IAAMrB,EAAG,GAAA,CAAIkB,GAAKF,CAAE,GACpBM,IAAKtB,EAAG,GAAA,CAAIA,EAAG,GAAA,CAAImB,CAAG,GAAGjF,CAAC,GAC1BqF,IAAKvB,EAAG,GAAA,CAAIA,EAAG,GAAA,CAAIoB,CAAG,GAAGlF,CAAC;QAChCgF,IAAMlB,EAAG,IAAA,CAAKkB,GAAKC,GAAKG,CAAE,GAC1BH,IAAMnB,EAAG,IAAA,CAAKqB,GAAKD,GAAKG,CAAE;QAC1B,MAAMC,IAAKxB,EAAG,GAAA,CAAIA,EAAG,GAAA,CAAImB,CAAG,GAAGjF,CAAC,GAC1B+D,IAAOD,EAAG,IAAA,CAAKkB,GAAKC,GAAKK,CAAE;QACjC,OAAAzB,GAAeC,GAAIC,GAAM/D,CAAC,GACnB+D;IACX;AACJ;AAQO,SAASY,GAAcJ,CAAAA,EAAG;IAG7B,IAAIA,IAAI7B,IACJ,MAAM,IAAI,MAAM,qCAAqC;IAEzD,IAAI6C,IAAIhB,IAAInG,GACRoH,IAAI;IACR,MAAOD,IAAI9C,OAAQtE,GACfoH,KAAK9C,IACL+C;IAGJ,IAAIC,IAAIhD;IACR,MAAMiD,IAAMjB,GAAMF,CAAC;IACnB,MAAOoB,GAAWD,GAAKD,CAAC,MAAM,GAG1B,IAAIA,MAAM,KACN,MAAM,IAAI,MAAM,+CAA+C;IAGvE,IAAID,MAAM,GACN,OAAOxB;IAGX,IAAI4B,IAAKF,EAAI,GAAA,CAAID,GAAGF,CAAC;IACrB,MAAMM,IAAAA,CAAUN,IAAInH,CAAAA,IAAOqE;IAC3B,OAAO,SAAqBqB,CAAAA,EAAI9D,CAAAA,EAAG;QAC/B,IAAI8D,EAAG,GAAA,CAAI9D,CAAC,GACR,OAAOA;QAEX,IAAI2F,GAAW7B,GAAI9D,CAAC,MAAM,GACtB,MAAM,IAAI,MAAM,yBAAyB;QAE7C,IAAI8F,IAAIN,GACJ5K,IAAIkJ,EAAG,GAAA,CAAIA,EAAG,GAAA,EAAK8B,CAAE,GACrBG,IAAIjC,EAAG,GAAA,CAAI9D,GAAGuF,CAAC,GACfS,IAAIlC,EAAG,GAAA,CAAI9D,GAAG6F,CAAM;QAGxB,MAAO,CAAC/B,EAAG,GAAA,CAAIiC,GAAGjC,EAAG,GAAG,GAAG;YACvB,IAAIA,EAAG,GAAA,CAAIiC,CAAC,GACR,OAAOjC,EAAG,IAAA;YACd,IAAI7H,IAAI,GAEJgK,IAAQnC,EAAG,GAAA,CAAIiC,CAAC;YACpB,MAAO,CAACjC,EAAG,GAAA,CAAImC,GAAOnC,EAAG,GAAG,GAGxB,IAFA7H,KACAgK,IAAQnC,EAAG,GAAA,CAAImC,CAAK,GAChBhK,MAAM6J,GACN,MAAM,IAAI,MAAM,yBAAyB;YAGjD,MAAMI,IAAW9H,KAAO,OAAO0H,IAAI7J,IAAI,CAAC,GAClCtB,IAAImJ,EAAG,GAAA,CAAIlJ,GAAGsL,CAAQ;YAE5BJ,IAAI7J,GACJrB,IAAIkJ,EAAG,GAAA,CAAInJ,CAAC,GACZoL,IAAIjC,EAAG,GAAA,CAAIiC,GAAGnL,CAAC,GACfoL,IAAIlC,EAAG,GAAA,CAAIkC,GAAGrL,CAAC;QACnB;QACA,OAAOqL;IACX;AACJ;AAYO,SAASG,GAAO5B,CAAAA,EAAG;IAEtB,OAAIA,IAAI5B,OAAQD,KACLsB,KAEPO,IAAIzB,OAAQF,KACLsB,KAEPK,IAAIvB,OAASD,KACNuB,GAAWC,CAAC,IAEhBI,GAAcJ,CAAC;AAC1B;AAIA,MAAM6B,KAAe;IACjB;IAAU;IAAW;IAAO;IAAO;IAAO;IAAQ;IAClD;IAAO;IAAO;IAAO;IAAO;IAAO;IACnC;IAAQ;IAAQ;IAAQ;CAC5B;AACO,SAASC,GAAcC,CAAAA,EAAO;IACjC,MAAMC,IAAU;QACZ,OAAO;QACP,OAAO;QACP,MAAM;IACd,GACUC,IAAOJ,GAAa,MAAA,CAAO,CAAC/D,GAAKN,IAAAA,CACnCM,CAAAA,CAAIN,CAAG,CAAA,GAAI,YACJM,CAAAA,GACRkE,CAAO;IACV,OAAAhF,GAAe+E,GAAOE,CAAI,GAInBF;AACX;AAMO,SAASG,GAAM3C,CAAAA,EAAIjF,CAAAA,EAAKwE,CAAAA,EAAO;IAClC,IAAIA,IAAQlF,GACR,MAAM,IAAI,MAAM,yCAAyC;IAC7D,IAAIkF,MAAUlF,GACV,OAAO2F,EAAG,GAAA;IACd,IAAIT,MAAUjF,GACV,OAAOS;IACX,IAAI6H,IAAI5C,EAAG,GAAA,EACP6C,IAAI9H;IACR,MAAOwE,IAAQlF,GACPkF,IAAQjF,KAAAA,CACRsI,IAAI5C,EAAG,GAAA,CAAI4C,GAAGC,CAAC,CAAA,GACnBA,IAAI7C,EAAG,GAAA,CAAI6C,CAAC,GACZtD,MAAUjF;IAEd,OAAOsI;AACX;AAMO,SAASE,GAAc9C,CAAAA,EAAI+C,CAAAA,EAAMC,IAAW,CAAA,CAAA,EAAO;IACtD,MAAMC,IAAW,IAAI,MAAMF,EAAK,MAAM,EAAE,IAAA,CAAKC,IAAWhD,EAAG,IAAA,GAAO,KAAA,CAAS,GAErEkD,IAAgBH,EAAK,MAAA,CAAO,CAACI,GAAKpI,GAAK5C,IACrC6H,EAAG,GAAA,CAAIjF,CAAG,IACHoI,IAAAA,CACXF,CAAAA,CAAS9K,CAAC,CAAA,GAAIgL,GACPnD,EAAG,GAAA,CAAImD,GAAKpI,CAAG,CAAA,GACvBiF,EAAG,GAAG,GAEHoD,IAAcpD,EAAG,GAAA,CAAIkD,CAAa;IAExC,OAAAH,EAAK,WAAA,CAAY,CAACI,GAAKpI,GAAK5C,IACpB6H,EAAG,GAAA,CAAIjF,CAAG,IACHoI,IAAAA,CACXF,CAAAA,CAAS9K,CAAC,CAAA,GAAI6H,EAAG,GAAA,CAAImD,GAAKF,CAAAA,CAAS9K,CAAC,CAAC,GAC9B6H,EAAG,GAAA,CAAImD,GAAKpI,CAAG,CAAA,GACvBqI,CAAW,GACPH;AACX;AAcO,SAASpB,GAAW7B,CAAAA,EAAI9D,CAAAA,EAAG;IAG9B,MAAMmH,IAAAA,CAAUrD,EAAG,KAAA,GAAQ1F,CAAAA,IAAOqE,IAC5B2E,IAAUtD,EAAG,GAAA,CAAI9D,GAAGmH,CAAM,GAC1BE,IAAMvD,EAAG,GAAA,CAAIsD,GAAStD,EAAG,GAAG,GAC5BwD,IAAOxD,EAAG,GAAA,CAAIsD,GAAStD,EAAG,IAAI,GAC9ByD,IAAKzD,EAAG,GAAA,CAAIsD,GAAStD,EAAG,GAAA,CAAIA,EAAG,GAAG,CAAC;IACzC,IAAI,CAACuD,KAAO,CAACC,KAAQ,CAACC,GAClB,MAAM,IAAI,MAAM,gCAAgC;IACpD,OAAOF,IAAM,IAAIC,IAAO,IAAI,CAAA;AAChC;AAOO,SAASE,GAAQ,CAAA,EAAGC,CAAAA,EAAY;IAE/BA,MAAe,KAAA,SACf9I,6OAAAA,EAAQ8I,CAAU;IACtB,MAAMC,IAAcD,MAAe,KAAA,IAAYA,IAAa,EAAE,QAAA,CAAS,CAAC,EAAE,MAAA,EACpEE,IAAc,KAAK,IAAA,CAAKD,IAAc,CAAC;IAC7C,OAAO;QAAE,YAAYA;QAAa,aAAAC;IAAW;AACjD;AACA,MAAMC,GAAO;IAUT,YAAYC,CAAAA,EAAOrB,IAAO,CAAA,CAAA,CAAI;QAT9BrL,EAAA,IAAA,EAAA;QACAA,EAAA,IAAA,EAAA;QACAA,EAAA,IAAA,EAAA;QACAA,EAAA,IAAA,EAAA;QACAA,EAAA,IAAA,EAAA,QAAOgD;QACPhD,EAAA,IAAA,EAAA,OAAMiD;QACNjD,EAAA,IAAA,EAAA;QACAA,EAAA,IAAA,EAAA;QACA,cAAA;QAAAA,EAAA,IAAA,EAAA;QAEI,IAAI0M,KAAS1J,GACT,MAAM,IAAI,MAAM,4CAA4C0J,CAAK;QACrE,IAAIC;QACJ,IAAA,CAAK,IAAA,GAAO,CAAA,GACRtB,KAAQ,QAAQ,OAAOA,KAAS,YAAA,CAC5B,OAAOA,EAAK,IAAA,IAAS,YAAA,CACrBsB,IAActB,EAAK,IAAA,GACnB,OAAOA,EAAK,IAAA,IAAS,cAAA,CACrB,IAAA,CAAK,IAAA,GAAOA,EAAK,IAAA,GACjB,OAAOA,EAAK,IAAA,IAAS,aAAA,CACrB,IAAA,CAAK,IAAA,GAAOA,EAAK,IAAA,GACjBA,EAAK,cAAA,IAAA,CACL,IAAA,CAAK,QAAA,GAAWA,EAAK,cAAA,EAAgB,MAAK,CAAA,GAC1C,OAAOA,EAAK,YAAA,IAAiB,aAAA,CAC7B,IAAA,CAAK,IAAA,GAAOA,EAAK,YAAA,CAAA;QAEzB,MAAM,EAAE,YAAAiB,CAAAA,EAAY,aAAAE,CAAAA,CAAW,CAAA,GAAKH,GAAQK,GAAOC,CAAW;QAC9D,IAAIH,IAAc,MACd,MAAM,IAAI,MAAM,gDAAgD;QACpE,IAAA,CAAK,KAAA,GAAQE,GACb,IAAA,CAAK,IAAA,GAAOJ,GACZ,IAAA,CAAK,KAAA,GAAQE,GACb,IAAA,CAAK,KAAA,GAAQ,KAAA,GACb,OAAO,iBAAA,CAAkB,IAAI;IACjC;IACA,OAAO9I,CAAAA,EAAK;QACR,OAAOoE,EAAIpE,GAAK,IAAA,CAAK,KAAK;IAC9B;IACA,QAAQA,CAAAA,EAAK;QACT,IAAI,OAAOA,KAAQ,UACf,MAAM,IAAI,MAAM,iDAAiD,OAAOA,CAAG;QAC/E,OAAOV,KAAOU,KAAOA,IAAM,IAAA,CAAK,KAAA;IACpC;IACA,IAAIA,CAAAA,EAAK;QACL,OAAOA,MAAQV;IACnB;IAAA,0BAAA;IAEA,YAAYU,CAAAA,EAAK;QACb,OAAO,CAAC,IAAA,CAAK,GAAA,CAAIA,CAAG,KAAK,IAAA,CAAK,OAAA,CAAQA,CAAG;IAC7C;IACA,MAAMA,CAAAA,EAAK;QACP,OAAA,CAAQA,IAAMT,CAAAA,MAASA;IAC3B;IACA,IAAIS,CAAAA,EAAK;QACL,OAAOoE,EAAI,CAACpE,GAAK,IAAA,CAAK,KAAK;IAC/B;IACA,IAAIkJ,CAAAA,EAAKC,CAAAA,EAAK;QACV,OAAOD,MAAQC;IACnB;IACA,IAAInJ,CAAAA,EAAK;QACL,OAAOoE,EAAIpE,IAAMA,GAAK,IAAA,CAAK,KAAK;IACpC;IACA,IAAIkJ,CAAAA,EAAKC,CAAAA,EAAK;QACV,OAAO/E,EAAI8E,IAAMC,GAAK,IAAA,CAAK,KAAK;IACpC;IACA,IAAID,CAAAA,EAAKC,CAAAA,EAAK;QACV,OAAO/E,EAAI8E,IAAMC,GAAK,IAAA,CAAK,KAAK;IACpC;IACA,IAAID,CAAAA,EAAKC,CAAAA,EAAK;QACV,OAAO/E,EAAI8E,IAAMC,GAAK,IAAA,CAAK,KAAK;IACpC;IACA,IAAInJ,CAAAA,EAAKwE,CAAAA,EAAO;QACZ,OAAOoD,GAAM,IAAA,EAAM5H,GAAKwE,CAAK;IACjC;IACA,IAAI0E,CAAAA,EAAKC,CAAAA,EAAK;QACV,OAAO/E,EAAI8E,IAAMxE,GAAOyE,GAAK,IAAA,CAAK,KAAK,GAAG,IAAA,CAAK,KAAK;IACxD;IAAA,uCAAA;IAEA,KAAKnJ,CAAAA,EAAK;QACN,OAAOA,IAAMA;IACjB;IACA,KAAKkJ,CAAAA,EAAKC,CAAAA,EAAK;QACX,OAAOD,IAAMC;IACjB;IACA,KAAKD,CAAAA,EAAKC,CAAAA,EAAK;QACX,OAAOD,IAAMC;IACjB;IACA,KAAKD,CAAAA,EAAKC,CAAAA,EAAK;QACX,OAAOD,IAAMC;IACjB;IACA,IAAInJ,CAAAA,EAAK;QACL,OAAO0E,GAAO1E,GAAK,IAAA,CAAK,KAAK;IACjC;IACA,KAAKA,CAAAA,EAAK;QAEN,OAAK,IAAA,CAAK,KAAA,IAAA,CACN,IAAA,CAAK,KAAA,GAAQsH,GAAO,IAAA,CAAK,KAAK,CAAA,GAC3B,IAAA,CAAK,KAAA,CAAM,IAAA,EAAMtH,CAAG;IAC/B;IACA,QAAQA,CAAAA,EAAK;QACT,OAAO,IAAA,CAAK,IAAA,GAAOW,GAAgBX,GAAK,IAAA,CAAK,KAAK,IAAIS,GAAgBT,GAAK,IAAA,CAAK,KAAK;IACzF;IACA,UAAUI,CAAAA,EAAOgJ,IAAiB,CAAA,CAAA,EAAO;YACrC1M,6OAAAA,EAAO0D,CAAK;QACZ,MAAM,EAAE,UAAUiJ,CAAAA,EAAgB,OAAAC,CAAAA,EAAO,MAAAjN,CAAAA,EAAM,OAAA2M,CAAAA,EAAO,MAAMO,CAAAA,CAAY,CAAA,GAAK,IAAA;QAC7E,IAAIF,GAAgB;YAChB,IAAI,CAACA,EAAe,QAAA,CAASjJ,EAAM,MAAM,KAAKA,EAAM,MAAA,GAASkJ,GACzD,MAAM,IAAI,MAAM,+BAA+BD,IAAiB,iBAAiBjJ,EAAM,MAAM;YAEjG,MAAMoJ,IAAS,IAAI,WAAWF,CAAK;YAEnCE,EAAO,GAAA,CAAIpJ,GAAO/D,IAAO,IAAImN,EAAO,MAAA,GAASpJ,EAAM,MAAM,GACzDA,IAAQoJ;QACZ;QACA,IAAIpJ,EAAM,MAAA,KAAWkJ,GACjB,MAAM,IAAI,MAAM,+BAA+BA,IAAQ,iBAAiBlJ,EAAM,MAAM;QACxF,IAAIqJ,IAASpN,IAAOiE,GAAgBF,CAAK,IAAID,GAAgBC,CAAK;QAGlE,IAFImJ,KAAAA,CACAE,IAASrF,EAAIqF,GAAQT,CAAK,CAAA,GAC1B,CAACI,KACG,CAAC,IAAA,CAAK,OAAA,CAAQK,CAAM,GACpB,MAAM,IAAI,MAAM,kDAAkD;QAG1E,OAAOA;IACX;IAAA,uDAAA;IAEA,YAAYC,CAAAA,EAAK;QACb,OAAO3B,GAAc,IAAA,EAAM2B,CAAG;IAClC;IAAA,wDAAA;IAAA,4CAAA;IAGA,KAAK7N,CAAAA,EAAGC,CAAAA,EAAG6N,CAAAA,EAAW;QAClB,OAAOA,IAAY7N,IAAID;IAC3B;AACJ;AAoBO,SAAS+J,GAAMoD,CAAAA,EAAOrB,IAAO,CAAA,CAAA,EAAI;IACpC,OAAO,IAAIoB,GAAOC,GAAOrB,CAAI;AACjC;AAgCO,SAASiC,GAAoBC,CAAAA,EAAY;IAC5C,IAAI,OAAOA,KAAe,UACtB,MAAM,IAAI,MAAM,4BAA4B;IAChD,MAAMC,IAAYD,EAAW,QAAA,CAAS,CAAC,EAAE,MAAA;IACzC,OAAO,KAAK,IAAA,CAAKC,IAAY,CAAC;AAClC;AAQO,SAASC,GAAiBF,CAAAA,EAAY;IACzC,MAAMnM,IAASkM,GAAoBC,CAAU;IAC7C,OAAOnM,IAAS,KAAK,IAAA,CAAKA,IAAS,CAAC;AACxC;AAcO,SAASsM,GAAeC,CAAAA,EAAKJ,CAAAA,EAAYxN,IAAO,CAAA,CAAA,EAAO;QAC1DK,6OAAAA,EAAOuN,CAAG;IACV,MAAMpN,IAAMoN,EAAI,MAAA,EACVC,IAAWN,GAAoBC,CAAU,GACzCM,IAASJ,GAAiBF,CAAU;IAE1C,IAAIhN,IAAM,MAAMA,IAAMsN,KAAUtN,IAAM,MAClC,MAAM,IAAI,MAAM,cAAcsN,IAAS,+BAA+BtN,CAAG;IAC7E,MAAMmD,IAAM3D,IAAOiE,GAAgB2J,CAAG,IAAI9J,GAAgB8J,CAAG,GAEvDG,IAAUhG,EAAIpE,GAAK6J,IAAatK,CAAG,IAAIA;IAC7C,OAAOlD,IAAOsE,GAAgByJ,GAASF,CAAQ,IAAIzJ,GAAgB2J,GAASF,CAAQ;AACxF;ACpiBA,oEAAA,GAGA,MAAM5K,KAAsB,aAAA,GAAA,OAAO,CAAC,GAC9BC,KAAsB,aAAA,GAAA,OAAO,CAAC;AAC7B,SAAS8K,GAASV,CAAAA,EAAWW,CAAAA,EAAM;IACtC,MAAMC,IAAMD,EAAK,MAAA,CAAM;IACvB,OAAOX,IAAYY,IAAMD;AAC7B;AAOO,SAASE,GAAWzO,CAAAA,EAAG0O,CAAAA,EAAQ;IAClC,MAAMC,IAAa3C,GAAchM,EAAE,EAAA,EAAI0O,EAAO,GAAA,CAAI,CAAC5C,IAAMA,EAAE,CAAC,CAAC;IAC7D,OAAO4C,EAAO,GAAA,CAAI,CAAC5C,GAAGzK,IAAMrB,EAAE,UAAA,CAAW8L,EAAE,QAAA,CAAS6C,CAAAA,CAAWtN,CAAC,CAAC,CAAC,CAAC;AACvE;AACA,SAASuN,GAAUC,CAAAA,EAAGC,CAAAA,EAAM;IACxB,IAAI,CAAC,OAAO,aAAA,CAAcD,CAAC,KAAKA,KAAK,KAAKA,IAAIC,GAC1C,MAAM,IAAI,MAAM,uCAAuCA,IAAO,cAAcD,CAAC;AACrF;AACA,SAASE,GAAUF,CAAAA,EAAGG,CAAAA,EAAY;IAC9BJ,GAAUC,GAAGG,CAAU;IACvB,MAAMC,IAAU,KAAK,IAAA,CAAKD,IAAaH,CAAC,IAAI,GACtCK,IAAa,KAAA,CAAML,IAAI,CAAA,GACvBM,IAAY,KAAKN,GACjBO,IAAO9J,GAAQuJ,CAAC,GAChBQ,IAAU,OAAOR,CAAC;IACxB,OAAO;QAAE,SAAAI;QAAS,YAAAC;QAAY,MAAAE;QAAM,WAAAD;QAAW,SAAAE;IAAO;AAC1D;AACA,SAASC,GAAY,CAAA,EAAGC,CAAAA,EAAQC,CAAAA,EAAO;IACnC,MAAM,EAAE,YAAAN,CAAAA,EAAY,MAAAE,CAAAA,EAAM,WAAAD,CAAAA,EAAW,SAAAE,CAAAA,CAAO,CAAA,GAAKG;IACjD,IAAIC,IAAQ,OAAO,IAAIL,CAAI,GACvBM,IAAQ,KAAKL;IAMbI,IAAQP,KAAAA,CAERO,KAASN,GACTO,KAASlM,EAAAA;IAEb,MAAMmM,IAAcJ,IAASL,GACvBxM,IAASiN,IAAc,KAAK,GAAA,CAAIF,CAAK,IAAI,GACzCG,IAASH,MAAU,GACnBI,IAAQJ,IAAQ,GAChBK,IAASP,IAAS,MAAM;IAE9B,OAAO;QAAE,OAAAG;QAAO,QAAAhN;QAAQ,QAAAkN;QAAQ,OAAAC;QAAO,QAAAC;QAAQ,SAD/BH;IACsC;AAC1D;AAoBA,MAAMI,KAAmB,aAAA,GAAA,IAAI,QAAO,GAC9BC,KAAmB,aAAA,GAAA,IAAI,QAAO;AACpC,SAASC,GAAKtG,CAAAA,EAAG;IAGb,OAAOqG,GAAiB,GAAA,CAAIrG,CAAC,KAAK;AACtC;AACA,SAASuG,GAAQ,CAAA,EAAG;IAChB,IAAI,MAAM3M,IACN,MAAM,IAAI,MAAM,cAAc;AACtC;AAmBO,MAAM4M,GAAK;IAAA,+DAAA;IAMd,YAAYC,CAAAA,EAAOtB,CAAAA,CAAM;QALzBvO,EAAA,IAAA,EAAA;QACAA,EAAA,IAAA,EAAA;QACAA,EAAA,IAAA,EAAA;QACAA,EAAA,IAAA,EAAA;QAGI,IAAA,CAAK,IAAA,GAAO6P,EAAM,IAAA,EAClB,IAAA,CAAK,IAAA,GAAOA,EAAM,IAAA,EAClB,IAAA,CAAK,EAAA,GAAKA,EAAM,EAAA,EAChB,IAAA,CAAK,IAAA,GAAOtB;IAChB;IAAA,uCAAA;IAEA,cAAcuB,CAAAA,EAAKjL,CAAAA,EAAG0G,IAAI,IAAA,CAAK,IAAA,EAAM;QACjC,IAAIC,IAAIsE;QACR,MAAOjL,IAAI7B,IACH6B,IAAI5B,MAAAA,CACJsI,IAAIA,EAAE,GAAA,CAAIC,CAAC,CAAA,GACfA,IAAIA,EAAE,MAAA,CAAM,GACZ3G,MAAM5B;QAEV,OAAOsI;IACX;IAAA;;;;;;;;;;;GAAA,GAaA,iBAAiBwE,CAAAA,EAAOzB,CAAAA,EAAG;QACvB,MAAM,EAAE,SAAAI,CAAAA,EAAS,YAAAC,CAAAA,CAAU,CAAA,GAAKH,GAAUF,GAAG,IAAA,CAAK,IAAI,GAChDH,IAAS,CAAA,CAAA;QACf,IAAI5C,IAAIwE,GACJC,IAAOzE;QACX,IAAA,IAASyD,IAAS,GAAGA,IAASN,GAASM,IAAU;YAC7CgB,IAAOzE,GACP4C,EAAO,IAAA,CAAK6B,CAAI;YAEhB,IAAA,IAASlP,IAAI,GAAGA,IAAI6N,GAAY7N,IAC5BkP,IAAOA,EAAK,GAAA,CAAIzE,CAAC,GACjB4C,EAAO,IAAA,CAAK6B,CAAI;YAEpBzE,IAAIyE,EAAK,MAAA,CAAM;QACnB;QACA,OAAO7B;IACX;IAAA;;;;;GAAA,GAOA,KAAKG,CAAAA,EAAG2B,CAAAA,EAAapL,CAAAA,EAAG;QAEpB,IAAI,CAAC,IAAA,CAAK,EAAA,CAAG,OAAA,CAAQA,CAAC,GAClB,MAAM,IAAI,MAAM,gBAAgB;QAEpC,IAAI0G,IAAI,IAAA,CAAK,IAAA,EACTxE,IAAI,IAAA,CAAK,IAAA;QAMb,MAAMmJ,IAAK1B,GAAUF,GAAG,IAAA,CAAK,IAAI;QACjC,IAAA,IAASU,IAAS,GAAGA,IAASkB,EAAG,OAAA,EAASlB,IAAU;YAEhD,MAAM,EAAE,OAAAG,CAAAA,EAAO,QAAAhN,CAAAA,EAAQ,QAAAkN,CAAAA,EAAQ,OAAAC,CAAAA,EAAO,QAAAC,CAAAA,EAAQ,SAAAY,CAAAA,CAAO,CAAA,GAAKpB,GAAYlK,GAAGmK,GAAQkB,CAAE;YACnFrL,IAAIsK,GACAE,IAGAtI,IAAIA,EAAE,GAAA,CAAIgH,GAASwB,GAAQU,CAAAA,CAAYE,CAAO,CAAC,CAAC,IAIhD5E,IAAIA,EAAE,GAAA,CAAIwC,GAASuB,GAAOW,CAAAA,CAAY9N,CAAM,CAAC,CAAC;QAEtD;QACA,OAAAwN,GAAQ9K,CAAC,GAIF;YAAE,GAAA0G;YAAG,GAAAxE;QAAC;IACjB;IAAA;;;;GAAA,GAMA,WAAWuH,CAAAA,EAAG2B,CAAAA,EAAapL,CAAAA,EAAGiH,IAAM,IAAA,CAAK,IAAA,EAAM;QAC3C,MAAMoE,IAAK1B,GAAUF,GAAG,IAAA,CAAK,IAAI;QACjC,IAAA,IAASU,IAAS,GAAGA,IAASkB,EAAG,OAAA,IACzBrL,MAAM7B,IAD4BgM,IAAU;YAGhD,MAAM,EAAE,OAAAG,CAAAA,EAAO,QAAAhN,CAAAA,EAAQ,QAAAkN,CAAAA,EAAQ,OAAAC,CAAAA,CAAK,CAAA,GAAKP,GAAYlK,GAAGmK,GAAQkB,CAAE;YAElE,IADArL,IAAIsK,GACA,CAAAE,GAKC;gBACD,MAAMrB,IAAOiC,CAAAA,CAAY9N,CAAM,CAAA;gBAC/B2J,IAAMA,EAAI,GAAA,CAAIwD,IAAQtB,EAAK,MAAA,CAAM,IAAKA,CAAI;YAC9C;QACJ;QACA,OAAA2B,GAAQ9K,CAAC,GACFiH;IACX;IACA,eAAewC,CAAAA,EAAGyB,CAAAA,EAAOK,CAAAA,EAAW;QAEhC,IAAIC,IAAOb,GAAiB,GAAA,CAAIO,CAAK;QACrC,OAAKM,KAAAA,CACDA,IAAO,IAAA,CAAK,gBAAA,CAAiBN,GAAOzB,CAAC,GACjCA,MAAM,KAAA,CAEF,OAAO8B,KAAc,cAAA,CACrBC,IAAOD,EAAUC,CAAI,CAAA,GACzBb,GAAiB,GAAA,CAAIO,GAAOM,CAAI,CAAA,CAAA,GAGjCA;IACX;IACA,OAAON,CAAAA,EAAO5C,CAAAA,EAAQiD,CAAAA,EAAW;QAC7B,MAAM9B,IAAIoB,GAAKK,CAAK;QACpB,OAAO,IAAA,CAAK,IAAA,CAAKzB,GAAG,IAAA,CAAK,cAAA,CAAeA,GAAGyB,GAAOK,CAAS,GAAGjD,CAAM;IACxE;IACA,OAAO4C,CAAAA,EAAO5C,CAAAA,EAAQiD,CAAAA,EAAWE,CAAAA,EAAM;QACnC,MAAMhC,IAAIoB,GAAKK,CAAK;QACpB,OAAIzB,MAAM,IACC,IAAA,CAAK,aAAA,CAAcyB,GAAO5C,GAAQmD,CAAI,IAC1C,IAAA,CAAK,UAAA,CAAWhC,GAAG,IAAA,CAAK,cAAA,CAAeA,GAAGyB,GAAOK,CAAS,GAAGjD,GAAQmD,CAAI;IACpF;IAAA,mEAAA;IAAA,wDAAA;IAAA,2EAAA;IAIA,YAAYlH,CAAAA,EAAGkF,CAAAA,EAAG;QACdD,GAAUC,GAAG,IAAA,CAAK,IAAI,GACtBmB,GAAiB,GAAA,CAAIrG,GAAGkF,CAAC,GACzBkB,GAAiB,MAAA,CAAOpG,CAAC;IAC7B;IACA,SAAS0G,CAAAA,EAAK;QACV,OAAOJ,GAAKI,CAAG,MAAM;IACzB;AACJ;AAKO,SAASS,GAAcV,CAAAA,EAAOE,CAAAA,EAAOS,CAAAA,EAAIC,CAAAA,EAAI;IAChD,IAAI3E,IAAMiE,GACNW,IAAKb,EAAM,IAAA,EACXc,IAAKd,EAAM,IAAA;IACf,MAAOW,IAAKxN,MAAOyN,IAAKzN,IAChBwN,IAAKvN,MAAAA,CACLyN,IAAKA,EAAG,GAAA,CAAI5E,CAAG,CAAA,GACf2E,IAAKxN,MAAAA,CACL0N,IAAKA,EAAG,GAAA,CAAI7E,CAAG,CAAA,GACnBA,IAAMA,EAAI,MAAA,CAAM,GAChB0E,MAAOvN,IACPwN,MAAOxN;IAEX,OAAO;QAAE,IAAAyN;QAAI,IAAAC;IAAE;AACnB;AA2IA,SAASC,GAAYC,CAAAA,EAAO1F,CAAAA,EAAOpL,CAAAA,EAAM;IACrC,IAAIoL,GAAO;QACP,IAAIA,EAAM,KAAA,KAAU0F,GAChB,MAAM,IAAI,MAAM,gDAAgD;QACpE,OAAA3F,GAAcC,CAAK,GACZA;IACX,OAEI,OAAO7B,GAAMuH,GAAO;QAAE,MAAA9Q;IAAAA,CAAM;AAEpC;AAEO,SAAS+Q,GAAkBC,CAAAA,EAAMC,CAAAA,EAAOC,IAAY,CAAA,CAAA,EAAIC,CAAAA,EAAQ;IAGnE,IAFIA,MAAW,KAAA,KAAA,CACXA,IAASH,MAAS,SAAA,GAClB,CAACC,KAAS,OAAOA,KAAU,UAC3B,MAAM,IAAI,MAAM,CAAA,eAAA,EAAkBD,CAAI,CAAA,aAAA,CAAe;IACzD,KAAA,MAAWxF,KAAK;QAAC;QAAK;QAAK,GAAG;KAAA,CAAG;QAC7B,MAAM3E,IAAMoK,CAAAA,CAAMzF,CAAC,CAAA;QACnB,IAAI,CAAA,CAAE,OAAO3E,KAAQ,YAAYA,IAAM5D,EAAAA,GACnC,MAAM,IAAI,MAAM,CAAA,MAAA,EAASuI,CAAC,CAAA,wBAAA,CAA0B;IAC5D;IACA,MAAM5C,IAAKiI,GAAYI,EAAM,CAAA,EAAGC,EAAU,EAAA,EAAIC,CAAM,GAC9CC,IAAKP,GAAYI,EAAM,CAAA,EAAGC,EAAU,EAAA,EAAIC,CAAM,GAE9CE,IAAS;QAAC;QAAM;QAAM;QADQ,GACD;KAAA;IACnC,KAAA,MAAW7F,KAAK6F,EAEZ,IAAI,CAACzI,EAAG,OAAA,CAAQqI,CAAAA,CAAMzF,CAAC,CAAC,GACpB,MAAM,IAAI,MAAM,CAAA,MAAA,EAASA,CAAC,CAAA,wCAAA,CAA0C;IAE5E,OAAAyF,IAAQ,OAAO,MAAA,CAAO,OAAO,MAAA,CAAO,CAAA,GAAIA,CAAK,CAAC,GACvC;QAAE,OAAAA;QAAO,IAAArI;QAAI,IAAAwI;IAAE;AAC1B;AACO,SAASE,GAAaC,CAAAA,EAAiBC,CAAAA,EAAc;IACxD,OAAO,SAAgBvL,CAAAA,EAAM;QACzB,MAAMwL,IAAYF,EAAgBtL,CAAI;QACtC,OAAO;YAAE,WAAAwL;YAAW,WAAWD,EAAaC,CAAS;QAAC;IAC1D;AACJ;ACjcO,MAAMC,GAAM;IAOf,YAAYC,CAAAA,EAAM/D,CAAAA,CAAK;QANvB3N,EAAA,IAAA,EAAA;QACAA,EAAA,IAAA,EAAA;QACAA,EAAA,IAAA,EAAA;QACAA,EAAA,IAAA,EAAA;QACAA,EAAA,IAAA,EAAA,YAAW,CAAA;QACXA,EAAA,IAAA,EAAA,aAAY,CAAA;QAKR,QAHA2R,6OAAAA,EAAMD,CAAI,OACVtR,6OAAAA,EAAOuN,GAAK,KAAA,GAAW,KAAK,GAC5B,IAAA,CAAK,KAAA,GAAQ+D,EAAK,MAAA,CAAM,GACpB,OAAO,IAAA,CAAK,KAAA,CAAM,MAAA,IAAW,YAC7B,MAAM,IAAI,MAAM,qDAAqD;QACzE,IAAA,CAAK,QAAA,GAAW,IAAA,CAAK,KAAA,CAAM,QAAA,EAC3B,IAAA,CAAK,SAAA,GAAY,IAAA,CAAK,KAAA,CAAM,SAAA;QAC5B,MAAM9R,IAAW,IAAA,CAAK,QAAA,EAChBgS,IAAM,IAAI,WAAWhS,CAAQ;QAEnCgS,EAAI,GAAA,CAAIjE,EAAI,MAAA,GAAS/N,IAAW8R,EAAK,MAAA,CAAM,EAAG,MAAA,CAAO/D,CAAG,EAAE,MAAA,CAAM,IAAKA,CAAG;QACxE,IAAA,IAAS7M,IAAI,GAAGA,IAAI8Q,EAAI,MAAA,EAAQ9Q,IAC5B8Q,CAAAA,CAAI9Q,CAAC,CAAA,IAAK;QACd,IAAA,CAAK,KAAA,CAAM,MAAA,CAAO8Q,CAAG,GAErB,IAAA,CAAK,KAAA,GAAQF,EAAK,MAAA,CAAM;QAExB,IAAA,IAAS5Q,IAAI,GAAGA,IAAI8Q,EAAI,MAAA,EAAQ9Q,IAC5B8Q,CAAAA,CAAI9Q,CAAC,CAAA,IAAK;QACd,IAAA,CAAK,KAAA,CAAM,MAAA,CAAO8Q,CAAG,OACrB/Q,6OAAAA,EAAM+Q,CAAG;IACb;IACA,OAAOC,CAAAA,EAAK;QACR,OAAA1R,iPAAAA,EAAQ,IAAI,GACZ,IAAA,CAAK,KAAA,CAAM,MAAA,CAAO0R,CAAG,GACd,IAAA;IACX;IACA,WAAWlR,CAAAA,EAAK;QACZR,iPAAAA,EAAQ,IAAI,GACZC,iPAAAA,EAAOO,GAAK,IAAA,CAAK,SAAA,EAAW,QAAQ,GACpC,IAAA,CAAK,QAAA,GAAW,CAAA,GAChB,IAAA,CAAK,KAAA,CAAM,UAAA,CAAWA,CAAG,GACzB,IAAA,CAAK,KAAA,CAAM,MAAA,CAAOA,CAAG,GACrB,IAAA,CAAK,KAAA,CAAM,UAAA,CAAWA,CAAG,GACzB,IAAA,CAAK,OAAA,CAAO;IAChB;IACA,SAAS;QACL,MAAMA,IAAM,IAAI,WAAW,IAAA,CAAK,KAAA,CAAM,SAAS;QAC/C,OAAA,IAAA,CAAK,UAAA,CAAWA,CAAG,GACZA;IACX;IACA,WAAWQ,CAAAA,EAAI;QAEXA,KAAAA,CAAAA,IAAO,OAAO,MAAA,CAAO,OAAO,cAAA,CAAe,IAAI,GAAG,CAAA,CAAE,CAAA;QACpD,MAAM,EAAE,OAAA2Q,CAAAA,EAAO,OAAAC,CAAAA,EAAO,UAAA1Q,CAAAA,EAAU,WAAAC,CAAAA,EAAW,UAAA1B,CAAAA,EAAU,WAAAC,CAAAA,CAAS,CAAA,GAAK,IAAA;QACnE,OAAAsB,IAAKA,GACLA,EAAG,QAAA,GAAWE,GACdF,EAAG,SAAA,GAAYG,GACfH,EAAG,QAAA,GAAWvB,GACduB,EAAG,SAAA,GAAYtB,GACfsB,EAAG,KAAA,GAAQ2Q,EAAM,UAAA,CAAW3Q,EAAG,KAAK,GACpCA,EAAG,KAAA,GAAQ4Q,EAAM,UAAA,CAAW5Q,EAAG,KAAK,GAC7BA;IACX;IACA,QAAQ;QACJ,OAAO,IAAA,CAAK,UAAA,CAAU;IAC1B;IACA,UAAU;QACN,IAAA,CAAK,SAAA,GAAY,CAAA,GACjB,IAAA,CAAK,KAAA,CAAM,OAAA,CAAO,GAClB,IAAA,CAAK,KAAA,CAAM,OAAA,CAAO;IACtB;AACJ;AAWY,MAAC6Q,KAAO,CAACN,GAAM/D,GAAKsE,IAAY,IAAIR,GAAMC,GAAM/D,CAAG,EAAE,MAAA,CAAOsE,CAAO,EAAE,MAAA,CAAM;AACvFD,GAAK,MAAA,GAAS,CAACN,GAAM/D,IAAQ,IAAI8D,GAAMC,GAAM/D,CAAG;AC9DhD,oEAAA,GAOA,MAAMuE,KAAa,CAACxO,GAAKyO,IAAAA,CAASzO,IAAAA,CAAOA,KAAO,IAAIyO,IAAM,CAACA,CAAAA,IAAO7K,EAAAA,IAAO6K;AAIlE,SAASC,GAAiB1M,CAAAA,EAAG2M,CAAAA,EAAOxN,CAAAA,EAAG;IAI1C,MAAM,CAAC,CAACyN,GAAIC,CAAE,CAAA,EAAG,CAACC,GAAIC,CAAE,CAAC,CAAA,GAAIJ,GACvB5I,IAAKyI,GAAWO,IAAK/M,GAAGb,CAAC,GACzB6E,IAAKwI,GAAW,CAACK,IAAK7M,GAAGb,CAAC;IAGhC,IAAI2L,IAAK9K,IAAI+D,IAAK6I,IAAK5I,IAAK8I,GACxB/B,IAAK,CAAChH,IAAK8I,IAAK7I,IAAK+I;IACzB,MAAMC,IAAQlC,IAAKxN,GACb2P,IAAQlC,IAAKzN;IACf0P,KAAAA,CACAlC,IAAK,CAACA,CAAAA,GACNmC,KAAAA,CACAlC,IAAK,CAACA,CAAAA;IAGV,MAAMmC,IAAU7N,GAAQ,KAAK,IAAA,CAAKD,GAAOD,CAAC,IAAI,CAAC,CAAC,IAAI5B;IACpD,IAAIuN,IAAKxN,KAAOwN,KAAMoC,KAAWnC,IAAKzN,KAAOyN,KAAMmC,GAC/C,MAAM,IAAI,MAAM,2CAA2ClN,CAAC;IAEhE,OAAO;QAAE,OAAAgN;QAAO,IAAAlC;QAAI,OAAAmC;QAAO,IAAAlC;IAAE;AACjC;AACA,SAASoC,GAAkBC,CAAAA,EAAQ;IAC/B,IAAI,CAAC;QAAC;QAAW;QAAa,KAAK;KAAA,CAAE,QAAA,CAASA,CAAM,GAChD,MAAM,IAAI,MAAM,2DAA2D;IAC/E,OAAOA;AACX;AACA,SAASC,GAAgB1H,CAAAA,EAAM2H,CAAAA,EAAK;IAChC,MAAMC,IAAQ,CAAA;IACd,KAAA,IAASC,KAAW,OAAO,IAAA,CAAKF,CAAG,EAE/BC,CAAAA,CAAMC,CAAO,CAAA,GAAI7H,CAAAA,CAAK6H,CAAO,CAAA,KAAM,KAAA,IAAYF,CAAAA,CAAIE,CAAO,CAAA,GAAI7H,CAAAA,CAAK6H,CAAO,CAAA;IAE9E,OAAAhQ,GAAM+P,EAAM,IAAA,EAAM,MAAM,GACxB/P,GAAM+P,EAAM,OAAA,EAAS,SAAS,GAC1BA,EAAM,MAAA,KAAW,KAAA,KACjBJ,GAAkBI,EAAM,MAAM,GAC3BA;AACX;AACO,MAAME,WAAe,MAAM;IAC9B,YAAY1K,IAAI,EAAA,CAAI;QAChB,KAAA,CAAMA,CAAC;IACX;AACJ;AAQO,MAAM2K,KAAM;IAAA,2BAAA;IAEf,KAAKD;IAAA,iDAAA;IAEL,MAAM;QACF,QAAQ,CAACE,GAAKnT,MAAS;YACnB,MAAM,EAAE,KAAK6B,CAAAA,CAAC,CAAA,GAAKqR;YACnB,IAAIC,IAAM,KAAKA,IAAM,KACjB,MAAM,IAAItR,EAAE,uBAAuB;YACvC,IAAI7B,EAAK,MAAA,GAAS,GACd,MAAM,IAAI6B,EAAE,2BAA2B;YAC3C,MAAMuR,IAAUpT,EAAK,MAAA,GAAS,GACxBK,IAAMkD,GAAoB6P,CAAO;YACvC,IAAK/S,EAAI,MAAA,GAAS,IAAK,KACnB,MAAM,IAAIwB,EAAE,sCAAsC;YAEtD,MAAMwR,IAASD,IAAU,MAAM7P,GAAqBlD,EAAI,MAAA,GAAS,IAAK,GAAW,IAAI;YAErF,OADUkD,GAAoB4P,CAAG,IACtBE,IAAShT,IAAML;QAC9B;QAAA,uCAAA;QAEA,QAAOmT,CAAAA,EAAKnT,CAAAA,EAAM;YACd,MAAM,EAAE,KAAK6B,CAAAA,CAAC,CAAA,GAAKqR;YACnB,IAAI5S,IAAM;YACV,IAAI6S,IAAM,KAAKA,IAAM,KACjB,MAAM,IAAItR,EAAE,uBAAuB;YACvC,IAAI7B,EAAK,MAAA,GAAS,KAAKA,CAAAA,CAAKM,GAAK,CAAA,KAAM6S,GACnC,MAAM,IAAItR,EAAE,uBAAuB;YACvC,MAAMyR,IAAQtT,CAAAA,CAAKM,GAAK,CAAA,EAClBiT,IAAS,CAAC,CAAA,CAAED,IAAQ,GAAA;YAC1B,IAAIpS,IAAS;YACb,IAAI,CAACqS,GACDrS,IAASoS;iBACR;gBAED,MAAMD,IAASC,IAAQ;gBACvB,IAAI,CAACD,GACD,MAAM,IAAIxR,EAAE,mDAAmD;gBACnE,IAAIwR,IAAS,GACT,MAAM,IAAIxR,EAAE,0CAA0C;gBAC1D,MAAM2R,IAAcxT,EAAK,QAAA,CAASM,GAAKA,IAAM+S,CAAM;gBACnD,IAAIG,EAAY,MAAA,KAAWH,GACvB,MAAM,IAAIxR,EAAE,uCAAuC;gBACvD,IAAI2R,CAAAA,CAAY,CAAC,CAAA,KAAM,GACnB,MAAM,IAAI3R,EAAE,sCAAsC;gBACtD,KAAA,MAAWvC,KAAKkU,EACZtS,IAAUA,KAAU,IAAK5B;gBAE7B,IADAgB,KAAO+S,GACHnS,IAAS,KACT,MAAM,IAAIW,EAAE,wCAAwC;YAC5D;YACA,MAAM0D,IAAIvF,EAAK,QAAA,CAASM,GAAKA,IAAMY,CAAM;YACzC,IAAIqE,EAAE,MAAA,KAAWrE,GACb,MAAM,IAAIW,EAAE,gCAAgC;YAChD,OAAO;gBAAE,GAAA0D;gBAAG,GAAGvF,EAAK,QAAA,CAASM,IAAMY,CAAM;YAAC;QAC9C;IACR;IAAA,0FAAA;IAAA,uEAAA;IAAA,4BAAA;IAAA,qFAAA;IAKI,MAAM;QACF,QAAOsC,CAAAA,EAAK;YACR,MAAM,EAAE,KAAK3B,CAAAA,CAAC,CAAA,GAAKqR;YACnB,IAAI1P,IAAMV,GACN,MAAM,IAAIjB,EAAE,4CAA4C;YAC5D,IAAI4B,IAAMF,GAAoBC,CAAG;YAIjC,IAFI,OAAO,QAAA,CAASC,CAAAA,CAAI,CAAC,CAAA,EAAG,EAAE,IAAI,KAAA,CAC9BA,IAAM,OAAOA,CAAAA,GACbA,EAAI,MAAA,GAAS,GACb,MAAM,IAAI5B,EAAE,gDAAgD;YAChE,OAAO4B;QACX;QACA,QAAOzD,CAAAA,EAAM;YACT,MAAM,EAAE,KAAK6B,CAAAA,CAAC,CAAA,GAAKqR;YACnB,IAAIlT,CAAAA,CAAK,CAAC,CAAA,GAAI,KACV,MAAM,IAAI6B,EAAE,qCAAqC;YACrD,IAAI7B,CAAAA,CAAK,CAAC,CAAA,KAAM,KAAQ,CAAA,CAAEA,CAAAA,CAAK,CAAC,CAAA,GAAI,GAAA,GAChC,MAAM,IAAI6B,EAAE,qDAAqD;YACrE,OAAO8B,GAAgB3D,CAAI;QAC/B;IACR;IACI,OAAM4D,CAAAA,EAAO;QAET,MAAM,EAAE,KAAK/B,CAAAA,EAAG,MAAM4R,CAAAA,EAAK,MAAMC,CAAAA,CAAG,CAAA,GAAKR,IACnClT,QAAOE,6OAAAA,EAAO0D,GAAO,KAAA,GAAW,WAAW,GAC3C,EAAE,GAAG+P,CAAAA,EAAU,GAAGC,CAAAA,CAAY,CAAA,GAAKF,EAAI,MAAA,CAAO,IAAM1T,CAAI;QAC9D,IAAI4T,EAAa,MAAA,EACb,MAAM,IAAI/R,EAAE,6CAA6C;QAC7D,MAAM,EAAE,GAAGgS,CAAAA,EAAQ,GAAGC,CAAAA,CAAU,CAAA,GAAKJ,EAAI,MAAA,CAAO,GAAMC,CAAQ,GACxD,EAAE,GAAGI,CAAAA,EAAQ,GAAGC,CAAAA,CAAU,CAAA,GAAKN,EAAI,MAAA,CAAO,GAAMI,CAAU;QAChE,IAAIE,EAAW,MAAA,EACX,MAAM,IAAInS,EAAE,6CAA6C;QAC7D,OAAO;YAAE,GAAG4R,EAAI,MAAA,CAAOI,CAAM;YAAG,GAAGJ,EAAI,MAAA,CAAOM,CAAM;QAAC;IACzD;IACA,YAAWE,CAAAA,EAAK;QACZ,MAAM,EAAE,MAAMP,CAAAA,EAAK,MAAMD,CAAAA,CAAG,CAAA,GAAKP,IAC3BgB,IAAKR,EAAI,MAAA,CAAO,GAAMD,EAAI,MAAA,CAAOQ,EAAI,CAAC,CAAC,GACvCE,IAAKT,EAAI,MAAA,CAAO,GAAMD,EAAI,MAAA,CAAOQ,EAAI,CAAC,CAAC,GACvCG,IAAMF,IAAKC;QACjB,OAAOT,EAAI,MAAA,CAAO,IAAMU,CAAG;IAC/B;AACJ,GAGMtR,IAAM,OAAO,CAAC,GAAGC,KAAM,OAAO,CAAC,GAAGqE,KAAM,OAAO,CAAC,GAAGC,KAAM,OAAO,CAAC,GAAGC,KAAM,OAAO,CAAC;AAoBjF,SAAS+M,GAAYnD,CAAAA,EAAQoD,IAAY,CAAA,CAAA,EAAI;IAChD,MAAMC,IAAY3D,GAAkB,eAAeM,GAAQoD,CAAS,GAC9D,EAAE,IAAA7L,CAAAA,EAAI,IAAAwI,CAAAA,CAAE,CAAA,GAAKsD;IACnB,IAAIzD,IAAQyD,EAAU,KAAA;IACtB,MAAM,EAAE,GAAGC,CAAAA,EAAU,GAAGC,CAAAA,CAAW,CAAA,GAAK3D;IACxC5K,GAAeoO,GAAW,CAAA,GAAI;QAC1B,oBAAoB;QACpB,eAAe;QACf,eAAe;QACf,WAAW;QACX,SAAS;QACT,MAAM;IACd,CAAK;IACD,MAAM,EAAE,MAAAI,CAAAA,CAAI,CAAA,GAAKJ;IACjB,IAAII,KAAAA,CAEI,CAACjM,EAAG,GAAA,CAAIqI,EAAM,CAAC,KAAK,OAAO4D,EAAK,IAAA,IAAS,YAAY,CAAC,MAAM,OAAA,CAAQA,EAAK,OAAO,CAAA,GAChF,MAAM,IAAI,MAAM,4DAA4D;IAGpF,MAAMC,IAAUC,GAAYnM,GAAIwI,CAAE;IAClC,SAAS4D,IAA+B;QACpC,IAAI,CAACpM,EAAG,KAAA,EACJ,MAAM,IAAI,MAAM,4DAA4D;IACpF;IAEA,SAASqM,EAAaC,CAAAA,EAAIlF,CAAAA,EAAOmF,CAAAA,EAAc;QAC3C,MAAM,EAAE,GAAAjN,CAAAA,EAAG,CAAA,EAAA,GAAM8H,EAAM,QAAA,CAAQ,GACzBoF,IAAKxM,EAAG,OAAA,CAAQV,CAAC;QAEvB,IADA/E,GAAMgS,GAAc,cAAc,GAC9BA,GAAc;YACdH,EAA4B;YAC5B,MAAMK,IAAW,CAACzM,EAAG,KAAA,CAAM,CAAC;YAC5B,WAAO0M,6OAAAA,EAAYC,GAAQF,CAAQ,GAAGD,CAAE;QAC5C,OAEI,WAAOE,6OAAAA,EAAY,WAAW,EAAA,CAAG,CAAI,GAAGF,GAAIxM,EAAG,OAAA,CAAQ,CAAC,CAAC;IAEjE;IACA,SAAS4M,EAAezR,CAAAA,EAAO;YAC3B1D,6OAAAA,EAAO0D,GAAO,KAAA,GAAW,OAAO;QAChC,MAAM,EAAE,WAAWuM,CAAAA,EAAM,uBAAuBmF,CAAAA,CAAM,CAAA,GAAKX,GACrDzT,IAAS0C,EAAM,MAAA,EACf2R,IAAO3R,CAAAA,CAAM,CAAC,CAAA,EACd4R,IAAO5R,EAAM,QAAA,CAAS,CAAC;QAE7B,IAAI1C,MAAWiP,KAAAA,CAASoF,MAAS,KAAQA,MAAS,CAAA,GAAO;YACrD,MAAMxN,IAAIU,EAAG,SAAA,CAAU+M,CAAI;YAC3B,IAAI,CAAC/M,EAAG,OAAA,CAAQV,CAAC,GACb,MAAM,IAAI,MAAM,qCAAqC;YACzD,MAAM0N,IAAKC,EAAoB3N,CAAC;YAChC,IAAI4N;YACJ,IAAI;gBACAA,IAAIlN,EAAG,IAAA,CAAKgN,CAAE;YAClB,EAAA,OACOG,GAAW;gBACd,MAAMC,IAAMD,aAAqB,QAAQ,OAAOA,EAAU,OAAA,GAAU;gBACpE,MAAM,IAAI,MAAM,2CAA2CC,CAAG;YAClE;YACAhB,EAA4B;YAC5B,MAAMiB,IAAQrN,EAAG,KAAA,CAAMkN,CAAC;YAExB,OAAA,CADeJ,IAAO,CAAA,MAAO,MACfO,KAAAA,CACVH,IAAIlN,EAAG,GAAA,CAAIkN,CAAC,CAAA,GACT;gBAAE,GAAA5N;gBAAG,GAAA4N;YAAC;QACjB,OAAA,IACSzU,MAAWoU,KAAUC,MAAS,GAAM;YAEzC,MAAMQ,IAAItN,EAAG,KAAA,EACP,IAAIA,EAAG,SAAA,CAAU+M,EAAK,QAAA,CAAS,GAAGO,CAAC,CAAC,GACpCJ,IAAIlN,EAAG,SAAA,CAAU+M,EAAK,QAAA,CAASO,GAAGA,IAAI,CAAC,CAAC;YAC9C,IAAI,CAACC,EAAU,GAAGL,CAAC,GACf,MAAM,IAAI,MAAM,4BAA4B;YAChD,OAAO;gBAAE;gBAAG,GAAAA;YAAC;QACjB,OAEI,MAAM,IAAI,MAAM,CAAA,sBAAA,EAAyBzU,CAAM,CAAA,sBAAA,EAAyBiP,CAAI,CAAA,iBAAA,EAAoBmF,CAAM,EAAE;IAEhH;IACA,MAAMW,IAAc3B,EAAU,OAAA,IAAWQ,GACnCoB,IAAc5B,EAAU,SAAA,IAAae;IAC3C,SAASK,EAAoB3N,CAAAA,EAAG;QAC5B,MAAMoO,IAAK1N,EAAG,GAAA,CAAIV,CAAC,GACbqO,IAAK3N,EAAG,GAAA,CAAI0N,GAAIpO,CAAC;QACvB,OAAOU,EAAG,GAAA,CAAIA,EAAG,GAAA,CAAI2N,GAAI3N,EAAG,GAAA,CAAIV,GAAG+I,EAAM,CAAC,CAAC,GAAGA,EAAM,CAAC;IACzD;IAGA,SAASkF,EAAUjO,CAAAA,EAAG4N,CAAAA,EAAG;QACrB,MAAMU,IAAO5N,EAAG,GAAA,CAAIkN,CAAC,GACfW,IAAQZ,EAAoB3N,CAAC;QACnC,OAAOU,EAAG,GAAA,CAAI4N,GAAMC,CAAK;IAC7B;IAGA,IAAI,CAACN,EAAUlF,EAAM,EAAA,EAAIA,EAAM,EAAE,GAC7B,MAAM,IAAI,MAAM,mCAAmC;IAGvD,MAAMyF,IAAO9N,EAAG,GAAA,CAAIA,EAAG,GAAA,CAAIqI,EAAM,CAAA,EAAGzJ,EAAG,GAAGC,EAAG,GACvCkP,IAAQ/N,EAAG,GAAA,CAAIA,EAAG,GAAA,CAAIqI,EAAM,CAAC,GAAG,OAAO,EAAE,CAAC;IAChD,IAAIrI,EAAG,GAAA,CAAIA,EAAG,GAAA,CAAI8N,GAAMC,CAAK,CAAC,GAC1B,MAAM,IAAI,MAAM,0BAA0B;IAE9C,SAASC,EAAOvT,CAAAA,EAAOyB,CAAAA,EAAG+R,IAAU,CAAA,CAAA,EAAO;QACvC,IAAI,CAACjO,EAAG,OAAA,CAAQ9D,CAAC,KAAM+R,KAAWjO,EAAG,GAAA,CAAI9D,CAAC,GACtC,MAAM,IAAI,MAAM,CAAA,qBAAA,EAAwBzB,CAAK,EAAE;QACnD,OAAOyB;IACX;IACA,SAASgS,EAAUC,CAAAA,EAAO;QACtB,IAAI,CAAA,CAAEA,aAAiBjH,CAAAA,GACnB,MAAM,IAAI,MAAM,4BAA4B;IACpD;IACA,SAASkH,GAAiBrR,CAAAA,EAAG;QACzB,IAAI,CAACkP,KAAQ,CAACA,EAAK,OAAA,EACf,MAAM,IAAI,MAAM,SAAS;QAC7B,OAAOxC,GAAiB1M,GAAGkP,EAAK,OAAA,EAASzD,EAAG,KAAK;IACrD;IAKA,MAAM6F,IAAehQ,GAAS,CAACuE,GAAG0L,MAAO;QACrC,MAAM,EAAE,GAAAC,CAAAA,EAAG,GAAAC,CAAAA,EAAG,GAAA7M,CAAAA,CAAC,CAAA,GAAKiB;QAEpB,IAAI5C,EAAG,GAAA,CAAI2B,GAAG3B,EAAG,GAAG,GAChB,OAAO;YAAE,GAAGuO;YAAG,GAAGC;QAAC;QACvB,MAAMC,IAAM7L,EAAE,GAAA,CAAG;QAGb0L,KAAM,QAAA,CACNA,IAAKG,IAAMzO,EAAG,GAAA,GAAMA,EAAG,GAAA,CAAI2B,CAAC,CAAA;QAChC,MAAMrC,IAAIU,EAAG,GAAA,CAAIuO,GAAGD,CAAE,GAChBpB,IAAIlN,EAAG,GAAA,CAAIwO,GAAGF,CAAE,GAChBI,IAAK1O,EAAG,GAAA,CAAI2B,GAAG2M,CAAE;QACvB,IAAIG,GACA,OAAO;YAAE,GAAGzO,EAAG,IAAA;YAAM,GAAGA,EAAG,IAAA;QAAI;QACnC,IAAI,CAACA,EAAG,GAAA,CAAI0O,GAAI1O,EAAG,GAAG,GAClB,MAAM,IAAI,MAAM,kBAAkB;QACtC,OAAO;YAAE,GAAAV;YAAG,GAAA4N;QAAC;IACjB,CAAC,GAGKyB,KAAkBtQ,GAAS,CAACuE,MAAM;QACpC,IAAIA,EAAE,GAAA,IAAO;YAIT,IAAIiJ,EAAU,kBAAA,IAAsB,CAAC7L,EAAG,GAAA,CAAI4C,EAAE,CAAC,GAC3C;YACJ,MAAM,IAAI,MAAM,iBAAiB;QACrC;QAEA,MAAM,EAAE,GAAAtD,CAAAA,EAAG,GAAA4N,CAAAA,EAAAA,GAAMtK,EAAE,QAAA,CAAQ;QAC3B,IAAI,CAAC5C,EAAG,OAAA,CAAQV,CAAC,KAAK,CAACU,EAAG,OAAA,CAAQkN,CAAC,GAC/B,MAAM,IAAI,MAAM,sCAAsC;QAC1D,IAAI,CAACK,EAAUjO,GAAG4N,CAAC,GACf,MAAM,IAAI,MAAM,mCAAmC;QACvD,IAAI,CAACtK,EAAE,aAAA,CAAa,GAChB,MAAM,IAAI,MAAM,wCAAwC;QAC5D,OAAO,CAAA;IACX,CAAC;IACD,SAASgM,GAAWC,CAAAA,EAAUC,CAAAA,EAAKC,CAAAA,EAAKhF,CAAAA,EAAOC,CAAAA,EAAO;QAClD,OAAA+E,IAAM,IAAI7H,EAAMlH,EAAG,GAAA,CAAI+O,EAAI,CAAA,EAAGF,CAAQ,GAAGE,EAAI,CAAA,EAAGA,EAAI,CAAC,GACrDD,IAAM1J,GAAS2E,GAAO+E,CAAG,GACzBC,IAAM3J,GAAS4E,GAAO+E,CAAG,GAClBD,EAAI,GAAA,CAAIC,CAAG;IACtB;IAMA,MAAMC,IAAN,MAAMA,EAAM;QAAA,sEAAA,GAaR,YAAYT,CAAAA,EAAGC,CAAAA,EAAG7M,CAAAA,CAAG;YAJrBtK,EAAA,IAAA,EAAA;YACAA,EAAA,IAAA,EAAA;YACAA,EAAA,IAAA,EAAA;YAGI,IAAA,CAAK,CAAA,GAAI2W,EAAO,KAAKO,CAAC,GACtB,IAAA,CAAK,CAAA,GAAIP,EAAO,KAAKQ,GAAG,CAAA,CAAI,GAC5B,IAAA,CAAK,CAAA,GAAIR,EAAO,KAAKrM,CAAC,GACtB,OAAO,MAAA,CAAO,IAAI;QACtB;QACA,OAAO,QAAQ;YACX,OAAO0G;QACX;QAAA,sEAAA,GAEA,OAAO,WAAWzF,CAAAA,EAAG;YACjB,MAAM,EAAE,GAAAtD,CAAAA,EAAG,GAAA4N,CAAAA,CAAC,CAAA,GAAKtK,KAAK,CAAA;YACtB,IAAI,CAACA,KAAK,CAAC5C,EAAG,OAAA,CAAQV,CAAC,KAAK,CAACU,EAAG,OAAA,CAAQkN,CAAC,GACrC,MAAM,IAAI,MAAM,sBAAsB;YAC1C,IAAItK,aAAaoM,GACb,MAAM,IAAI,MAAM,8BAA8B;YAElD,OAAIhP,EAAG,GAAA,CAAIV,CAAC,KAAKU,EAAG,GAAA,CAAIkN,CAAC,IACd8B,EAAM,IAAA,GACV,IAAIA,EAAM1P,GAAG4N,GAAGlN,EAAG,GAAG;QACjC;QACA,OAAO,UAAU7E,CAAAA,EAAO;YACpB,MAAMsF,IAAIuO,EAAM,UAAA,CAAWvB,MAAYhW,6OAAAA,EAAO0D,GAAO,KAAA,GAAW,OAAO,CAAC,CAAC;YACzE,OAAAsF,EAAE,cAAA,CAAc,GACTA;QACX;QACA,OAAO,QAAQzF,CAAAA,EAAK;YAChB,OAAOgU,EAAM,SAAA,KAAUC,6OAAAA,EAAWjU,CAAG,CAAC;QAC1C;QACA,IAAI,IAAI;YACJ,OAAO,IAAA,CAAK,QAAA,CAAQ,EAAG,CAAA;QAC3B;QACA,IAAI,IAAI;YACJ,OAAO,IAAA,CAAK,QAAA,CAAQ,EAAG,CAAA;QAC3B;QAAA;;;;;KAAA,GAOA,WAAWgL,IAAa,CAAA,EAAGkJ,IAAS,CAAA,CAAA,EAAM;YACtC,OAAAC,GAAK,WAAA,CAAY,IAAA,EAAMnJ,CAAU,GAC5BkJ,KACD,IAAA,CAAK,QAAA,CAAStQ,EAAG,GACd,IAAA;QACX;QAAA,sBAAA;QAAA,0DAAA,GAGA,iBAAiB;YACb+P,GAAgB,IAAI;QACxB;QACA,WAAW;YACP,MAAM,EAAE,GAAAzB,CAAAA,CAAC,CAAA,GAAK,IAAA,CAAK,QAAA,CAAQ;YAC3B,IAAI,CAAClN,EAAG,KAAA,EACJ,MAAM,IAAI,MAAM,6BAA6B;YACjD,OAAO,CAACA,EAAG,KAAA,CAAMkN,CAAC;QACtB;QAAA,kCAAA,GAEA,OAAOiB,CAAAA,EAAO;YACVD,EAAUC,CAAK;YACf,MAAM,EAAE,GAAGiB,CAAAA,EAAI,GAAGC,CAAAA,EAAI,GAAGC,CAAAA,CAAE,CAAA,GAAK,IAAA,EAC1B,EAAE,GAAGC,CAAAA,EAAI,GAAGC,CAAAA,EAAI,GAAGC,CAAAA,CAAE,CAAA,GAAKtB,GAC1BuB,IAAK1P,EAAG,GAAA,CAAIA,EAAG,GAAA,CAAIoP,GAAIK,CAAE,GAAGzP,EAAG,GAAA,CAAIuP,GAAID,CAAE,CAAC,GAC1CK,IAAK3P,EAAG,GAAA,CAAIA,EAAG,GAAA,CAAIqP,GAAII,CAAE,GAAGzP,EAAG,GAAA,CAAIwP,GAAIF,CAAE,CAAC;YAChD,OAAOI,KAAMC;QACjB;QAAA,uEAAA,GAEA,SAAS;YACL,OAAO,IAAIX,EAAM,IAAA,CAAK,CAAA,EAAGhP,EAAG,GAAA,CAAI,IAAA,CAAK,CAAC,GAAG,IAAA,CAAK,CAAC;QACnD;QAAA,yDAAA;QAAA,gEAAA;QAAA,iDAAA;QAAA,sCAAA;QAKA,SAAS;YACL,MAAM,EAAE,CAAA,EAAG,GAAAnJ,CAAAA,CAAC,CAAA,GAAKwR,GACXuH,IAAK5P,EAAG,GAAA,CAAInJ,GAAG+H,EAAG,GAClB,EAAE,GAAGwQ,CAAAA,EAAI,GAAGC,CAAAA,EAAI,GAAGC,CAAAA,CAAE,CAAA,GAAK,IAAA;YAChC,IAAIO,IAAK7P,EAAG,IAAA,EAAM8P,IAAK9P,EAAG,IAAA,EAAM+P,IAAK/P,EAAG,IAAA,EACpCgQ,IAAKhQ,EAAG,GAAA,CAAIoP,GAAIA,CAAE,GAClBa,IAAKjQ,EAAG,GAAA,CAAIqP,GAAIA,CAAE,GAClBa,IAAKlQ,EAAG,GAAA,CAAIsP,GAAIA,CAAE,GAClBa,IAAKnQ,EAAG,GAAA,CAAIoP,GAAIC,CAAE;YACtB,OAAAc,IAAKnQ,EAAG,GAAA,CAAImQ,GAAIA,CAAE,GAClBJ,IAAK/P,EAAG,GAAA,CAAIoP,GAAIE,CAAE,GAClBS,IAAK/P,EAAG,GAAA,CAAI+P,GAAIA,CAAE,GAClBF,IAAK7P,EAAG,GAAA,CAAI,GAAG+P,CAAE,GACjBD,IAAK9P,EAAG,GAAA,CAAI4P,GAAIM,CAAE,GAClBJ,IAAK9P,EAAG,GAAA,CAAI6P,GAAIC,CAAE,GAClBD,IAAK7P,EAAG,GAAA,CAAIiQ,GAAIH,CAAE,GAClBA,IAAK9P,EAAG,GAAA,CAAIiQ,GAAIH,CAAE,GAClBA,IAAK9P,EAAG,GAAA,CAAI6P,GAAIC,CAAE,GAClBD,IAAK7P,EAAG,GAAA,CAAImQ,GAAIN,CAAE,GAClBE,IAAK/P,EAAG,GAAA,CAAI4P,GAAIG,CAAE,GAClBG,IAAKlQ,EAAG,GAAA,CAAI,GAAGkQ,CAAE,GACjBC,IAAKnQ,EAAG,GAAA,CAAIgQ,GAAIE,CAAE,GAClBC,IAAKnQ,EAAG,GAAA,CAAI,GAAGmQ,CAAE,GACjBA,IAAKnQ,EAAG,GAAA,CAAImQ,GAAIJ,CAAE,GAClBA,IAAK/P,EAAG,GAAA,CAAIgQ,GAAIA,CAAE,GAClBA,IAAKhQ,EAAG,GAAA,CAAI+P,GAAIC,CAAE,GAClBA,IAAKhQ,EAAG,GAAA,CAAIgQ,GAAIE,CAAE,GAClBF,IAAKhQ,EAAG,GAAA,CAAIgQ,GAAIG,CAAE,GAClBL,IAAK9P,EAAG,GAAA,CAAI8P,GAAIE,CAAE,GAClBE,IAAKlQ,EAAG,GAAA,CAAIqP,GAAIC,CAAE,GAClBY,IAAKlQ,EAAG,GAAA,CAAIkQ,GAAIA,CAAE,GAClBF,IAAKhQ,EAAG,GAAA,CAAIkQ,GAAIC,CAAE,GAClBN,IAAK7P,EAAG,GAAA,CAAI6P,GAAIG,CAAE,GAClBD,IAAK/P,EAAG,GAAA,CAAIkQ,GAAID,CAAE,GAClBF,IAAK/P,EAAG,GAAA,CAAI+P,GAAIA,CAAE,GAClBA,IAAK/P,EAAG,GAAA,CAAI+P,GAAIA,CAAE,GACX,IAAIf,EAAMa,GAAIC,GAAIC,CAAE;QAC/B;QAAA,yDAAA;QAAA,gEAAA;QAAA,iDAAA;QAAA,uCAAA;QAKA,IAAI5B,CAAAA,EAAO;YACPD,EAAUC,CAAK;YACf,MAAM,EAAE,GAAGiB,CAAAA,EAAI,GAAGC,CAAAA,EAAI,GAAGC,CAAAA,CAAE,CAAA,GAAK,IAAA,EAC1B,EAAE,GAAGC,CAAAA,EAAI,GAAGC,CAAAA,EAAI,GAAGC,CAAAA,CAAE,CAAA,GAAKtB;YAChC,IAAI0B,IAAK7P,EAAG,IAAA,EAAM8P,IAAK9P,EAAG,IAAA,EAAM+P,IAAK/P,EAAG,IAAA;YACxC,MAAMpJ,IAAIyR,EAAM,CAAA,EACVuH,IAAK5P,EAAG,GAAA,CAAIqI,EAAM,CAAA,EAAGzJ,EAAG;YAC9B,IAAIoR,IAAKhQ,EAAG,GAAA,CAAIoP,GAAIG,CAAE,GAClBU,IAAKjQ,EAAG,GAAA,CAAIqP,GAAIG,CAAE,GAClBU,IAAKlQ,EAAG,GAAA,CAAIsP,GAAIG,CAAE,GAClBU,IAAKnQ,EAAG,GAAA,CAAIoP,GAAIC,CAAE,GAClBe,IAAKpQ,EAAG,GAAA,CAAIuP,GAAIC,CAAE;YACtBW,IAAKnQ,EAAG,GAAA,CAAImQ,GAAIC,CAAE,GAClBA,IAAKpQ,EAAG,GAAA,CAAIgQ,GAAIC,CAAE,GAClBE,IAAKnQ,EAAG,GAAA,CAAImQ,GAAIC,CAAE,GAClBA,IAAKpQ,EAAG,GAAA,CAAIoP,GAAIE,CAAE;YAClB,IAAIe,IAAKrQ,EAAG,GAAA,CAAIuP,GAAIE,CAAE;YACtB,OAAAW,IAAKpQ,EAAG,GAAA,CAAIoQ,GAAIC,CAAE,GAClBA,IAAKrQ,EAAG,GAAA,CAAIgQ,GAAIE,CAAE,GAClBE,IAAKpQ,EAAG,GAAA,CAAIoQ,GAAIC,CAAE,GAClBA,IAAKrQ,EAAG,GAAA,CAAIqP,GAAIC,CAAE,GAClBO,IAAK7P,EAAG,GAAA,CAAIwP,GAAIC,CAAE,GAClBY,IAAKrQ,EAAG,GAAA,CAAIqQ,GAAIR,CAAE,GAClBA,IAAK7P,EAAG,GAAA,CAAIiQ,GAAIC,CAAE,GAClBG,IAAKrQ,EAAG,GAAA,CAAIqQ,GAAIR,CAAE,GAClBE,IAAK/P,EAAG,GAAA,CAAIpJ,GAAGwZ,CAAE,GACjBP,IAAK7P,EAAG,GAAA,CAAI4P,GAAIM,CAAE,GAClBH,IAAK/P,EAAG,GAAA,CAAI6P,GAAIE,CAAE,GAClBF,IAAK7P,EAAG,GAAA,CAAIiQ,GAAIF,CAAE,GAClBA,IAAK/P,EAAG,GAAA,CAAIiQ,GAAIF,CAAE,GAClBD,IAAK9P,EAAG,GAAA,CAAI6P,GAAIE,CAAE,GAClBE,IAAKjQ,EAAG,GAAA,CAAIgQ,GAAIA,CAAE,GAClBC,IAAKjQ,EAAG,GAAA,CAAIiQ,GAAID,CAAE,GAClBE,IAAKlQ,EAAG,GAAA,CAAIpJ,GAAGsZ,CAAE,GACjBE,IAAKpQ,EAAG,GAAA,CAAI4P,GAAIQ,CAAE,GAClBH,IAAKjQ,EAAG,GAAA,CAAIiQ,GAAIC,CAAE,GAClBA,IAAKlQ,EAAG,GAAA,CAAIgQ,GAAIE,CAAE,GAClBA,IAAKlQ,EAAG,GAAA,CAAIpJ,GAAGsZ,CAAE,GACjBE,IAAKpQ,EAAG,GAAA,CAAIoQ,GAAIF,CAAE,GAClBF,IAAKhQ,EAAG,GAAA,CAAIiQ,GAAIG,CAAE,GAClBN,IAAK9P,EAAG,GAAA,CAAI8P,GAAIE,CAAE,GAClBA,IAAKhQ,EAAG,GAAA,CAAIqQ,GAAID,CAAE,GAClBP,IAAK7P,EAAG,GAAA,CAAImQ,GAAIN,CAAE,GAClBA,IAAK7P,EAAG,GAAA,CAAI6P,GAAIG,CAAE,GAClBA,IAAKhQ,EAAG,GAAA,CAAImQ,GAAIF,CAAE,GAClBF,IAAK/P,EAAG,GAAA,CAAIqQ,GAAIN,CAAE,GAClBA,IAAK/P,EAAG,GAAA,CAAI+P,GAAIC,CAAE,GACX,IAAIhB,EAAMa,GAAIC,GAAIC,CAAE;QAC/B;QACA,SAAS5B,CAAAA,EAAO;YACZ,OAAO,IAAA,CAAK,GAAA,CAAIA,EAAM,MAAA,CAAM,CAAE;QAClC;QACA,MAAM;YACF,OAAO,IAAA,CAAK,MAAA,CAAOa,EAAM,IAAI;QACjC;QAAA;;;;;;;;KAAA,GAUA,SAASxK,CAAAA,EAAQ;YACb,MAAM,EAAE,MAAAyH,CAAAA,CAAI,CAAA,GAAKJ;YACjB,IAAI,CAACrD,EAAG,WAAA,CAAYhE,CAAM,GACtB,MAAM,IAAI,MAAM,8BAA8B;YAClD,IAAI4C,GAAOkJ;YACX,MAAMC,IAAM,CAACrU,IAAMiT,GAAK,MAAA,CAAO,IAAA,EAAMjT,GAAG,CAAC0G,IAAM2C,GAAWyJ,GAAOpM,CAAC,CAAC;YAEnE,IAAIqJ,GAAM;gBACN,MAAM,EAAE,OAAAlC,CAAAA,EAAO,IAAAlC,CAAAA,EAAI,OAAAmC,CAAAA,EAAO,IAAAlC,CAAAA,CAAE,CAAA,GAAKsG,GAAiB5J,CAAM,GAClD,EAAE,GAAGsK,CAAAA,EAAK,GAAG0B,CAAAA,CAAG,CAAA,GAAKD,EAAI1I,CAAE,GAC3B,EAAE,GAAGkH,CAAAA,EAAK,GAAG0B,CAAAA,CAAG,CAAA,GAAKF,EAAIzI,CAAE;gBACjCwI,IAAOE,EAAI,GAAA,CAAIC,CAAG,GAClBrJ,IAAQwH,GAAW3C,EAAK,IAAA,EAAM6C,GAAKC,GAAKhF,GAAOC,CAAK;YACxD,OACK;gBACD,MAAM,EAAE,GAAApH,CAAAA,EAAG,GAAAxE,CAAAA,EAAAA,GAAMmS,EAAI/L,CAAM;gBAC3B4C,IAAQxE,GACR0N,IAAOlS;YACX;YAEA,OAAOmH,GAAWyJ,GAAO;gBAAC5H;gBAAOkJ,CAAI;aAAC,CAAA,CAAE,CAAC,CAAA;QAC7C;QAAA;;;;KAAA,GAMA,eAAeI,CAAAA,EAAI;YACf,MAAM,EAAE,MAAAzE,CAAAA,CAAI,CAAA,GAAKJ,GACXjJ,IAAI,IAAA;YACV,IAAI,CAAC4F,EAAG,OAAA,CAAQkI,CAAE,GACd,MAAM,IAAI,MAAM,8BAA8B;YAClD,IAAIA,MAAOrW,KAAOuI,EAAE,GAAA,CAAG,GACnB,OAAOoM,EAAM,IAAA;YACjB,IAAI0B,MAAOpW,IACP,OAAOsI;YACX,IAAIuM,GAAK,QAAA,CAAS,IAAI,GAClB,OAAO,IAAA,CAAK,QAAA,CAASuB,CAAE;YAG3B,IAAIzE,GAAM;gBACN,MAAM,EAAE,OAAAlC,CAAAA,EAAO,IAAAlC,CAAAA,EAAI,OAAAmC,CAAAA,EAAO,IAAAlC,CAAAA,CAAE,CAAA,GAAKsG,GAAiBsC,CAAE,GAC9C,EAAE,IAAA3I,CAAAA,EAAI,IAAAC,CAAAA,EAAAA,GAAOJ,GAAcoH,GAAOpM,GAAGiF,GAAIC,CAAE;gBACjD,OAAO8G,GAAW3C,EAAK,IAAA,EAAMlE,GAAIC,GAAI+B,GAAOC,CAAK;YACrD,OAEI,OAAOmF,GAAK,MAAA,CAAOvM,GAAG8N,CAAE;QAEhC;QAAA;;;KAAA,GAKA,SAASC,CAAAA,EAAW;YAChB,OAAOtC,EAAa,IAAA,EAAMsC,CAAS;QACvC;QAAA;;;KAAA,GAKA,gBAAgB;YACZ,MAAM,EAAE,eAAAC,CAAAA,CAAa,CAAA,GAAK/E;YAC1B,OAAIE,MAAazR,KACN,CAAA,IACPsW,IACOA,EAAc5B,GAAO,IAAI,IAC7BG,GAAK,MAAA,CAAO,IAAA,EAAMnD,CAAW,EAAE,GAAA,CAAG;QAC7C;QACA,gBAAgB;YACZ,MAAM,EAAE,eAAA6E,CAAAA,CAAa,CAAA,GAAKhF;YAC1B,OAAIE,MAAazR,KACN,IAAA,GACPuW,IACOA,EAAc7B,GAAO,IAAI,IAC7B,IAAA,CAAK,cAAA,CAAejD,CAAQ;QACvC;QACA,eAAe;YAEX,OAAO,IAAA,CAAK,cAAA,CAAeA,CAAQ,EAAE,GAAA,CAAG;QAC5C;QACA,QAAQQ,IAAe,CAAA,CAAA,EAAM;YACzB,OAAAhS,GAAMgS,GAAc,cAAc,GAClC,IAAA,CAAK,cAAA,CAAc,GACZiB,EAAYwB,GAAO,IAAA,EAAMzC,CAAY;QAChD;QACA,MAAMA,IAAe,CAAA,CAAA,EAAM;YACvB,WAAOuE,6OAAAA,EAAW,IAAA,CAAK,OAAA,CAAQvE,CAAY,CAAC;QAChD;QACA,WAAW;YACP,OAAO,CAAA,OAAA,EAAU,IAAA,CAAK,GAAA,CAAG,IAAK,SAAS,IAAA,CAAK,KAAA,CAAK,CAAE,CAAA,CAAA,CAAA;QACvD;IACR;IA3RQ,yBAAA;IAAAlV,EAFE2X,GAEK,QAAO,IAAIA,EAAM3G,EAAM,EAAA,EAAIA,EAAM,EAAA,EAAIrI,EAAG,GAAG,IAElD3I,EAJE2X,GAIK,QAAO,IAAIA,EAAMhP,EAAG,IAAA,EAAMA,EAAG,GAAA,EAAKA,EAAG,IAAI,IAAA,aAAA;IAEhD3I,EANE2X,GAMK,MAAKhP,IAEZ3I,EARE2X,GAQK,MAAKxG;IARhB,IAAMtB,IAAN8H;IA8RA,MAAMpJ,KAAO4C,EAAG,IAAA,EACV2G,KAAO,IAAIlI,GAAKC,GAAO2E,EAAU,IAAA,GAAO,KAAK,IAAA,CAAKjG,KAAO,CAAC,IAAIA,EAAI;IACxE,OAAAsB,EAAM,IAAA,CAAK,UAAA,CAAW,CAAC,GAChBA;AACX;AAEA,SAASyF,GAAQF,CAAAA,EAAU;IACvB,OAAO,WAAW,EAAA,CAAGA,IAAW,IAAO,CAAI;AAC/C;AA6HA,SAASN,GAAYnM,CAAAA,EAAIwI,CAAAA,EAAI;IACzB,OAAO;QACH,WAAWA,EAAG,KAAA;QACd,WAAW,IAAIxI,EAAG,KAAA;QAClB,uBAAuB,IAAI,IAAIA,EAAG,KAAA;QAClC,oBAAoB,CAAA;QACpB,WAAW,IAAIwI,EAAG,KAAA;IAC1B;AACA;AAKO,SAASuI,GAAK7J,CAAAA,EAAO8J,IAAW,CAAA,CAAA,EAAI;IACvC,MAAM,EAAE,IAAAxI,CAAAA,CAAE,CAAA,GAAKtB,GACT+J,IAAeD,EAAS,WAAA,IAAeE,6OAAAA,EACvChF,IAAU,OAAO,MAAA,CAAOC,GAAYjF,EAAM,EAAA,EAAIsB,CAAE,GAAG;QAAE,MAAM1D,GAAiB0D,EAAG,KAAK;IAAC,CAAE;IAC7F,SAAS2I,EAAiBtI,CAAAA,EAAW;QACjC,IAAI;YACA,MAAM9N,IAAMyN,EAAG,SAAA,CAAUK,CAAS;YAClC,OAAOL,EAAG,WAAA,CAAYzN,CAAG;QAC7B,EAAA,OACc;YACV,OAAO,CAAA;QACX;IACJ;IACA,SAASqW,EAAiBC,CAAAA,EAAW9E,CAAAA,EAAc;QAC/C,MAAM,EAAE,WAAW7E,CAAAA,EAAM,uBAAA4J,CAAAA,CAAqB,CAAA,GAAKpF;QACnD,IAAI;YACA,MAAMqF,IAAIF,EAAU,MAAA;YAGpB,OAFI9E,MAAiB,CAAA,KAAQgF,MAAM7J,KAE/B6E,MAAiB,CAAA,KAASgF,MAAMD,IACzB,CAAA,IACJ,CAAC,CAACpK,EAAM,SAAA,CAAUmK,CAAS;QACtC,EAAA,OACc;YACV,OAAO,CAAA;QACX;IACJ;IAKA,SAAS1I,EAAgBtL,IAAO4T,EAAa/E,EAAQ,IAAI,CAAA,EAAG;QACxD,OAAOnH,OAAetN,6OAAAA,EAAO4F,GAAM6O,EAAQ,IAAA,EAAM,MAAM,GAAG1D,EAAG,KAAK;IACtE;IAMA,SAASI,EAAaC,CAAAA,EAAW0D,IAAe,CAAA,CAAA,EAAM;QAClD,OAAOrF,EAAM,IAAA,CAAK,QAAA,CAASsB,EAAG,SAAA,CAAUK,CAAS,CAAC,EAAE,OAAA,CAAQ0D,CAAY;IAC5E;IAIA,SAASiF,EAAUnM,CAAAA,EAAM;QACrB,MAAM,EAAE,WAAAwD,CAAAA,EAAW,WAAAwI,CAAAA,EAAW,uBAAAC,CAAAA,CAAqB,CAAA,GAAKpF;QAGxD,IAFI,KAACuF,6OAAAA,EAAQpM,CAAI,KAEZ,cAAcmD,KAAMA,EAAG,QAAA,IAAaK,MAAcwI,GACnD;QACJ,MAAME,QAAI9Z,6OAAAA,EAAO4N,GAAM,KAAA,GAAW,KAAK,EAAE,MAAA;QACzC,OAAOkM,MAAMF,KAAaE,MAAMD;IACpC;IASA,SAASI,EAAgBC,CAAAA,EAAYC,CAAAA,EAAYrF,IAAe,CAAA,CAAA,EAAM;QAClE,IAAIiF,EAAUG,CAAU,MAAM,CAAA,GAC1B,MAAM,IAAI,MAAM,+BAA+B;QACnD,IAAIH,EAAUI,CAAU,MAAM,CAAA,GAC1B,MAAM,IAAI,MAAM,+BAA+B;QACnD,MAAMC,IAAIrJ,EAAG,SAAA,CAAUmJ,CAAU;QAEjC,OADUzK,EAAM,SAAA,CAAU0K,CAAU,EAC3B,QAAA,CAASC,CAAC,EAAE,OAAA,CAAQtF,CAAY;IAC7C;IACA,MAAMuF,IAAQ;QACV,kBAAAX;QACA,kBAAAC;QACA,iBAAAzI;IACR,GACUoJ,IAASrJ,GAAaC,GAAiBC,CAAY;IACzD,OAAO,OAAO,MAAA,CAAO;QAAE,cAAAA;QAAc,iBAAA8I;QAAiB,QAAAK;QAAQ,OAAA7K;QAAO,OAAA4K;QAAO,SAAA5F;IAAAA,CAAS;AACzF;AAgBO,SAAS8F,GAAM9K,CAAAA,EAAO6B,CAAAA,EAAMkJ,IAAY,CAAA,CAAA,EAAI;QAC/CjJ,6OAAAA,EAAMD,CAAI,GACVtL,GAAewU,GAAW,CAAA,GAAI;QAC1B,MAAM;QACN,MAAM;QACN,aAAa;QACb,UAAU;QACV,eAAe;IACvB,CAAK,GACDA,IAAY,OAAO,MAAA,CAAO,CAAA,GAAIA,CAAS;IACvC,MAAMC,IAAcD,EAAU,WAAA,IAAef,6OAAAA,EACvC7H,IAAO4I,EAAU,IAAA,IAAA,CAAS,CAACjN,GAAKmN,IAAQC,GAAUrJ,GAAM/D,GAAKmN,CAAG,CAAA,GAChE,EAAE,IAAAnS,CAAAA,EAAI,IAAAwI,CAAAA,CAAE,CAAA,GAAKtB,GACb,EAAE,OAAO8E,CAAAA,EAAa,MAAMqG,CAAAA,CAAM,CAAA,GAAK7J,GACvC,EAAE,QAAAuJ,CAAAA,EAAQ,cAAAnJ,CAAAA,EAAc,iBAAA8I,CAAAA,EAAiB,OAAAI,CAAAA,EAAO,SAAA5F,CAAAA,EAAAA,GAAY6E,GAAK7J,GAAO+K,CAAS,GACjFK,IAAiB;QACnB,SAAS,CAAA;QACT,MAAM,OAAOL,EAAU,IAAA,IAAS,YAAYA,EAAU,IAAA,GAAO,CAAA;QAC7D,QAAQ;QACR,cAAc,CAAA;IACtB,GACUM,IAAmBvG,IAAcrN,KAAMqB,EAAG,KAAA;IAChD,SAASwS,EAAsB9S,CAAAA,EAAQ;QACnC,MAAM+S,IAAOzG,KAAe1R;QAC5B,OAAOoF,IAAS+S;IACpB;IACA,SAASC,EAAWjY,CAAAA,EAAOM,CAAAA,EAAK;QAC5B,IAAI,CAACyN,EAAG,WAAA,CAAYzN,CAAG,GACnB,MAAM,IAAI,MAAM,CAAA,kBAAA,EAAqBN,CAAK,CAAA,gCAAA,CAAkC;QAChF,OAAOM;IACX;IACA,SAAS4X,IAAsB;QAS3B,IAAIJ,GACA,MAAM,IAAI,MAAM,8DAA8D;IACtF;IACA,SAASK,EAAkBzX,CAAAA,EAAOgP,CAAAA,EAAQ;QACtCD,GAAkBC,CAAM;QACxB,MAAM0I,IAAO3G,EAAQ,SAAA,EACf4G,IAAQ3I,MAAW,YAAY0I,IAAO1I,MAAW,cAAc0I,IAAO,IAAI,KAAA;QAChF,WAAOpb,6OAAAA,EAAO0D,GAAO2X,CAAK;IAC9B;IAIA,MAAMC,EAAU;QAIZ,YAAYlT,CAAAA,EAAGgS,CAAAA,EAAGmB,CAAAA,CAAU;YAH5B3b,EAAA,IAAA,EAAA;YACAA,EAAA,IAAA,EAAA;YACAA,EAAA,IAAA,EAAA;YAII,IAFA,IAAA,CAAK,CAAA,GAAIqb,EAAW,KAAK7S,CAAC,GAC1B,IAAA,CAAK,CAAA,GAAI6S,EAAW,KAAKb,CAAC,GACtBmB,KAAY,MAAM;gBAElB,IADAL,EAAmB,GACf,CAAC;oBAAC;oBAAG;oBAAG;oBAAG,CAAC;iBAAA,CAAE,QAAA,CAASK,CAAQ,GAC/B,MAAM,IAAI,MAAM,qBAAqB;gBACzC,IAAA,CAAK,QAAA,GAAWA;YACpB;YACA,OAAO,MAAA,CAAO,IAAI;QACtB;QACA,OAAO,UAAU7X,CAAAA,EAAOgP,IAASmI,EAAe,MAAA,EAAQ;YACpDM,EAAkBzX,GAAOgP,CAAM;YAC/B,IAAI8I;YACJ,IAAI9I,MAAW,OAAO;gBAClB,MAAM,EAAE,GAAAtK,CAAAA,EAAG,GAAAgS,CAAAA,CAAC,CAAA,GAAKpH,GAAI,KAAA,CAAMhT,iPAAAA,EAAO0D,CAAK,CAAC;gBACxC,OAAO,IAAI4X,EAAUlT,GAAGgS,CAAC;YAC7B;YACI1H,MAAW,eAAA,CACX8I,IAAQ9X,CAAAA,CAAM,CAAC,CAAA,EACfgP,IAAS,WACThP,IAAQA,EAAM,QAAA,CAAS,CAAC,CAAA;YAE5B,MAAMmS,IAAIpB,EAAQ,SAAA,GAAY,GACxBrM,IAAI1E,EAAM,QAAA,CAAS,GAAGmS,CAAC,GACvBuE,IAAI1W,EAAM,QAAA,CAASmS,GAAGA,IAAI,CAAC;YACjC,OAAO,IAAIyF,EAAUvK,EAAG,SAAA,CAAU3I,CAAC,GAAG2I,EAAG,SAAA,CAAUqJ,CAAC,GAAGoB,CAAK;QAChE;QACA,OAAO,QAAQjY,CAAAA,EAAKmP,CAAAA,EAAQ;YACxB,OAAO,IAAA,CAAK,SAAA,KAAU8E,6OAAAA,EAAWjU,CAAG,GAAGmP,CAAM;QACjD;QACA,iBAAiB;YACb,MAAM,EAAE,UAAA6I,CAAAA,CAAQ,CAAA,GAAK,IAAA;YACrB,IAAIA,KAAY,MACZ,MAAM,IAAI,MAAM,sCAAsC;YAC1D,OAAOA;QACX;QACA,eAAeA,CAAAA,EAAU;YACrB,OAAO,IAAID,EAAU,IAAA,CAAK,CAAA,EAAG,IAAA,CAAK,CAAA,EAAGC,CAAQ;QACjD;QACA,iBAAiBE,CAAAA,EAAa;YAC1B,MAAM,EAAE,GAAArT,CAAAA,EAAG,GAAAgS,CAAAA,CAAC,CAAA,GAAK,IAAA,EACXmB,IAAW,IAAA,CAAK,cAAA,CAAc,GAC9BG,IAAOH,MAAa,KAAKA,MAAa,IAAInT,IAAImM,IAAcnM;YAClE,IAAI,CAACG,EAAG,OAAA,CAAQmT,CAAI,GAChB,MAAM,IAAI,MAAM,2CAA2C;YAC/D,MAAM,IAAInT,EAAG,OAAA,CAAQmT,CAAI,GACnBjR,IAAIgF,EAAM,SAAA,KAAUwF,6OAAAA,EAAYC,GAAAA,CAASqG,IAAW,CAAA,MAAO,CAAC,GAAG,CAAC,CAAC,GACjEI,IAAK5K,EAAG,GAAA,CAAI2K,CAAI,GAChBlW,IAAIoW,EAAc5b,iPAAAA,EAAOyb,GAAa,KAAA,GAAW,SAAS,CAAC,GAC3DI,IAAK9K,EAAG,MAAA,CAAO,CAACvL,IAAImW,CAAE,GACtBG,IAAK/K,EAAG,MAAA,CAAOqJ,IAAIuB,CAAE,GAErB3R,IAAIyF,EAAM,IAAA,CAAK,cAAA,CAAeoM,CAAE,EAAE,GAAA,CAAIpR,EAAE,cAAA,CAAeqR,CAAE,CAAC;YAChE,IAAI9R,EAAE,GAAA,CAAG,GACL,MAAM,IAAI,MAAM,qCAAqC;YACzD,OAAAA,EAAE,cAAA,CAAc,GACTA;QACX;QAAA,uDAAA;QAEA,WAAW;YACP,OAAO+Q,EAAsB,IAAA,CAAK,CAAC;QACvC;QACA,QAAQrI,IAASmI,EAAe,MAAA,EAAQ;YAEpC,IADApI,GAAkBC,CAAM,GACpBA,MAAW,OACX,WAAO8E,6OAAAA,EAAWxE,GAAI,UAAA,CAAW,IAAI,CAAC;YAC1C,MAAM,EAAE,GAAA5K,CAAAA,EAAG,GAAAgS,CAAAA,CAAC,CAAA,GAAK,IAAA,EACX2B,IAAKhL,EAAG,OAAA,CAAQ3I,CAAC,GACjB4T,IAAKjL,EAAG,OAAA,CAAQqJ,CAAC;YACvB,OAAI1H,MAAW,cAAA,CACXwI,EAAmB,OACZjG,6OAAAA,EAAY,WAAW,EAAA,CAAG,IAAA,CAAK,cAAA,EAAgB,GAAG8G,GAAIC,CAAE,CAAA,IAE5D/G,iPAAAA,EAAY8G,GAAIC,CAAE;QAC7B;QACA,MAAMtJ,CAAAA,EAAQ;YACV,WAAO2G,6OAAAA,EAAW,IAAA,CAAK,OAAA,CAAQ3G,CAAM,CAAC;QAC1C;IACR;IAKI,MAAMuJ,KAAWzB,EAAU,QAAA,IACvB,SAAsB9W,CAAAA,EAAO;QAEzB,IAAIA,EAAM,MAAA,GAAS,MACf,MAAM,IAAI,MAAM,oBAAoB;QAGxC,MAAMJ,IAAMG,GAAgBC,CAAK,GAC3BwY,IAAQxY,EAAM,MAAA,GAAS,IAAIkX;QACjC,OAAOsB,IAAQ,IAAI5Y,KAAO,OAAO4Y,CAAK,IAAI5Y;IAC9C,GACEsY,IAAgBpB,EAAU,aAAA,IAC5B,SAA2B9W,CAAAA,EAAO;QAC9B,OAAOqN,EAAG,MAAA,CAAOkL,GAASvY,CAAK,CAAC;IACpC,GAEEyY,KAAaxX,GAAQiW,CAAM;IAEjC,SAASwB,GAAW9Y,CAAAA,EAAK;QAErB,OAAAkB,GAAS,aAAaoW,GAAQtX,GAAKV,GAAKuZ,EAAU,GAC3CpL,EAAG,OAAA,CAAQzN,CAAG;IACzB;IACA,SAAS+Y,EAAmBxK,CAAAA,EAASyK,CAAAA,EAAS;QAC1C,WAAAtc,6OAAAA,EAAO6R,GAAS,KAAA,GAAW,SAAS,GAC7ByK,QAAUtc,6OAAAA,EAAOsR,EAAKO,CAAO,GAAG,KAAA,GAAW,mBAAmB,IAAIA;IAC7E;IASA,SAAS0K,GAAQ1K,CAAAA,EAAST,CAAAA,EAAWnG,CAAAA,EAAM;QACvC,MAAM,EAAE,MAAAuR,CAAAA,EAAM,SAAAF,CAAAA,EAAS,cAAAG,CAAAA,CAAY,CAAA,GAAK9J,GAAgB1H,GAAM4P,CAAc;QAC5EhJ,IAAUwK,EAAmBxK,GAASyK,CAAO;QAI7C,MAAMI,IAAQd,EAAc/J,CAAO,GAC7BzG,IAAI2F,EAAG,SAAA,CAAUK,CAAS;QAChC,IAAI,CAACL,EAAG,WAAA,CAAY3F,CAAC,GACjB,MAAM,IAAI,MAAM,qBAAqB;QACzC,MAAMuR,IAAW;YAACP,GAAWhR,CAAC;YAAGgR,GAAWM,CAAK,CAAC;SAAA;QAElD,IAAID,KAAgB,QAAQA,MAAiB,CAAA,GAAO;YAGhD,MAAMG,IAAIH,MAAiB,CAAA,IAAOhC,EAAYhG,EAAQ,SAAS,IAAIgI;YACnEE,EAAS,IAAA,CAAK3c,iPAAAA,EAAO4c,GAAG,KAAA,GAAW,cAAc,CAAC;QACtD;QACA,MAAMhX,QAAOqP,6OAAAA,CAAY,IAAG0H,CAAQ,GAC9BtU,IAAIqU;QASV,SAASG,EAAMC,CAAAA,EAAQ;YAGnB,MAAMxX,IAAI2W,GAASa,CAAM;YACzB,IAAI,CAAC/L,EAAG,WAAA,CAAYzL,CAAC,GACjB;YACJ,MAAMyX,IAAKhM,EAAG,GAAA,CAAIzL,CAAC,GACb6C,IAAIsH,EAAM,IAAA,CAAK,QAAA,CAASnK,CAAC,EAAE,QAAA,IAC3B8C,IAAI2I,EAAG,MAAA,CAAO5I,EAAE,CAAC;YACvB,IAAIC,MAAMxF,GACN;YACJ,MAAMwX,IAAIrJ,EAAG,MAAA,CAAOgM,IAAKhM,EAAG,MAAA,CAAO1I,IAAID,IAAIgD,CAAC,CAAC;YAC7C,IAAIgP,MAAMxX,GACN;YACJ,IAAI2Y,KAAAA,CAAYpT,EAAE,CAAA,KAAMC,IAAI,IAAI,CAAA,IAAK,OAAOD,EAAE,CAAA,GAAItF,EAAG,GACjDma,KAAQ5C;YACZ,OAAIoC,KAAQzB,EAAsBX,CAAC,KAAA,CAC/B4C,KAAQjM,EAAG,GAAA,CAAIqJ,CAAC,GAChBmB,MAAY,CAAA,GAET,IAAID,EAAUlT,GAAG4U,IAAOlC,IAAmB,KAAA,IAAYS,EAAQ;QAC1E;QACA,OAAO;YAAE,MAAA3V;YAAM,OAAAiX;QAAK;IACxB;IAYA,SAASI,GAAKpL,CAAAA,EAAST,CAAAA,EAAWnG,IAAO,CAAA,CAAA,EAAI;QACzC,MAAM,EAAE,MAAArF,CAAAA,EAAM,OAAAiX,CAAAA,CAAK,CAAA,GAAKN,GAAQ1K,GAAST,GAAWnG,CAAI;QAGxD,OAFarG,GAAe0M,EAAK,SAAA,EAAWP,EAAG,KAAA,EAAOa,CAAI,EACzChM,GAAMiX,CAAK,EACjB,OAAA,CAAQ5R,EAAK,MAAM;IAClC;IAcA,SAASiS,EAAOC,CAAAA,EAAWtL,CAAAA,EAAS+H,CAAAA,EAAW3O,IAAO,CAAA,CAAA,EAAI;QACtD,MAAM,EAAE,MAAAuR,CAAAA,EAAM,SAAAF,CAAAA,EAAS,QAAA5J,CAAAA,CAAM,CAAA,GAAKC,GAAgB1H,GAAM4P,CAAc;QAGtE,IAFAjB,QAAY5Z,6OAAAA,EAAO4Z,GAAW,KAAA,GAAW,WAAW,GACpD/H,IAAUwK,EAAmBxK,GAASyK,CAAO,GACzC,CAACtC,iPAAAA,EAAQmD,CAAS,GAAG;YACrB,MAAMC,IAAMD,aAAqB7B,IAAY,wBAAwB;YACrE,MAAM,IAAI,MAAM,wCAAwC8B,CAAG;QAC/D;QACAjC,EAAkBgC,GAAWzK,CAAM;QACnC,IAAI;YACA,MAAMqB,IAAMuH,EAAU,SAAA,CAAU6B,GAAWzK,CAAM,GAC3C1J,IAAIyG,EAAM,SAAA,CAAUmK,CAAS;YACnC,IAAI4C,KAAQzI,EAAI,QAAA,CAAQ,GACpB,OAAO,CAAA;YACX,MAAM,EAAE,GAAA3L,CAAAA,EAAG,GAAAgS,CAAAA,CAAC,CAAA,GAAKrG,GACXvO,IAAIoW,EAAc/J,CAAO,GACzBwL,IAAKtM,EAAG,GAAA,CAAIqJ,CAAC,GACbyB,IAAK9K,EAAG,MAAA,CAAOvL,IAAI6X,CAAE,GACrBvB,IAAK/K,EAAG,MAAA,CAAO3I,IAAIiV,CAAE,GACrB5S,IAAIgF,EAAM,IAAA,CAAK,cAAA,CAAeoM,CAAE,EAAE,GAAA,CAAI7S,EAAE,cAAA,CAAe8S,CAAE,CAAC;YAChE,OAAIrR,EAAE,GAAA,CAAG,IACE,CAAA,IACDsG,EAAG,MAAA,CAAOtG,EAAE,CAAC,MACVrC;QACjB,EAAA,OACU;YACN,OAAO,CAAA;QACX;IACJ;IACA,SAASkV,EAAiBH,CAAAA,EAAWtL,CAAAA,EAAS5G,IAAO,CAAA,CAAA,EAAI;QACrD,MAAM,EAAE,SAAAqR,CAAAA,CAAO,CAAA,GAAK3J,GAAgB1H,GAAM4P,CAAc;QACxD,OAAAhJ,IAAUwK,EAAmBxK,GAASyK,CAAO,GACtChB,EAAU,SAAA,CAAU6B,GAAW,WAAW,EAAE,gBAAA,CAAiBtL,CAAO,EAAE,OAAA,CAAO;IACxF;IACA,OAAO,OAAO,MAAA,CAAO;QACjB,QAAAyI;QACA,cAAAnJ;QACA,iBAAA8I;QACA,OAAAI;QACA,SAAA5F;QACA,OAAAhF;QACA,MAAAwN;QACA,QAAAC;QACA,kBAAAI;QACA,WAAAhC;QACA,MAAAhK;IACR,CAAK;AACL;AC7rCA,oEAAA,GAWA,MAAMiM,KAAkB;IACpB,GAAG,OAAO,oEAAoE;IAC9E,GAAG,OAAO,oEAAoE;IAC9E,GAAG,OAAO,CAAC;IACX,GAAG,OAAO,CAAC;IACX,GAAG,OAAO,CAAC;IACX,IAAI,OAAO,oEAAoE;IAC/E,IAAI,OAAO,oEAAoE;AACnF,GACMC,KAAiB;IACnB,MAAM,OAAO,oEAAoE;IACjF,SAAS;QACL;YAAC,OAAO,oCAAoC;YAAG,CAAC,OAAO,oCAAoC,CAAC;SAAA;QAC5F;YAAC,OAAO,qCAAqC;YAAG,OAAO,oCAAoC,CAAC;SAAA;KACpG;AACA,GACM5a,KAAsB,aAAA,GAAA,OAAO,CAAC,GAC9BsE,KAAsB,aAAA,GAAA,OAAO,CAAC;AAKpC,SAASuW,GAAQhI,CAAAA,EAAG;IAChB,MAAMzM,IAAIuU,GAAgB,CAAA,EAEpBpW,IAAM,OAAO,CAAC,GAAGuW,IAAM,OAAO,CAAC,GAAGC,IAAO,OAAO,EAAE,GAAGC,IAAO,OAAO,EAAE,GAErEC,IAAO,OAAO,EAAE,GAAGC,IAAO,OAAO,EAAE,GAAGC,IAAO,OAAO,EAAE,GACtD1L,IAAMoD,IAAIA,IAAIA,IAAKzM,GACnBmP,IAAM9F,IAAKA,IAAKoD,IAAKzM,GACrBgV,IAAMpW,EAAKuQ,GAAIhR,GAAK6B,CAAC,IAAImP,IAAMnP,GAC/BiV,IAAMrW,EAAKoW,GAAI7W,GAAK6B,CAAC,IAAImP,IAAMnP,GAC/BkV,IAAOtW,EAAKqW,GAAI/W,IAAK8B,CAAC,IAAIqJ,IAAMrJ,GAChCmV,IAAOvW,EAAKsW,GAAKP,GAAM3U,CAAC,IAAIkV,IAAOlV,GACnCoV,IAAOxW,EAAKuW,GAAKP,GAAM5U,CAAC,IAAImV,IAAOnV,GACnCqV,IAAOzW,EAAKwW,GAAKN,GAAM9U,CAAC,IAAIoV,IAAOpV,GACnCsV,IAAQ1W,EAAKyW,GAAKN,GAAM/U,CAAC,IAAIqV,IAAOrV,GACpCuV,IAAQ3W,EAAK0W,GAAMR,GAAM9U,CAAC,IAAIoV,IAAOpV,GACrCwV,IAAQ5W,EAAK2W,GAAMpX,GAAK6B,CAAC,IAAImP,IAAMnP,GACnCwP,IAAM5Q,EAAK4W,GAAMX,GAAM7U,CAAC,IAAImV,IAAOnV,GACnCyP,KAAM7Q,EAAK4Q,GAAIkF,GAAK1U,CAAC,IAAIqJ,IAAMrJ,GAC/BR,IAAOZ,EAAK6Q,IAAIvR,IAAK8B,CAAC;IAC5B,IAAI,CAACyV,GAAK,GAAA,CAAIA,GAAK,GAAA,CAAIjW,CAAI,GAAGiN,CAAC,GAC3B,MAAM,IAAI,MAAM,yBAAyB;IAC7C,OAAOjN;AACX;AACA,MAAMiW,KAAOvV,GAAMqU,GAAgB,CAAA,EAAG;IAAE,MAAME;AAAAA,CAAS,GACjDiB,KAA0B,aAAA,GAAAvK,GAAYoJ,IAAiB;IACzD,IAAIkB;IACJ,MAAMjB;AACV,CAAC,GAkBYmB,KAA4B,aAAA,GAAApE,GAAMmE,IAASjc,EAAM,GAIxDmc,KAAuB,CAAA;AAC7B,SAASC,GAAW5L,CAAAA,EAAAA,GAAQ6L,CAAAA,EAAU;IAClC,IAAIC,IAAOH,EAAAA,CAAqB3L,CAAG,CAAA;IACnC,IAAI8L,MAAS,KAAA,GAAW;QACpB,MAAMC,IAAOvc,GAAOyB,GAAa+O,CAAG,CAAC;QACrC8L,QAAO9J,6OAAAA,EAAY+J,GAAMA,CAAI,GAC7BJ,EAAAA,CAAqB3L,CAAG,CAAA,GAAI8L;IAChC;IACA,OAAOtc,OAAOwS,6OAAAA,EAAY8J,GAAM,GAAGD,CAAQ,CAAC;AAChD;AAEA,MAAMlK,KAAe,CAACjF,IAAUA,EAAM,OAAA,CAAQ,CAAA,CAAI,EAAE,KAAA,CAAM,CAAC,GACrDsP,KAAU,CAACxJ,IAAMA,IAAIvO,OAAQtE;AAEnC,SAASsc,GAAoBC,CAAAA,EAAM;IAC/B,MAAM,EAAE,IAAApO,CAAAA,EAAI,MAAAqO,CAAAA,CAAI,CAAA,GAAKV,IACfW,IAAKtO,EAAG,SAAA,CAAUoO,CAAI,GACtBhU,IAAIiU,EAAK,QAAA,CAASC,CAAE;IAE1B,OAAO;QAAE,QADMJ,GAAQ9T,EAAE,CAAC,IAAIkU,IAAKtO,EAAG,GAAA,CAAIsO,CAAE;QAC3B,OAAOzK,GAAazJ,CAAC;IAAC;AAC3C;AAKA,SAASmU,GAAOzX,CAAAA,EAAG;IACf,MAAMU,IAAKkW;IACX,IAAI,CAAClW,EAAG,WAAA,CAAYV,CAAC,GACjB,MAAM,IAAI,MAAM,0BAA0B;IAC9C,MAAM0X,IAAKhX,EAAG,MAAA,CAAOV,IAAIA,CAAC,GACpBxI,IAAIkJ,EAAG,MAAA,CAAOgX,IAAK1X,IAAI,OAAO,CAAC,CAAC;IACtC,IAAI4N,IAAIlN,EAAG,IAAA,CAAKlJ,CAAC;IAGZ4f,GAAQxJ,CAAC,KAAA,CACVA,IAAIlN,EAAG,GAAA,CAAIkN,CAAC,CAAA;IAChB,MAAMtK,IAAIuT,GAAQ,UAAA,CAAW;QAAE,GAAA7W;QAAG,GAAA4N;IAAC,CAAE;IACrC,OAAAtK,EAAE,cAAA,CAAc,GACTA;AACX;AACA,MAAM7H,KAAMG;AAIZ,SAAS+b,GAAAA,GAAaxY,CAAAA,EAAM;IACxB,OAAO0X,GAAQ,EAAA,CAAG,MAAA,CAAOpb,GAAIub,GAAW,qBAAqB,GAAG7X,CAAI,CAAC,CAAC;AAC1E;AAIA,SAASyY,GAAoBrO,CAAAA,EAAW;IACpC,OAAO8N,GAAoB9N,CAAS,EAAE,KAAA;AAC1C;AAKA,SAASsO,GAAY7N,CAAAA,EAAST,CAAAA,EAAWuO,QAAUlF,6OAAAA,EAAY,EAAE,CAAA,EAAG;IAChE,MAAM,EAAE,IAAA1J,CAAAA,CAAE,CAAA,GAAK2N,IACTrW,QAAIrI,6OAAAA,EAAO6R,GAAS,KAAA,GAAW,SAAS,GACxC,EAAE,OAAO+N,CAAAA,EAAI,QAAQxU,CAAAA,EAAAA,GAAM8T,GAAoB9N,CAAS,GACxDjS,QAAIa,6OAAAA,EAAO2f,GAAS,IAAI,SAAS,GACjCnV,IAAIuG,EAAG,OAAA,CAAQ3F,IAAI9H,GAAIub,GAAW,eAAe1f,CAAC,CAAC,CAAC,GACpD0gB,IAAOhB,GAAW,iBAAiBrU,GAAGoV,GAAIvX,CAAC,GAE3C,EAAE,OAAOyX,CAAAA,EAAI,QAAQxa,CAAAA,CAAC,CAAA,GAAK4Z,GAAoBW,CAAI,GACnDjD,IAAI4C,GAAUM,GAAIF,GAAIvX,CAAC,GACvB0L,IAAM,IAAI,WAAW,EAAE;IAI7B,IAHAA,EAAI,GAAA,CAAI+L,GAAI,CAAC,GACb/L,EAAI,GAAA,CAAIhD,EAAG,OAAA,CAAQA,EAAG,MAAA,CAAOzL,IAAIsX,IAAIxR,CAAC,CAAC,GAAG,EAAE,GAExC,CAAC2U,GAAchM,GAAK1L,GAAGuX,CAAE,GACzB,MAAM,IAAI,MAAM,kCAAkC;IACtD,OAAO7L;AACX;AAKA,SAASgM,GAAc5C,CAAAA,EAAWtL,CAAAA,EAAS+H,CAAAA,EAAW;IAClD,MAAM,EAAE,IAAArR,CAAAA,EAAI,IAAAwI,CAAAA,EAAI,MAAAqO,CAAAA,CAAI,CAAA,GAAKV,IACnB3K,QAAM/T,6OAAAA,EAAOmd,GAAW,IAAI,WAAW,GACvC9U,QAAIrI,6OAAAA,EAAO6R,GAAS,KAAA,GAAW,SAAS,GACxCmO,QAAMhgB,6OAAAA,EAAO4Z,GAAW,IAAI,WAAW;IAC7C,IAAI;QACA,MAAM5Q,IAAIsW,GAAOhc,GAAI0c,CAAG,CAAC,GACnB5X,IAAI9E,GAAIyQ,EAAI,QAAA,CAAS,GAAG,EAAE,CAAC;QACjC,IAAI,CAACxL,EAAG,WAAA,CAAYH,CAAC,GACjB,OAAO,CAAA;QACX,MAAMgS,IAAI9W,GAAIyQ,EAAI,QAAA,CAAS,IAAI,EAAE,CAAC;QAClC,IAAI,CAAChD,EAAG,WAAA,CAAYqJ,CAAC,GACjB,OAAO,CAAA;QACX,MAAMwC,IAAI4C,GAAUzO,EAAG,OAAA,CAAQ3I,CAAC,GAAGwM,GAAa5L,CAAC,GAAGX,CAAC,GAE/CoC,IAAI2U,EAAK,cAAA,CAAehF,CAAC,EAAE,GAAA,CAAIpR,EAAE,cAAA,CAAe+H,EAAG,GAAA,CAAI6L,CAAC,CAAC,CAAC,GAC1D,EAAE,GAAA/U,CAAAA,EAAG,GAAA4N,CAAAA,EAAAA,GAAMhL,EAAE,QAAA,CAAQ;QAE3B,OAAI,CAAA,CAAAA,EAAE,GAAA,MAAS,CAACwU,GAAQxJ,CAAC,KAAK5N,MAAMO,CAAAA;IAGxC,EAAA,OACc;QACV,OAAO,CAAA;IACX;AACJ;AAcY,MAAC6X,KAA2B,aAAA,GAAA,CAAA,MAAM;IAG1C,MAAM/O,IAAkB,CAACtL,QAAO6U,6OAAAA,EAAY,EAAU,CAAA,GAC3CnN,GAAe1H,GAAM2X,GAAgB,CAAC;IAEjD,OAAO;QACH,QAAQtM,GAAaC,GAAiBuO,EAAmB;QACzD,cAAcA;QACd,MAAMC;QACN,QAAQK;QACR,OAAOrB;QACP,OAAO;YACH,iBAAAxN;YACA,YAAA2N;YACA,QAAAS;YACA,cAAA1K;QACZ;QACQ,SAAS;YACL,WAAW;YACX,WAAW;YACX,oBAAoB,CAAA;YACpB,WAAW;YACX,MAAM;QAClB;IACA;AACA,CAAA,EAAC"}},
    {"offset": {"line": 1673, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@cashu+cashu-ts@2.9.0/node_modules/@cashu/cashu-ts/lib/utils-t45upHsJ.js","sources":["file:///home/maximoto/dev/sats-rover/node_modules/.pnpm/%40cashu%2Bcashu-ts%402.9.0/node_modules/%40cashu/cashu-ts/node_modules/vite-plugin-node-polyfills/shims/buffer/dist/index.js","file:///home/maximoto/dev/sats-rover/node_modules/.pnpm/%40cashu%2Bcashu-ts%402.9.0/node_modules/%40cashu/cashu-ts/src/utils/Bytes.ts","file:///home/maximoto/dev/sats-rover/node_modules/.pnpm/%40cashu%2Bcashu-ts%402.9.0/node_modules/%40cashu/cashu-ts/src/crypto/util/utils.ts"],"sourcesContent":["var buffer = {};\n\nvar base64Js = {};\n\nbase64Js.byteLength = byteLength;\nbase64Js.toByteArray = toByteArray;\nbase64Js.fromByteArray = fromByteArray;\n\nvar lookup = [];\nvar revLookup = [];\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i];\n  revLookup[code.charCodeAt(i)] = i;\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62;\nrevLookup['_'.charCodeAt(0)] = 63;\n\nfunction getLens (b64) {\n  var len = b64.length;\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=');\n  if (validLen === -1) validLen = len;\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4);\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64);\n  var validLen = lens[0];\n  var placeHoldersLen = lens[1];\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp;\n  var lens = getLens(b64);\n  var validLen = lens[0];\n  var placeHoldersLen = lens[1];\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));\n\n  var curByte = 0;\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen;\n\n  var i;\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)];\n    arr[curByte++] = (tmp >> 16) & 0xFF;\n    arr[curByte++] = (tmp >> 8) & 0xFF;\n    arr[curByte++] = tmp & 0xFF;\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4);\n    arr[curByte++] = tmp & 0xFF;\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2);\n    arr[curByte++] = (tmp >> 8) & 0xFF;\n    arr[curByte++] = tmp & 0xFF;\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp;\n  var output = [];\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF);\n    output.push(tripletToBase64(tmp));\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp;\n  var len = uint8.length;\n  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes\n  var parts = [];\n  var maxChunkLength = 16383; // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1];\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    );\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1];\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    );\n  }\n\n  return parts.join('')\n}\n\nvar ieee754 = {};\n\n/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\n\nieee754.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m;\n  var eLen = (nBytes * 8) - mLen - 1;\n  var eMax = (1 << eLen) - 1;\n  var eBias = eMax >> 1;\n  var nBits = -7;\n  var i = isLE ? (nBytes - 1) : 0;\n  var d = isLE ? -1 : 1;\n  var s = buffer[offset + i];\n\n  i += d;\n\n  e = s & ((1 << (-nBits)) - 1);\n  s >>= (-nBits);\n  nBits += eLen;\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1);\n  e >>= (-nBits);\n  nBits += mLen;\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias;\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen);\n    e = e - eBias;\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n};\n\nieee754.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c;\n  var eLen = (nBytes * 8) - mLen - 1;\n  var eMax = (1 << eLen) - 1;\n  var eBias = eMax >> 1;\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);\n  var i = isLE ? 0 : (nBytes - 1);\n  var d = isLE ? 1 : -1;\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;\n\n  value = Math.abs(value);\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0;\n    e = eMax;\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2);\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--;\n      c *= 2;\n    }\n    if (e + eBias >= 1) {\n      value += rt / c;\n    } else {\n      value += rt * Math.pow(2, 1 - eBias);\n    }\n    if (value * c >= 2) {\n      e++;\n      c /= 2;\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0;\n      e = eMax;\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen);\n      e = e + eBias;\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n      e = 0;\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m;\n  eLen += mLen;\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128;\n};\n\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n\n(function (exports) {\n\n\tconst base64 = base64Js;\n\tconst ieee754$1 = ieee754;\n\tconst customInspectSymbol =\n\t  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation\n\t    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation\n\t    : null;\n\n\texports.Buffer = Buffer;\n\texports.SlowBuffer = SlowBuffer;\n\texports.INSPECT_MAX_BYTES = 50;\n\n\tconst K_MAX_LENGTH = 0x7fffffff;\n\texports.kMaxLength = K_MAX_LENGTH;\n\tconst { Uint8Array: GlobalUint8Array, ArrayBuffer: GlobalArrayBuffer, SharedArrayBuffer: GlobalSharedArrayBuffer } = globalThis;\n\n\t/**\n\t * If `Buffer.TYPED_ARRAY_SUPPORT`:\n\t *   === true    Use Uint8Array implementation (fastest)\n\t *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n\t *               implementation (most compatible, even IE6)\n\t *\n\t * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n\t * Opera 11.6+, iOS 4.2+.\n\t *\n\t * We report that the browser does not support typed arrays if the are not subclassable\n\t * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n\t * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n\t * for __proto__ and has a buggy typed array implementation.\n\t */\n\tBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport();\n\n\tif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n\t    typeof console.error === 'function') {\n\t  console.error(\n\t    'This browser lacks typed array (Uint8Array) support which is required by ' +\n\t    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n\t  );\n\t}\n\n\tfunction typedArraySupport () {\n\t  // Can typed array instances can be augmented?\n\t  try {\n\t    const arr = new GlobalUint8Array(1);\n\t    const proto = { foo: function () { return 42 } };\n\t    Object.setPrototypeOf(proto, GlobalUint8Array.prototype);\n\t    Object.setPrototypeOf(arr, proto);\n\t    return arr.foo() === 42\n\t  } catch (e) {\n\t    return false\n\t  }\n\t}\n\n\tObject.defineProperty(Buffer.prototype, 'parent', {\n\t  enumerable: true,\n\t  get: function () {\n\t    if (!Buffer.isBuffer(this)) return undefined\n\t    return this.buffer\n\t  }\n\t});\n\n\tObject.defineProperty(Buffer.prototype, 'offset', {\n\t  enumerable: true,\n\t  get: function () {\n\t    if (!Buffer.isBuffer(this)) return undefined\n\t    return this.byteOffset\n\t  }\n\t});\n\n\tfunction createBuffer (length) {\n\t  if (length > K_MAX_LENGTH) {\n\t    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n\t  }\n\t  // Return an augmented `Uint8Array` instance\n\t  const buf = new GlobalUint8Array(length);\n\t  Object.setPrototypeOf(buf, Buffer.prototype);\n\t  return buf\n\t}\n\n\t/**\n\t * The Buffer constructor returns instances of `Uint8Array` that have their\n\t * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n\t * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n\t * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n\t * returns a single octet.\n\t *\n\t * The `Uint8Array` prototype remains unmodified.\n\t */\n\n\tfunction Buffer (arg, encodingOrOffset, length) {\n\t  // Common case.\n\t  if (typeof arg === 'number') {\n\t    if (typeof encodingOrOffset === 'string') {\n\t      throw new TypeError(\n\t        'The \"string\" argument must be of type string. Received type number'\n\t      )\n\t    }\n\t    return allocUnsafe(arg)\n\t  }\n\t  return from(arg, encodingOrOffset, length)\n\t}\n\n\tBuffer.poolSize = 8192; // not used by this implementation\n\n\tfunction from (value, encodingOrOffset, length) {\n\t  if (typeof value === 'string') {\n\t    return fromString(value, encodingOrOffset)\n\t  }\n\n\t  if (GlobalArrayBuffer.isView(value)) {\n\t    return fromArrayView(value)\n\t  }\n\n\t  if (value == null) {\n\t    throw new TypeError(\n\t      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n\t      'or Array-like Object. Received type ' + (typeof value)\n\t    )\n\t  }\n\n\t  if (isInstance(value, GlobalArrayBuffer) ||\n\t      (value && isInstance(value.buffer, GlobalArrayBuffer))) {\n\t    return fromArrayBuffer(value, encodingOrOffset, length)\n\t  }\n\n\t  if (typeof GlobalSharedArrayBuffer !== 'undefined' &&\n\t      (isInstance(value, GlobalSharedArrayBuffer) ||\n\t      (value && isInstance(value.buffer, GlobalSharedArrayBuffer)))) {\n\t    return fromArrayBuffer(value, encodingOrOffset, length)\n\t  }\n\n\t  if (typeof value === 'number') {\n\t    throw new TypeError(\n\t      'The \"value\" argument must not be of type number. Received type number'\n\t    )\n\t  }\n\n\t  const valueOf = value.valueOf && value.valueOf();\n\t  if (valueOf != null && valueOf !== value) {\n\t    return Buffer.from(valueOf, encodingOrOffset, length)\n\t  }\n\n\t  const b = fromObject(value);\n\t  if (b) return b\n\n\t  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n\t      typeof value[Symbol.toPrimitive] === 'function') {\n\t    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)\n\t  }\n\n\t  throw new TypeError(\n\t    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n\t    'or Array-like Object. Received type ' + (typeof value)\n\t  )\n\t}\n\n\t/**\n\t * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n\t * if value is a number.\n\t * Buffer.from(str[, encoding])\n\t * Buffer.from(array)\n\t * Buffer.from(buffer)\n\t * Buffer.from(arrayBuffer[, byteOffset[, length]])\n\t **/\n\tBuffer.from = function (value, encodingOrOffset, length) {\n\t  return from(value, encodingOrOffset, length)\n\t};\n\n\t// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n\t// https://github.com/feross/buffer/pull/148\n\tObject.setPrototypeOf(Buffer.prototype, GlobalUint8Array.prototype);\n\tObject.setPrototypeOf(Buffer, GlobalUint8Array);\n\n\tfunction assertSize (size) {\n\t  if (typeof size !== 'number') {\n\t    throw new TypeError('\"size\" argument must be of type number')\n\t  } else if (size < 0) {\n\t    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n\t  }\n\t}\n\n\tfunction alloc (size, fill, encoding) {\n\t  assertSize(size);\n\t  if (size <= 0) {\n\t    return createBuffer(size)\n\t  }\n\t  if (fill !== undefined) {\n\t    // Only pay attention to encoding if it's a string. This\n\t    // prevents accidentally sending in a number that would\n\t    // be interpreted as a start offset.\n\t    return typeof encoding === 'string'\n\t      ? createBuffer(size).fill(fill, encoding)\n\t      : createBuffer(size).fill(fill)\n\t  }\n\t  return createBuffer(size)\n\t}\n\n\t/**\n\t * Creates a new filled Buffer instance.\n\t * alloc(size[, fill[, encoding]])\n\t **/\n\tBuffer.alloc = function (size, fill, encoding) {\n\t  return alloc(size, fill, encoding)\n\t};\n\n\tfunction allocUnsafe (size) {\n\t  assertSize(size);\n\t  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n\t}\n\n\t/**\n\t * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n\t * */\n\tBuffer.allocUnsafe = function (size) {\n\t  return allocUnsafe(size)\n\t};\n\t/**\n\t * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n\t */\n\tBuffer.allocUnsafeSlow = function (size) {\n\t  return allocUnsafe(size)\n\t};\n\n\tfunction fromString (string, encoding) {\n\t  if (typeof encoding !== 'string' || encoding === '') {\n\t    encoding = 'utf8';\n\t  }\n\n\t  if (!Buffer.isEncoding(encoding)) {\n\t    throw new TypeError('Unknown encoding: ' + encoding)\n\t  }\n\n\t  const length = byteLength(string, encoding) | 0;\n\t  let buf = createBuffer(length);\n\n\t  const actual = buf.write(string, encoding);\n\n\t  if (actual !== length) {\n\t    // Writing a hex string, for example, that contains invalid characters will\n\t    // cause everything after the first invalid character to be ignored. (e.g.\n\t    // 'abxxcd' will be treated as 'ab')\n\t    buf = buf.slice(0, actual);\n\t  }\n\n\t  return buf\n\t}\n\n\tfunction fromArrayLike (array) {\n\t  const length = array.length < 0 ? 0 : checked(array.length) | 0;\n\t  const buf = createBuffer(length);\n\t  for (let i = 0; i < length; i += 1) {\n\t    buf[i] = array[i] & 255;\n\t  }\n\t  return buf\n\t}\n\n\tfunction fromArrayView (arrayView) {\n\t  if (isInstance(arrayView, GlobalUint8Array)) {\n\t    const copy = new GlobalUint8Array(arrayView);\n\t    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)\n\t  }\n\t  return fromArrayLike(arrayView)\n\t}\n\n\tfunction fromArrayBuffer (array, byteOffset, length) {\n\t  if (byteOffset < 0 || array.byteLength < byteOffset) {\n\t    throw new RangeError('\"offset\" is outside of buffer bounds')\n\t  }\n\n\t  if (array.byteLength < byteOffset + (length || 0)) {\n\t    throw new RangeError('\"length\" is outside of buffer bounds')\n\t  }\n\n\t  let buf;\n\t  if (byteOffset === undefined && length === undefined) {\n\t    buf = new GlobalUint8Array(array);\n\t  } else if (length === undefined) {\n\t    buf = new GlobalUint8Array(array, byteOffset);\n\t  } else {\n\t    buf = new GlobalUint8Array(array, byteOffset, length);\n\t  }\n\n\t  // Return an augmented `Uint8Array` instance\n\t  Object.setPrototypeOf(buf, Buffer.prototype);\n\n\t  return buf\n\t}\n\n\tfunction fromObject (obj) {\n\t  if (Buffer.isBuffer(obj)) {\n\t    const len = checked(obj.length) | 0;\n\t    const buf = createBuffer(len);\n\n\t    if (buf.length === 0) {\n\t      return buf\n\t    }\n\n\t    obj.copy(buf, 0, 0, len);\n\t    return buf\n\t  }\n\n\t  if (obj.length !== undefined) {\n\t    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n\t      return createBuffer(0)\n\t    }\n\t    return fromArrayLike(obj)\n\t  }\n\n\t  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n\t    return fromArrayLike(obj.data)\n\t  }\n\t}\n\n\tfunction checked (length) {\n\t  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n\t  // length is NaN (which is otherwise coerced to zero.)\n\t  if (length >= K_MAX_LENGTH) {\n\t    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n\t                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n\t  }\n\t  return length | 0\n\t}\n\n\tfunction SlowBuffer (length) {\n\t  if (+length != length) { // eslint-disable-line eqeqeq\n\t    length = 0;\n\t  }\n\t  return Buffer.alloc(+length)\n\t}\n\n\tBuffer.isBuffer = function isBuffer (b) {\n\t  return b != null && b._isBuffer === true &&\n\t    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n\t};\n\n\tBuffer.compare = function compare (a, b) {\n\t  if (isInstance(a, GlobalUint8Array)) a = Buffer.from(a, a.offset, a.byteLength);\n\t  if (isInstance(b, GlobalUint8Array)) b = Buffer.from(b, b.offset, b.byteLength);\n\t  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n\t    throw new TypeError(\n\t      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n\t    )\n\t  }\n\n\t  if (a === b) return 0\n\n\t  let x = a.length;\n\t  let y = b.length;\n\n\t  for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n\t    if (a[i] !== b[i]) {\n\t      x = a[i];\n\t      y = b[i];\n\t      break\n\t    }\n\t  }\n\n\t  if (x < y) return -1\n\t  if (y < x) return 1\n\t  return 0\n\t};\n\n\tBuffer.isEncoding = function isEncoding (encoding) {\n\t  switch (String(encoding).toLowerCase()) {\n\t    case 'hex':\n\t    case 'utf8':\n\t    case 'utf-8':\n\t    case 'ascii':\n\t    case 'latin1':\n\t    case 'binary':\n\t    case 'base64':\n\t    case 'ucs2':\n\t    case 'ucs-2':\n\t    case 'utf16le':\n\t    case 'utf-16le':\n\t      return true\n\t    default:\n\t      return false\n\t  }\n\t};\n\n\tBuffer.concat = function concat (list, length) {\n\t  if (!Array.isArray(list)) {\n\t    throw new TypeError('\"list\" argument must be an Array of Buffers')\n\t  }\n\n\t  if (list.length === 0) {\n\t    return Buffer.alloc(0)\n\t  }\n\n\t  let i;\n\t  if (length === undefined) {\n\t    length = 0;\n\t    for (i = 0; i < list.length; ++i) {\n\t      length += list[i].length;\n\t    }\n\t  }\n\n\t  const buffer = Buffer.allocUnsafe(length);\n\t  let pos = 0;\n\t  for (i = 0; i < list.length; ++i) {\n\t    let buf = list[i];\n\t    if (isInstance(buf, GlobalUint8Array)) {\n\t      if (pos + buf.length > buffer.length) {\n\t        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf);\n\t        buf.copy(buffer, pos);\n\t      } else {\n\t        GlobalUint8Array.prototype.set.call(\n\t          buffer,\n\t          buf,\n\t          pos\n\t        );\n\t      }\n\t    } else if (!Buffer.isBuffer(buf)) {\n\t      throw new TypeError('\"list\" argument must be an Array of Buffers')\n\t    } else {\n\t      buf.copy(buffer, pos);\n\t    }\n\t    pos += buf.length;\n\t  }\n\t  return buffer\n\t};\n\n\tfunction byteLength (string, encoding) {\n\t  if (Buffer.isBuffer(string)) {\n\t    return string.length\n\t  }\n\t  if (GlobalArrayBuffer.isView(string) || isInstance(string, GlobalArrayBuffer)) {\n\t    return string.byteLength\n\t  }\n\t  if (typeof string !== 'string') {\n\t    throw new TypeError(\n\t      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n\t      'Received type ' + typeof string\n\t    )\n\t  }\n\n\t  const len = string.length;\n\t  const mustMatch = (arguments.length > 2 && arguments[2] === true);\n\t  if (!mustMatch && len === 0) return 0\n\n\t  // Use a for loop to avoid recursion\n\t  let loweredCase = false;\n\t  for (;;) {\n\t    switch (encoding) {\n\t      case 'ascii':\n\t      case 'latin1':\n\t      case 'binary':\n\t        return len\n\t      case 'utf8':\n\t      case 'utf-8':\n\t        return utf8ToBytes(string).length\n\t      case 'ucs2':\n\t      case 'ucs-2':\n\t      case 'utf16le':\n\t      case 'utf-16le':\n\t        return len * 2\n\t      case 'hex':\n\t        return len >>> 1\n\t      case 'base64':\n\t        return base64ToBytes(string).length\n\t      default:\n\t        if (loweredCase) {\n\t          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n\t        }\n\t        encoding = ('' + encoding).toLowerCase();\n\t        loweredCase = true;\n\t    }\n\t  }\n\t}\n\tBuffer.byteLength = byteLength;\n\n\tfunction slowToString (encoding, start, end) {\n\t  let loweredCase = false;\n\n\t  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n\t  // property of a typed array.\n\n\t  // This behaves neither like String nor Uint8Array in that we set start/end\n\t  // to their upper/lower bounds if the value passed is out of range.\n\t  // undefined is handled specially as per ECMA-262 6th Edition,\n\t  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n\t  if (start === undefined || start < 0) {\n\t    start = 0;\n\t  }\n\t  // Return early if start > this.length. Done here to prevent potential uint32\n\t  // coercion fail below.\n\t  if (start > this.length) {\n\t    return ''\n\t  }\n\n\t  if (end === undefined || end > this.length) {\n\t    end = this.length;\n\t  }\n\n\t  if (end <= 0) {\n\t    return ''\n\t  }\n\n\t  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n\t  end >>>= 0;\n\t  start >>>= 0;\n\n\t  if (end <= start) {\n\t    return ''\n\t  }\n\n\t  if (!encoding) encoding = 'utf8';\n\n\t  while (true) {\n\t    switch (encoding) {\n\t      case 'hex':\n\t        return hexSlice(this, start, end)\n\n\t      case 'utf8':\n\t      case 'utf-8':\n\t        return utf8Slice(this, start, end)\n\n\t      case 'ascii':\n\t        return asciiSlice(this, start, end)\n\n\t      case 'latin1':\n\t      case 'binary':\n\t        return latin1Slice(this, start, end)\n\n\t      case 'base64':\n\t        return base64Slice(this, start, end)\n\n\t      case 'ucs2':\n\t      case 'ucs-2':\n\t      case 'utf16le':\n\t      case 'utf-16le':\n\t        return utf16leSlice(this, start, end)\n\n\t      default:\n\t        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n\t        encoding = (encoding + '').toLowerCase();\n\t        loweredCase = true;\n\t    }\n\t  }\n\t}\n\n\t// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n\t// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n\t// reliably in a browserify context because there could be multiple different\n\t// copies of the 'buffer' package in use. This method works even for Buffer\n\t// instances that were created from another copy of the `buffer` package.\n\t// See: https://github.com/feross/buffer/issues/154\n\tBuffer.prototype._isBuffer = true;\n\n\tfunction swap (b, n, m) {\n\t  const i = b[n];\n\t  b[n] = b[m];\n\t  b[m] = i;\n\t}\n\n\tBuffer.prototype.swap16 = function swap16 () {\n\t  const len = this.length;\n\t  if (len % 2 !== 0) {\n\t    throw new RangeError('Buffer size must be a multiple of 16-bits')\n\t  }\n\t  for (let i = 0; i < len; i += 2) {\n\t    swap(this, i, i + 1);\n\t  }\n\t  return this\n\t};\n\n\tBuffer.prototype.swap32 = function swap32 () {\n\t  const len = this.length;\n\t  if (len % 4 !== 0) {\n\t    throw new RangeError('Buffer size must be a multiple of 32-bits')\n\t  }\n\t  for (let i = 0; i < len; i += 4) {\n\t    swap(this, i, i + 3);\n\t    swap(this, i + 1, i + 2);\n\t  }\n\t  return this\n\t};\n\n\tBuffer.prototype.swap64 = function swap64 () {\n\t  const len = this.length;\n\t  if (len % 8 !== 0) {\n\t    throw new RangeError('Buffer size must be a multiple of 64-bits')\n\t  }\n\t  for (let i = 0; i < len; i += 8) {\n\t    swap(this, i, i + 7);\n\t    swap(this, i + 1, i + 6);\n\t    swap(this, i + 2, i + 5);\n\t    swap(this, i + 3, i + 4);\n\t  }\n\t  return this\n\t};\n\n\tBuffer.prototype.toString = function toString () {\n\t  const length = this.length;\n\t  if (length === 0) return ''\n\t  if (arguments.length === 0) return utf8Slice(this, 0, length)\n\t  return slowToString.apply(this, arguments)\n\t};\n\n\tBuffer.prototype.toLocaleString = Buffer.prototype.toString;\n\n\tBuffer.prototype.equals = function equals (b) {\n\t  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n\t  if (this === b) return true\n\t  return Buffer.compare(this, b) === 0\n\t};\n\n\tBuffer.prototype.inspect = function inspect () {\n\t  let str = '';\n\t  const max = exports.INSPECT_MAX_BYTES;\n\t  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();\n\t  if (this.length > max) str += ' ... ';\n\t  return '<Buffer ' + str + '>'\n\t};\n\tif (customInspectSymbol) {\n\t  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;\n\t}\n\n\tBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n\t  if (isInstance(target, GlobalUint8Array)) {\n\t    target = Buffer.from(target, target.offset, target.byteLength);\n\t  }\n\t  if (!Buffer.isBuffer(target)) {\n\t    throw new TypeError(\n\t      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n\t      'Received type ' + (typeof target)\n\t    )\n\t  }\n\n\t  if (start === undefined) {\n\t    start = 0;\n\t  }\n\t  if (end === undefined) {\n\t    end = target ? target.length : 0;\n\t  }\n\t  if (thisStart === undefined) {\n\t    thisStart = 0;\n\t  }\n\t  if (thisEnd === undefined) {\n\t    thisEnd = this.length;\n\t  }\n\n\t  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n\t    throw new RangeError('out of range index')\n\t  }\n\n\t  if (thisStart >= thisEnd && start >= end) {\n\t    return 0\n\t  }\n\t  if (thisStart >= thisEnd) {\n\t    return -1\n\t  }\n\t  if (start >= end) {\n\t    return 1\n\t  }\n\n\t  start >>>= 0;\n\t  end >>>= 0;\n\t  thisStart >>>= 0;\n\t  thisEnd >>>= 0;\n\n\t  if (this === target) return 0\n\n\t  let x = thisEnd - thisStart;\n\t  let y = end - start;\n\t  const len = Math.min(x, y);\n\n\t  const thisCopy = this.slice(thisStart, thisEnd);\n\t  const targetCopy = target.slice(start, end);\n\n\t  for (let i = 0; i < len; ++i) {\n\t    if (thisCopy[i] !== targetCopy[i]) {\n\t      x = thisCopy[i];\n\t      y = targetCopy[i];\n\t      break\n\t    }\n\t  }\n\n\t  if (x < y) return -1\n\t  if (y < x) return 1\n\t  return 0\n\t};\n\n\t// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n\t// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n\t//\n\t// Arguments:\n\t// - buffer - a Buffer to search\n\t// - val - a string, Buffer, or number\n\t// - byteOffset - an index into `buffer`; will be clamped to an int32\n\t// - encoding - an optional encoding, relevant is val is a string\n\t// - dir - true for indexOf, false for lastIndexOf\n\tfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n\t  // Empty buffer means no match\n\t  if (buffer.length === 0) return -1\n\n\t  // Normalize byteOffset\n\t  if (typeof byteOffset === 'string') {\n\t    encoding = byteOffset;\n\t    byteOffset = 0;\n\t  } else if (byteOffset > 0x7fffffff) {\n\t    byteOffset = 0x7fffffff;\n\t  } else if (byteOffset < -0x80000000) {\n\t    byteOffset = -0x80000000;\n\t  }\n\t  byteOffset = +byteOffset; // Coerce to Number.\n\t  if (numberIsNaN(byteOffset)) {\n\t    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n\t    byteOffset = dir ? 0 : (buffer.length - 1);\n\t  }\n\n\t  // Normalize byteOffset: negative offsets start from the end of the buffer\n\t  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;\n\t  if (byteOffset >= buffer.length) {\n\t    if (dir) return -1\n\t    else byteOffset = buffer.length - 1;\n\t  } else if (byteOffset < 0) {\n\t    if (dir) byteOffset = 0;\n\t    else return -1\n\t  }\n\n\t  // Normalize val\n\t  if (typeof val === 'string') {\n\t    val = Buffer.from(val, encoding);\n\t  }\n\n\t  // Finally, search either indexOf (if dir is true) or lastIndexOf\n\t  if (Buffer.isBuffer(val)) {\n\t    // Special case: looking for empty string/buffer always fails\n\t    if (val.length === 0) {\n\t      return -1\n\t    }\n\t    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n\t  } else if (typeof val === 'number') {\n\t    val = val & 0xFF; // Search for a byte value [0-255]\n\t    if (typeof GlobalUint8Array.prototype.indexOf === 'function') {\n\t      if (dir) {\n\t        return GlobalUint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n\t      } else {\n\t        return GlobalUint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n\t      }\n\t    }\n\t    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)\n\t  }\n\n\t  throw new TypeError('val must be string, number or Buffer')\n\t}\n\n\tfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n\t  let indexSize = 1;\n\t  let arrLength = arr.length;\n\t  let valLength = val.length;\n\n\t  if (encoding !== undefined) {\n\t    encoding = String(encoding).toLowerCase();\n\t    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n\t        encoding === 'utf16le' || encoding === 'utf-16le') {\n\t      if (arr.length < 2 || val.length < 2) {\n\t        return -1\n\t      }\n\t      indexSize = 2;\n\t      arrLength /= 2;\n\t      valLength /= 2;\n\t      byteOffset /= 2;\n\t    }\n\t  }\n\n\t  function read (buf, i) {\n\t    if (indexSize === 1) {\n\t      return buf[i]\n\t    } else {\n\t      return buf.readUInt16BE(i * indexSize)\n\t    }\n\t  }\n\n\t  let i;\n\t  if (dir) {\n\t    let foundIndex = -1;\n\t    for (i = byteOffset; i < arrLength; i++) {\n\t      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n\t        if (foundIndex === -1) foundIndex = i;\n\t        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n\t      } else {\n\t        if (foundIndex !== -1) i -= i - foundIndex;\n\t        foundIndex = -1;\n\t      }\n\t    }\n\t  } else {\n\t    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;\n\t    for (i = byteOffset; i >= 0; i--) {\n\t      let found = true;\n\t      for (let j = 0; j < valLength; j++) {\n\t        if (read(arr, i + j) !== read(val, j)) {\n\t          found = false;\n\t          break\n\t        }\n\t      }\n\t      if (found) return i\n\t    }\n\t  }\n\n\t  return -1\n\t}\n\n\tBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n\t  return this.indexOf(val, byteOffset, encoding) !== -1\n\t};\n\n\tBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n\t  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n\t};\n\n\tBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n\t  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n\t};\n\n\tfunction hexWrite (buf, string, offset, length) {\n\t  offset = Number(offset) || 0;\n\t  const remaining = buf.length - offset;\n\t  if (!length) {\n\t    length = remaining;\n\t  } else {\n\t    length = Number(length);\n\t    if (length > remaining) {\n\t      length = remaining;\n\t    }\n\t  }\n\n\t  const strLen = string.length;\n\n\t  if (length > strLen / 2) {\n\t    length = strLen / 2;\n\t  }\n\t  let i;\n\t  for (i = 0; i < length; ++i) {\n\t    const parsed = parseInt(string.substr(i * 2, 2), 16);\n\t    if (numberIsNaN(parsed)) return i\n\t    buf[offset + i] = parsed;\n\t  }\n\t  return i\n\t}\n\n\tfunction utf8Write (buf, string, offset, length) {\n\t  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n\t}\n\n\tfunction asciiWrite (buf, string, offset, length) {\n\t  return blitBuffer(asciiToBytes(string), buf, offset, length)\n\t}\n\n\tfunction base64Write (buf, string, offset, length) {\n\t  return blitBuffer(base64ToBytes(string), buf, offset, length)\n\t}\n\n\tfunction ucs2Write (buf, string, offset, length) {\n\t  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n\t}\n\n\tBuffer.prototype.write = function write (string, offset, length, encoding) {\n\t  // Buffer#write(string)\n\t  if (offset === undefined) {\n\t    encoding = 'utf8';\n\t    length = this.length;\n\t    offset = 0;\n\t  // Buffer#write(string, encoding)\n\t  } else if (length === undefined && typeof offset === 'string') {\n\t    encoding = offset;\n\t    length = this.length;\n\t    offset = 0;\n\t  // Buffer#write(string, offset[, length][, encoding])\n\t  } else if (isFinite(offset)) {\n\t    offset = offset >>> 0;\n\t    if (isFinite(length)) {\n\t      length = length >>> 0;\n\t      if (encoding === undefined) encoding = 'utf8';\n\t    } else {\n\t      encoding = length;\n\t      length = undefined;\n\t    }\n\t  } else {\n\t    throw new Error(\n\t      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n\t    )\n\t  }\n\n\t  const remaining = this.length - offset;\n\t  if (length === undefined || length > remaining) length = remaining;\n\n\t  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n\t    throw new RangeError('Attempt to write outside buffer bounds')\n\t  }\n\n\t  if (!encoding) encoding = 'utf8';\n\n\t  let loweredCase = false;\n\t  for (;;) {\n\t    switch (encoding) {\n\t      case 'hex':\n\t        return hexWrite(this, string, offset, length)\n\n\t      case 'utf8':\n\t      case 'utf-8':\n\t        return utf8Write(this, string, offset, length)\n\n\t      case 'ascii':\n\t      case 'latin1':\n\t      case 'binary':\n\t        return asciiWrite(this, string, offset, length)\n\n\t      case 'base64':\n\t        // Warning: maxLength not taken into account in base64Write\n\t        return base64Write(this, string, offset, length)\n\n\t      case 'ucs2':\n\t      case 'ucs-2':\n\t      case 'utf16le':\n\t      case 'utf-16le':\n\t        return ucs2Write(this, string, offset, length)\n\n\t      default:\n\t        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n\t        encoding = ('' + encoding).toLowerCase();\n\t        loweredCase = true;\n\t    }\n\t  }\n\t};\n\n\tBuffer.prototype.toJSON = function toJSON () {\n\t  return {\n\t    type: 'Buffer',\n\t    data: Array.prototype.slice.call(this._arr || this, 0)\n\t  }\n\t};\n\n\tfunction base64Slice (buf, start, end) {\n\t  if (start === 0 && end === buf.length) {\n\t    return base64.fromByteArray(buf)\n\t  } else {\n\t    return base64.fromByteArray(buf.slice(start, end))\n\t  }\n\t}\n\n\tfunction utf8Slice (buf, start, end) {\n\t  end = Math.min(buf.length, end);\n\t  const res = [];\n\n\t  let i = start;\n\t  while (i < end) {\n\t    const firstByte = buf[i];\n\t    let codePoint = null;\n\t    let bytesPerSequence = (firstByte > 0xEF)\n\t      ? 4\n\t      : (firstByte > 0xDF)\n\t          ? 3\n\t          : (firstByte > 0xBF)\n\t              ? 2\n\t              : 1;\n\n\t    if (i + bytesPerSequence <= end) {\n\t      let secondByte, thirdByte, fourthByte, tempCodePoint;\n\n\t      switch (bytesPerSequence) {\n\t        case 1:\n\t          if (firstByte < 0x80) {\n\t            codePoint = firstByte;\n\t          }\n\t          break\n\t        case 2:\n\t          secondByte = buf[i + 1];\n\t          if ((secondByte & 0xC0) === 0x80) {\n\t            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);\n\t            if (tempCodePoint > 0x7F) {\n\t              codePoint = tempCodePoint;\n\t            }\n\t          }\n\t          break\n\t        case 3:\n\t          secondByte = buf[i + 1];\n\t          thirdByte = buf[i + 2];\n\t          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n\t            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);\n\t            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n\t              codePoint = tempCodePoint;\n\t            }\n\t          }\n\t          break\n\t        case 4:\n\t          secondByte = buf[i + 1];\n\t          thirdByte = buf[i + 2];\n\t          fourthByte = buf[i + 3];\n\t          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n\t            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);\n\t            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n\t              codePoint = tempCodePoint;\n\t            }\n\t          }\n\t      }\n\t    }\n\n\t    if (codePoint === null) {\n\t      // we did not generate a valid codePoint so insert a\n\t      // replacement char (U+FFFD) and advance only 1 byte\n\t      codePoint = 0xFFFD;\n\t      bytesPerSequence = 1;\n\t    } else if (codePoint > 0xFFFF) {\n\t      // encode to utf16 (surrogate pair dance)\n\t      codePoint -= 0x10000;\n\t      res.push(codePoint >>> 10 & 0x3FF | 0xD800);\n\t      codePoint = 0xDC00 | codePoint & 0x3FF;\n\t    }\n\n\t    res.push(codePoint);\n\t    i += bytesPerSequence;\n\t  }\n\n\t  return decodeCodePointsArray(res)\n\t}\n\n\t// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n\t// the lowest limit is Chrome, with 0x10000 args.\n\t// We go 1 magnitude less, for safety\n\tconst MAX_ARGUMENTS_LENGTH = 0x1000;\n\n\tfunction decodeCodePointsArray (codePoints) {\n\t  const len = codePoints.length;\n\t  if (len <= MAX_ARGUMENTS_LENGTH) {\n\t    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n\t  }\n\n\t  // Decode in chunks to avoid \"call stack size exceeded\".\n\t  let res = '';\n\t  let i = 0;\n\t  while (i < len) {\n\t    res += String.fromCharCode.apply(\n\t      String,\n\t      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n\t    );\n\t  }\n\t  return res\n\t}\n\n\tfunction asciiSlice (buf, start, end) {\n\t  let ret = '';\n\t  end = Math.min(buf.length, end);\n\n\t  for (let i = start; i < end; ++i) {\n\t    ret += String.fromCharCode(buf[i] & 0x7F);\n\t  }\n\t  return ret\n\t}\n\n\tfunction latin1Slice (buf, start, end) {\n\t  let ret = '';\n\t  end = Math.min(buf.length, end);\n\n\t  for (let i = start; i < end; ++i) {\n\t    ret += String.fromCharCode(buf[i]);\n\t  }\n\t  return ret\n\t}\n\n\tfunction hexSlice (buf, start, end) {\n\t  const len = buf.length;\n\n\t  if (!start || start < 0) start = 0;\n\t  if (!end || end < 0 || end > len) end = len;\n\n\t  let out = '';\n\t  for (let i = start; i < end; ++i) {\n\t    out += hexSliceLookupTable[buf[i]];\n\t  }\n\t  return out\n\t}\n\n\tfunction utf16leSlice (buf, start, end) {\n\t  const bytes = buf.slice(start, end);\n\t  let res = '';\n\t  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n\t  for (let i = 0; i < bytes.length - 1; i += 2) {\n\t    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256));\n\t  }\n\t  return res\n\t}\n\n\tBuffer.prototype.slice = function slice (start, end) {\n\t  const len = this.length;\n\t  start = ~~start;\n\t  end = end === undefined ? len : ~~end;\n\n\t  if (start < 0) {\n\t    start += len;\n\t    if (start < 0) start = 0;\n\t  } else if (start > len) {\n\t    start = len;\n\t  }\n\n\t  if (end < 0) {\n\t    end += len;\n\t    if (end < 0) end = 0;\n\t  } else if (end > len) {\n\t    end = len;\n\t  }\n\n\t  if (end < start) end = start;\n\n\t  const newBuf = this.subarray(start, end);\n\t  // Return an augmented `Uint8Array` instance\n\t  Object.setPrototypeOf(newBuf, Buffer.prototype);\n\n\t  return newBuf\n\t};\n\n\t/*\n\t * Need to make sure that buffer isn't trying to write out of bounds.\n\t */\n\tfunction checkOffset (offset, ext, length) {\n\t  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n\t  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n\t}\n\n\tBuffer.prototype.readUintLE =\n\tBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n\t  offset = offset >>> 0;\n\t  byteLength = byteLength >>> 0;\n\t  if (!noAssert) checkOffset(offset, byteLength, this.length);\n\n\t  let val = this[offset];\n\t  let mul = 1;\n\t  let i = 0;\n\t  while (++i < byteLength && (mul *= 0x100)) {\n\t    val += this[offset + i] * mul;\n\t  }\n\n\t  return val\n\t};\n\n\tBuffer.prototype.readUintBE =\n\tBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n\t  offset = offset >>> 0;\n\t  byteLength = byteLength >>> 0;\n\t  if (!noAssert) {\n\t    checkOffset(offset, byteLength, this.length);\n\t  }\n\n\t  let val = this[offset + --byteLength];\n\t  let mul = 1;\n\t  while (byteLength > 0 && (mul *= 0x100)) {\n\t    val += this[offset + --byteLength] * mul;\n\t  }\n\n\t  return val\n\t};\n\n\tBuffer.prototype.readUint8 =\n\tBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkOffset(offset, 1, this.length);\n\t  return this[offset]\n\t};\n\n\tBuffer.prototype.readUint16LE =\n\tBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkOffset(offset, 2, this.length);\n\t  return this[offset] | (this[offset + 1] << 8)\n\t};\n\n\tBuffer.prototype.readUint16BE =\n\tBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkOffset(offset, 2, this.length);\n\t  return (this[offset] << 8) | this[offset + 1]\n\t};\n\n\tBuffer.prototype.readUint32LE =\n\tBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkOffset(offset, 4, this.length);\n\n\t  return ((this[offset]) |\n\t      (this[offset + 1] << 8) |\n\t      (this[offset + 2] << 16)) +\n\t      (this[offset + 3] * 0x1000000)\n\t};\n\n\tBuffer.prototype.readUint32BE =\n\tBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkOffset(offset, 4, this.length);\n\n\t  return (this[offset] * 0x1000000) +\n\t    ((this[offset + 1] << 16) |\n\t    (this[offset + 2] << 8) |\n\t    this[offset + 3])\n\t};\n\n\tBuffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {\n\t  offset = offset >>> 0;\n\t  validateNumber(offset, 'offset');\n\t  const first = this[offset];\n\t  const last = this[offset + 7];\n\t  if (first === undefined || last === undefined) {\n\t    boundsError(offset, this.length - 8);\n\t  }\n\n\t  const lo = first +\n\t    this[++offset] * 2 ** 8 +\n\t    this[++offset] * 2 ** 16 +\n\t    this[++offset] * 2 ** 24;\n\n\t  const hi = this[++offset] +\n\t    this[++offset] * 2 ** 8 +\n\t    this[++offset] * 2 ** 16 +\n\t    last * 2 ** 24;\n\n\t  return BigInt(lo) + (BigInt(hi) << BigInt(32))\n\t});\n\n\tBuffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {\n\t  offset = offset >>> 0;\n\t  validateNumber(offset, 'offset');\n\t  const first = this[offset];\n\t  const last = this[offset + 7];\n\t  if (first === undefined || last === undefined) {\n\t    boundsError(offset, this.length - 8);\n\t  }\n\n\t  const hi = first * 2 ** 24 +\n\t    this[++offset] * 2 ** 16 +\n\t    this[++offset] * 2 ** 8 +\n\t    this[++offset];\n\n\t  const lo = this[++offset] * 2 ** 24 +\n\t    this[++offset] * 2 ** 16 +\n\t    this[++offset] * 2 ** 8 +\n\t    last;\n\n\t  return (BigInt(hi) << BigInt(32)) + BigInt(lo)\n\t});\n\n\tBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n\t  offset = offset >>> 0;\n\t  byteLength = byteLength >>> 0;\n\t  if (!noAssert) checkOffset(offset, byteLength, this.length);\n\n\t  let val = this[offset];\n\t  let mul = 1;\n\t  let i = 0;\n\t  while (++i < byteLength && (mul *= 0x100)) {\n\t    val += this[offset + i] * mul;\n\t  }\n\t  mul *= 0x80;\n\n\t  if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n\n\t  return val\n\t};\n\n\tBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n\t  offset = offset >>> 0;\n\t  byteLength = byteLength >>> 0;\n\t  if (!noAssert) checkOffset(offset, byteLength, this.length);\n\n\t  let i = byteLength;\n\t  let mul = 1;\n\t  let val = this[offset + --i];\n\t  while (i > 0 && (mul *= 0x100)) {\n\t    val += this[offset + --i] * mul;\n\t  }\n\t  mul *= 0x80;\n\n\t  if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n\n\t  return val\n\t};\n\n\tBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkOffset(offset, 1, this.length);\n\t  if (!(this[offset] & 0x80)) return (this[offset])\n\t  return ((0xff - this[offset] + 1) * -1)\n\t};\n\n\tBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkOffset(offset, 2, this.length);\n\t  const val = this[offset] | (this[offset + 1] << 8);\n\t  return (val & 0x8000) ? val | 0xFFFF0000 : val\n\t};\n\n\tBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkOffset(offset, 2, this.length);\n\t  const val = this[offset + 1] | (this[offset] << 8);\n\t  return (val & 0x8000) ? val | 0xFFFF0000 : val\n\t};\n\n\tBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkOffset(offset, 4, this.length);\n\n\t  return (this[offset]) |\n\t    (this[offset + 1] << 8) |\n\t    (this[offset + 2] << 16) |\n\t    (this[offset + 3] << 24)\n\t};\n\n\tBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkOffset(offset, 4, this.length);\n\n\t  return (this[offset] << 24) |\n\t    (this[offset + 1] << 16) |\n\t    (this[offset + 2] << 8) |\n\t    (this[offset + 3])\n\t};\n\n\tBuffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {\n\t  offset = offset >>> 0;\n\t  validateNumber(offset, 'offset');\n\t  const first = this[offset];\n\t  const last = this[offset + 7];\n\t  if (first === undefined || last === undefined) {\n\t    boundsError(offset, this.length - 8);\n\t  }\n\n\t  const val = this[offset + 4] +\n\t    this[offset + 5] * 2 ** 8 +\n\t    this[offset + 6] * 2 ** 16 +\n\t    (last << 24); // Overflow\n\n\t  return (BigInt(val) << BigInt(32)) +\n\t    BigInt(first +\n\t    this[++offset] * 2 ** 8 +\n\t    this[++offset] * 2 ** 16 +\n\t    this[++offset] * 2 ** 24)\n\t});\n\n\tBuffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {\n\t  offset = offset >>> 0;\n\t  validateNumber(offset, 'offset');\n\t  const first = this[offset];\n\t  const last = this[offset + 7];\n\t  if (first === undefined || last === undefined) {\n\t    boundsError(offset, this.length - 8);\n\t  }\n\n\t  const val = (first << 24) + // Overflow\n\t    this[++offset] * 2 ** 16 +\n\t    this[++offset] * 2 ** 8 +\n\t    this[++offset];\n\n\t  return (BigInt(val) << BigInt(32)) +\n\t    BigInt(this[++offset] * 2 ** 24 +\n\t    this[++offset] * 2 ** 16 +\n\t    this[++offset] * 2 ** 8 +\n\t    last)\n\t});\n\n\tBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkOffset(offset, 4, this.length);\n\t  return ieee754$1.read(this, offset, true, 23, 4)\n\t};\n\n\tBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkOffset(offset, 4, this.length);\n\t  return ieee754$1.read(this, offset, false, 23, 4)\n\t};\n\n\tBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkOffset(offset, 8, this.length);\n\t  return ieee754$1.read(this, offset, true, 52, 8)\n\t};\n\n\tBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkOffset(offset, 8, this.length);\n\t  return ieee754$1.read(this, offset, false, 52, 8)\n\t};\n\n\tfunction checkInt (buf, value, offset, ext, max, min) {\n\t  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n\t  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n\t  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n\t}\n\n\tBuffer.prototype.writeUintLE =\n\tBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n\t  value = +value;\n\t  offset = offset >>> 0;\n\t  byteLength = byteLength >>> 0;\n\t  if (!noAssert) {\n\t    const maxBytes = Math.pow(2, 8 * byteLength) - 1;\n\t    checkInt(this, value, offset, byteLength, maxBytes, 0);\n\t  }\n\n\t  let mul = 1;\n\t  let i = 0;\n\t  this[offset] = value & 0xFF;\n\t  while (++i < byteLength && (mul *= 0x100)) {\n\t    this[offset + i] = (value / mul) & 0xFF;\n\t  }\n\n\t  return offset + byteLength\n\t};\n\n\tBuffer.prototype.writeUintBE =\n\tBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n\t  value = +value;\n\t  offset = offset >>> 0;\n\t  byteLength = byteLength >>> 0;\n\t  if (!noAssert) {\n\t    const maxBytes = Math.pow(2, 8 * byteLength) - 1;\n\t    checkInt(this, value, offset, byteLength, maxBytes, 0);\n\t  }\n\n\t  let i = byteLength - 1;\n\t  let mul = 1;\n\t  this[offset + i] = value & 0xFF;\n\t  while (--i >= 0 && (mul *= 0x100)) {\n\t    this[offset + i] = (value / mul) & 0xFF;\n\t  }\n\n\t  return offset + byteLength\n\t};\n\n\tBuffer.prototype.writeUint8 =\n\tBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n\t  value = +value;\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);\n\t  this[offset] = (value & 0xff);\n\t  return offset + 1\n\t};\n\n\tBuffer.prototype.writeUint16LE =\n\tBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n\t  value = +value;\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n\t  this[offset] = (value & 0xff);\n\t  this[offset + 1] = (value >>> 8);\n\t  return offset + 2\n\t};\n\n\tBuffer.prototype.writeUint16BE =\n\tBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n\t  value = +value;\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n\t  this[offset] = (value >>> 8);\n\t  this[offset + 1] = (value & 0xff);\n\t  return offset + 2\n\t};\n\n\tBuffer.prototype.writeUint32LE =\n\tBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n\t  value = +value;\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n\t  this[offset + 3] = (value >>> 24);\n\t  this[offset + 2] = (value >>> 16);\n\t  this[offset + 1] = (value >>> 8);\n\t  this[offset] = (value & 0xff);\n\t  return offset + 4\n\t};\n\n\tBuffer.prototype.writeUint32BE =\n\tBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n\t  value = +value;\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n\t  this[offset] = (value >>> 24);\n\t  this[offset + 1] = (value >>> 16);\n\t  this[offset + 2] = (value >>> 8);\n\t  this[offset + 3] = (value & 0xff);\n\t  return offset + 4\n\t};\n\n\tfunction wrtBigUInt64LE (buf, value, offset, min, max) {\n\t  checkIntBI(value, min, max, buf, offset, 7);\n\n\t  let lo = Number(value & BigInt(0xffffffff));\n\t  buf[offset++] = lo;\n\t  lo = lo >> 8;\n\t  buf[offset++] = lo;\n\t  lo = lo >> 8;\n\t  buf[offset++] = lo;\n\t  lo = lo >> 8;\n\t  buf[offset++] = lo;\n\t  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));\n\t  buf[offset++] = hi;\n\t  hi = hi >> 8;\n\t  buf[offset++] = hi;\n\t  hi = hi >> 8;\n\t  buf[offset++] = hi;\n\t  hi = hi >> 8;\n\t  buf[offset++] = hi;\n\t  return offset\n\t}\n\n\tfunction wrtBigUInt64BE (buf, value, offset, min, max) {\n\t  checkIntBI(value, min, max, buf, offset, 7);\n\n\t  let lo = Number(value & BigInt(0xffffffff));\n\t  buf[offset + 7] = lo;\n\t  lo = lo >> 8;\n\t  buf[offset + 6] = lo;\n\t  lo = lo >> 8;\n\t  buf[offset + 5] = lo;\n\t  lo = lo >> 8;\n\t  buf[offset + 4] = lo;\n\t  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));\n\t  buf[offset + 3] = hi;\n\t  hi = hi >> 8;\n\t  buf[offset + 2] = hi;\n\t  hi = hi >> 8;\n\t  buf[offset + 1] = hi;\n\t  hi = hi >> 8;\n\t  buf[offset] = hi;\n\t  return offset + 8\n\t}\n\n\tBuffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {\n\t  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n\t});\n\n\tBuffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {\n\t  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n\t});\n\n\tBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n\t  value = +value;\n\t  offset = offset >>> 0;\n\t  if (!noAssert) {\n\t    const limit = Math.pow(2, (8 * byteLength) - 1);\n\n\t    checkInt(this, value, offset, byteLength, limit - 1, -limit);\n\t  }\n\n\t  let i = 0;\n\t  let mul = 1;\n\t  let sub = 0;\n\t  this[offset] = value & 0xFF;\n\t  while (++i < byteLength && (mul *= 0x100)) {\n\t    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n\t      sub = 1;\n\t    }\n\t    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;\n\t  }\n\n\t  return offset + byteLength\n\t};\n\n\tBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n\t  value = +value;\n\t  offset = offset >>> 0;\n\t  if (!noAssert) {\n\t    const limit = Math.pow(2, (8 * byteLength) - 1);\n\n\t    checkInt(this, value, offset, byteLength, limit - 1, -limit);\n\t  }\n\n\t  let i = byteLength - 1;\n\t  let mul = 1;\n\t  let sub = 0;\n\t  this[offset + i] = value & 0xFF;\n\t  while (--i >= 0 && (mul *= 0x100)) {\n\t    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n\t      sub = 1;\n\t    }\n\t    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;\n\t  }\n\n\t  return offset + byteLength\n\t};\n\n\tBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n\t  value = +value;\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);\n\t  if (value < 0) value = 0xff + value + 1;\n\t  this[offset] = (value & 0xff);\n\t  return offset + 1\n\t};\n\n\tBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n\t  value = +value;\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n\t  this[offset] = (value & 0xff);\n\t  this[offset + 1] = (value >>> 8);\n\t  return offset + 2\n\t};\n\n\tBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n\t  value = +value;\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n\t  this[offset] = (value >>> 8);\n\t  this[offset + 1] = (value & 0xff);\n\t  return offset + 2\n\t};\n\n\tBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n\t  value = +value;\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n\t  this[offset] = (value & 0xff);\n\t  this[offset + 1] = (value >>> 8);\n\t  this[offset + 2] = (value >>> 16);\n\t  this[offset + 3] = (value >>> 24);\n\t  return offset + 4\n\t};\n\n\tBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n\t  value = +value;\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n\t  if (value < 0) value = 0xffffffff + value + 1;\n\t  this[offset] = (value >>> 24);\n\t  this[offset + 1] = (value >>> 16);\n\t  this[offset + 2] = (value >>> 8);\n\t  this[offset + 3] = (value & 0xff);\n\t  return offset + 4\n\t};\n\n\tBuffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {\n\t  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n\t});\n\n\tBuffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {\n\t  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n\t});\n\n\tfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n\t  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n\t  if (offset < 0) throw new RangeError('Index out of range')\n\t}\n\n\tfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n\t  value = +value;\n\t  offset = offset >>> 0;\n\t  if (!noAssert) {\n\t    checkIEEE754(buf, value, offset, 4);\n\t  }\n\t  ieee754$1.write(buf, value, offset, littleEndian, 23, 4);\n\t  return offset + 4\n\t}\n\n\tBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n\t  return writeFloat(this, value, offset, true, noAssert)\n\t};\n\n\tBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n\t  return writeFloat(this, value, offset, false, noAssert)\n\t};\n\n\tfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n\t  value = +value;\n\t  offset = offset >>> 0;\n\t  if (!noAssert) {\n\t    checkIEEE754(buf, value, offset, 8);\n\t  }\n\t  ieee754$1.write(buf, value, offset, littleEndian, 52, 8);\n\t  return offset + 8\n\t}\n\n\tBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n\t  return writeDouble(this, value, offset, true, noAssert)\n\t};\n\n\tBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n\t  return writeDouble(this, value, offset, false, noAssert)\n\t};\n\n\t// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\n\tBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n\t  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n\t  if (!start) start = 0;\n\t  if (!end && end !== 0) end = this.length;\n\t  if (targetStart >= target.length) targetStart = target.length;\n\t  if (!targetStart) targetStart = 0;\n\t  if (end > 0 && end < start) end = start;\n\n\t  // Copy 0 bytes; we're done\n\t  if (end === start) return 0\n\t  if (target.length === 0 || this.length === 0) return 0\n\n\t  // Fatal error conditions\n\t  if (targetStart < 0) {\n\t    throw new RangeError('targetStart out of bounds')\n\t  }\n\t  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n\t  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n\t  // Are we oob?\n\t  if (end > this.length) end = this.length;\n\t  if (target.length - targetStart < end - start) {\n\t    end = target.length - targetStart + start;\n\t  }\n\n\t  const len = end - start;\n\n\t  if (this === target && typeof GlobalUint8Array.prototype.copyWithin === 'function') {\n\t    // Use built-in when available, missing from IE11\n\t    this.copyWithin(targetStart, start, end);\n\t  } else {\n\t    GlobalUint8Array.prototype.set.call(\n\t      target,\n\t      this.subarray(start, end),\n\t      targetStart\n\t    );\n\t  }\n\n\t  return len\n\t};\n\n\t// Usage:\n\t//    buffer.fill(number[, offset[, end]])\n\t//    buffer.fill(buffer[, offset[, end]])\n\t//    buffer.fill(string[, offset[, end]][, encoding])\n\tBuffer.prototype.fill = function fill (val, start, end, encoding) {\n\t  // Handle string cases:\n\t  if (typeof val === 'string') {\n\t    if (typeof start === 'string') {\n\t      encoding = start;\n\t      start = 0;\n\t      end = this.length;\n\t    } else if (typeof end === 'string') {\n\t      encoding = end;\n\t      end = this.length;\n\t    }\n\t    if (encoding !== undefined && typeof encoding !== 'string') {\n\t      throw new TypeError('encoding must be a string')\n\t    }\n\t    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n\t      throw new TypeError('Unknown encoding: ' + encoding)\n\t    }\n\t    if (val.length === 1) {\n\t      const code = val.charCodeAt(0);\n\t      if ((encoding === 'utf8' && code < 128) ||\n\t          encoding === 'latin1') {\n\t        // Fast path: If `val` fits into a single byte, use that numeric value.\n\t        val = code;\n\t      }\n\t    }\n\t  } else if (typeof val === 'number') {\n\t    val = val & 255;\n\t  } else if (typeof val === 'boolean') {\n\t    val = Number(val);\n\t  }\n\n\t  // Invalid ranges are not set to a default, so can range check early.\n\t  if (start < 0 || this.length < start || this.length < end) {\n\t    throw new RangeError('Out of range index')\n\t  }\n\n\t  if (end <= start) {\n\t    return this\n\t  }\n\n\t  start = start >>> 0;\n\t  end = end === undefined ? this.length : end >>> 0;\n\n\t  if (!val) val = 0;\n\n\t  let i;\n\t  if (typeof val === 'number') {\n\t    for (i = start; i < end; ++i) {\n\t      this[i] = val;\n\t    }\n\t  } else {\n\t    const bytes = Buffer.isBuffer(val)\n\t      ? val\n\t      : Buffer.from(val, encoding);\n\t    const len = bytes.length;\n\t    if (len === 0) {\n\t      throw new TypeError('The value \"' + val +\n\t        '\" is invalid for argument \"value\"')\n\t    }\n\t    for (i = 0; i < end - start; ++i) {\n\t      this[i + start] = bytes[i % len];\n\t    }\n\t  }\n\n\t  return this\n\t};\n\n\t// CUSTOM ERRORS\n\t// =============\n\n\t// Simplified versions from Node, changed for Buffer-only usage\n\tconst errors = {};\n\tfunction E (sym, getMessage, Base) {\n\t  errors[sym] = class NodeError extends Base {\n\t    constructor () {\n\t      super();\n\n\t      Object.defineProperty(this, 'message', {\n\t        value: getMessage.apply(this, arguments),\n\t        writable: true,\n\t        configurable: true\n\t      });\n\n\t      // Add the error code to the name to include it in the stack trace.\n\t      this.name = `${this.name} [${sym}]`;\n\t      // Access the stack to generate the error message including the error code\n\t      // from the name.\n\t      this.stack; // eslint-disable-line no-unused-expressions\n\t      // Reset the name to the actual name.\n\t      delete this.name;\n\t    }\n\n\t    get code () {\n\t      return sym\n\t    }\n\n\t    set code (value) {\n\t      Object.defineProperty(this, 'code', {\n\t        configurable: true,\n\t        enumerable: true,\n\t        value,\n\t        writable: true\n\t      });\n\t    }\n\n\t    toString () {\n\t      return `${this.name} [${sym}]: ${this.message}`\n\t    }\n\t  };\n\t}\n\n\tE('ERR_BUFFER_OUT_OF_BOUNDS',\n\t  function (name) {\n\t    if (name) {\n\t      return `${name} is outside of buffer bounds`\n\t    }\n\n\t    return 'Attempt to access memory outside buffer bounds'\n\t  }, RangeError);\n\tE('ERR_INVALID_ARG_TYPE',\n\t  function (name, actual) {\n\t    return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`\n\t  }, TypeError);\n\tE('ERR_OUT_OF_RANGE',\n\t  function (str, range, input) {\n\t    let msg = `The value of \"${str}\" is out of range.`;\n\t    let received = input;\n\t    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n\t      received = addNumericalSeparator(String(input));\n\t    } else if (typeof input === 'bigint') {\n\t      received = String(input);\n\t      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {\n\t        received = addNumericalSeparator(received);\n\t      }\n\t      received += 'n';\n\t    }\n\t    msg += ` It must be ${range}. Received ${received}`;\n\t    return msg\n\t  }, RangeError);\n\n\tfunction addNumericalSeparator (val) {\n\t  let res = '';\n\t  let i = val.length;\n\t  const start = val[0] === '-' ? 1 : 0;\n\t  for (; i >= start + 4; i -= 3) {\n\t    res = `_${val.slice(i - 3, i)}${res}`;\n\t  }\n\t  return `${val.slice(0, i)}${res}`\n\t}\n\n\t// CHECK FUNCTIONS\n\t// ===============\n\n\tfunction checkBounds (buf, offset, byteLength) {\n\t  validateNumber(offset, 'offset');\n\t  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {\n\t    boundsError(offset, buf.length - (byteLength + 1));\n\t  }\n\t}\n\n\tfunction checkIntBI (value, min, max, buf, offset, byteLength) {\n\t  if (value > max || value < min) {\n\t    const n = typeof min === 'bigint' ? 'n' : '';\n\t    let range;\n\t    if (byteLength > 3) {\n\t      if (min === 0 || min === BigInt(0)) {\n\t        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`;\n\t      } else {\n\t        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +\n\t                `${(byteLength + 1) * 8 - 1}${n}`;\n\t      }\n\t    } else {\n\t      range = `>= ${min}${n} and <= ${max}${n}`;\n\t    }\n\t    throw new errors.ERR_OUT_OF_RANGE('value', range, value)\n\t  }\n\t  checkBounds(buf, offset, byteLength);\n\t}\n\n\tfunction validateNumber (value, name) {\n\t  if (typeof value !== 'number') {\n\t    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)\n\t  }\n\t}\n\n\tfunction boundsError (value, length, type) {\n\t  if (Math.floor(value) !== value) {\n\t    validateNumber(value, type);\n\t    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)\n\t  }\n\n\t  if (length < 0) {\n\t    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()\n\t  }\n\n\t  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',\n\t                                    `>= ${type ? 1 : 0} and <= ${length}`,\n\t                                    value)\n\t}\n\n\t// HELPER FUNCTIONS\n\t// ================\n\n\tconst INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;\n\n\tfunction base64clean (str) {\n\t  // Node takes equal signs as end of the Base64 encoding\n\t  str = str.split('=')[0];\n\t  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n\t  str = str.trim().replace(INVALID_BASE64_RE, '');\n\t  // Node converts strings with length < 2 to ''\n\t  if (str.length < 2) return ''\n\t  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n\t  while (str.length % 4 !== 0) {\n\t    str = str + '=';\n\t  }\n\t  return str\n\t}\n\n\tfunction utf8ToBytes (string, units) {\n\t  units = units || Infinity;\n\t  let codePoint;\n\t  const length = string.length;\n\t  let leadSurrogate = null;\n\t  const bytes = [];\n\n\t  for (let i = 0; i < length; ++i) {\n\t    codePoint = string.charCodeAt(i);\n\n\t    // is surrogate component\n\t    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n\t      // last char was a lead\n\t      if (!leadSurrogate) {\n\t        // no lead yet\n\t        if (codePoint > 0xDBFF) {\n\t          // unexpected trail\n\t          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n\t          continue\n\t        } else if (i + 1 === length) {\n\t          // unpaired lead\n\t          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n\t          continue\n\t        }\n\n\t        // valid lead\n\t        leadSurrogate = codePoint;\n\n\t        continue\n\t      }\n\n\t      // 2 leads in a row\n\t      if (codePoint < 0xDC00) {\n\t        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n\t        leadSurrogate = codePoint;\n\t        continue\n\t      }\n\n\t      // valid surrogate pair\n\t      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;\n\t    } else if (leadSurrogate) {\n\t      // valid bmp char, but last char was a lead\n\t      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n\t    }\n\n\t    leadSurrogate = null;\n\n\t    // encode utf8\n\t    if (codePoint < 0x80) {\n\t      if ((units -= 1) < 0) break\n\t      bytes.push(codePoint);\n\t    } else if (codePoint < 0x800) {\n\t      if ((units -= 2) < 0) break\n\t      bytes.push(\n\t        codePoint >> 0x6 | 0xC0,\n\t        codePoint & 0x3F | 0x80\n\t      );\n\t    } else if (codePoint < 0x10000) {\n\t      if ((units -= 3) < 0) break\n\t      bytes.push(\n\t        codePoint >> 0xC | 0xE0,\n\t        codePoint >> 0x6 & 0x3F | 0x80,\n\t        codePoint & 0x3F | 0x80\n\t      );\n\t    } else if (codePoint < 0x110000) {\n\t      if ((units -= 4) < 0) break\n\t      bytes.push(\n\t        codePoint >> 0x12 | 0xF0,\n\t        codePoint >> 0xC & 0x3F | 0x80,\n\t        codePoint >> 0x6 & 0x3F | 0x80,\n\t        codePoint & 0x3F | 0x80\n\t      );\n\t    } else {\n\t      throw new Error('Invalid code point')\n\t    }\n\t  }\n\n\t  return bytes\n\t}\n\n\tfunction asciiToBytes (str) {\n\t  const byteArray = [];\n\t  for (let i = 0; i < str.length; ++i) {\n\t    // Node's code seems to be doing this and not & 0x7F..\n\t    byteArray.push(str.charCodeAt(i) & 0xFF);\n\t  }\n\t  return byteArray\n\t}\n\n\tfunction utf16leToBytes (str, units) {\n\t  let c, hi, lo;\n\t  const byteArray = [];\n\t  for (let i = 0; i < str.length; ++i) {\n\t    if ((units -= 2) < 0) break\n\n\t    c = str.charCodeAt(i);\n\t    hi = c >> 8;\n\t    lo = c % 256;\n\t    byteArray.push(lo);\n\t    byteArray.push(hi);\n\t  }\n\n\t  return byteArray\n\t}\n\n\tfunction base64ToBytes (str) {\n\t  return base64.toByteArray(base64clean(str))\n\t}\n\n\tfunction blitBuffer (src, dst, offset, length) {\n\t  let i;\n\t  for (i = 0; i < length; ++i) {\n\t    if ((i + offset >= dst.length) || (i >= src.length)) break\n\t    dst[i + offset] = src[i];\n\t  }\n\t  return i\n\t}\n\n\t// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n\t// the `instanceof` check but they should be treated as of that type.\n\t// See: https://github.com/feross/buffer/issues/166\n\tfunction isInstance (obj, type) {\n\t  return obj instanceof type ||\n\t    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n\t      obj.constructor.name === type.name)\n\t}\n\tfunction numberIsNaN (obj) {\n\t  // For IE11 support\n\t  return obj !== obj // eslint-disable-line no-self-compare\n\t}\n\n\t// Create lookup table for `toString('hex')`\n\t// See: https://github.com/feross/buffer/issues/219\n\tconst hexSliceLookupTable = (function () {\n\t  const alphabet = '0123456789abcdef';\n\t  const table = new Array(256);\n\t  for (let i = 0; i < 16; ++i) {\n\t    const i16 = i * 16;\n\t    for (let j = 0; j < 16; ++j) {\n\t      table[i16 + j] = alphabet[i] + alphabet[j];\n\t    }\n\t  }\n\t  return table\n\t})();\n\n\t// Return not function with Error if BigInt not supported\n\tfunction defineBigIntMethod (fn) {\n\t  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn\n\t}\n\n\tfunction BufferBigIntNotDefined () {\n\t  throw new Error('BigInt not supported')\n\t} \n} (buffer));\n\nconst Buffer = buffer.Buffer;\n\nconst Blob = buffer.Blob;\nconst BlobOptions = buffer.BlobOptions;\nconst Buffer$1 = buffer.Buffer;\nconst File = buffer.File;\nconst FileOptions = buffer.FileOptions;\nconst INSPECT_MAX_BYTES = buffer.INSPECT_MAX_BYTES;\nconst SlowBuffer = buffer.SlowBuffer;\nconst TranscodeEncoding = buffer.TranscodeEncoding;\nconst atob = buffer.atob;\nconst btoa = buffer.btoa;\nconst constants = buffer.constants;\nconst isAscii = buffer.isAscii;\nconst isUtf8 = buffer.isUtf8;\nconst kMaxLength = buffer.kMaxLength;\nconst kStringMaxLength = buffer.kStringMaxLength;\nconst resolveObjectURL = buffer.resolveObjectURL;\nconst transcode = buffer.transcode;\nexport { Blob, BlobOptions, Buffer$1 as Buffer, File, FileOptions, INSPECT_MAX_BYTES, SlowBuffer, TranscodeEncoding, atob, btoa, constants, Buffer as default, isAscii, isUtf8, kMaxLength, kStringMaxLength, resolveObjectURL, transcode };\n//# sourceMappingURL=index.js.map\n","export class Bytes {\n\tstatic fromHex(hex: string): Uint8Array {\n\t\thex = hex.trim();\n\t\tif (hex.length === 0) {\n\t\t\treturn new Uint8Array(0);\n\t\t}\n\t\tif (hex.length < 2 || hex.length & 1) {\n\t\t\tthrow new Error('Invalid hex string: odd length.');\n\t\t}\n\t\tif (hex.startsWith('0x') || hex.startsWith('0X')) {\n\t\t\thex = hex.slice(2);\n\t\t}\n\t\tconst match = hex.match(/^[0-9a-fA-F]*$/);\n\t\tif (!match) {\n\t\t\tthrow new Error('Invalid hex string: contains non-hex characters');\n\t\t}\n\t\tconst matches = hex.match(/.{1,2}/g);\n\t\tif (!matches) {\n\t\t\tthrow new Error('Invalid hex string');\n\t\t}\n\t\treturn new Uint8Array(matches.map((byte) => parseInt(byte, 16)));\n\t}\n\n\tstatic toHex(bytes: Uint8Array): string {\n\t\treturn Array.from(bytes, (byte) => byte.toString(16).padStart(2, '0')).join('');\n\t}\n\n\tstatic fromString(str: string): Uint8Array {\n\t\tstr = str.trim();\n\t\treturn new TextEncoder().encode(str);\n\t}\n\n\tstatic toString(bytes: Uint8Array): string {\n\t\treturn new TextDecoder('utf-8').decode(bytes);\n\t}\n\n\tstatic concat(...arrays: Uint8Array[]): Uint8Array {\n\t\tconst totalLength = arrays.reduce((sum, arr) => sum + arr.length, 0);\n\t\tconst result = new Uint8Array(totalLength);\n\t\tlet offset = 0;\n\t\tfor (const arr of arrays) {\n\t\t\tresult.set(arr, offset);\n\t\t\toffset += arr.length;\n\t\t}\n\t\treturn result;\n\t}\n\n\tstatic alloc(size: number): Uint8Array {\n\t\treturn new Uint8Array(size);\n\t}\n\n\tstatic writeBigUint64BE(value: bigint): Uint8Array {\n\t\tconst buffer = new ArrayBuffer(8);\n\t\tnew DataView(buffer).setBigUint64(0, value, false);\n\t\treturn new Uint8Array(buffer);\n\t}\n\n\tstatic toBase64(bytes: Uint8Array): string {\n\t\tif (typeof Buffer !== 'undefined') {\n\t\t\treturn Buffer.from(bytes).toString('base64');\n\t\t}\n\t\t// preventing stack overflow by chunking\n\t\tif (bytes.length > 32768) {\n\t\t\tlet result = '';\n\t\t\tfor (let i = 0; i < bytes.length; i += 32768) {\n\t\t\t\tconst chunk = bytes.slice(i, i + 32768);\n\t\t\t\tresult += btoa(String.fromCharCode(...chunk));\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t\treturn btoa(String.fromCharCode(...bytes));\n\t}\n\n\tstatic fromBase64(base64: string): Uint8Array {\n\t\tbase64 = base64.trim();\n\t\tif (typeof Buffer !== 'undefined') {\n\t\t\treturn new Uint8Array(Buffer.from(base64, 'base64'));\n\t\t}\n\n\t\tlet normalizedBase64 = base64.replace(/-/g, '+').replace(/_/g, '/');\n\t\twhile (normalizedBase64.length % 4) {\n\t\t\tnormalizedBase64 += '=';\n\t\t}\n\t\treturn new Uint8Array([...atob(normalizedBase64)].map((c) => c.charCodeAt(0)));\n\t}\n\n\tstatic equals(a: Uint8Array, b: Uint8Array): boolean {\n\t\tif (a.length !== b.length) return false;\n\t\tlet result = 0;\n\t\tfor (let i = 0; i < a.length; i++) {\n\t\t\tresult |= a[i] ^ b[i];\n\t\t}\n\t\treturn result === 0;\n\t}\n\n\tstatic compare(a: Uint8Array, b: Uint8Array): number {\n\t\tconst minLength = Math.min(a.length, b.length);\n\t\tfor (let i = 0; i < minLength; i++) {\n\t\t\tif (a[i] < b[i]) return -1;\n\t\t\tif (a[i] > b[i]) return 1;\n\t\t}\n\t\treturn a.length - b.length;\n\t}\n}\n","import { bytesToHex } from '@noble/curves/utils.js';\nimport { Bytes } from '../../utils/Bytes';\n\nexport function bytesToNumber(bytes: Uint8Array): bigint {\n\treturn hexToNumber(bytesToHex(bytes));\n}\n\nexport function hexToNumber(hex: string): bigint {\n\treturn BigInt(`0x${hex}`);\n}\n\nexport function encodeBase64toUint8(base64String: string): Uint8Array {\n\treturn Bytes.fromBase64(base64String);\n}\n"],"names":["buffer","base64Js","byteLength","toByteArray","fromByteArray","lookup","revLookup","Arr","code","i","len","getLens","b64","validLen","placeHoldersLen","lens","_byteLength","tmp","arr","curByte","tripletToBase64","num","encodeChunk","uint8","start","end","output","extraBytes","parts","maxChunkLength","len2","ieee754","offset","isLE","mLen","nBytes","e","m","eLen","eMax","eBias","nBits","d","s","value","c","rt","exports","base64","ieee754$1","customInspectSymbol","Buffer","SlowBuffer","K_MAX_LENGTH","GlobalUint8Array","GlobalArrayBuffer","GlobalSharedArrayBuffer","typedArraySupport","proto","createBuffer","length","buf","arg","encodingOrOffset","allocUnsafe","from","fromString","fromArrayView","isInstance","fromArrayBuffer","valueOf","b","fromObject","assertSize","size","alloc","fill","encoding","checked","string","actual","fromArrayLike","array","arrayView","copy","byteOffset","obj","numberIsNaN","a","x","y","list","pos","mustMatch","loweredCase","utf8ToBytes","base64ToBytes","slowToString","hexSlice","utf8Slice","asciiSlice","latin1Slice","base64Slice","utf16leSlice","swap","n","str","max","target","thisStart","thisEnd","thisCopy","targetCopy","bidirectionalIndexOf","val","dir","arrayIndexOf","indexSize","arrLength","valLength","read","foundIndex","found","j","hexWrite","remaining","strLen","parsed","utf8Write","blitBuffer","asciiWrite","asciiToBytes","base64Write","ucs2Write","utf16leToBytes","res","firstByte","codePoint","bytesPerSequence","secondByte","thirdByte","fourthByte","tempCodePoint","decodeCodePointsArray","MAX_ARGUMENTS_LENGTH","codePoints","ret","out","hexSliceLookupTable","bytes","newBuf","checkOffset","ext","noAssert","mul","defineBigIntMethod","validateNumber","first","last","boundsError","lo","hi","checkInt","min","maxBytes","wrtBigUInt64LE","checkIntBI","wrtBigUInt64BE","limit","sub","checkIEEE754","writeFloat","littleEndian","writeDouble","targetStart","errors","E","sym","getMessage","Base","name","range","input","msg","received","addNumericalSeparator","checkBounds","type","INVALID_BASE64_RE","base64clean","units","leadSurrogate","byteArray","src","dst","alphabet","table","i16","fn","BufferBigIntNotDefined","Bytes","hex","matches","byte","arrays","totalLength","sum","result","chunk","normalizedBase64","minLength","bytesToNumber","hexToNumber","bytesToHex","encodeBase64toUint8","base64String"],"mappings":"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"}},
    {"offset": {"line": 2626, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@cashu+cashu-ts@2.9.0/node_modules/@cashu/cashu-ts/lib/crypto/common.es.js","sources":["file:///home/maximoto/dev/sats-rover/node_modules/.pnpm/%40cashu%2Bcashu-ts%402.9.0/node_modules/%40cashu/cashu-ts/src/crypto/common/index.ts"],"sourcesContent":["import { type WeierstrassPoint } from '@noble/curves/abstract/weierstrass.js';\nimport { secp256k1 } from '@noble/curves/secp256k1.js';\nimport { sha256 } from '@noble/hashes/sha2.js';\nimport { bytesToHex, hexToBytes } from '@noble/curves/utils.js';\nimport { bytesToNumber, encodeBase64toUint8, hexToNumber } from '../util/utils';\nimport { Bytes } from '../../utils/Bytes';\n\nexport type Enumerate<N extends number, Acc extends number[] = []> = Acc['length'] extends N\n\t? Acc[number]\n\t: Enumerate<N, [...Acc, Acc['length']]>;\n\nexport type IntRange<F extends number, T extends number> = Exclude<Enumerate<T>, Enumerate<F>>;\n\nexport type MintKeys = { [k: string]: Uint8Array };\n\nexport type SerializedMintKeys = {\n\t[k: string]: string;\n};\n\nexport type Keyset = {\n\tid: string;\n\tunit: string;\n\tactive: boolean;\n};\n\nexport type BlindSignature = {\n\tC_: WeierstrassPoint<bigint>;\n\tamount: number;\n\tid: string;\n};\n\nexport type SerializedBlindSignature = {\n\tC_: string;\n\tamount: number;\n\tid: string;\n};\n\nexport type DLEQ = {\n\ts: Uint8Array; // signature\n\te: Uint8Array; // challenge\n\tr?: bigint; // optional: blinding factor\n};\n\nexport type Proof = {\n\tC: WeierstrassPoint<bigint>;\n\tsecret: Uint8Array;\n\tamount: number;\n\tid: string;\n\twitness?: Witness;\n};\n\nexport type SerializedProof = {\n\tC: string;\n\tsecret: string;\n\tamount: number;\n\tid: string;\n\twitness?: string;\n};\n\nexport type SerializedBlindedMessage = {\n\tB_: string;\n\tamount: number;\n\twitness?: string;\n};\n\nexport type Secret = [WellKnownSecret, SecretData];\n\nexport type WellKnownSecret = 'P2PK';\n\nexport type SecretData = {\n\tnonce: string;\n\tdata: string;\n\ttags?: string[][];\n};\n\nexport type Witness = {\n\tsignatures: string[];\n};\n\nexport type Tags = {\n\t[k: string]: string;\n};\n\nexport type SigFlag = 'SIG_INPUTS' | 'SIG_ALL';\n\nconst DOMAIN_SEPARATOR = hexToBytes('536563703235366b315f48617368546f43757276655f43617368755f');\n\nexport function hashToCurve(secret: Uint8Array): WeierstrassPoint<bigint> {\n\tconst msgToHash = sha256(Bytes.concat(DOMAIN_SEPARATOR, secret));\n\tconst counter = new Uint32Array(1);\n\tconst maxIterations = 2 ** 16;\n\tfor (let i = 0; i < maxIterations; i++) {\n\t\tconst counterBytes = new Uint8Array(counter.buffer);\n\t\tconst hash = sha256(Bytes.concat(msgToHash, counterBytes));\n\t\ttry {\n\t\t\treturn pointFromHex(bytesToHex(Bytes.concat(new Uint8Array([0x02]), hash)));\n\t\t} catch {\n\t\t\tcounter[0]++;\n\t\t}\n\t}\n\tthrow new Error('No valid point found');\n}\n\nexport function hash_e(pubkeys: Array<WeierstrassPoint<bigint>>): Uint8Array {\n\tconst hexStrings = pubkeys.map((p) => p.toHex(false));\n\tconst e_ = hexStrings.join('');\n\treturn sha256(new TextEncoder().encode(e_));\n}\n\nexport function pointFromBytes(bytes: Uint8Array) {\n\treturn secp256k1.Point.fromHex(bytesToHex(bytes));\n}\n\nexport function pointFromHex(hex: string) {\n\treturn secp256k1.Point.fromHex(hex);\n}\n\nexport const getKeysetIdInt = (keysetId: string): bigint => {\n\tlet keysetIdInt: bigint;\n\tif (/^[a-fA-F0-9]+$/.test(keysetId)) {\n\t\tkeysetIdInt = hexToNumber(keysetId) % BigInt(2 ** 31 - 1);\n\t} else {\n\t\t//legacy keyset compatibility\n\t\tkeysetIdInt = bytesToNumber(encodeBase64toUint8(keysetId)) % BigInt(2 ** 31 - 1);\n\t}\n\treturn keysetIdInt;\n};\n\nexport function createRandomPrivateKey() {\n\treturn secp256k1.utils.randomSecretKey();\n}\n\nexport function serializeMintKeys(mintKeys: MintKeys): SerializedMintKeys {\n\tconst serializedMintKeys: SerializedMintKeys = {};\n\tObject.keys(mintKeys).forEach((p) => {\n\t\tserializedMintKeys[p] = bytesToHex(mintKeys[p]);\n\t});\n\treturn serializedMintKeys;\n}\n\nexport function deserializeMintKeys(serializedMintKeys: SerializedMintKeys): MintKeys {\n\tconst mintKeys: MintKeys = {};\n\tObject.keys(serializedMintKeys).forEach((p) => {\n\t\tmintKeys[p] = hexToBytes(serializedMintKeys[p]);\n\t});\n\treturn mintKeys;\n}\n\nexport function deriveKeysetId(keys: MintKeys): string {\n\tconst KEYSET_VERSION = '00';\n\tconst mapBigInt = (k: [string, string]): [bigint, string] => {\n\t\treturn [BigInt(k[0]), k[1]];\n\t};\n\tconst pubkeysConcat = Object.entries(serializeMintKeys(keys))\n\t\t.map(mapBigInt)\n\t\t.sort((a, b) => (a[0] < b[0] ? -1 : a[0] > b[0] ? 1 : 0))\n\t\t.map(([, pubKey]) => hexToBytes(pubKey))\n\t\t.reduce((prev, curr) => mergeUInt8Arrays(prev, curr), new Uint8Array());\n\tconst hash = sha256(pubkeysConcat);\n\tconst hashHex = Bytes.toHex(hash).slice(0, 14);\n\treturn KEYSET_VERSION + hashHex;\n}\n\nfunction mergeUInt8Arrays(a1: Uint8Array, a2: Uint8Array): Uint8Array {\n\t// sum of individual array lengths\n\tconst mergedArray = new Uint8Array(a1.length + a2.length);\n\tmergedArray.set(a1);\n\tmergedArray.set(a2, a1.length);\n\treturn mergedArray;\n}\n"],"names":["DOMAIN_SEPARATOR","hexToBytes","hashToCurve","secret","msgToHash","sha256","Bytes","counter","maxIterations","i","counterBytes","hash","pointFromHex","bytesToHex","hash_e","pubkeys","e_","p","pointFromBytes","bytes","secp256k1","hex","getKeysetIdInt","keysetId","keysetIdInt","hexToNumber","bytesToNumber","encodeBase64toUint8","createRandomPrivateKey","serializeMintKeys","mintKeys","serializedMintKeys","deserializeMintKeys","deriveKeysetId","keys","mapBigInt","k","pubkeysConcat","a","b","pubKey","prev","curr","mergeUInt8Arrays","a1","a2","mergedArray"],"mappings":"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"}},
    {"offset": {"line": 2713, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@cashu+cashu-ts@2.9.0/node_modules/@cashu/cashu-ts/lib/crypto/client/NUT12.es.js","sources":["file:///home/maximoto/dev/sats-rover/node_modules/.pnpm/%40cashu%2Bcashu-ts%402.9.0/node_modules/%40cashu/cashu-ts/src/crypto/client/NUT12.ts"],"sourcesContent":["import { type DLEQ, hash_e, hashToCurve } from '../common/index';\nimport { type WeierstrassPoint } from '@noble/curves/abstract/weierstrass.js';\nimport { secp256k1 } from '@noble/curves/secp256k1.js';\n\nfunction arraysEqual(arr1: Uint8Array, arr2: Uint8Array) {\n\tif (arr1.length !== arr2.length) return false;\n\tfor (let i = 0; i < arr1.length; i++) {\n\t\tif (arr1[i] !== arr2[i]) return false;\n\t}\n\treturn true;\n}\n\nexport const verifyDLEQProof = (\n\tdleq: DLEQ,\n\tB_: WeierstrassPoint<bigint>,\n\tC_: WeierstrassPoint<bigint>,\n\tA: WeierstrassPoint<bigint>,\n) => {\n\tconst s = secp256k1.Point.Fn.fromBytes(dleq.s);\n\tconst e = secp256k1.Point.Fn.fromBytes(dleq.e);\n\tconst sG = secp256k1.Point.BASE.multiply(s);\n\tconst eA = A.multiply(e);\n\tconst sB_ = B_.multiply(s);\n\tconst eC_ = C_.multiply(e);\n\tconst R_1 = sG.subtract(eA); // R1 = sG - eA\n\tconst R_2 = sB_.subtract(eC_); // R2 = sB' - eC'\n\tconst hash = hash_e([R_1, R_2, A, C_]); // e == hash(R1, R2, A, C')\n\treturn arraysEqual(hash, dleq.e);\n};\n\nexport const verifyDLEQProof_reblind = (\n\tsecret: Uint8Array, // secret\n\tdleq: DLEQ,\n\tC: WeierstrassPoint<bigint>, // unblinded e-cash signature point\n\tA: WeierstrassPoint<bigint>, // mint public key point\n) => {\n\tif (dleq.r === undefined) throw new Error('verifyDLEQProof_reblind: Undefined blinding factor');\n\tconst Y = hashToCurve(secret);\n\tconst C_ = C.add(A.multiply(dleq.r)); // Re-blind the e-cash signature\n\tconst bG = secp256k1.Point.BASE.multiply(dleq.r);\n\tconst B_ = Y.add(bG); // Re-blind the message\n\treturn verifyDLEQProof(dleq, B_, C_, A);\n};\n"],"names":["arraysEqual","arr1","arr2","i","verifyDLEQProof","dleq","B_","C_","A","secp256k1","sG","eA","sB_","eC_","R_1","R_2","hash","hash_e","verifyDLEQProof_reblind","secret","C","Y","hashToCurve","bG"],"mappings":";;;;;;;;;;AAIA,SAASA,EAAYC,CAAAA,EAAkBC,CAAAA,EAAkB;IACxD,IAAID,EAAK,MAAA,KAAWC,EAAK,MAAA,CAAQ,CAAA,OAAO,CAAA;IACxC,IAAA,IAASC,IAAI,GAAGA,IAAIF,EAAK,MAAA,EAAQE,IAChC,IAAIF,CAAAA,CAAKE,CAAC,CAAA,KAAMD,CAAAA,CAAKC,CAAC,CAAA,CAAG,CAAA,OAAO,CAAA;IAEjC,OAAO,CAAA;AACR;AAEO,MAAMC,IAAkB,CAC9BC,GACAC,GACAC,GACAC,MACI;IACJ,MAAM,IAAIC,iPAAAA,CAAU,KAAA,CAAM,EAAA,CAAG,SAAA,CAAUJ,EAAK,CAAC,GACvC,IAAII,iPAAAA,CAAU,KAAA,CAAM,EAAA,CAAG,SAAA,CAAUJ,EAAK,CAAC,GACvCK,IAAKD,iPAAAA,CAAU,KAAA,CAAM,IAAA,CAAK,QAAA,CAAS,CAAC,GACpCE,IAAKH,EAAE,QAAA,CAAS,CAAC,GACjBI,IAAMN,EAAG,QAAA,CAAS,CAAC,GACnBO,IAAMN,EAAG,QAAA,CAAS,CAAC,GACnBO,IAAMJ,EAAG,QAAA,CAASC,CAAE,GACpBI,IAAMH,EAAI,QAAA,CAASC,CAAG,GACtBG,QAAOC,uPAAAA,EAAO;QAACH;QAAKC;QAAKP;QAAGD,CAAE;KAAC;IACrC,OAAOP,EAAYgB,GAAMX,EAAK,CAAC;AAChC,GAEaa,IAA0B,CACtCC,GACAd,GACAe,GACAZ,MACI;IACJ,IAAIH,EAAK,CAAA,KAAM,KAAA,EAAW,CAAA,MAAM,IAAI,MAAM,oDAAoD;IAC9F,MAAMgB,QAAIC,4PAAAA,EAAYH,CAAM,GACtBZ,IAAKa,EAAE,GAAA,CAAIZ,EAAE,QAAA,CAASH,EAAK,CAAC,CAAC,GAC7BkB,IAAKd,iPAAAA,CAAU,KAAA,CAAM,IAAA,CAAK,QAAA,CAASJ,EAAK,CAAC,GACzCC,IAAKe,EAAE,GAAA,CAAIE,CAAE;IACnB,OAAOnB,EAAgBC,GAAMC,GAAIC,GAAIC,CAAC;AACvC"}},
    {"offset": {"line": 2747, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@cashu+cashu-ts@2.9.0/node_modules/@cashu/cashu-ts/lib/index-Dm_sS4zv.js","sources":["file:///home/maximoto/dev/sats-rover/node_modules/.pnpm/%40cashu%2Bcashu-ts%402.9.0/node_modules/%40cashu/cashu-ts/node_modules/%40scure/bip32/node_modules/%40noble/hashes/esm/crypto.js","file:///home/maximoto/dev/sats-rover/node_modules/.pnpm/%40cashu%2Bcashu-ts%402.9.0/node_modules/%40cashu/cashu-ts/node_modules/%40scure/bip32/node_modules/%40noble/hashes/esm/utils.js","file:///home/maximoto/dev/sats-rover/node_modules/.pnpm/%40cashu%2Bcashu-ts%402.9.0/node_modules/%40cashu/cashu-ts/node_modules/%40scure/bip32/node_modules/%40noble/curves/esm/utils.js","file:///home/maximoto/dev/sats-rover/node_modules/.pnpm/%40cashu%2Bcashu-ts%402.9.0/node_modules/%40cashu/cashu-ts/node_modules/%40scure/bip32/node_modules/%40noble/curves/esm/abstract/modular.js","file:///home/maximoto/dev/sats-rover/node_modules/.pnpm/%40cashu%2Bcashu-ts%402.9.0/node_modules/%40cashu/cashu-ts/node_modules/%40scure/bip32/node_modules/%40noble/hashes/esm/_md.js","file:///home/maximoto/dev/sats-rover/node_modules/.pnpm/%40cashu%2Bcashu-ts%402.9.0/node_modules/%40cashu/cashu-ts/node_modules/%40scure/bip32/node_modules/%40noble/hashes/esm/_u64.js","file:///home/maximoto/dev/sats-rover/node_modules/.pnpm/%40cashu%2Bcashu-ts%402.9.0/node_modules/%40cashu/cashu-ts/node_modules/%40scure/bip32/node_modules/%40noble/hashes/esm/sha2.js","file:///home/maximoto/dev/sats-rover/node_modules/.pnpm/%40cashu%2Bcashu-ts%402.9.0/node_modules/%40cashu/cashu-ts/node_modules/%40scure/bip32/node_modules/%40noble/hashes/esm/hmac.js","file:///home/maximoto/dev/sats-rover/node_modules/.pnpm/%40cashu%2Bcashu-ts%402.9.0/node_modules/%40cashu/cashu-ts/node_modules/%40scure/bip32/node_modules/%40noble/curves/esm/abstract/curve.js","file:///home/maximoto/dev/sats-rover/node_modules/.pnpm/%40cashu%2Bcashu-ts%402.9.0/node_modules/%40cashu/cashu-ts/node_modules/%40scure/bip32/node_modules/%40noble/curves/esm/abstract/weierstrass.js","file:///home/maximoto/dev/sats-rover/node_modules/.pnpm/%40cashu%2Bcashu-ts%402.9.0/node_modules/%40cashu/cashu-ts/node_modules/%40scure/bip32/node_modules/%40noble/curves/esm/_shortw_utils.js","file:///home/maximoto/dev/sats-rover/node_modules/.pnpm/%40cashu%2Bcashu-ts%402.9.0/node_modules/%40cashu/cashu-ts/node_modules/%40scure/bip32/node_modules/%40noble/curves/esm/secp256k1.js","file:///home/maximoto/dev/sats-rover/node_modules/.pnpm/%40cashu%2Bcashu-ts%402.9.0/node_modules/%40cashu/cashu-ts/node_modules/%40scure/bip32/node_modules/%40noble/hashes/esm/legacy.js","file:///home/maximoto/dev/sats-rover/node_modules/.pnpm/%40cashu%2Bcashu-ts%402.9.0/node_modules/%40cashu/cashu-ts/node_modules/%40scure/base/lib/esm/index.js","file:///home/maximoto/dev/sats-rover/node_modules/.pnpm/%40cashu%2Bcashu-ts%402.9.0/node_modules/%40cashu/cashu-ts/node_modules/%40scure/bip32/lib/esm/index.js"],"sourcesContent":["export const crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\n//# sourceMappingURL=crypto.js.map","/**\n * Utilities for hex, bytes, CSPRNG.\n * @module\n */\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\nimport { crypto } from '@noble/hashes/crypto';\n/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */\nexport function isBytes(a) {\n    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n/** Asserts something is positive integer. */\nexport function anumber(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error('positive integer expected, got ' + n);\n}\n/** Asserts something is Uint8Array. */\nexport function abytes(b, ...lengths) {\n    if (!isBytes(b))\n        throw new Error('Uint8Array expected');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);\n}\n/** Asserts something is hash */\nexport function ahash(h) {\n    if (typeof h !== 'function' || typeof h.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.createHasher');\n    anumber(h.outputLen);\n    anumber(h.blockLen);\n}\n/** Asserts a hash instance has not been destroyed / finished */\nexport function aexists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\n/** Asserts output is properly-sized byte array */\nexport function aoutput(out, instance) {\n    abytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error('digestInto() expects output buffer of length at least ' + min);\n    }\n}\n/** Cast u8 / u16 / u32 to u8. */\nexport function u8(arr) {\n    return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n/** Cast u8 / u16 / u32 to u32. */\nexport function u32(arr) {\n    return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n}\n/** Zeroize a byte array. Warning: JS provides no guarantees. */\nexport function clean(...arrays) {\n    for (let i = 0; i < arrays.length; i++) {\n        arrays[i].fill(0);\n    }\n}\n/** Create DataView of an array for easy byte-level manipulation. */\nexport function createView(arr) {\n    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n/** The rotate right (circular right shift) operation for uint32 */\nexport function rotr(word, shift) {\n    return (word << (32 - shift)) | (word >>> shift);\n}\n/** The rotate left (circular left shift) operation for uint32 */\nexport function rotl(word, shift) {\n    return (word << shift) | ((word >>> (32 - shift)) >>> 0);\n}\n/** Is current platform little-endian? Most are. Big-Endian platform: IBM */\nexport const isLE = /* @__PURE__ */ (() => new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();\n/** The byte swap operation for uint32 */\nexport function byteSwap(word) {\n    return (((word << 24) & 0xff000000) |\n        ((word << 8) & 0xff0000) |\n        ((word >>> 8) & 0xff00) |\n        ((word >>> 24) & 0xff));\n}\n/** Conditionally byte swap if on a big-endian platform */\nexport const swap8IfBE = isLE\n    ? (n) => n\n    : (n) => byteSwap(n);\n/** @deprecated */\nexport const byteSwapIfBE = swap8IfBE;\n/** In place byte swap for Uint32Array */\nexport function byteSwap32(arr) {\n    for (let i = 0; i < arr.length; i++) {\n        arr[i] = byteSwap(arr[i]);\n    }\n    return arr;\n}\nexport const swap32IfBE = isLE\n    ? (u) => u\n    : byteSwap32;\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\nconst hasHexBuiltin = /* @__PURE__ */ (() => \n// @ts-ignore\ntypeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function')();\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * Convert byte array to hex string. Uses built-in function, when available.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes) {\n    abytes(bytes);\n    // @ts-ignore\n    if (hasHexBuiltin)\n        return bytes.toHex();\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };\nfunction asciiToBase16(ch) {\n    if (ch >= asciis._0 && ch <= asciis._9)\n        return ch - asciis._0; // '2' => 50-48\n    if (ch >= asciis.A && ch <= asciis.F)\n        return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n    if (ch >= asciis.a && ch <= asciis.f)\n        return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n    return;\n}\n/**\n * Convert hex string to byte array. Uses built-in function, when available.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    // @ts-ignore\n    if (hasHexBuiltin)\n        return Uint8Array.fromHex(hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n    }\n    return array;\n}\n/**\n * There is no setImmediate in browser and setTimeout is slow.\n * Call of async fn will return Promise, which will be fullfiled only on\n * next scheduler queue processing step and this is exactly what we need.\n */\nexport const nextTick = async () => { };\n/** Returns control to thread each 'tick' ms to avoid blocking. */\nexport async function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * Converts string to bytes using UTF8 encoding.\n * @example utf8ToBytes('abc') // Uint8Array.from([97, 98, 99])\n */\nexport function utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error('string expected');\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Converts bytes to string using UTF8 encoding.\n * @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'\n */\nexport function bytesToUtf8(bytes) {\n    return new TextDecoder().decode(bytes);\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    abytes(data);\n    return data;\n}\n/**\n * Helper for KDFs: consumes uint8array or string.\n * When string is passed, does utf8 decoding, using TextDecoder.\n */\nexport function kdfInputToBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    abytes(data);\n    return data;\n}\n/** Copies several Uint8Arrays into one. */\nexport function concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        abytes(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\nexport function checkOpts(defaults, opts) {\n    if (opts !== undefined && {}.toString.call(opts) !== '[object Object]')\n        throw new Error('options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\n/** For runtime check if class implements interface */\nexport class Hash {\n}\n/** Wraps hash function, creating an interface on top of it */\nexport function createHasher(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nexport function createOptHasher(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nexport function createXOFer(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nexport const wrapConstructor = createHasher;\nexport const wrapConstructorWithOpts = createOptHasher;\nexport const wrapXOFConstructorWithOpts = createXOFer;\n/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */\nexport function randomBytes(bytesLength = 32) {\n    if (crypto && typeof crypto.getRandomValues === 'function') {\n        return crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    // Legacy Node.js compatibility\n    if (crypto && typeof crypto.randomBytes === 'function') {\n        return Uint8Array.from(crypto.randomBytes(bytesLength));\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\n//# sourceMappingURL=utils.js.map","/**\n * Hex, bytes and number utilities.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { abytes as abytes_, bytesToHex as bytesToHex_, concatBytes as concatBytes_, hexToBytes as hexToBytes_, isBytes as isBytes_, } from '@noble/hashes/utils.js';\nexport { abytes, anumber, bytesToHex, bytesToUtf8, concatBytes, hexToBytes, isBytes, randomBytes, utf8ToBytes, } from '@noble/hashes/utils.js';\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nexport function abool(title, value) {\n    if (typeof value !== 'boolean')\n        throw new Error(title + ' boolean expected, got ' + value);\n}\n// tmp name until v2\nexport function _abool2(value, title = '') {\n    if (typeof value !== 'boolean') {\n        const prefix = title && `\"${title}\"`;\n        throw new Error(prefix + 'expected boolean, got type=' + typeof value);\n    }\n    return value;\n}\n// tmp name until v2\n/** Asserts something is Uint8Array. */\nexport function _abytes2(value, length, title = '') {\n    const bytes = isBytes_(value);\n    const len = value?.length;\n    const needsLen = length !== undefined;\n    if (!bytes || (needsLen && len !== length)) {\n        const prefix = title && `\"${title}\" `;\n        const ofLen = needsLen ? ` of length ${length}` : '';\n        const got = bytes ? `length=${len}` : `type=${typeof value}`;\n        throw new Error(prefix + 'expected Uint8Array' + ofLen + ', got ' + got);\n    }\n    return value;\n}\n// Used in weierstrass, der\nexport function numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? '0' + hex : hex;\n}\nexport function hexToNumber(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    return hex === '' ? _0n : BigInt('0x' + hex); // Big Endian\n}\n// BE: Big Endian, LE: Little Endian\nexport function bytesToNumberBE(bytes) {\n    return hexToNumber(bytesToHex_(bytes));\n}\nexport function bytesToNumberLE(bytes) {\n    abytes_(bytes);\n    return hexToNumber(bytesToHex_(Uint8Array.from(bytes).reverse()));\n}\nexport function numberToBytesBE(n, len) {\n    return hexToBytes_(n.toString(16).padStart(len * 2, '0'));\n}\nexport function numberToBytesLE(n, len) {\n    return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nexport function numberToVarBytesBE(n) {\n    return hexToBytes_(numberToHexUnpadded(n));\n}\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'secret key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */\nexport function ensureBytes(title, hex, expectedLength) {\n    let res;\n    if (typeof hex === 'string') {\n        try {\n            res = hexToBytes_(hex);\n        }\n        catch (e) {\n            throw new Error(title + ' must be hex string or Uint8Array, cause: ' + e);\n        }\n    }\n    else if (isBytes_(hex)) {\n        // Uint8Array.from() instead of hash.slice() because node.js Buffer\n        // is instance of Uint8Array, and its slice() creates **mutable** copy\n        res = Uint8Array.from(hex);\n    }\n    else {\n        throw new Error(title + ' must be hex string or Uint8Array');\n    }\n    const len = res.length;\n    if (typeof expectedLength === 'number' && len !== expectedLength)\n        throw new Error(title + ' of length ' + expectedLength + ' expected, got ' + len);\n    return res;\n}\n// Compares 2 u8a-s in kinda constant time\nexport function equalBytes(a, b) {\n    if (a.length !== b.length)\n        return false;\n    let diff = 0;\n    for (let i = 0; i < a.length; i++)\n        diff |= a[i] ^ b[i];\n    return diff === 0;\n}\n/**\n * Copies Uint8Array. We can't use u8a.slice(), because u8a can be Buffer,\n * and Buffer#slice creates mutable copy. Never use Buffers!\n */\nexport function copyBytes(bytes) {\n    return Uint8Array.from(bytes);\n}\n/**\n * Decodes 7-bit ASCII string to Uint8Array, throws on non-ascii symbols\n * Should be safe to use for things expected to be ASCII.\n * Returns exact same result as utf8ToBytes for ASCII or throws.\n */\nexport function asciiToBytes(ascii) {\n    return Uint8Array.from(ascii, (c, i) => {\n        const charCode = c.charCodeAt(0);\n        if (c.length !== 1 || charCode > 127) {\n            throw new Error(`string contains non-ASCII character \"${ascii[i]}\" with code ${charCode} at position ${i}`);\n        }\n        return charCode;\n    });\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\n// export const utf8ToBytes: typeof utf8ToBytes_ = utf8ToBytes_;\n/**\n * Converts bytes to string using UTF8 encoding.\n * @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'\n */\n// export const bytesToUtf8: typeof bytesToUtf8_ = bytesToUtf8_;\n// Is positive bigint\nconst isPosBig = (n) => typeof n === 'bigint' && _0n <= n;\nexport function inRange(n, min, max) {\n    return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;\n}\n/**\n * Asserts min <= n < max. NOTE: It's < max and not <= max.\n * @example\n * aInRange('x', x, 1n, 256n); // would assume x is in (1n..255n)\n */\nexport function aInRange(title, n, min, max) {\n    // Why min <= n < max and not a (min < n < max) OR b (min <= n <= max)?\n    // consider P=256n, min=0n, max=P\n    // - a for min=0 would require -1:          `inRange('x', x, -1n, P)`\n    // - b would commonly require subtraction:  `inRange('x', x, 0n, P - 1n)`\n    // - our way is the cleanest:               `inRange('x', x, 0n, P)\n    if (!inRange(n, min, max))\n        throw new Error('expected valid ' + title + ': ' + min + ' <= n < ' + max + ', got ' + n);\n}\n// Bit operations\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n * TODO: merge with nLength in modular\n */\nexport function bitLen(n) {\n    let len;\n    for (len = 0; n > _0n; n >>= _1n, len += 1)\n        ;\n    return len;\n}\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */\nexport function bitGet(n, pos) {\n    return (n >> BigInt(pos)) & _1n;\n}\n/**\n * Sets single bit at position.\n */\nexport function bitSet(n, pos, value) {\n    return n | ((value ? _1n : _0n) << BigInt(pos));\n}\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */\nexport const bitMask = (n) => (_1n << BigInt(n)) - _1n;\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */\nexport function createHmacDrbg(hashLen, qByteLen, hmacFn) {\n    if (typeof hashLen !== 'number' || hashLen < 2)\n        throw new Error('hashLen must be a number');\n    if (typeof qByteLen !== 'number' || qByteLen < 2)\n        throw new Error('qByteLen must be a number');\n    if (typeof hmacFn !== 'function')\n        throw new Error('hmacFn must be a function');\n    // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n    const u8n = (len) => new Uint8Array(len); // creates Uint8Array\n    const u8of = (byte) => Uint8Array.of(byte); // another shortcut\n    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n    let i = 0; // Iterations counter, will throw when over 1000\n    const reset = () => {\n        v.fill(1);\n        k.fill(0);\n        i = 0;\n    };\n    const h = (...b) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n    const reseed = (seed = u8n(0)) => {\n        // HMAC-DRBG reseed() function. Steps D-G\n        k = h(u8of(0x00), seed); // k = hmac(k || v || 0x00 || seed)\n        v = h(); // v = hmac(k || v)\n        if (seed.length === 0)\n            return;\n        k = h(u8of(0x01), seed); // k = hmac(k || v || 0x01 || seed)\n        v = h(); // v = hmac(k || v)\n    };\n    const gen = () => {\n        // HMAC-DRBG generate() function\n        if (i++ >= 1000)\n            throw new Error('drbg: tried 1000 values');\n        let len = 0;\n        const out = [];\n        while (len < qByteLen) {\n            v = h();\n            const sl = v.slice();\n            out.push(sl);\n            len += v.length;\n        }\n        return concatBytes_(...out);\n    };\n    const genUntil = (seed, pred) => {\n        reset();\n        reseed(seed); // Steps D-G\n        let res = undefined; // Step H: grind until k is in [1..n-1]\n        while (!(res = pred(gen())))\n            reseed();\n        reset();\n        return res;\n    };\n    return genUntil;\n}\n// Validating curves and fields\nconst validatorFns = {\n    bigint: (val) => typeof val === 'bigint',\n    function: (val) => typeof val === 'function',\n    boolean: (val) => typeof val === 'boolean',\n    string: (val) => typeof val === 'string',\n    stringOrUint8Array: (val) => typeof val === 'string' || isBytes_(val),\n    isSafeInteger: (val) => Number.isSafeInteger(val),\n    array: (val) => Array.isArray(val),\n    field: (val, object) => object.Fp.isValid(val),\n    hash: (val) => typeof val === 'function' && Number.isSafeInteger(val.outputLen),\n};\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\nexport function validateObject(object, validators, optValidators = {}) {\n    const checkField = (fieldName, type, isOptional) => {\n        const checkVal = validatorFns[type];\n        if (typeof checkVal !== 'function')\n            throw new Error('invalid validator function');\n        const val = object[fieldName];\n        if (isOptional && val === undefined)\n            return;\n        if (!checkVal(val, object)) {\n            throw new Error('param ' + String(fieldName) + ' is invalid. Expected ' + type + ', got ' + val);\n        }\n    };\n    for (const [fieldName, type] of Object.entries(validators))\n        checkField(fieldName, type, false);\n    for (const [fieldName, type] of Object.entries(optValidators))\n        checkField(fieldName, type, true);\n    return object;\n}\n// validate type tests\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n// // Should fail type-check\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\nexport function isHash(val) {\n    return typeof val === 'function' && Number.isSafeInteger(val.outputLen);\n}\nexport function _validateObject(object, fields, optFields = {}) {\n    if (!object || typeof object !== 'object')\n        throw new Error('expected valid options object');\n    function checkField(fieldName, expectedType, isOpt) {\n        const val = object[fieldName];\n        if (isOpt && val === undefined)\n            return;\n        const current = typeof val;\n        if (current !== expectedType || val === null)\n            throw new Error(`param \"${fieldName}\" is invalid: expected ${expectedType}, got ${current}`);\n    }\n    Object.entries(fields).forEach(([k, v]) => checkField(k, v, false));\n    Object.entries(optFields).forEach(([k, v]) => checkField(k, v, true));\n}\n/**\n * throws not implemented error\n */\nexport const notImplemented = () => {\n    throw new Error('not implemented');\n};\n/**\n * Memoizes (caches) computation result.\n * Uses WeakMap: the value is going auto-cleaned by GC after last reference is removed.\n */\nexport function memoized(fn) {\n    const map = new WeakMap();\n    return (arg, ...args) => {\n        const val = map.get(arg);\n        if (val !== undefined)\n            return val;\n        const computed = fn(arg, ...args);\n        map.set(arg, computed);\n        return computed;\n    };\n}\n//# sourceMappingURL=utils.js.map","/**\n * Utils for modular division and fields.\n * Field over 11 is a finite (Galois) field is integer number operations `mod 11`.\n * There is no division: it is replaced by modular multiplicative inverse.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { _validateObject, anumber, bitMask, bytesToNumberBE, bytesToNumberLE, ensureBytes, numberToBytesBE, numberToBytesLE, } from \"../utils.js\";\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = /* @__PURE__ */ BigInt(2), _3n = /* @__PURE__ */ BigInt(3);\n// prettier-ignore\nconst _4n = /* @__PURE__ */ BigInt(4), _5n = /* @__PURE__ */ BigInt(5), _7n = /* @__PURE__ */ BigInt(7);\n// prettier-ignore\nconst _8n = /* @__PURE__ */ BigInt(8), _9n = /* @__PURE__ */ BigInt(9), _16n = /* @__PURE__ */ BigInt(16);\n// Calculates a modulo b\nexport function mod(a, b) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */\nexport function pow(num, power, modulo) {\n    return FpPow(Field(modulo), num, power);\n}\n/** Does `x^(2^power)` mod p. `pow2(30, 4)` == `30^(2^4)` */\nexport function pow2(x, power, modulo) {\n    let res = x;\n    while (power-- > _0n) {\n        res *= res;\n        res %= modulo;\n    }\n    return res;\n}\n/**\n * Inverses number over modulo.\n * Implemented using [Euclidean GCD](https://brilliant.org/wiki/extended-euclidean-algorithm/).\n */\nexport function invert(number, modulo) {\n    if (number === _0n)\n        throw new Error('invert: expected non-zero number');\n    if (modulo <= _0n)\n        throw new Error('invert: expected positive modulus, got ' + modulo);\n    // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n    let a = mod(number, modulo);\n    let b = modulo;\n    // prettier-ignore\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while (a !== _0n) {\n        // JIT applies optimization if those two lines follow each other\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        // prettier-ignore\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n)\n        throw new Error('invert: does not exist');\n    return mod(x, modulo);\n}\nfunction assertIsSquare(Fp, root, n) {\n    if (!Fp.eql(Fp.sqr(root), n))\n        throw new Error('Cannot find square root');\n}\n// Not all roots are possible! Example which will throw:\n// const NUM =\n// n = 72057594037927816n;\n// Fp = Field(BigInt('0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab'));\nfunction sqrt3mod4(Fp, n) {\n    const p1div4 = (Fp.ORDER + _1n) / _4n;\n    const root = Fp.pow(n, p1div4);\n    assertIsSquare(Fp, root, n);\n    return root;\n}\nfunction sqrt5mod8(Fp, n) {\n    const p5div8 = (Fp.ORDER - _5n) / _8n;\n    const n2 = Fp.mul(n, _2n);\n    const v = Fp.pow(n2, p5div8);\n    const nv = Fp.mul(n, v);\n    const i = Fp.mul(Fp.mul(nv, _2n), v);\n    const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n    assertIsSquare(Fp, root, n);\n    return root;\n}\n// Based on RFC9380, Kong algorithm\n// prettier-ignore\nfunction sqrt9mod16(P) {\n    const Fp_ = Field(P);\n    const tn = tonelliShanks(P);\n    const c1 = tn(Fp_, Fp_.neg(Fp_.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n    const c2 = tn(Fp_, c1); //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n    const c3 = tn(Fp_, Fp_.neg(c1)); //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n    const c4 = (P + _7n) / _16n; //  4. c4 = (q + 7) / 16        # Integer arithmetic\n    return (Fp, n) => {\n        let tv1 = Fp.pow(n, c4); //  1. tv1 = x^c4\n        let tv2 = Fp.mul(tv1, c1); //  2. tv2 = c1 * tv1\n        const tv3 = Fp.mul(tv1, c2); //  3. tv3 = c2 * tv1\n        const tv4 = Fp.mul(tv1, c3); //  4. tv4 = c3 * tv1\n        const e1 = Fp.eql(Fp.sqr(tv2), n); //  5.  e1 = (tv2^2) == x\n        const e2 = Fp.eql(Fp.sqr(tv3), n); //  6.  e2 = (tv3^2) == x\n        tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n        tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n        const e3 = Fp.eql(Fp.sqr(tv2), n); //  9.  e3 = (tv2^2) == x\n        const root = Fp.cmov(tv1, tv2, e3); // 10.  z = CMOV(tv1, tv2, e3)   # Select sqrt from tv1 & tv2\n        assertIsSquare(Fp, root, n);\n        return root;\n    };\n}\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */\nexport function tonelliShanks(P) {\n    // Initialization (precomputation).\n    // Caching initialization could boost perf by 7%.\n    if (P < _3n)\n        throw new Error('sqrt is not defined for small field');\n    // Factor P - 1 = Q * 2^S, where Q is odd\n    let Q = P - _1n;\n    let S = 0;\n    while (Q % _2n === _0n) {\n        Q /= _2n;\n        S++;\n    }\n    // Find the first quadratic non-residue Z >= 2\n    let Z = _2n;\n    const _Fp = Field(P);\n    while (FpLegendre(_Fp, Z) === 1) {\n        // Basic primality test for P. After x iterations, chance of\n        // not finding quadratic non-residue is 2^x, so 2^1000.\n        if (Z++ > 1000)\n            throw new Error('Cannot find square root: probably non-prime P');\n    }\n    // Fast-path; usually done before Z, but we do \"primality test\".\n    if (S === 1)\n        return sqrt3mod4;\n    // Slow-path\n    // TODO: test on Fp2 and others\n    let cc = _Fp.pow(Z, Q); // c = z^Q\n    const Q1div2 = (Q + _1n) / _2n;\n    return function tonelliSlow(Fp, n) {\n        if (Fp.is0(n))\n            return n;\n        // Check if n is a quadratic residue using Legendre symbol\n        if (FpLegendre(Fp, n) !== 1)\n            throw new Error('Cannot find square root');\n        // Initialize variables for the main loop\n        let M = S;\n        let c = Fp.mul(Fp.ONE, cc); // c = z^Q, move cc from field _Fp into field Fp\n        let t = Fp.pow(n, Q); // t = n^Q, first guess at the fudge factor\n        let R = Fp.pow(n, Q1div2); // R = n^((Q+1)/2), first guess at the square root\n        // Main loop\n        // while t != 1\n        while (!Fp.eql(t, Fp.ONE)) {\n            if (Fp.is0(t))\n                return Fp.ZERO; // if t=0 return R=0\n            let i = 1;\n            // Find the smallest i >= 1 such that t^(2^i)  1 (mod P)\n            let t_tmp = Fp.sqr(t); // t^(2^1)\n            while (!Fp.eql(t_tmp, Fp.ONE)) {\n                i++;\n                t_tmp = Fp.sqr(t_tmp); // t^(2^2)...\n                if (i === M)\n                    throw new Error('Cannot find square root');\n            }\n            // Calculate the exponent for b: 2^(M - i - 1)\n            const exponent = _1n << BigInt(M - i - 1); // bigint is important\n            const b = Fp.pow(c, exponent); // b = 2^(M - i - 1)\n            // Update variables\n            M = i;\n            c = Fp.sqr(b); // c = b^2\n            t = Fp.mul(t, c); // t = (t * b^2)\n            R = Fp.mul(R, b); // R = R*b\n        }\n        return R;\n    };\n}\n/**\n * Square root for a finite field. Will try optimized versions first:\n *\n * 1. P  3 (mod 4)\n * 2. P  5 (mod 8)\n * 3. P  9 (mod 16)\n * 4. Tonelli-Shanks algorithm\n *\n * Different algorithms can give different roots, it is up to user to decide which one they want.\n * For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n */\nexport function FpSqrt(P) {\n    // P  3 (mod 4) => n = n^((P+1)/4)\n    if (P % _4n === _3n)\n        return sqrt3mod4;\n    // P  5 (mod 8) => Atkin algorithm, page 10 of https://eprint.iacr.org/2012/685.pdf\n    if (P % _8n === _5n)\n        return sqrt5mod8;\n    // P  9 (mod 16) => Kong algorithm, page 11 of https://eprint.iacr.org/2012/685.pdf (algorithm 4)\n    if (P % _16n === _9n)\n        return sqrt9mod16(P);\n    // Tonelli-Shanks algorithm\n    return tonelliShanks(P);\n}\n// Little-endian check for first LE bit (last BE bit);\nexport const isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;\n// prettier-ignore\nconst FIELD_FIELDS = [\n    'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',\n    'eql', 'add', 'sub', 'mul', 'pow', 'div',\n    'addN', 'subN', 'mulN', 'sqrN'\n];\nexport function validateField(field) {\n    const initial = {\n        ORDER: 'bigint',\n        MASK: 'bigint',\n        BYTES: 'number',\n        BITS: 'number',\n    };\n    const opts = FIELD_FIELDS.reduce((map, val) => {\n        map[val] = 'function';\n        return map;\n    }, initial);\n    _validateObject(field, opts);\n    // const max = 16384;\n    // if (field.BYTES < 1 || field.BYTES > max) throw new Error('invalid field');\n    // if (field.BITS < 1 || field.BITS > 8 * max) throw new Error('invalid field');\n    return field;\n}\n// Generic field functions\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */\nexport function FpPow(Fp, num, power) {\n    if (power < _0n)\n        throw new Error('invalid exponent, negatives unsupported');\n    if (power === _0n)\n        return Fp.ONE;\n    if (power === _1n)\n        return num;\n    let p = Fp.ONE;\n    let d = num;\n    while (power > _0n) {\n        if (power & _1n)\n            p = Fp.mul(p, d);\n        d = Fp.sqr(d);\n        power >>= _1n;\n    }\n    return p;\n}\n/**\n * Efficiently invert an array of Field elements.\n * Exception-free. Will return `undefined` for 0 elements.\n * @param passZero map 0 to 0 (instead of undefined)\n */\nexport function FpInvertBatch(Fp, nums, passZero = false) {\n    const inverted = new Array(nums.length).fill(passZero ? Fp.ZERO : undefined);\n    // Walk from first to last, multiply them by each other MOD p\n    const multipliedAcc = nums.reduce((acc, num, i) => {\n        if (Fp.is0(num))\n            return acc;\n        inverted[i] = acc;\n        return Fp.mul(acc, num);\n    }, Fp.ONE);\n    // Invert last element\n    const invertedAcc = Fp.inv(multipliedAcc);\n    // Walk from last to first, multiply them by inverted each other MOD p\n    nums.reduceRight((acc, num, i) => {\n        if (Fp.is0(num))\n            return acc;\n        inverted[i] = Fp.mul(acc, inverted[i]);\n        return Fp.mul(acc, num);\n    }, invertedAcc);\n    return inverted;\n}\n// TODO: remove\nexport function FpDiv(Fp, lhs, rhs) {\n    return Fp.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, Fp.ORDER) : Fp.inv(rhs));\n}\n/**\n * Legendre symbol.\n * Legendre constant is used to calculate Legendre symbol (a | p)\n * which denotes the value of a^((p-1)/2) (mod p).\n *\n * * (a | p)  1    if a is a square (mod p), quadratic residue\n * * (a | p)  -1   if a is not a square (mod p), quadratic non residue\n * * (a | p)  0    if a  0 (mod p)\n */\nexport function FpLegendre(Fp, n) {\n    // We can use 3rd argument as optional cache of this value\n    // but seems unneeded for now. The operation is very fast.\n    const p1mod2 = (Fp.ORDER - _1n) / _2n;\n    const powered = Fp.pow(n, p1mod2);\n    const yes = Fp.eql(powered, Fp.ONE);\n    const zero = Fp.eql(powered, Fp.ZERO);\n    const no = Fp.eql(powered, Fp.neg(Fp.ONE));\n    if (!yes && !zero && !no)\n        throw new Error('invalid Legendre symbol result');\n    return yes ? 1 : zero ? 0 : -1;\n}\n// This function returns True whenever the value x is a square in the field F.\nexport function FpIsSquare(Fp, n) {\n    const l = FpLegendre(Fp, n);\n    return l === 1;\n}\n// CURVE.n lengths\nexport function nLength(n, nBitLength) {\n    // Bit size, byte size of CURVE.n\n    if (nBitLength !== undefined)\n        anumber(nBitLength);\n    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n    const nByteLength = Math.ceil(_nBitLength / 8);\n    return { nBitLength: _nBitLength, nByteLength };\n}\n/**\n * Creates a finite field. Major performance optimizations:\n * * 1. Denormalized operations like mulN instead of mul.\n * * 2. Identical object shape: never add or remove keys.\n * * 3. `Object.freeze`.\n * Fragile: always run a benchmark on a change.\n * Security note: operations don't check 'isValid' for all elements for performance reasons,\n * it is caller responsibility to check this.\n * This is low-level code, please make sure you know what you're doing.\n *\n * Note about field properties:\n * * CHARACTERISTIC p = prime number, number of elements in main subgroup.\n * * ORDER q = similar to cofactor in curves, may be composite `q = p^m`.\n *\n * @param ORDER field order, probably prime, or could be composite\n * @param bitLen how many bits the field consumes\n * @param isLE (default: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */\nexport function Field(ORDER, bitLenOrOpts, // TODO: use opts only in v2?\nisLE = false, opts = {}) {\n    if (ORDER <= _0n)\n        throw new Error('invalid field: expected ORDER > 0, got ' + ORDER);\n    let _nbitLength = undefined;\n    let _sqrt = undefined;\n    let modFromBytes = false;\n    let allowedLengths = undefined;\n    if (typeof bitLenOrOpts === 'object' && bitLenOrOpts != null) {\n        if (opts.sqrt || isLE)\n            throw new Error('cannot specify opts in two arguments');\n        const _opts = bitLenOrOpts;\n        if (_opts.BITS)\n            _nbitLength = _opts.BITS;\n        if (_opts.sqrt)\n            _sqrt = _opts.sqrt;\n        if (typeof _opts.isLE === 'boolean')\n            isLE = _opts.isLE;\n        if (typeof _opts.modFromBytes === 'boolean')\n            modFromBytes = _opts.modFromBytes;\n        allowedLengths = _opts.allowedLengths;\n    }\n    else {\n        if (typeof bitLenOrOpts === 'number')\n            _nbitLength = bitLenOrOpts;\n        if (opts.sqrt)\n            _sqrt = opts.sqrt;\n    }\n    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, _nbitLength);\n    if (BYTES > 2048)\n        throw new Error('invalid field: expected ORDER of <= 2048 bytes');\n    let sqrtP; // cached sqrtP\n    const f = Object.freeze({\n        ORDER,\n        isLE,\n        BITS,\n        BYTES,\n        MASK: bitMask(BITS),\n        ZERO: _0n,\n        ONE: _1n,\n        allowedLengths: allowedLengths,\n        create: (num) => mod(num, ORDER),\n        isValid: (num) => {\n            if (typeof num !== 'bigint')\n                throw new Error('invalid field element: expected bigint, got ' + typeof num);\n            return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n        },\n        is0: (num) => num === _0n,\n        // is valid and invertible\n        isValidNot0: (num) => !f.is0(num) && f.isValid(num),\n        isOdd: (num) => (num & _1n) === _1n,\n        neg: (num) => mod(-num, ORDER),\n        eql: (lhs, rhs) => lhs === rhs,\n        sqr: (num) => mod(num * num, ORDER),\n        add: (lhs, rhs) => mod(lhs + rhs, ORDER),\n        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),\n        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),\n        pow: (num, power) => FpPow(f, num, power),\n        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),\n        // Same as above, but doesn't normalize\n        sqrN: (num) => num * num,\n        addN: (lhs, rhs) => lhs + rhs,\n        subN: (lhs, rhs) => lhs - rhs,\n        mulN: (lhs, rhs) => lhs * rhs,\n        inv: (num) => invert(num, ORDER),\n        sqrt: _sqrt ||\n            ((n) => {\n                if (!sqrtP)\n                    sqrtP = FpSqrt(ORDER);\n                return sqrtP(f, n);\n            }),\n        toBytes: (num) => (isLE ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES)),\n        fromBytes: (bytes, skipValidation = true) => {\n            if (allowedLengths) {\n                if (!allowedLengths.includes(bytes.length) || bytes.length > BYTES) {\n                    throw new Error('Field.fromBytes: expected ' + allowedLengths + ' bytes, got ' + bytes.length);\n                }\n                const padded = new Uint8Array(BYTES);\n                // isLE add 0 to right, !isLE to the left.\n                padded.set(bytes, isLE ? 0 : padded.length - bytes.length);\n                bytes = padded;\n            }\n            if (bytes.length !== BYTES)\n                throw new Error('Field.fromBytes: expected ' + BYTES + ' bytes, got ' + bytes.length);\n            let scalar = isLE ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);\n            if (modFromBytes)\n                scalar = mod(scalar, ORDER);\n            if (!skipValidation)\n                if (!f.isValid(scalar))\n                    throw new Error('invalid field element: outside of range 0..ORDER');\n            // NOTE: we don't validate scalar here, please use isValid. This done such way because some\n            // protocol may allow non-reduced scalar that reduced later or changed some other way.\n            return scalar;\n        },\n        // TODO: we don't need it here, move out to separate fn\n        invertBatch: (lst) => FpInvertBatch(f, lst),\n        // We can't move this out because Fp6, Fp12 implement it\n        // and it's unclear what to return in there.\n        cmov: (a, b, c) => (c ? b : a),\n    });\n    return Object.freeze(f);\n}\n// Generic random scalar, we can do same for other fields if via Fp2.mul(Fp2.ONE, Fp2.random)?\n// This allows unsafe methods like ignore bias or zero. These unsafe, but often used in different protocols (if deterministic RNG).\n// which mean we cannot force this via opts.\n// Not sure what to do with randomBytes, we can accept it inside opts if wanted.\n// Probably need to export getMinHashLength somewhere?\n// random(bytes?: Uint8Array, unsafeAllowZero = false, unsafeAllowBias = false) {\n//   const LEN = !unsafeAllowBias ? getMinHashLength(ORDER) : BYTES;\n//   if (bytes === undefined) bytes = randomBytes(LEN); // _opts.randomBytes?\n//   const num = isLE ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);\n//   // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n//   const reduced = unsafeAllowZero ? mod(num, ORDER) : mod(num, ORDER - _1n) + _1n;\n//   return reduced;\n// },\nexport function FpSqrtOdd(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(\"Field doesn't have isOdd\");\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? root : Fp.neg(root);\n}\nexport function FpSqrtEven(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(\"Field doesn't have isOdd\");\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).\n * Which makes it slightly more biased, less secure.\n * @deprecated use `mapKeyToField` instead\n */\nexport function hashToPrivateScalar(hash, groupOrder, isLE = false) {\n    hash = ensureBytes('privateHash', hash);\n    const hashLen = hash.length;\n    const minLen = nLength(groupOrder).nByteLength + 8;\n    if (minLen < 24 || hashLen < minLen || hashLen > 1024)\n        throw new Error('hashToPrivateScalar: expected ' + minLen + '-1024 bytes of input, got ' + hashLen);\n    const num = isLE ? bytesToNumberLE(hash) : bytesToNumberBE(hash);\n    return mod(num, groupOrder - _1n) + _1n;\n}\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */\nexport function getFieldBytesLength(fieldOrder) {\n    if (typeof fieldOrder !== 'bigint')\n        throw new Error('field order must be bigint');\n    const bitLength = fieldOrder.toString(2).length;\n    return Math.ceil(bitLength / 8);\n}\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */\nexport function getMinHashLength(fieldOrder) {\n    const length = getFieldBytesLength(fieldOrder);\n    return length + Math.ceil(length / 2);\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */\nexport function mapHashToField(key, fieldOrder, isLE = false) {\n    const len = key.length;\n    const fieldLen = getFieldBytesLength(fieldOrder);\n    const minLen = getMinHashLength(fieldOrder);\n    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n    if (len < 16 || len < minLen || len > 1024)\n        throw new Error('expected ' + minLen + '-1024 bytes of input, got ' + len);\n    const num = isLE ? bytesToNumberLE(key) : bytesToNumberBE(key);\n    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n    const reduced = mod(num, fieldOrder - _1n) + _1n;\n    return isLE ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);\n}\n//# sourceMappingURL=modular.js.map","/**\n * Internal Merkle-Damgard hash utils.\n * @module\n */\nimport { Hash, abytes, aexists, aoutput, clean, createView, toBytes } from \"./utils.js\";\n/** Polyfill for Safari 14. https://caniuse.com/mdn-javascript_builtins_dataview_setbiguint64 */\nexport function setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n/** Choice: a ? b : c */\nexport function Chi(a, b, c) {\n    return (a & b) ^ (~a & c);\n}\n/** Majority function, true if any two inputs is true. */\nexport function Maj(a, b, c) {\n    return (a & b) ^ (a & c) ^ (b & c);\n}\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */\nexport class HashMD extends Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = createView(this.buffer);\n    }\n    update(data) {\n        aexists(this);\n        data = toBytes(data);\n        abytes(data);\n        const { view, buffer, blockLen } = this;\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = createView(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        aexists(this);\n        aoutput(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        clean(this.buffer.subarray(pos));\n        // we have less than padOffset left in buffer, so we cannot put length in\n        // current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = createView(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.destroyed = destroyed;\n        to.finished = finished;\n        to.length = length;\n        to.pos = pos;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n    clone() {\n        return this._cloneInto();\n    }\n}\n/**\n * Initial SHA-2 state: fractional parts of square roots of first 16 primes 2..53.\n * Check out `test/misc/sha2-gen-iv.js` for recomputation guide.\n */\n/** Initial SHA256 state. Bits 0..32 of frac part of sqrt of primes 2..19 */\nexport const SHA256_IV = /* @__PURE__ */ Uint32Array.from([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19,\n]);\n/** Initial SHA224 state. Bits 32..64 of frac part of sqrt of primes 23..53 */\nexport const SHA224_IV = /* @__PURE__ */ Uint32Array.from([\n    0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939, 0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4,\n]);\n/** Initial SHA384 state. Bits 0..64 of frac part of sqrt of primes 23..53 */\nexport const SHA384_IV = /* @__PURE__ */ Uint32Array.from([\n    0xcbbb9d5d, 0xc1059ed8, 0x629a292a, 0x367cd507, 0x9159015a, 0x3070dd17, 0x152fecd8, 0xf70e5939,\n    0x67332667, 0xffc00b31, 0x8eb44a87, 0x68581511, 0xdb0c2e0d, 0x64f98fa7, 0x47b5481d, 0xbefa4fa4,\n]);\n/** Initial SHA512 state. Bits 0..64 of frac part of sqrt of primes 2..19 */\nexport const SHA512_IV = /* @__PURE__ */ Uint32Array.from([\n    0x6a09e667, 0xf3bcc908, 0xbb67ae85, 0x84caa73b, 0x3c6ef372, 0xfe94f82b, 0xa54ff53a, 0x5f1d36f1,\n    0x510e527f, 0xade682d1, 0x9b05688c, 0x2b3e6c1f, 0x1f83d9ab, 0xfb41bd6b, 0x5be0cd19, 0x137e2179,\n]);\n//# sourceMappingURL=_md.js.map","/**\n * Internal helpers for u64. BigUint64Array is too slow as per 2025, so we implement it using Uint32Array.\n * @todo re-check https://issues.chromium.org/issues/42212588\n * @module\n */\nconst U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\nfunction fromBig(n, le = false) {\n    if (le)\n        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\nfunction split(lst, le = false) {\n    const len = lst.length;\n    let Ah = new Uint32Array(len);\n    let Al = new Uint32Array(len);\n    for (let i = 0; i < len; i++) {\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [h, l];\n    }\n    return [Ah, Al];\n}\nconst toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h, _l, s) => h >>> s;\nconst shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h, l) => l;\nconst rotr32L = (h, _l) => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n// prettier-ignore\nexport { add, add3H, add3L, add4H, add4L, add5H, add5L, fromBig, rotlBH, rotlBL, rotlSH, rotlSL, rotr32H, rotr32L, rotrBH, rotrBL, rotrSH, rotrSL, shrSH, shrSL, split, toBig };\n// prettier-ignore\nconst u64 = {\n    fromBig, split, toBig,\n    shrSH, shrSL,\n    rotrSH, rotrSL, rotrBH, rotrBL,\n    rotr32H, rotr32L,\n    rotlSH, rotlSL, rotlBH, rotlBL,\n    add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\nexport default u64;\n//# sourceMappingURL=_u64.js.map","/**\n * SHA2 hash function. A.k.a. sha256, sha384, sha512, sha512_224, sha512_256.\n * SHA256 is the fastest hash implementable in JS, even faster than Blake3.\n * Check out [RFC 4634](https://datatracker.ietf.org/doc/html/rfc4634) and\n * [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).\n * @module\n */\nimport { Chi, HashMD, Maj, SHA224_IV, SHA256_IV, SHA384_IV, SHA512_IV } from \"./_md.js\";\nimport * as u64 from \"./_u64.js\";\nimport { clean, createHasher, rotr } from \"./utils.js\";\n/**\n * Round constants:\n * First 32 bits of fractional parts of the cube roots of the first 64 primes 2..311)\n */\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ Uint32Array.from([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n/** Reusable temporary buffer. \"W\" comes straight from spec. */\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nexport class SHA256 extends HashMD {\n    constructor(outputLen = 32) {\n        super(64, outputLen, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = SHA256_IV[0] | 0;\n        this.B = SHA256_IV[1] | 0;\n        this.C = SHA256_IV[2] | 0;\n        this.D = SHA256_IV[3] | 0;\n        this.E = SHA256_IV[4] | 0;\n        this.F = SHA256_IV[5] | 0;\n        this.G = SHA256_IV[6] | 0;\n        this.H = SHA256_IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ (W15 >>> 3);\n            const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);\n            const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);\n            const T2 = (sigma0 + Maj(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        clean(SHA256_W);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        clean(this.buffer);\n    }\n}\nexport class SHA224 extends SHA256 {\n    constructor() {\n        super(28);\n        this.A = SHA224_IV[0] | 0;\n        this.B = SHA224_IV[1] | 0;\n        this.C = SHA224_IV[2] | 0;\n        this.D = SHA224_IV[3] | 0;\n        this.E = SHA224_IV[4] | 0;\n        this.F = SHA224_IV[5] | 0;\n        this.G = SHA224_IV[6] | 0;\n        this.H = SHA224_IV[7] | 0;\n    }\n}\n// SHA2-512 is slower than sha256 in js because u64 operations are slow.\n// Round contants\n// First 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409\n// prettier-ignore\nconst K512 = /* @__PURE__ */ (() => u64.split([\n    '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',\n    '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',\n    '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',\n    '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',\n    '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',\n    '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',\n    '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',\n    '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',\n    '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',\n    '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',\n    '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',\n    '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',\n    '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',\n    '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',\n    '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',\n    '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',\n    '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',\n    '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',\n    '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',\n    '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'\n].map(n => BigInt(n))))();\nconst SHA512_Kh = /* @__PURE__ */ (() => K512[0])();\nconst SHA512_Kl = /* @__PURE__ */ (() => K512[1])();\n// Reusable temporary buffers\nconst SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);\nconst SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);\nexport class SHA512 extends HashMD {\n    constructor(outputLen = 64) {\n        super(128, outputLen, 16, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = SHA512_IV[0] | 0;\n        this.Al = SHA512_IV[1] | 0;\n        this.Bh = SHA512_IV[2] | 0;\n        this.Bl = SHA512_IV[3] | 0;\n        this.Ch = SHA512_IV[4] | 0;\n        this.Cl = SHA512_IV[5] | 0;\n        this.Dh = SHA512_IV[6] | 0;\n        this.Dl = SHA512_IV[7] | 0;\n        this.Eh = SHA512_IV[8] | 0;\n        this.El = SHA512_IV[9] | 0;\n        this.Fh = SHA512_IV[10] | 0;\n        this.Fl = SHA512_IV[11] | 0;\n        this.Gh = SHA512_IV[12] | 0;\n        this.Gl = SHA512_IV[13] | 0;\n        this.Hh = SHA512_IV[14] | 0;\n        this.Hl = SHA512_IV[15] | 0;\n    }\n    // prettier-ignore\n    get() {\n        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];\n    }\n    // prettier-ignore\n    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {\n        this.Ah = Ah | 0;\n        this.Al = Al | 0;\n        this.Bh = Bh | 0;\n        this.Bl = Bl | 0;\n        this.Ch = Ch | 0;\n        this.Cl = Cl | 0;\n        this.Dh = Dh | 0;\n        this.Dl = Dl | 0;\n        this.Eh = Eh | 0;\n        this.El = El | 0;\n        this.Fh = Fh | 0;\n        this.Fl = Fl | 0;\n        this.Gh = Gh | 0;\n        this.Gl = Gl | 0;\n        this.Hh = Hh | 0;\n        this.Hl = Hl | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4) {\n            SHA512_W_H[i] = view.getUint32(offset);\n            SHA512_W_L[i] = view.getUint32((offset += 4));\n        }\n        for (let i = 16; i < 80; i++) {\n            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\n            const W15h = SHA512_W_H[i - 15] | 0;\n            const W15l = SHA512_W_L[i - 15] | 0;\n            const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);\n            const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);\n            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\n            const W2h = SHA512_W_H[i - 2] | 0;\n            const W2l = SHA512_W_L[i - 2] | 0;\n            const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);\n            const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);\n            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\n            const SUMl = u64.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n            const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n            SHA512_W_H[i] = SUMh | 0;\n            SHA512_W_L[i] = SUMl | 0;\n        }\n        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        // Compression function main loop, 80 rounds\n        for (let i = 0; i < 80; i++) {\n            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\n            const sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);\n            const sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);\n            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const CHIh = (Eh & Fh) ^ (~Eh & Gh);\n            const CHIl = (El & Fl) ^ (~El & Gl);\n            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\n            // prettier-ignore\n            const T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n            const T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n            const T1l = T1ll | 0;\n            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\n            const sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);\n            const sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);\n            const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);\n            const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);\n            Hh = Gh | 0;\n            Hl = Gl | 0;\n            Gh = Fh | 0;\n            Gl = Fl | 0;\n            Fh = Eh | 0;\n            Fl = El | 0;\n            ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n            Dh = Ch | 0;\n            Dl = Cl | 0;\n            Ch = Bh | 0;\n            Cl = Bl | 0;\n            Bh = Ah | 0;\n            Bl = Al | 0;\n            const All = u64.add3L(T1l, sigma0l, MAJl);\n            Ah = u64.add3H(All, T1h, sigma0h, MAJh);\n            Al = All | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        ({ h: Ah, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n        ({ h: Bh, l: Bl } = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n        ({ h: Ch, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n        ({ h: Dh, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n        ({ h: Eh, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n        ({ h: Fh, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n        ({ h: Gh, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n        ({ h: Hh, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n    }\n    roundClean() {\n        clean(SHA512_W_H, SHA512_W_L);\n    }\n    destroy() {\n        clean(this.buffer);\n        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    }\n}\nexport class SHA384 extends SHA512 {\n    constructor() {\n        super(48);\n        this.Ah = SHA384_IV[0] | 0;\n        this.Al = SHA384_IV[1] | 0;\n        this.Bh = SHA384_IV[2] | 0;\n        this.Bl = SHA384_IV[3] | 0;\n        this.Ch = SHA384_IV[4] | 0;\n        this.Cl = SHA384_IV[5] | 0;\n        this.Dh = SHA384_IV[6] | 0;\n        this.Dl = SHA384_IV[7] | 0;\n        this.Eh = SHA384_IV[8] | 0;\n        this.El = SHA384_IV[9] | 0;\n        this.Fh = SHA384_IV[10] | 0;\n        this.Fl = SHA384_IV[11] | 0;\n        this.Gh = SHA384_IV[12] | 0;\n        this.Gl = SHA384_IV[13] | 0;\n        this.Hh = SHA384_IV[14] | 0;\n        this.Hl = SHA384_IV[15] | 0;\n    }\n}\n/**\n * Truncated SHA512/256 and SHA512/224.\n * SHA512_IV is XORed with 0xa5a5a5a5a5a5a5a5, then used as \"intermediary\" IV of SHA512/t.\n * Then t hashes string to produce result IV.\n * See `test/misc/sha2-gen-iv.js`.\n */\n/** SHA512/224 IV */\nconst T224_IV = /* @__PURE__ */ Uint32Array.from([\n    0x8c3d37c8, 0x19544da2, 0x73e19966, 0x89dcd4d6, 0x1dfab7ae, 0x32ff9c82, 0x679dd514, 0x582f9fcf,\n    0x0f6d2b69, 0x7bd44da8, 0x77e36f73, 0x04c48942, 0x3f9d85a8, 0x6a1d36c8, 0x1112e6ad, 0x91d692a1,\n]);\n/** SHA512/256 IV */\nconst T256_IV = /* @__PURE__ */ Uint32Array.from([\n    0x22312194, 0xfc2bf72c, 0x9f555fa3, 0xc84c64c2, 0x2393b86b, 0x6f53b151, 0x96387719, 0x5940eabd,\n    0x96283ee2, 0xa88effe3, 0xbe5e1e25, 0x53863992, 0x2b0199fc, 0x2c85b8aa, 0x0eb72ddc, 0x81c52ca2,\n]);\nexport class SHA512_224 extends SHA512 {\n    constructor() {\n        super(28);\n        this.Ah = T224_IV[0] | 0;\n        this.Al = T224_IV[1] | 0;\n        this.Bh = T224_IV[2] | 0;\n        this.Bl = T224_IV[3] | 0;\n        this.Ch = T224_IV[4] | 0;\n        this.Cl = T224_IV[5] | 0;\n        this.Dh = T224_IV[6] | 0;\n        this.Dl = T224_IV[7] | 0;\n        this.Eh = T224_IV[8] | 0;\n        this.El = T224_IV[9] | 0;\n        this.Fh = T224_IV[10] | 0;\n        this.Fl = T224_IV[11] | 0;\n        this.Gh = T224_IV[12] | 0;\n        this.Gl = T224_IV[13] | 0;\n        this.Hh = T224_IV[14] | 0;\n        this.Hl = T224_IV[15] | 0;\n    }\n}\nexport class SHA512_256 extends SHA512 {\n    constructor() {\n        super(32);\n        this.Ah = T256_IV[0] | 0;\n        this.Al = T256_IV[1] | 0;\n        this.Bh = T256_IV[2] | 0;\n        this.Bl = T256_IV[3] | 0;\n        this.Ch = T256_IV[4] | 0;\n        this.Cl = T256_IV[5] | 0;\n        this.Dh = T256_IV[6] | 0;\n        this.Dl = T256_IV[7] | 0;\n        this.Eh = T256_IV[8] | 0;\n        this.El = T256_IV[9] | 0;\n        this.Fh = T256_IV[10] | 0;\n        this.Fl = T256_IV[11] | 0;\n        this.Gh = T256_IV[12] | 0;\n        this.Gl = T256_IV[13] | 0;\n        this.Hh = T256_IV[14] | 0;\n        this.Hl = T256_IV[15] | 0;\n    }\n}\n/**\n * SHA2-256 hash function from RFC 4634.\n *\n * It is the fastest JS hash, even faster than Blake3.\n * To break sha256 using birthday attack, attackers need to try 2^128 hashes.\n * BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.\n */\nexport const sha256 = /* @__PURE__ */ createHasher(() => new SHA256());\n/** SHA2-224 hash function from RFC 4634 */\nexport const sha224 = /* @__PURE__ */ createHasher(() => new SHA224());\n/** SHA2-512 hash function from RFC 4634. */\nexport const sha512 = /* @__PURE__ */ createHasher(() => new SHA512());\n/** SHA2-384 hash function from RFC 4634. */\nexport const sha384 = /* @__PURE__ */ createHasher(() => new SHA384());\n/**\n * SHA2-512/256 \"truncated\" hash function, with improved resistance to length extension attacks.\n * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).\n */\nexport const sha512_256 = /* @__PURE__ */ createHasher(() => new SHA512_256());\n/**\n * SHA2-512/224 \"truncated\" hash function, with improved resistance to length extension attacks.\n * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).\n */\nexport const sha512_224 = /* @__PURE__ */ createHasher(() => new SHA512_224());\n//# sourceMappingURL=sha2.js.map","/**\n * HMAC: RFC2104 message authentication code.\n * @module\n */\nimport { abytes, aexists, ahash, clean, Hash, toBytes } from \"./utils.js\";\nexport class HMAC extends Hash {\n    constructor(hash, _key) {\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        ahash(hash);\n        const key = toBytes(_key);\n        this.iHash = hash.create();\n        if (typeof this.iHash.update !== 'function')\n            throw new Error('Expected instance of class which extends utils.Hash');\n        this.blockLen = this.iHash.blockLen;\n        this.outputLen = this.iHash.outputLen;\n        const blockLen = this.blockLen;\n        const pad = new Uint8Array(blockLen);\n        // blockLen can be bigger than outputLen\n        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n        this.oHash = hash.create();\n        // Undo internal XOR && apply outer XOR\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36 ^ 0x5c;\n        this.oHash.update(pad);\n        clean(pad);\n    }\n    update(buf) {\n        aexists(this);\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        aexists(this);\n        abytes(out, this.outputLen);\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        // Create new instance without calling constructor since key already in state and we don't know it.\n        to || (to = Object.create(Object.getPrototypeOf(this), {}));\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n        to = to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash);\n        to.iHash = iHash._cloneInto(to.iHash);\n        return to;\n    }\n    clone() {\n        return this._cloneInto();\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n}\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n * @example\n * import { hmac } from '@noble/hashes/hmac';\n * import { sha256 } from '@noble/hashes/sha2';\n * const mac1 = hmac(sha256, 'key', 'message');\n */\nexport const hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();\nhmac.create = (hash, key) => new HMAC(hash, key);\n//# sourceMappingURL=hmac.js.map","/**\n * Methods for elliptic curve multiplication by scalars.\n * Contains wNAF, pippenger.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { bitLen, bitMask, validateObject } from \"../utils.js\";\nimport { Field, FpInvertBatch, nLength, validateField } from \"./modular.js\";\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nexport function negateCt(condition, item) {\n    const neg = item.negate();\n    return condition ? neg : item;\n}\n/**\n * Takes a bunch of Projective Points but executes only one\n * inversion on all of them. Inversion is very slow operation,\n * so this improves performance massively.\n * Optimization: converts a list of projective points to a list of identical points with Z=1.\n */\nexport function normalizeZ(c, points) {\n    const invertedZs = FpInvertBatch(c.Fp, points.map((p) => p.Z));\n    return points.map((p, i) => c.fromAffine(p.toAffine(invertedZs[i])));\n}\nfunction validateW(W, bits) {\n    if (!Number.isSafeInteger(W) || W <= 0 || W > bits)\n        throw new Error('invalid window size, expected [1..' + bits + '], got W=' + W);\n}\nfunction calcWOpts(W, scalarBits) {\n    validateW(W, scalarBits);\n    const windows = Math.ceil(scalarBits / W) + 1; // W=8 33. Not 32, because we skip zero\n    const windowSize = 2 ** (W - 1); // W=8 128. Not 256, because we skip zero\n    const maxNumber = 2 ** W; // W=8 256\n    const mask = bitMask(W); // W=8 255 == mask 0b11111111\n    const shiftBy = BigInt(W); // W=8 8\n    return { windows, windowSize, mask, maxNumber, shiftBy };\n}\nfunction calcOffsets(n, window, wOpts) {\n    const { windowSize, mask, maxNumber, shiftBy } = wOpts;\n    let wbits = Number(n & mask); // extract W bits.\n    let nextN = n >> shiftBy; // shift number by W bits.\n    // What actually happens here:\n    // const highestBit = Number(mask ^ (mask >> 1n));\n    // let wbits2 = wbits - 1; // skip zero\n    // if (wbits2 & highestBit) { wbits2 ^= Number(mask); // (~);\n    // split if bits > max: +224 => 256-32\n    if (wbits > windowSize) {\n        // we skip zero, which means instead of `>= size-1`, we do `> size`\n        wbits -= maxNumber; // -32, can be maxNumber - wbits, but then we need to set isNeg here.\n        nextN += _1n; // +256 (carry)\n    }\n    const offsetStart = window * windowSize;\n    const offset = offsetStart + Math.abs(wbits) - 1; // -1 because we skip zero\n    const isZero = wbits === 0; // is current window slice a 0?\n    const isNeg = wbits < 0; // is current window slice negative?\n    const isNegF = window % 2 !== 0; // fake random statement for noise\n    const offsetF = offsetStart; // fake offset for noise\n    return { nextN, offset, isZero, isNeg, isNegF, offsetF };\n}\nfunction validateMSMPoints(points, c) {\n    if (!Array.isArray(points))\n        throw new Error('array expected');\n    points.forEach((p, i) => {\n        if (!(p instanceof c))\n            throw new Error('invalid point at index ' + i);\n    });\n}\nfunction validateMSMScalars(scalars, field) {\n    if (!Array.isArray(scalars))\n        throw new Error('array of scalars expected');\n    scalars.forEach((s, i) => {\n        if (!field.isValid(s))\n            throw new Error('invalid scalar at index ' + i);\n    });\n}\n// Since points in different groups cannot be equal (different object constructor),\n// we can have single place to store precomputes.\n// Allows to make points frozen / immutable.\nconst pointPrecomputes = new WeakMap();\nconst pointWindowSizes = new WeakMap();\nfunction getW(P) {\n    // To disable precomputes:\n    // return 1;\n    return pointWindowSizes.get(P) || 1;\n}\nfunction assert0(n) {\n    if (n !== _0n)\n        throw new Error('invalid wNAF');\n}\n/**\n * Elliptic curve multiplication of Point by scalar. Fragile.\n * Table generation takes **30MB of ram and 10ms on high-end CPU**,\n * but may take much longer on slow devices. Actual generation will happen on\n * first call of `multiply()`. By default, `BASE` point is precomputed.\n *\n * Scalars should always be less than curve order: this should be checked inside of a curve itself.\n * Creates precomputation tables for fast multiplication:\n * - private scalar is split by fixed size windows of W bits\n * - every window point is collected from window's table & added to accumulator\n * - since windows are different, same point inside tables won't be accessed more than once per calc\n * - each multiplication is 'Math.ceil(CURVE_ORDER / ) + 1' point additions (fixed for any scalar)\n * - +1 window is neccessary for wNAF\n * - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n *\n * @todo Research returning 2d JS array of windows, instead of a single window.\n * This would allow windows to be in different memory locations\n */\nexport class wNAF {\n    // Parametrized with a given Point class (not individual point)\n    constructor(Point, bits) {\n        this.BASE = Point.BASE;\n        this.ZERO = Point.ZERO;\n        this.Fn = Point.Fn;\n        this.bits = bits;\n    }\n    // non-const time multiplication ladder\n    _unsafeLadder(elm, n, p = this.ZERO) {\n        let d = elm;\n        while (n > _0n) {\n            if (n & _1n)\n                p = p.add(d);\n            d = d.double();\n            n >>= _1n;\n        }\n        return p;\n    }\n    /**\n     * Creates a wNAF precomputation window. Used for caching.\n     * Default window size is set by `utils.precompute()` and is equal to 8.\n     * Number of precomputed points depends on the curve size:\n     * 2^(1) * (Math.ceil( / ) + 1), where:\n     * -  is the window size\n     * -  is the bitlength of the curve order.\n     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n     * @param point Point instance\n     * @param W window size\n     * @returns precomputed point tables flattened to a single array\n     */\n    precomputeWindow(point, W) {\n        const { windows, windowSize } = calcWOpts(W, this.bits);\n        const points = [];\n        let p = point;\n        let base = p;\n        for (let window = 0; window < windows; window++) {\n            base = p;\n            points.push(base);\n            // i=1, bc we skip 0\n            for (let i = 1; i < windowSize; i++) {\n                base = base.add(p);\n                points.push(base);\n            }\n            p = base.double();\n        }\n        return points;\n    }\n    /**\n     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n     * More compact implementation:\n     * https://github.com/paulmillr/noble-secp256k1/blob/47cb1669b6e506ad66b35fe7d76132ae97465da2/index.ts#L502-L541\n     * @returns real and fake (for const-time) points\n     */\n    wNAF(W, precomputes, n) {\n        // Scalar should be smaller than field order\n        if (!this.Fn.isValid(n))\n            throw new Error('invalid scalar');\n        // Accumulators\n        let p = this.ZERO;\n        let f = this.BASE;\n        // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n        // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n        // there is negate now: it is possible that negated element from low value\n        // would be the same as high element, which will create carry into next window.\n        // It's not obvious how this can fail, but still worth investigating later.\n        const wo = calcWOpts(W, this.bits);\n        for (let window = 0; window < wo.windows; window++) {\n            // (n === _0n) is handled and not early-exited. isEven and offsetF are used for noise\n            const { nextN, offset, isZero, isNeg, isNegF, offsetF } = calcOffsets(n, window, wo);\n            n = nextN;\n            if (isZero) {\n                // bits are 0: add garbage to fake point\n                // Important part for const-time getPublicKey: add random \"noise\" point to f.\n                f = f.add(negateCt(isNegF, precomputes[offsetF]));\n            }\n            else {\n                // bits are 1: add to result point\n                p = p.add(negateCt(isNeg, precomputes[offset]));\n            }\n        }\n        assert0(n);\n        // Return both real and fake points: JIT won't eliminate f.\n        // At this point there is a way to F be infinity-point even if p is not,\n        // which makes it less const-time: around 1 bigint multiply.\n        return { p, f };\n    }\n    /**\n     * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.\n     * @param acc accumulator point to add result of multiplication\n     * @returns point\n     */\n    wNAFUnsafe(W, precomputes, n, acc = this.ZERO) {\n        const wo = calcWOpts(W, this.bits);\n        for (let window = 0; window < wo.windows; window++) {\n            if (n === _0n)\n                break; // Early-exit, skip 0 value\n            const { nextN, offset, isZero, isNeg } = calcOffsets(n, window, wo);\n            n = nextN;\n            if (isZero) {\n                // Window bits are 0: skip processing.\n                // Move to next window.\n                continue;\n            }\n            else {\n                const item = precomputes[offset];\n                acc = acc.add(isNeg ? item.negate() : item); // Re-using acc allows to save adds in MSM\n            }\n        }\n        assert0(n);\n        return acc;\n    }\n    getPrecomputes(W, point, transform) {\n        // Calculate precomputes on a first run, reuse them after\n        let comp = pointPrecomputes.get(point);\n        if (!comp) {\n            comp = this.precomputeWindow(point, W);\n            if (W !== 1) {\n                // Doing transform outside of if brings 15% perf hit\n                if (typeof transform === 'function')\n                    comp = transform(comp);\n                pointPrecomputes.set(point, comp);\n            }\n        }\n        return comp;\n    }\n    cached(point, scalar, transform) {\n        const W = getW(point);\n        return this.wNAF(W, this.getPrecomputes(W, point, transform), scalar);\n    }\n    unsafe(point, scalar, transform, prev) {\n        const W = getW(point);\n        if (W === 1)\n            return this._unsafeLadder(point, scalar, prev); // For W=1 ladder is ~x2 faster\n        return this.wNAFUnsafe(W, this.getPrecomputes(W, point, transform), scalar, prev);\n    }\n    // We calculate precomputes for elliptic curve point multiplication\n    // using windowed method. This specifies window size and\n    // stores precomputed values. Usually only base point would be precomputed.\n    createCache(P, W) {\n        validateW(W, this.bits);\n        pointWindowSizes.set(P, W);\n        pointPrecomputes.delete(P);\n    }\n    hasCache(elm) {\n        return getW(elm) !== 1;\n    }\n}\n/**\n * Endomorphism-specific multiplication for Koblitz curves.\n * Cost: 128 dbl, 0-256 adds.\n */\nexport function mulEndoUnsafe(Point, point, k1, k2) {\n    let acc = point;\n    let p1 = Point.ZERO;\n    let p2 = Point.ZERO;\n    while (k1 > _0n || k2 > _0n) {\n        if (k1 & _1n)\n            p1 = p1.add(acc);\n        if (k2 & _1n)\n            p2 = p2.add(acc);\n        acc = acc.double();\n        k1 >>= _1n;\n        k2 >>= _1n;\n    }\n    return { p1, p2 };\n}\n/**\n * Pippenger algorithm for multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * 30x faster vs naive addition on L=4096, 10x faster than precomputes.\n * For N=254bit, L=1, it does: 1024 ADD + 254 DBL. For L=5: 1536 ADD + 254 DBL.\n * Algorithmically constant-time (for same L), even when 1 point + scalar, or when scalar = 0.\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @param scalars array of L scalars (aka secret keys / bigints)\n */\nexport function pippenger(c, fieldN, points, scalars) {\n    // If we split scalars by some window (let's say 8 bits), every chunk will only\n    // take 256 buckets even if there are 4096 scalars, also re-uses double.\n    // TODO:\n    // - https://eprint.iacr.org/2024/750.pdf\n    // - https://tches.iacr.org/index.php/TCHES/article/view/10287\n    // 0 is accepted in scalars\n    validateMSMPoints(points, c);\n    validateMSMScalars(scalars, fieldN);\n    const plength = points.length;\n    const slength = scalars.length;\n    if (plength !== slength)\n        throw new Error('arrays of points and scalars must have equal length');\n    // if (plength === 0) throw new Error('array must be of length >= 2');\n    const zero = c.ZERO;\n    const wbits = bitLen(BigInt(plength));\n    let windowSize = 1; // bits\n    if (wbits > 12)\n        windowSize = wbits - 3;\n    else if (wbits > 4)\n        windowSize = wbits - 2;\n    else if (wbits > 0)\n        windowSize = 2;\n    const MASK = bitMask(windowSize);\n    const buckets = new Array(Number(MASK) + 1).fill(zero); // +1 for zero array\n    const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;\n    let sum = zero;\n    for (let i = lastBits; i >= 0; i -= windowSize) {\n        buckets.fill(zero);\n        for (let j = 0; j < slength; j++) {\n            const scalar = scalars[j];\n            const wbits = Number((scalar >> BigInt(i)) & MASK);\n            buckets[wbits] = buckets[wbits].add(points[j]);\n        }\n        let resI = zero; // not using this will do small speed-up, but will lose ct\n        // Skip first bucket, because it is zero\n        for (let j = buckets.length - 1, sumI = zero; j > 0; j--) {\n            sumI = sumI.add(buckets[j]);\n            resI = resI.add(sumI);\n        }\n        sum = sum.add(resI);\n        if (i !== 0)\n            for (let j = 0; j < windowSize; j++)\n                sum = sum.double();\n    }\n    return sum;\n}\n/**\n * Precomputed multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @returns function which multiplies points with scaars\n */\nexport function precomputeMSMUnsafe(c, fieldN, points, windowSize) {\n    /**\n     * Performance Analysis of Window-based Precomputation\n     *\n     * Base Case (256-bit scalar, 8-bit window):\n     * - Standard precomputation requires:\n     *   - 31 additions per scalar  256 scalars = 7,936 ops\n     *   - Plus 255 summary additions = 8,191 total ops\n     *   Note: Summary additions can be optimized via accumulator\n     *\n     * Chunked Precomputation Analysis:\n     * - Using 32 chunks requires:\n     *   - 255 additions per chunk\n     *   - 256 doublings\n     *   - Total: (255  32) + 256 = 8,416 ops\n     *\n     * Memory Usage Comparison:\n     * Window Size | Standard Points | Chunked Points\n     * ------------|-----------------|---------------\n     *     4-bit   |     520         |      15\n     *     8-bit   |    4,224        |     255\n     *    10-bit   |   13,824        |   1,023\n     *    16-bit   |  557,056        |  65,535\n     *\n     * Key Advantages:\n     * 1. Enables larger window sizes due to reduced memory overhead\n     * 2. More efficient for smaller scalar counts:\n     *    - 16 chunks: (16  255) + 256 = 4,336 ops\n     *    - ~2x faster than standard 8,191 ops\n     *\n     * Limitations:\n     * - Not suitable for plain precomputes (requires 256 constant doublings)\n     * - Performance degrades with larger scalar counts:\n     *   - Optimal for ~256 scalars\n     *   - Less efficient for 4096+ scalars (Pippenger preferred)\n     */\n    validateW(windowSize, fieldN.BITS);\n    validateMSMPoints(points, c);\n    const zero = c.ZERO;\n    const tableSize = 2 ** windowSize - 1; // table size (without zero)\n    const chunks = Math.ceil(fieldN.BITS / windowSize); // chunks of item\n    const MASK = bitMask(windowSize);\n    const tables = points.map((p) => {\n        const res = [];\n        for (let i = 0, acc = p; i < tableSize; i++) {\n            res.push(acc);\n            acc = acc.add(p);\n        }\n        return res;\n    });\n    return (scalars) => {\n        validateMSMScalars(scalars, fieldN);\n        if (scalars.length > points.length)\n            throw new Error('array of scalars must be smaller than array of points');\n        let res = zero;\n        for (let i = 0; i < chunks; i++) {\n            // No need to double if accumulator is still zero.\n            if (res !== zero)\n                for (let j = 0; j < windowSize; j++)\n                    res = res.double();\n            const shiftBy = BigInt(chunks * windowSize - (i + 1) * windowSize);\n            for (let j = 0; j < scalars.length; j++) {\n                const n = scalars[j];\n                const curr = Number((n >> shiftBy) & MASK);\n                if (!curr)\n                    continue; // skip zero scalars chunks\n                res = res.add(tables[j][curr - 1]);\n            }\n        }\n        return res;\n    };\n}\n// TODO: remove\n/** @deprecated */\nexport function validateBasic(curve) {\n    validateField(curve.Fp);\n    validateObject(curve, {\n        n: 'bigint',\n        h: 'bigint',\n        Gx: 'field',\n        Gy: 'field',\n    }, {\n        nBitLength: 'isSafeInteger',\n        nByteLength: 'isSafeInteger',\n    });\n    // Set defaults\n    return Object.freeze({\n        ...nLength(curve.n, curve.nBitLength),\n        ...curve,\n        ...{ p: curve.Fp.ORDER },\n    });\n}\nfunction createField(order, field, isLE) {\n    if (field) {\n        if (field.ORDER !== order)\n            throw new Error('Field.ORDER must match order: Fp == p, Fn == n');\n        validateField(field);\n        return field;\n    }\n    else {\n        return Field(order, { isLE });\n    }\n}\n/** Validates CURVE opts and creates fields */\nexport function _createCurveFields(type, CURVE, curveOpts = {}, FpFnLE) {\n    if (FpFnLE === undefined)\n        FpFnLE = type === 'edwards';\n    if (!CURVE || typeof CURVE !== 'object')\n        throw new Error(`expected valid ${type} CURVE object`);\n    for (const p of ['p', 'n', 'h']) {\n        const val = CURVE[p];\n        if (!(typeof val === 'bigint' && val > _0n))\n            throw new Error(`CURVE.${p} must be positive bigint`);\n    }\n    const Fp = createField(CURVE.p, curveOpts.Fp, FpFnLE);\n    const Fn = createField(CURVE.n, curveOpts.Fn, FpFnLE);\n    const _b = type === 'weierstrass' ? 'b' : 'd';\n    const params = ['Gx', 'Gy', 'a', _b];\n    for (const p of params) {\n        // @ts-ignore\n        if (!Fp.isValid(CURVE[p]))\n            throw new Error(`CURVE.${p} must be valid field element of CURVE.Fp`);\n    }\n    CURVE = Object.freeze(Object.assign({}, CURVE));\n    return { CURVE, Fp, Fn };\n}\n//# sourceMappingURL=curve.js.map","/**\n * Short Weierstrass curve methods. The formula is: y = x + ax + b.\n *\n * ### Design rationale for types\n *\n * * Interaction between classes from different curves should fail:\n *   `k256.Point.BASE.add(p256.Point.BASE)`\n * * For this purpose we want to use `instanceof` operator, which is fast and works during runtime\n * * Different calls of `curve()` would return different classes -\n *   `curve(params) !== curve(params)`: if somebody decided to monkey-patch their curve,\n *   it won't affect others\n *\n * TypeScript can't infer types for classes created inside a function. Classes is one instance\n * of nominative types in TypeScript and interfaces only check for shape, so it's hard to create\n * unique type for every function call.\n *\n * We can use generic types via some param, like curve opts, but that would:\n *     1. Enable interaction between `curve(params)` and `curve(params)` (curves of same params)\n *     which is hard to debug.\n *     2. Params can be generic and we can't enforce them to be constant value:\n *     if somebody creates curve from non-constant params,\n *     it would be allowed to interact with other curves with non-constant params\n *\n * @todo https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-7.html#unique-symbol\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { hmac as nobleHmac } from '@noble/hashes/hmac.js';\nimport { ahash } from '@noble/hashes/utils';\nimport { _validateObject, _abool2 as abool, _abytes2 as abytes, aInRange, bitLen, bitMask, bytesToHex, bytesToNumberBE, concatBytes, createHmacDrbg, ensureBytes, hexToBytes, inRange, isBytes, memoized, numberToHexUnpadded, randomBytes as randomBytesWeb, } from \"../utils.js\";\nimport { _createCurveFields, mulEndoUnsafe, negateCt, normalizeZ, pippenger, wNAF, } from \"./curve.js\";\nimport { Field, FpInvertBatch, getMinHashLength, mapHashToField, nLength, validateField, } from \"./modular.js\";\n// We construct basis in such way that den is always positive and equals n, but num sign depends on basis (not on secret value)\nconst divNearest = (num, den) => (num + (num >= 0 ? den : -den) / _2n) / den;\n/**\n * Splits scalar for GLV endomorphism.\n */\nexport function _splitEndoScalar(k, basis, n) {\n    // Split scalar into two such that part is ~half bits: `abs(part) < sqrt(N)`\n    // Since part can be negative, we need to do this on point.\n    // TODO: verifyScalar function which consumes lambda\n    const [[a1, b1], [a2, b2]] = basis;\n    const c1 = divNearest(b2 * k, n);\n    const c2 = divNearest(-b1 * k, n);\n    // |k1|/|k2| is < sqrt(N), but can be negative.\n    // If we do `k1 mod N`, we'll get big scalar (`> sqrt(N)`): so, we do cheaper negation instead.\n    let k1 = k - c1 * a1 - c2 * a2;\n    let k2 = -c1 * b1 - c2 * b2;\n    const k1neg = k1 < _0n;\n    const k2neg = k2 < _0n;\n    if (k1neg)\n        k1 = -k1;\n    if (k2neg)\n        k2 = -k2;\n    // Double check that resulting scalar less than half bits of N: otherwise wNAF will fail.\n    // This should only happen on wrong basises. Also, math inside is too complex and I don't trust it.\n    const MAX_NUM = bitMask(Math.ceil(bitLen(n) / 2)) + _1n; // Half bits of N\n    if (k1 < _0n || k1 >= MAX_NUM || k2 < _0n || k2 >= MAX_NUM) {\n        throw new Error('splitScalar (endomorphism): failed, k=' + k);\n    }\n    return { k1neg, k1, k2neg, k2 };\n}\nfunction validateSigFormat(format) {\n    if (!['compact', 'recovered', 'der'].includes(format))\n        throw new Error('Signature format must be \"compact\", \"recovered\", or \"der\"');\n    return format;\n}\nfunction validateSigOpts(opts, def) {\n    const optsn = {};\n    for (let optName of Object.keys(def)) {\n        // @ts-ignore\n        optsn[optName] = opts[optName] === undefined ? def[optName] : opts[optName];\n    }\n    abool(optsn.lowS, 'lowS');\n    abool(optsn.prehash, 'prehash');\n    if (optsn.format !== undefined)\n        validateSigFormat(optsn.format);\n    return optsn;\n}\nexport class DERErr extends Error {\n    constructor(m = '') {\n        super(m);\n    }\n}\n/**\n * ASN.1 DER encoding utilities. ASN is very complex & fragile. Format:\n *\n *     [0x30 (SEQUENCE), bytelength, 0x02 (INTEGER), intLength, R, 0x02 (INTEGER), intLength, S]\n *\n * Docs: https://letsencrypt.org/docs/a-warm-welcome-to-asn1-and-der/, https://luca.ntop.org/Teaching/Appunti/asn1.html\n */\nexport const DER = {\n    // asn.1 DER encoding utils\n    Err: DERErr,\n    // Basic building block is TLV (Tag-Length-Value)\n    _tlv: {\n        encode: (tag, data) => {\n            const { Err: E } = DER;\n            if (tag < 0 || tag > 256)\n                throw new E('tlv.encode: wrong tag');\n            if (data.length & 1)\n                throw new E('tlv.encode: unpadded data');\n            const dataLen = data.length / 2;\n            const len = numberToHexUnpadded(dataLen);\n            if ((len.length / 2) & 128)\n                throw new E('tlv.encode: long form length too big');\n            // length of length with long form flag\n            const lenLen = dataLen > 127 ? numberToHexUnpadded((len.length / 2) | 128) : '';\n            const t = numberToHexUnpadded(tag);\n            return t + lenLen + len + data;\n        },\n        // v - value, l - left bytes (unparsed)\n        decode(tag, data) {\n            const { Err: E } = DER;\n            let pos = 0;\n            if (tag < 0 || tag > 256)\n                throw new E('tlv.encode: wrong tag');\n            if (data.length < 2 || data[pos++] !== tag)\n                throw new E('tlv.decode: wrong tlv');\n            const first = data[pos++];\n            const isLong = !!(first & 128); // First bit of first length byte is flag for short/long form\n            let length = 0;\n            if (!isLong)\n                length = first;\n            else {\n                // Long form: [longFlag(1bit), lengthLength(7bit), length (BE)]\n                const lenLen = first & 127;\n                if (!lenLen)\n                    throw new E('tlv.decode(long): indefinite length not supported');\n                if (lenLen > 4)\n                    throw new E('tlv.decode(long): byte length is too big'); // this will overflow u32 in js\n                const lengthBytes = data.subarray(pos, pos + lenLen);\n                if (lengthBytes.length !== lenLen)\n                    throw new E('tlv.decode: length bytes not complete');\n                if (lengthBytes[0] === 0)\n                    throw new E('tlv.decode(long): zero leftmost byte');\n                for (const b of lengthBytes)\n                    length = (length << 8) | b;\n                pos += lenLen;\n                if (length < 128)\n                    throw new E('tlv.decode(long): not minimal encoding');\n            }\n            const v = data.subarray(pos, pos + length);\n            if (v.length !== length)\n                throw new E('tlv.decode: wrong value length');\n            return { v, l: data.subarray(pos + length) };\n        },\n    },\n    // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n    // since we always use positive integers here. It must always be empty:\n    // - add zero byte if exists\n    // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n    _int: {\n        encode(num) {\n            const { Err: E } = DER;\n            if (num < _0n)\n                throw new E('integer: negative integers are not allowed');\n            let hex = numberToHexUnpadded(num);\n            // Pad with zero byte if negative flag is present\n            if (Number.parseInt(hex[0], 16) & 0b1000)\n                hex = '00' + hex;\n            if (hex.length & 1)\n                throw new E('unexpected DER parsing assertion: unpadded hex');\n            return hex;\n        },\n        decode(data) {\n            const { Err: E } = DER;\n            if (data[0] & 128)\n                throw new E('invalid signature integer: negative');\n            if (data[0] === 0x00 && !(data[1] & 128))\n                throw new E('invalid signature integer: unnecessary leading zero');\n            return bytesToNumberBE(data);\n        },\n    },\n    toSig(hex) {\n        // parse DER signature\n        const { Err: E, _int: int, _tlv: tlv } = DER;\n        const data = ensureBytes('signature', hex);\n        const { v: seqBytes, l: seqLeftBytes } = tlv.decode(0x30, data);\n        if (seqLeftBytes.length)\n            throw new E('invalid signature: left bytes after parsing');\n        const { v: rBytes, l: rLeftBytes } = tlv.decode(0x02, seqBytes);\n        const { v: sBytes, l: sLeftBytes } = tlv.decode(0x02, rLeftBytes);\n        if (sLeftBytes.length)\n            throw new E('invalid signature: left bytes after parsing');\n        return { r: int.decode(rBytes), s: int.decode(sBytes) };\n    },\n    hexFromSig(sig) {\n        const { _tlv: tlv, _int: int } = DER;\n        const rs = tlv.encode(0x02, int.encode(sig.r));\n        const ss = tlv.encode(0x02, int.encode(sig.s));\n        const seq = rs + ss;\n        return tlv.encode(0x30, seq);\n    },\n};\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\nexport function _normFnElement(Fn, key) {\n    const { BYTES: expected } = Fn;\n    let num;\n    if (typeof key === 'bigint') {\n        num = key;\n    }\n    else {\n        let bytes = ensureBytes('private key', key);\n        try {\n            num = Fn.fromBytes(bytes);\n        }\n        catch (error) {\n            throw new Error(`invalid private key: expected ui8a of size ${expected}, got ${typeof key}`);\n        }\n    }\n    if (!Fn.isValidNot0(num))\n        throw new Error('invalid private key: out of range [1..N-1]');\n    return num;\n}\n/**\n * Creates weierstrass Point constructor, based on specified curve options.\n *\n * @example\n```js\nconst opts = {\n  p: BigInt('0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff'),\n  n: BigInt('0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551'),\n  h: BigInt(1),\n  a: BigInt('0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc'),\n  b: BigInt('0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b'),\n  Gx: BigInt('0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296'),\n  Gy: BigInt('0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5'),\n};\nconst p256_Point = weierstrass(opts);\n```\n */\nexport function weierstrassN(params, extraOpts = {}) {\n    const validated = _createCurveFields('weierstrass', params, extraOpts);\n    const { Fp, Fn } = validated;\n    let CURVE = validated.CURVE;\n    const { h: cofactor, n: CURVE_ORDER } = CURVE;\n    _validateObject(extraOpts, {}, {\n        allowInfinityPoint: 'boolean',\n        clearCofactor: 'function',\n        isTorsionFree: 'function',\n        fromBytes: 'function',\n        toBytes: 'function',\n        endo: 'object',\n        wrapPrivateKey: 'boolean',\n    });\n    const { endo } = extraOpts;\n    if (endo) {\n        // validateObject(endo, { beta: 'bigint', splitScalar: 'function' });\n        if (!Fp.is0(CURVE.a) || typeof endo.beta !== 'bigint' || !Array.isArray(endo.basises)) {\n            throw new Error('invalid endo: expected \"beta\": bigint and \"basises\": array');\n        }\n    }\n    const lengths = getWLengths(Fp, Fn);\n    function assertCompressionIsSupported() {\n        if (!Fp.isOdd)\n            throw new Error('compression is not supported: Field does not have .isOdd()');\n    }\n    // Implements IEEE P1363 point encoding\n    function pointToBytes(_c, point, isCompressed) {\n        const { x, y } = point.toAffine();\n        const bx = Fp.toBytes(x);\n        abool(isCompressed, 'isCompressed');\n        if (isCompressed) {\n            assertCompressionIsSupported();\n            const hasEvenY = !Fp.isOdd(y);\n            return concatBytes(pprefix(hasEvenY), bx);\n        }\n        else {\n            return concatBytes(Uint8Array.of(0x04), bx, Fp.toBytes(y));\n        }\n    }\n    function pointFromBytes(bytes) {\n        abytes(bytes, undefined, 'Point');\n        const { publicKey: comp, publicKeyUncompressed: uncomp } = lengths; // e.g. for 32-byte: 33, 65\n        const length = bytes.length;\n        const head = bytes[0];\n        const tail = bytes.subarray(1);\n        // No actual validation is done here: use .assertValidity()\n        if (length === comp && (head === 0x02 || head === 0x03)) {\n            const x = Fp.fromBytes(tail);\n            if (!Fp.isValid(x))\n                throw new Error('bad point: is not on curve, wrong x');\n            const y2 = weierstrassEquation(x); // y = x + ax + b\n            let y;\n            try {\n                y = Fp.sqrt(y2); // y = y ^ (p+1)/4\n            }\n            catch (sqrtError) {\n                const err = sqrtError instanceof Error ? ': ' + sqrtError.message : '';\n                throw new Error('bad point: is not on curve, sqrt error' + err);\n            }\n            assertCompressionIsSupported();\n            const isYOdd = Fp.isOdd(y); // (y & _1n) === _1n;\n            const isHeadOdd = (head & 1) === 1; // ECDSA-specific\n            if (isHeadOdd !== isYOdd)\n                y = Fp.neg(y);\n            return { x, y };\n        }\n        else if (length === uncomp && head === 0x04) {\n            // TODO: more checks\n            const L = Fp.BYTES;\n            const x = Fp.fromBytes(tail.subarray(0, L));\n            const y = Fp.fromBytes(tail.subarray(L, L * 2));\n            if (!isValidXY(x, y))\n                throw new Error('bad point: is not on curve');\n            return { x, y };\n        }\n        else {\n            throw new Error(`bad point: got length ${length}, expected compressed=${comp} or uncompressed=${uncomp}`);\n        }\n    }\n    const encodePoint = extraOpts.toBytes || pointToBytes;\n    const decodePoint = extraOpts.fromBytes || pointFromBytes;\n    function weierstrassEquation(x) {\n        const x2 = Fp.sqr(x); // x * x\n        const x3 = Fp.mul(x2, x); // x * x\n        return Fp.add(Fp.add(x3, Fp.mul(x, CURVE.a)), CURVE.b); // x + a * x + b\n    }\n    // TODO: move top-level\n    /** Checks whether equation holds for given x, y: y == x + ax + b */\n    function isValidXY(x, y) {\n        const left = Fp.sqr(y); // y\n        const right = weierstrassEquation(x); // x + ax + b\n        return Fp.eql(left, right);\n    }\n    // Validate whether the passed curve params are valid.\n    // Test 1: equation y = x + ax + b should work for generator point.\n    if (!isValidXY(CURVE.Gx, CURVE.Gy))\n        throw new Error('bad curve params: generator point');\n    // Test 2: discriminant  part should be non-zero: 4a + 27b != 0.\n    // Guarantees curve is genus-1, smooth (non-singular).\n    const _4a3 = Fp.mul(Fp.pow(CURVE.a, _3n), _4n);\n    const _27b2 = Fp.mul(Fp.sqr(CURVE.b), BigInt(27));\n    if (Fp.is0(Fp.add(_4a3, _27b2)))\n        throw new Error('bad curve params: a or b');\n    /** Asserts coordinate is valid: 0 <= n < Fp.ORDER. */\n    function acoord(title, n, banZero = false) {\n        if (!Fp.isValid(n) || (banZero && Fp.is0(n)))\n            throw new Error(`bad point coordinate ${title}`);\n        return n;\n    }\n    function aprjpoint(other) {\n        if (!(other instanceof Point))\n            throw new Error('ProjectivePoint expected');\n    }\n    function splitEndoScalarN(k) {\n        if (!endo || !endo.basises)\n            throw new Error('no endo');\n        return _splitEndoScalar(k, endo.basises, Fn.ORDER);\n    }\n    // Memoized toAffine / validity check. They are heavy. Points are immutable.\n    // Converts Projective point to affine (x, y) coordinates.\n    // Can accept precomputed Z^-1 - for example, from invertBatch.\n    // (X, Y, Z)  (x=X/Z, y=Y/Z)\n    const toAffineMemo = memoized((p, iz) => {\n        const { X, Y, Z } = p;\n        // Fast-path for normalized points\n        if (Fp.eql(Z, Fp.ONE))\n            return { x: X, y: Y };\n        const is0 = p.is0();\n        // If invZ was 0, we return zero point. However we still want to execute\n        // all operations, so we replace invZ with a random number, 1.\n        if (iz == null)\n            iz = is0 ? Fp.ONE : Fp.inv(Z);\n        const x = Fp.mul(X, iz);\n        const y = Fp.mul(Y, iz);\n        const zz = Fp.mul(Z, iz);\n        if (is0)\n            return { x: Fp.ZERO, y: Fp.ZERO };\n        if (!Fp.eql(zz, Fp.ONE))\n            throw new Error('invZ was invalid');\n        return { x, y };\n    });\n    // NOTE: on exception this will crash 'cached' and no value will be set.\n    // Otherwise true will be return\n    const assertValidMemo = memoized((p) => {\n        if (p.is0()) {\n            // (0, 1, 0) aka ZERO is invalid in most contexts.\n            // In BLS, ZERO can be serialized, so we allow it.\n            // (0, 0, 0) is invalid representation of ZERO.\n            if (extraOpts.allowInfinityPoint && !Fp.is0(p.Y))\n                return;\n            throw new Error('bad point: ZERO');\n        }\n        // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\n        const { x, y } = p.toAffine();\n        if (!Fp.isValid(x) || !Fp.isValid(y))\n            throw new Error('bad point: x or y not field elements');\n        if (!isValidXY(x, y))\n            throw new Error('bad point: equation left != right');\n        if (!p.isTorsionFree())\n            throw new Error('bad point: not in prime-order subgroup');\n        return true;\n    });\n    function finishEndo(endoBeta, k1p, k2p, k1neg, k2neg) {\n        k2p = new Point(Fp.mul(k2p.X, endoBeta), k2p.Y, k2p.Z);\n        k1p = negateCt(k1neg, k1p);\n        k2p = negateCt(k2neg, k2p);\n        return k1p.add(k2p);\n    }\n    /**\n     * Projective Point works in 3d / projective (homogeneous) coordinates:(X, Y, Z)  (x=X/Z, y=Y/Z).\n     * Default Point works in 2d / affine coordinates: (x, y).\n     * We're doing calculations in projective, because its operations don't require costly inversion.\n     */\n    class Point {\n        /** Does NOT validate if the point is valid. Use `.assertValidity()`. */\n        constructor(X, Y, Z) {\n            this.X = acoord('x', X);\n            this.Y = acoord('y', Y, true);\n            this.Z = acoord('z', Z);\n            Object.freeze(this);\n        }\n        static CURVE() {\n            return CURVE;\n        }\n        /** Does NOT validate if the point is valid. Use `.assertValidity()`. */\n        static fromAffine(p) {\n            const { x, y } = p || {};\n            if (!p || !Fp.isValid(x) || !Fp.isValid(y))\n                throw new Error('invalid affine point');\n            if (p instanceof Point)\n                throw new Error('projective point not allowed');\n            // (0, 0) would've produced (0, 0, 1) - instead, we need (0, 1, 0)\n            if (Fp.is0(x) && Fp.is0(y))\n                return Point.ZERO;\n            return new Point(x, y, Fp.ONE);\n        }\n        static fromBytes(bytes) {\n            const P = Point.fromAffine(decodePoint(abytes(bytes, undefined, 'point')));\n            P.assertValidity();\n            return P;\n        }\n        static fromHex(hex) {\n            return Point.fromBytes(ensureBytes('pointHex', hex));\n        }\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        /**\n         *\n         * @param windowSize\n         * @param isLazy true will defer table computation until the first multiplication\n         * @returns\n         */\n        precompute(windowSize = 8, isLazy = true) {\n            wnaf.createCache(this, windowSize);\n            if (!isLazy)\n                this.multiply(_3n); // random number\n            return this;\n        }\n        // TODO: return `this`\n        /** A point on curve is valid if it conforms to equation. */\n        assertValidity() {\n            assertValidMemo(this);\n        }\n        hasEvenY() {\n            const { y } = this.toAffine();\n            if (!Fp.isOdd)\n                throw new Error(\"Field doesn't support isOdd\");\n            return !Fp.isOdd(y);\n        }\n        /** Compare one point to another. */\n        equals(other) {\n            aprjpoint(other);\n            const { X: X1, Y: Y1, Z: Z1 } = this;\n            const { X: X2, Y: Y2, Z: Z2 } = other;\n            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\n            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\n            return U1 && U2;\n        }\n        /** Flips point to one corresponding to (x, -y) in Affine coordinates. */\n        negate() {\n            return new Point(this.X, Fp.neg(this.Y), this.Z);\n        }\n        // Renes-Costello-Batina exception-free doubling formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 3\n        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n        double() {\n            const { a, b } = CURVE;\n            const b3 = Fp.mul(b, _3n);\n            const { X: X1, Y: Y1, Z: Z1 } = this;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            let t0 = Fp.mul(X1, X1); // step 1\n            let t1 = Fp.mul(Y1, Y1);\n            let t2 = Fp.mul(Z1, Z1);\n            let t3 = Fp.mul(X1, Y1);\n            t3 = Fp.add(t3, t3); // step 5\n            Z3 = Fp.mul(X1, Z1);\n            Z3 = Fp.add(Z3, Z3);\n            X3 = Fp.mul(a, Z3);\n            Y3 = Fp.mul(b3, t2);\n            Y3 = Fp.add(X3, Y3); // step 10\n            X3 = Fp.sub(t1, Y3);\n            Y3 = Fp.add(t1, Y3);\n            Y3 = Fp.mul(X3, Y3);\n            X3 = Fp.mul(t3, X3);\n            Z3 = Fp.mul(b3, Z3); // step 15\n            t2 = Fp.mul(a, t2);\n            t3 = Fp.sub(t0, t2);\n            t3 = Fp.mul(a, t3);\n            t3 = Fp.add(t3, Z3);\n            Z3 = Fp.add(t0, t0); // step 20\n            t0 = Fp.add(Z3, t0);\n            t0 = Fp.add(t0, t2);\n            t0 = Fp.mul(t0, t3);\n            Y3 = Fp.add(Y3, t0);\n            t2 = Fp.mul(Y1, Z1); // step 25\n            t2 = Fp.add(t2, t2);\n            t0 = Fp.mul(t2, t3);\n            X3 = Fp.sub(X3, t0);\n            Z3 = Fp.mul(t2, t1);\n            Z3 = Fp.add(Z3, Z3); // step 30\n            Z3 = Fp.add(Z3, Z3);\n            return new Point(X3, Y3, Z3);\n        }\n        // Renes-Costello-Batina exception-free addition formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 1\n        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n        add(other) {\n            aprjpoint(other);\n            const { X: X1, Y: Y1, Z: Z1 } = this;\n            const { X: X2, Y: Y2, Z: Z2 } = other;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            const a = CURVE.a;\n            const b3 = Fp.mul(CURVE.b, _3n);\n            let t0 = Fp.mul(X1, X2); // step 1\n            let t1 = Fp.mul(Y1, Y2);\n            let t2 = Fp.mul(Z1, Z2);\n            let t3 = Fp.add(X1, Y1);\n            let t4 = Fp.add(X2, Y2); // step 5\n            t3 = Fp.mul(t3, t4);\n            t4 = Fp.add(t0, t1);\n            t3 = Fp.sub(t3, t4);\n            t4 = Fp.add(X1, Z1);\n            let t5 = Fp.add(X2, Z2); // step 10\n            t4 = Fp.mul(t4, t5);\n            t5 = Fp.add(t0, t2);\n            t4 = Fp.sub(t4, t5);\n            t5 = Fp.add(Y1, Z1);\n            X3 = Fp.add(Y2, Z2); // step 15\n            t5 = Fp.mul(t5, X3);\n            X3 = Fp.add(t1, t2);\n            t5 = Fp.sub(t5, X3);\n            Z3 = Fp.mul(a, t4);\n            X3 = Fp.mul(b3, t2); // step 20\n            Z3 = Fp.add(X3, Z3);\n            X3 = Fp.sub(t1, Z3);\n            Z3 = Fp.add(t1, Z3);\n            Y3 = Fp.mul(X3, Z3);\n            t1 = Fp.add(t0, t0); // step 25\n            t1 = Fp.add(t1, t0);\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.mul(b3, t4);\n            t1 = Fp.add(t1, t2);\n            t2 = Fp.sub(t0, t2); // step 30\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.add(t4, t2);\n            t0 = Fp.mul(t1, t4);\n            Y3 = Fp.add(Y3, t0);\n            t0 = Fp.mul(t5, t4); // step 35\n            X3 = Fp.mul(t3, X3);\n            X3 = Fp.sub(X3, t0);\n            t0 = Fp.mul(t3, t1);\n            Z3 = Fp.mul(t5, Z3);\n            Z3 = Fp.add(Z3, t0); // step 40\n            return new Point(X3, Y3, Z3);\n        }\n        subtract(other) {\n            return this.add(other.negate());\n        }\n        is0() {\n            return this.equals(Point.ZERO);\n        }\n        /**\n         * Constant time multiplication.\n         * Uses wNAF method. Windowed method may be 10% faster,\n         * but takes 2x longer to generate and consumes 2x memory.\n         * Uses precomputes when available.\n         * Uses endomorphism for Koblitz curves.\n         * @param scalar by which the point would be multiplied\n         * @returns New point\n         */\n        multiply(scalar) {\n            const { endo } = extraOpts;\n            if (!Fn.isValidNot0(scalar))\n                throw new Error('invalid scalar: out of range'); // 0 is invalid\n            let point, fake; // Fake point is used to const-time mult\n            const mul = (n) => wnaf.cached(this, n, (p) => normalizeZ(Point, p));\n            /** See docs for {@link EndomorphismOpts} */\n            if (endo) {\n                const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(scalar);\n                const { p: k1p, f: k1f } = mul(k1);\n                const { p: k2p, f: k2f } = mul(k2);\n                fake = k1f.add(k2f);\n                point = finishEndo(endo.beta, k1p, k2p, k1neg, k2neg);\n            }\n            else {\n                const { p, f } = mul(scalar);\n                point = p;\n                fake = f;\n            }\n            // Normalize `z` for both points, but return only real one\n            return normalizeZ(Point, [point, fake])[0];\n        }\n        /**\n         * Non-constant-time multiplication. Uses double-and-add algorithm.\n         * It's faster, but should only be used when you don't care about\n         * an exposed secret key e.g. sig verification, which works over *public* keys.\n         */\n        multiplyUnsafe(sc) {\n            const { endo } = extraOpts;\n            const p = this;\n            if (!Fn.isValid(sc))\n                throw new Error('invalid scalar: out of range'); // 0 is valid\n            if (sc === _0n || p.is0())\n                return Point.ZERO;\n            if (sc === _1n)\n                return p; // fast-path\n            if (wnaf.hasCache(this))\n                return this.multiply(sc);\n            if (endo) {\n                const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(sc);\n                const { p1, p2 } = mulEndoUnsafe(Point, p, k1, k2); // 30% faster vs wnaf.unsafe\n                return finishEndo(endo.beta, p1, p2, k1neg, k2neg);\n            }\n            else {\n                return wnaf.unsafe(p, sc);\n            }\n        }\n        multiplyAndAddUnsafe(Q, a, b) {\n            const sum = this.multiplyUnsafe(a).add(Q.multiplyUnsafe(b));\n            return sum.is0() ? undefined : sum;\n        }\n        /**\n         * Converts Projective point to affine (x, y) coordinates.\n         * @param invertedZ Z^-1 (inverted zero) - optional, precomputation is useful for invertBatch\n         */\n        toAffine(invertedZ) {\n            return toAffineMemo(this, invertedZ);\n        }\n        /**\n         * Checks whether Point is free of torsion elements (is in prime subgroup).\n         * Always torsion-free for cofactor=1 curves.\n         */\n        isTorsionFree() {\n            const { isTorsionFree } = extraOpts;\n            if (cofactor === _1n)\n                return true;\n            if (isTorsionFree)\n                return isTorsionFree(Point, this);\n            return wnaf.unsafe(this, CURVE_ORDER).is0();\n        }\n        clearCofactor() {\n            const { clearCofactor } = extraOpts;\n            if (cofactor === _1n)\n                return this; // Fast-path\n            if (clearCofactor)\n                return clearCofactor(Point, this);\n            return this.multiplyUnsafe(cofactor);\n        }\n        isSmallOrder() {\n            // can we use this.clearCofactor()?\n            return this.multiplyUnsafe(cofactor).is0();\n        }\n        toBytes(isCompressed = true) {\n            abool(isCompressed, 'isCompressed');\n            this.assertValidity();\n            return encodePoint(Point, this, isCompressed);\n        }\n        toHex(isCompressed = true) {\n            return bytesToHex(this.toBytes(isCompressed));\n        }\n        toString() {\n            return `<Point ${this.is0() ? 'ZERO' : this.toHex()}>`;\n        }\n        // TODO: remove\n        get px() {\n            return this.X;\n        }\n        get py() {\n            return this.X;\n        }\n        get pz() {\n            return this.Z;\n        }\n        toRawBytes(isCompressed = true) {\n            return this.toBytes(isCompressed);\n        }\n        _setWindowSize(windowSize) {\n            this.precompute(windowSize);\n        }\n        static normalizeZ(points) {\n            return normalizeZ(Point, points);\n        }\n        static msm(points, scalars) {\n            return pippenger(Point, Fn, points, scalars);\n        }\n        static fromPrivateKey(privateKey) {\n            return Point.BASE.multiply(_normFnElement(Fn, privateKey));\n        }\n    }\n    // base / generator point\n    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\n    // zero / infinity / identity point\n    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO); // 0, 1, 0\n    // math field\n    Point.Fp = Fp;\n    // scalar field\n    Point.Fn = Fn;\n    const bits = Fn.BITS;\n    const wnaf = new wNAF(Point, extraOpts.endo ? Math.ceil(bits / 2) : bits);\n    Point.BASE.precompute(8); // Enable precomputes. Slows down first publicKey computation by 20ms.\n    return Point;\n}\n// Points start with byte 0x02 when y is even; otherwise 0x03\nfunction pprefix(hasEvenY) {\n    return Uint8Array.of(hasEvenY ? 0x02 : 0x03);\n}\n/**\n * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.\n * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.\n * b = True and y = sqrt(u / v) if (u / v) is square in F, and\n * b = False and y = sqrt(Z * (u / v)) otherwise.\n * @param Fp\n * @param Z\n * @returns\n */\nexport function SWUFpSqrtRatio(Fp, Z) {\n    // Generic implementation\n    const q = Fp.ORDER;\n    let l = _0n;\n    for (let o = q - _1n; o % _2n === _0n; o /= _2n)\n        l += _1n;\n    const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\n    // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.\n    // 2n ** c1 == 2n << (c1-1)\n    const _2n_pow_c1_1 = _2n << (c1 - _1n - _1n);\n    const _2n_pow_c1 = _2n_pow_c1_1 * _2n;\n    const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic\n    const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\n    const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\n    const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic\n    const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\n    const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)\n    let sqrtRatio = (u, v) => {\n        let tv1 = c6; // 1. tv1 = c6\n        let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\n        let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\n        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\n        let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\n        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\n        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\n        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\n        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\n        let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\n        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\n        let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\n        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\n        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\n        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\n        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\n        // 17. for i in (c1, c1 - 1, ..., 2):\n        for (let i = c1; i > _1n; i--) {\n            let tv5 = i - _2n; // 18.    tv5 = i - 2\n            tv5 = _2n << (tv5 - _1n); // 19.    tv5 = 2^tv5\n            let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\n            const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\n            tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\n            tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\n            tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\n            tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\n            tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\n        }\n        return { isValid: isQR, value: tv3 };\n    };\n    if (Fp.ORDER % _4n === _3n) {\n        // sqrt_ratio_3mod4(u, v)\n        const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\n        const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\n        sqrtRatio = (u, v) => {\n            let tv1 = Fp.sqr(v); // 1. tv1 = v^2\n            const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\n            tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\n            let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\n            y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\n            const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\n            const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\n            const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\n            let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\n            return { isValid: isQR, value: y }; // 11. return (isQR, y) isQR ? y : y*c2\n        };\n    }\n    // No curves uses that\n    // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\n    return sqrtRatio;\n}\n/**\n * Simplified Shallue-van de Woestijne-Ulas Method\n * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2\n */\nexport function mapToCurveSimpleSWU(Fp, opts) {\n    validateField(Fp);\n    const { A, B, Z } = opts;\n    if (!Fp.isValid(A) || !Fp.isValid(B) || !Fp.isValid(Z))\n        throw new Error('mapToCurveSimpleSWU: invalid opts');\n    const sqrtRatio = SWUFpSqrtRatio(Fp, Z);\n    if (!Fp.isOdd)\n        throw new Error('Field does not have .isOdd()');\n    // Input: u, an element of F.\n    // Output: (x, y), a point on E.\n    return (u) => {\n        // prettier-ignore\n        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\n        tv1 = Fp.sqr(u); // 1.  tv1 = u^2\n        tv1 = Fp.mul(tv1, Z); // 2.  tv1 = Z * tv1\n        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\n        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\n        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\n        tv3 = Fp.mul(tv3, B); // 6.  tv3 = B * tv3\n        tv4 = Fp.cmov(Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\n        tv4 = Fp.mul(tv4, A); // 8.  tv4 = A * tv4\n        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\n        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\n        tv5 = Fp.mul(tv6, A); // 11. tv5 = A * tv6\n        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\n        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\n        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\n        tv5 = Fp.mul(tv6, B); // 15. tv5 = B * tv6\n        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\n        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\n        const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\n        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\n        y = Fp.mul(y, value); // 20.   y = y * y1\n        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\n        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\n        const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)\n        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\n        const tv4_inv = FpInvertBatch(Fp, [tv4], true)[0];\n        x = Fp.mul(x, tv4_inv); // 25.   x = x / tv4\n        return { x, y };\n    };\n}\nfunction getWLengths(Fp, Fn) {\n    return {\n        secretKey: Fn.BYTES,\n        publicKey: 1 + Fp.BYTES,\n        publicKeyUncompressed: 1 + 2 * Fp.BYTES,\n        publicKeyHasPrefix: true,\n        signature: 2 * Fn.BYTES,\n    };\n}\n/**\n * Sometimes users only need getPublicKey, getSharedSecret, and secret key handling.\n * This helper ensures no signature functionality is present. Less code, smaller bundle size.\n */\nexport function ecdh(Point, ecdhOpts = {}) {\n    const { Fn } = Point;\n    const randomBytes_ = ecdhOpts.randomBytes || randomBytesWeb;\n    const lengths = Object.assign(getWLengths(Point.Fp, Fn), { seed: getMinHashLength(Fn.ORDER) });\n    function isValidSecretKey(secretKey) {\n        try {\n            return !!_normFnElement(Fn, secretKey);\n        }\n        catch (error) {\n            return false;\n        }\n    }\n    function isValidPublicKey(publicKey, isCompressed) {\n        const { publicKey: comp, publicKeyUncompressed } = lengths;\n        try {\n            const l = publicKey.length;\n            if (isCompressed === true && l !== comp)\n                return false;\n            if (isCompressed === false && l !== publicKeyUncompressed)\n                return false;\n            return !!Point.fromBytes(publicKey);\n        }\n        catch (error) {\n            return false;\n        }\n    }\n    /**\n     * Produces cryptographically secure secret key from random of size\n     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.\n     */\n    function randomSecretKey(seed = randomBytes_(lengths.seed)) {\n        return mapHashToField(abytes(seed, lengths.seed, 'seed'), Fn.ORDER);\n    }\n    /**\n     * Computes public key for a secret key. Checks for validity of the secret key.\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns Public key, full when isCompressed=false; short when isCompressed=true\n     */\n    function getPublicKey(secretKey, isCompressed = true) {\n        return Point.BASE.multiply(_normFnElement(Fn, secretKey)).toBytes(isCompressed);\n    }\n    function keygen(seed) {\n        const secretKey = randomSecretKey(seed);\n        return { secretKey, publicKey: getPublicKey(secretKey) };\n    }\n    /**\n     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\n     */\n    function isProbPub(item) {\n        if (typeof item === 'bigint')\n            return false;\n        if (item instanceof Point)\n            return true;\n        const { secretKey, publicKey, publicKeyUncompressed } = lengths;\n        if (Fn.allowedLengths || secretKey === publicKey)\n            return undefined;\n        const l = ensureBytes('key', item).length;\n        return l === publicKey || l === publicKeyUncompressed;\n    }\n    /**\n     * ECDH (Elliptic Curve Diffie Hellman).\n     * Computes shared public key from secret key A and public key B.\n     * Checks: 1) secret key validity 2) shared key is on-curve.\n     * Does NOT hash the result.\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns shared public key\n     */\n    function getSharedSecret(secretKeyA, publicKeyB, isCompressed = true) {\n        if (isProbPub(secretKeyA) === true)\n            throw new Error('first arg must be private key');\n        if (isProbPub(publicKeyB) === false)\n            throw new Error('second arg must be public key');\n        const s = _normFnElement(Fn, secretKeyA);\n        const b = Point.fromHex(publicKeyB); // checks for being on-curve\n        return b.multiply(s).toBytes(isCompressed);\n    }\n    const utils = {\n        isValidSecretKey,\n        isValidPublicKey,\n        randomSecretKey,\n        // TODO: remove\n        isValidPrivateKey: isValidSecretKey,\n        randomPrivateKey: randomSecretKey,\n        normPrivateKeyToScalar: (key) => _normFnElement(Fn, key),\n        precompute(windowSize = 8, point = Point.BASE) {\n            return point.precompute(windowSize, false);\n        },\n    };\n    return Object.freeze({ getPublicKey, getSharedSecret, keygen, Point, utils, lengths });\n}\n/**\n * Creates ECDSA signing interface for given elliptic curve `Point` and `hash` function.\n * We need `hash` for 2 features:\n * 1. Message prehash-ing. NOT used if `sign` / `verify` are called with `prehash: false`\n * 2. k generation in `sign`, using HMAC-drbg(hash)\n *\n * ECDSAOpts are only rarely needed.\n *\n * @example\n * ```js\n * const p256_Point = weierstrass(...);\n * const p256_sha256 = ecdsa(p256_Point, sha256);\n * const p256_sha224 = ecdsa(p256_Point, sha224);\n * const p256_sha224_r = ecdsa(p256_Point, sha224, { randomBytes: (length) => { ... } });\n * ```\n */\nexport function ecdsa(Point, hash, ecdsaOpts = {}) {\n    ahash(hash);\n    _validateObject(ecdsaOpts, {}, {\n        hmac: 'function',\n        lowS: 'boolean',\n        randomBytes: 'function',\n        bits2int: 'function',\n        bits2int_modN: 'function',\n    });\n    const randomBytes = ecdsaOpts.randomBytes || randomBytesWeb;\n    const hmac = ecdsaOpts.hmac ||\n        ((key, ...msgs) => nobleHmac(hash, key, concatBytes(...msgs)));\n    const { Fp, Fn } = Point;\n    const { ORDER: CURVE_ORDER, BITS: fnBits } = Fn;\n    const { keygen, getPublicKey, getSharedSecret, utils, lengths } = ecdh(Point, ecdsaOpts);\n    const defaultSigOpts = {\n        prehash: false,\n        lowS: typeof ecdsaOpts.lowS === 'boolean' ? ecdsaOpts.lowS : false,\n        format: undefined, //'compact' as ECDSASigFormat,\n        extraEntropy: false,\n    };\n    const defaultSigOpts_format = 'compact';\n    function isBiggerThanHalfOrder(number) {\n        const HALF = CURVE_ORDER >> _1n;\n        return number > HALF;\n    }\n    function validateRS(title, num) {\n        if (!Fn.isValidNot0(num))\n            throw new Error(`invalid signature ${title}: out of range 1..Point.Fn.ORDER`);\n        return num;\n    }\n    function validateSigLength(bytes, format) {\n        validateSigFormat(format);\n        const size = lengths.signature;\n        const sizer = format === 'compact' ? size : format === 'recovered' ? size + 1 : undefined;\n        return abytes(bytes, sizer, `${format} signature`);\n    }\n    /**\n     * ECDSA signature with its (r, s) properties. Supports compact, recovered & DER representations.\n     */\n    class Signature {\n        constructor(r, s, recovery) {\n            this.r = validateRS('r', r); // r in [1..N-1];\n            this.s = validateRS('s', s); // s in [1..N-1];\n            if (recovery != null)\n                this.recovery = recovery;\n            Object.freeze(this);\n        }\n        static fromBytes(bytes, format = defaultSigOpts_format) {\n            validateSigLength(bytes, format);\n            let recid;\n            if (format === 'der') {\n                const { r, s } = DER.toSig(abytes(bytes));\n                return new Signature(r, s);\n            }\n            if (format === 'recovered') {\n                recid = bytes[0];\n                format = 'compact';\n                bytes = bytes.subarray(1);\n            }\n            const L = Fn.BYTES;\n            const r = bytes.subarray(0, L);\n            const s = bytes.subarray(L, L * 2);\n            return new Signature(Fn.fromBytes(r), Fn.fromBytes(s), recid);\n        }\n        static fromHex(hex, format) {\n            return this.fromBytes(hexToBytes(hex), format);\n        }\n        addRecoveryBit(recovery) {\n            return new Signature(this.r, this.s, recovery);\n        }\n        recoverPublicKey(messageHash) {\n            const FIELD_ORDER = Fp.ORDER;\n            const { r, s, recovery: rec } = this;\n            if (rec == null || ![0, 1, 2, 3].includes(rec))\n                throw new Error('recovery id invalid');\n            // ECDSA recovery is hard for cofactor > 1 curves.\n            // In sign, `r = q.x mod n`, and here we recover q.x from r.\n            // While recovering q.x >= n, we need to add r+n for cofactor=1 curves.\n            // However, for cofactor>1, r+n may not get q.x:\n            // r+n*i would need to be done instead where i is unknown.\n            // To easily get i, we either need to:\n            // a. increase amount of valid recid values (4, 5...); OR\n            // b. prohibit non-prime-order signatures (recid > 1).\n            const hasCofactor = CURVE_ORDER * _2n < FIELD_ORDER;\n            if (hasCofactor && rec > 1)\n                throw new Error('recovery id is ambiguous for h>1 curve');\n            const radj = rec === 2 || rec === 3 ? r + CURVE_ORDER : r;\n            if (!Fp.isValid(radj))\n                throw new Error('recovery id 2 or 3 invalid');\n            const x = Fp.toBytes(radj);\n            const R = Point.fromBytes(concatBytes(pprefix((rec & 1) === 0), x));\n            const ir = Fn.inv(radj); // r^-1\n            const h = bits2int_modN(ensureBytes('msgHash', messageHash)); // Truncate hash\n            const u1 = Fn.create(-h * ir); // -hr^-1\n            const u2 = Fn.create(s * ir); // sr^-1\n            // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1). unsafe is fine: there is no private data.\n            const Q = Point.BASE.multiplyUnsafe(u1).add(R.multiplyUnsafe(u2));\n            if (Q.is0())\n                throw new Error('point at infinify');\n            Q.assertValidity();\n            return Q;\n        }\n        // Signatures should be low-s, to prevent malleability.\n        hasHighS() {\n            return isBiggerThanHalfOrder(this.s);\n        }\n        toBytes(format = defaultSigOpts_format) {\n            validateSigFormat(format);\n            if (format === 'der')\n                return hexToBytes(DER.hexFromSig(this));\n            const r = Fn.toBytes(this.r);\n            const s = Fn.toBytes(this.s);\n            if (format === 'recovered') {\n                if (this.recovery == null)\n                    throw new Error('recovery bit must be present');\n                return concatBytes(Uint8Array.of(this.recovery), r, s);\n            }\n            return concatBytes(r, s);\n        }\n        toHex(format) {\n            return bytesToHex(this.toBytes(format));\n        }\n        // TODO: remove\n        assertValidity() { }\n        static fromCompact(hex) {\n            return Signature.fromBytes(ensureBytes('sig', hex), 'compact');\n        }\n        static fromDER(hex) {\n            return Signature.fromBytes(ensureBytes('sig', hex), 'der');\n        }\n        normalizeS() {\n            return this.hasHighS() ? new Signature(this.r, Fn.neg(this.s), this.recovery) : this;\n        }\n        toDERRawBytes() {\n            return this.toBytes('der');\n        }\n        toDERHex() {\n            return bytesToHex(this.toBytes('der'));\n        }\n        toCompactRawBytes() {\n            return this.toBytes('compact');\n        }\n        toCompactHex() {\n            return bytesToHex(this.toBytes('compact'));\n        }\n    }\n    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\n    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\n    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\n    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\n    const bits2int = ecdsaOpts.bits2int ||\n        function bits2int_def(bytes) {\n            // Our custom check \"just in case\", for protection against DoS\n            if (bytes.length > 8192)\n                throw new Error('input is too large');\n            // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\n            // for some cases, since bytes.length * 8 is not actual bitLength.\n            const num = bytesToNumberBE(bytes); // check for == u8 done here\n            const delta = bytes.length * 8 - fnBits; // truncate to nBitLength leftmost bits\n            return delta > 0 ? num >> BigInt(delta) : num;\n        };\n    const bits2int_modN = ecdsaOpts.bits2int_modN ||\n        function bits2int_modN_def(bytes) {\n            return Fn.create(bits2int(bytes)); // can't use bytesToNumberBE here\n        };\n    // Pads output with zero as per spec\n    const ORDER_MASK = bitMask(fnBits);\n    /** Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`. */\n    function int2octets(num) {\n        // IMPORTANT: the check ensures working for case `Fn.BYTES != Fn.BITS * 8`\n        aInRange('num < 2^' + fnBits, num, _0n, ORDER_MASK);\n        return Fn.toBytes(num);\n    }\n    function validateMsgAndHash(message, prehash) {\n        abytes(message, undefined, 'message');\n        return prehash ? abytes(hash(message), undefined, 'prehashed message') : message;\n    }\n    /**\n     * Steps A, D of RFC6979 3.2.\n     * Creates RFC6979 seed; converts msg/privKey to numbers.\n     * Used only in sign, not in verify.\n     *\n     * Warning: we cannot assume here that message has same amount of bytes as curve order,\n     * this will be invalid at least for P521. Also it can be bigger for P224 + SHA256.\n     */\n    function prepSig(message, privateKey, opts) {\n        if (['recovered', 'canonical'].some((k) => k in opts))\n            throw new Error('sign() legacy options not supported');\n        const { lowS, prehash, extraEntropy } = validateSigOpts(opts, defaultSigOpts);\n        message = validateMsgAndHash(message, prehash); // RFC6979 3.2 A: h1 = H(m)\n        // We can't later call bits2octets, since nested bits2int is broken for curves\n        // with fnBits % 8 !== 0. Because of that, we unwrap it here as int2octets call.\n        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\n        const h1int = bits2int_modN(message);\n        const d = _normFnElement(Fn, privateKey); // validate secret key, convert to bigint\n        const seedArgs = [int2octets(d), int2octets(h1int)];\n        // extraEntropy. RFC6979 3.6: additional k' (optional).\n        if (extraEntropy != null && extraEntropy !== false) {\n            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n            // gen random bytes OR pass as-is\n            const e = extraEntropy === true ? randomBytes(lengths.secretKey) : extraEntropy;\n            seedArgs.push(ensureBytes('extraEntropy', e)); // check for being bytes\n        }\n        const seed = concatBytes(...seedArgs); // Step D of RFC6979 3.2\n        const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!\n        // Converts signature params into point w r/s, checks result for validity.\n        // To transform k => Signature:\n        // q = kG\n        // r = q.x mod n\n        // s = k^-1(m + rd) mod n\n        // Can use scalar blinding b^-1(bm + bdr) where b  [1,q1] according to\n        // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\n        // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\n        function k2sig(kBytes) {\n            // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n            // Important: all mod() calls here must be done over N\n            const k = bits2int(kBytes); // mod n, not mod p\n            if (!Fn.isValidNot0(k))\n                return; // Valid scalars (including k) must be in 1..N-1\n            const ik = Fn.inv(k); // k^-1 mod n\n            const q = Point.BASE.multiply(k).toAffine(); // q = kG\n            const r = Fn.create(q.x); // r = q.x mod n\n            if (r === _0n)\n                return;\n            const s = Fn.create(ik * Fn.create(m + r * d)); // Not using blinding here, see comment above\n            if (s === _0n)\n                return;\n            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)\n            let normS = s;\n            if (lowS && isBiggerThanHalfOrder(s)) {\n                normS = Fn.neg(s); // if lowS was passed, ensure s is always\n                recovery ^= 1; // // in the bottom half of N\n            }\n            return new Signature(r, normS, recovery); // use normS, not s\n        }\n        return { seed, k2sig };\n    }\n    /**\n     * Signs message hash with a secret key.\n     *\n     * ```\n     * sign(m, d) where\n     *   k = rfc6979_hmac_drbg(m, d)\n     *   (x, y) = G  k\n     *   r = x mod n\n     *   s = (m + dr) / k mod n\n     * ```\n     */\n    function sign(message, secretKey, opts = {}) {\n        message = ensureBytes('message', message);\n        const { seed, k2sig } = prepSig(message, secretKey, opts); // Steps A, D of RFC6979 3.2.\n        const drbg = createHmacDrbg(hash.outputLen, Fn.BYTES, hmac);\n        const sig = drbg(seed, k2sig); // Steps B, C, D, E, F, G\n        return sig;\n    }\n    function tryParsingSig(sg) {\n        // Try to deduce format\n        let sig = undefined;\n        const isHex = typeof sg === 'string' || isBytes(sg);\n        const isObj = !isHex &&\n            sg !== null &&\n            typeof sg === 'object' &&\n            typeof sg.r === 'bigint' &&\n            typeof sg.s === 'bigint';\n        if (!isHex && !isObj)\n            throw new Error('invalid signature, expected Uint8Array, hex string or Signature instance');\n        if (isObj) {\n            sig = new Signature(sg.r, sg.s);\n        }\n        else if (isHex) {\n            try {\n                sig = Signature.fromBytes(ensureBytes('sig', sg), 'der');\n            }\n            catch (derError) {\n                if (!(derError instanceof DER.Err))\n                    throw derError;\n            }\n            if (!sig) {\n                try {\n                    sig = Signature.fromBytes(ensureBytes('sig', sg), 'compact');\n                }\n                catch (error) {\n                    return false;\n                }\n            }\n        }\n        if (!sig)\n            return false;\n        return sig;\n    }\n    /**\n     * Verifies a signature against message and public key.\n     * Rejects lowS signatures by default: see {@link ECDSAVerifyOpts}.\n     * Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\n     *\n     * ```\n     * verify(r, s, h, P) where\n     *   u1 = hs^-1 mod n\n     *   u2 = rs^-1 mod n\n     *   R = u1G + u2P\n     *   mod(R.x, n) == r\n     * ```\n     */\n    function verify(signature, message, publicKey, opts = {}) {\n        const { lowS, prehash, format } = validateSigOpts(opts, defaultSigOpts);\n        publicKey = ensureBytes('publicKey', publicKey);\n        message = validateMsgAndHash(ensureBytes('message', message), prehash);\n        if ('strict' in opts)\n            throw new Error('options.strict was renamed to lowS');\n        const sig = format === undefined\n            ? tryParsingSig(signature)\n            : Signature.fromBytes(ensureBytes('sig', signature), format);\n        if (sig === false)\n            return false;\n        try {\n            const P = Point.fromBytes(publicKey);\n            if (lowS && sig.hasHighS())\n                return false;\n            const { r, s } = sig;\n            const h = bits2int_modN(message); // mod n, not mod p\n            const is = Fn.inv(s); // s^-1 mod n\n            const u1 = Fn.create(h * is); // u1 = hs^-1 mod n\n            const u2 = Fn.create(r * is); // u2 = rs^-1 mod n\n            const R = Point.BASE.multiplyUnsafe(u1).add(P.multiplyUnsafe(u2)); // u1G + u2P\n            if (R.is0())\n                return false;\n            const v = Fn.create(R.x); // v = r.x mod n\n            return v === r;\n        }\n        catch (e) {\n            return false;\n        }\n    }\n    function recoverPublicKey(signature, message, opts = {}) {\n        const { prehash } = validateSigOpts(opts, defaultSigOpts);\n        message = validateMsgAndHash(message, prehash);\n        return Signature.fromBytes(signature, 'recovered').recoverPublicKey(message).toBytes();\n    }\n    return Object.freeze({\n        keygen,\n        getPublicKey,\n        getSharedSecret,\n        utils,\n        lengths,\n        Point,\n        sign,\n        verify,\n        recoverPublicKey,\n        Signature,\n        hash,\n    });\n}\n/** @deprecated use `weierstrass` in newer releases */\nexport function weierstrassPoints(c) {\n    const { CURVE, curveOpts } = _weierstrass_legacy_opts_to_new(c);\n    const Point = weierstrassN(CURVE, curveOpts);\n    return _weierstrass_new_output_to_legacy(c, Point);\n}\nfunction _weierstrass_legacy_opts_to_new(c) {\n    const CURVE = {\n        a: c.a,\n        b: c.b,\n        p: c.Fp.ORDER,\n        n: c.n,\n        h: c.h,\n        Gx: c.Gx,\n        Gy: c.Gy,\n    };\n    const Fp = c.Fp;\n    let allowedLengths = c.allowedPrivateKeyLengths\n        ? Array.from(new Set(c.allowedPrivateKeyLengths.map((l) => Math.ceil(l / 2))))\n        : undefined;\n    const Fn = Field(CURVE.n, {\n        BITS: c.nBitLength,\n        allowedLengths: allowedLengths,\n        modFromBytes: c.wrapPrivateKey,\n    });\n    const curveOpts = {\n        Fp,\n        Fn,\n        allowInfinityPoint: c.allowInfinityPoint,\n        endo: c.endo,\n        isTorsionFree: c.isTorsionFree,\n        clearCofactor: c.clearCofactor,\n        fromBytes: c.fromBytes,\n        toBytes: c.toBytes,\n    };\n    return { CURVE, curveOpts };\n}\nfunction _ecdsa_legacy_opts_to_new(c) {\n    const { CURVE, curveOpts } = _weierstrass_legacy_opts_to_new(c);\n    const ecdsaOpts = {\n        hmac: c.hmac,\n        randomBytes: c.randomBytes,\n        lowS: c.lowS,\n        bits2int: c.bits2int,\n        bits2int_modN: c.bits2int_modN,\n    };\n    return { CURVE, curveOpts, hash: c.hash, ecdsaOpts };\n}\nexport function _legacyHelperEquat(Fp, a, b) {\n    /**\n     * y = x + ax + b: Short weierstrass curve formula. Takes x, returns y.\n     * @returns y\n     */\n    function weierstrassEquation(x) {\n        const x2 = Fp.sqr(x); // x * x\n        const x3 = Fp.mul(x2, x); // x * x\n        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x + a * x + b\n    }\n    return weierstrassEquation;\n}\nfunction _weierstrass_new_output_to_legacy(c, Point) {\n    const { Fp, Fn } = Point;\n    function isWithinCurveOrder(num) {\n        return inRange(num, _1n, Fn.ORDER);\n    }\n    const weierstrassEquation = _legacyHelperEquat(Fp, c.a, c.b);\n    return Object.assign({}, {\n        CURVE: c,\n        Point: Point,\n        ProjectivePoint: Point,\n        normPrivateKeyToScalar: (key) => _normFnElement(Fn, key),\n        weierstrassEquation,\n        isWithinCurveOrder,\n    });\n}\nfunction _ecdsa_new_output_to_legacy(c, _ecdsa) {\n    const Point = _ecdsa.Point;\n    return Object.assign({}, _ecdsa, {\n        ProjectivePoint: Point,\n        CURVE: Object.assign({}, c, nLength(Point.Fn.ORDER, Point.Fn.BITS)),\n    });\n}\n// _ecdsa_legacy\nexport function weierstrass(c) {\n    const { CURVE, curveOpts, hash, ecdsaOpts } = _ecdsa_legacy_opts_to_new(c);\n    const Point = weierstrassN(CURVE, curveOpts);\n    const signs = ecdsa(Point, hash, ecdsaOpts);\n    return _ecdsa_new_output_to_legacy(c, signs);\n}\n//# sourceMappingURL=weierstrass.js.map","/**\n * Utilities for short weierstrass curves, combined with noble-hashes.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { weierstrass } from \"./abstract/weierstrass.js\";\n/** connects noble-curves to noble-hashes */\nexport function getHash(hash) {\n    return { hash };\n}\n/** @deprecated use new `weierstrass()` and `ecdsa()` methods */\nexport function createCurve(curveDef, defHash) {\n    const create = (hash) => weierstrass({ ...curveDef, hash: hash });\n    return { ...create(defHash), create };\n}\n//# sourceMappingURL=_shortw_utils.js.map","/**\n * SECG secp256k1. See [pdf](https://www.secg.org/sec2-v2.pdf).\n *\n * Belongs to Koblitz curves: it has efficiently-computable GLV endomorphism ,\n * check out {@link EndomorphismOpts}. Seems to be rigid (not backdoored).\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { sha256 } from '@noble/hashes/sha2.js';\nimport { randomBytes } from '@noble/hashes/utils.js';\nimport { createCurve } from \"./_shortw_utils.js\";\nimport { createHasher, isogenyMap, } from \"./abstract/hash-to-curve.js\";\nimport { Field, mapHashToField, mod, pow2 } from \"./abstract/modular.js\";\nimport { _normFnElement, mapToCurveSimpleSWU, } from \"./abstract/weierstrass.js\";\nimport { bytesToNumberBE, concatBytes, ensureBytes, inRange, numberToBytesBE, utf8ToBytes, } from \"./utils.js\";\n// Seems like generator was produced from some seed:\n// `Point.BASE.multiply(Point.Fn.inv(2n, N)).toAffine().x`\n// // gives short x 0x3b78ce563f89a0ed9414f5aa28ad0d96d6795f9c63n\nconst secp256k1_CURVE = {\n    p: BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f'),\n    n: BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141'),\n    h: BigInt(1),\n    a: BigInt(0),\n    b: BigInt(7),\n    Gx: BigInt('0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'),\n    Gy: BigInt('0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8'),\n};\nconst secp256k1_ENDO = {\n    beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\n    basises: [\n        [BigInt('0x3086d221a7d46bcde86c90e49284eb15'), -BigInt('0xe4437ed6010e88286f547fa90abfe4c3')],\n        [BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8'), BigInt('0x3086d221a7d46bcde86c90e49284eb15')],\n    ],\n};\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nconst _2n = /* @__PURE__ */ BigInt(2);\n/**\n * n = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.\n * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]\n */\nfunction sqrtMod(y) {\n    const P = secp256k1_CURVE.p;\n    // prettier-ignore\n    const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);\n    // prettier-ignore\n    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);\n    const b2 = (y * y * y) % P; // x^3, 11\n    const b3 = (b2 * b2 * y) % P; // x^7\n    const b6 = (pow2(b3, _3n, P) * b3) % P;\n    const b9 = (pow2(b6, _3n, P) * b3) % P;\n    const b11 = (pow2(b9, _2n, P) * b2) % P;\n    const b22 = (pow2(b11, _11n, P) * b11) % P;\n    const b44 = (pow2(b22, _22n, P) * b22) % P;\n    const b88 = (pow2(b44, _44n, P) * b44) % P;\n    const b176 = (pow2(b88, _88n, P) * b88) % P;\n    const b220 = (pow2(b176, _44n, P) * b44) % P;\n    const b223 = (pow2(b220, _3n, P) * b3) % P;\n    const t1 = (pow2(b223, _23n, P) * b22) % P;\n    const t2 = (pow2(t1, _6n, P) * b2) % P;\n    const root = pow2(t2, _2n, P);\n    if (!Fpk1.eql(Fpk1.sqr(root), y))\n        throw new Error('Cannot find square root');\n    return root;\n}\nconst Fpk1 = Field(secp256k1_CURVE.p, { sqrt: sqrtMod });\n/**\n * secp256k1 curve, ECDSA and ECDH methods.\n *\n * Field: `2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n`\n *\n * @example\n * ```js\n * import { secp256k1 } from '@noble/curves/secp256k1';\n * const { secretKey, publicKey } = secp256k1.keygen();\n * const msg = new TextEncoder().encode('hello');\n * const sig = secp256k1.sign(msg, secretKey);\n * const isValid = secp256k1.verify(sig, msg, publicKey) === true;\n * ```\n */\nexport const secp256k1 = createCurve({ ...secp256k1_CURVE, Fp: Fpk1, lowS: true, endo: secp256k1_ENDO }, sha256);\n// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.\n// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\n/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */\nconst TAGGED_HASH_PREFIXES = {};\nfunction taggedHash(tag, ...messages) {\n    let tagP = TAGGED_HASH_PREFIXES[tag];\n    if (tagP === undefined) {\n        const tagH = sha256(utf8ToBytes(tag));\n        tagP = concatBytes(tagH, tagH);\n        TAGGED_HASH_PREFIXES[tag] = tagP;\n    }\n    return sha256(concatBytes(tagP, ...messages));\n}\n// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03\nconst pointToBytes = (point) => point.toBytes(true).slice(1);\nconst Pointk1 = /* @__PURE__ */ (() => secp256k1.Point)();\nconst hasEven = (y) => y % _2n === _0n;\n// Calculate point, scalar and bytes\nfunction schnorrGetExtPubKey(priv) {\n    const { Fn, BASE } = Pointk1;\n    const d_ = _normFnElement(Fn, priv);\n    const p = BASE.multiply(d_); // P = d'G; 0 < d' < n check is done inside\n    const scalar = hasEven(p.y) ? d_ : Fn.neg(d_);\n    return { scalar, bytes: pointToBytes(p) };\n}\n/**\n * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.\n * @returns valid point checked for being on-curve\n */\nfunction lift_x(x) {\n    const Fp = Fpk1;\n    if (!Fp.isValidNot0(x))\n        throw new Error('invalid x: Fail if x  p');\n    const xx = Fp.create(x * x);\n    const c = Fp.create(xx * x + BigInt(7)); // Let c = x + 7 mod p.\n    let y = Fp.sqrt(c); // Let y = c^(p+1)/4 mod p. Same as sqrt().\n    // Return the unique point P such that x(P) = x and\n    // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.\n    if (!hasEven(y))\n        y = Fp.neg(y);\n    const p = Pointk1.fromAffine({ x, y });\n    p.assertValidity();\n    return p;\n}\nconst num = bytesToNumberBE;\n/**\n * Create tagged hash, convert it to bigint, reduce modulo-n.\n */\nfunction challenge(...args) {\n    return Pointk1.Fn.create(num(taggedHash('BIP0340/challenge', ...args)));\n}\n/**\n * Schnorr public key is just `x` coordinate of Point as per BIP340.\n */\nfunction schnorrGetPublicKey(secretKey) {\n    return schnorrGetExtPubKey(secretKey).bytes; // d'=int(sk). Fail if d'=0 or d'n. Ret bytes(d'G)\n}\n/**\n * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.\n * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.\n */\nfunction schnorrSign(message, secretKey, auxRand = randomBytes(32)) {\n    const { Fn } = Pointk1;\n    const m = ensureBytes('message', message);\n    const { bytes: px, scalar: d } = schnorrGetExtPubKey(secretKey); // checks for isWithinCurveOrder\n    const a = ensureBytes('auxRand', auxRand, 32); // Auxiliary random data a: a 32-byte array\n    const t = Fn.toBytes(d ^ num(taggedHash('BIP0340/aux', a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)\n    const rand = taggedHash('BIP0340/nonce', t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)\n    // Let k' = int(rand) mod n. Fail if k' = 0. Let R = k'G\n    const { bytes: rx, scalar: k } = schnorrGetExtPubKey(rand);\n    const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.\n    const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).\n    sig.set(rx, 0);\n    sig.set(Fn.toBytes(Fn.create(k + e * d)), 32);\n    // If Verify(bytes(P), m, sig) (see below) returns failure, abort\n    if (!schnorrVerify(sig, m, px))\n        throw new Error('sign: Invalid signature produced');\n    return sig;\n}\n/**\n * Verifies Schnorr signature.\n * Will swallow errors & return false except for initial type validation of arguments.\n */\nfunction schnorrVerify(signature, message, publicKey) {\n    const { Fn, BASE } = Pointk1;\n    const sig = ensureBytes('signature', signature, 64);\n    const m = ensureBytes('message', message);\n    const pub = ensureBytes('publicKey', publicKey, 32);\n    try {\n        const P = lift_x(num(pub)); // P = lift_x(int(pk)); fail if that fails\n        const r = num(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r  p.\n        if (!inRange(r, _1n, secp256k1_CURVE.p))\n            return false;\n        const s = num(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s  n.\n        if (!inRange(s, _1n, secp256k1_CURVE.n))\n            return false;\n        // int(challenge(bytes(r)||bytes(P)||m))%n\n        const e = challenge(Fn.toBytes(r), pointToBytes(P), m);\n        // R = sG - eP, where -eP == (n-e)P\n        const R = BASE.multiplyUnsafe(s).add(P.multiplyUnsafe(Fn.neg(e)));\n        const { x, y } = R.toAffine();\n        // Fail if is_infinite(R) / not has_even_y(R) / x(R)  r.\n        if (R.is0() || !hasEven(y) || x !== r)\n            return false;\n        return true;\n    }\n    catch (error) {\n        return false;\n    }\n}\n/**\n * Schnorr signatures over secp256k1.\n * https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\n * @example\n * ```js\n * import { schnorr } from '@noble/curves/secp256k1';\n * const { secretKey, publicKey } = schnorr.keygen();\n * // const publicKey = schnorr.getPublicKey(secretKey);\n * const msg = new TextEncoder().encode('hello');\n * const sig = schnorr.sign(msg, secretKey);\n * const isValid = schnorr.verify(sig, msg, publicKey);\n * ```\n */\nexport const schnorr = /* @__PURE__ */ (() => {\n    const size = 32;\n    const seedLength = 48;\n    const randomSecretKey = (seed = randomBytes(seedLength)) => {\n        return mapHashToField(seed, secp256k1_CURVE.n);\n    };\n    // TODO: remove\n    secp256k1.utils.randomSecretKey;\n    function keygen(seed) {\n        const secretKey = randomSecretKey(seed);\n        return { secretKey, publicKey: schnorrGetPublicKey(secretKey) };\n    }\n    return {\n        keygen,\n        getPublicKey: schnorrGetPublicKey,\n        sign: schnorrSign,\n        verify: schnorrVerify,\n        Point: Pointk1,\n        utils: {\n            randomSecretKey: randomSecretKey,\n            randomPrivateKey: randomSecretKey,\n            taggedHash,\n            // TODO: remove\n            lift_x,\n            pointToBytes,\n            numberToBytesBE,\n            bytesToNumberBE,\n            mod,\n        },\n        lengths: {\n            secretKey: size,\n            publicKey: size,\n            publicKeyHasPrefix: false,\n            signature: size * 2,\n            seed: seedLength,\n        },\n    };\n})();\nconst isoMap = /* @__PURE__ */ (() => isogenyMap(Fpk1, [\n    // xNum\n    [\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7',\n        '0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581',\n        '0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262',\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c',\n    ],\n    // xDen\n    [\n        '0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b',\n        '0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n    // yNum\n    [\n        '0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c',\n        '0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3',\n        '0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931',\n        '0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84',\n    ],\n    // yDen\n    [\n        '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b',\n        '0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573',\n        '0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n].map((i) => i.map((j) => BigInt(j)))))();\nconst mapSWU = /* @__PURE__ */ (() => mapToCurveSimpleSWU(Fpk1, {\n    A: BigInt('0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533'),\n    B: BigInt('1771'),\n    Z: Fpk1.create(BigInt('-11')),\n}))();\n/** Hashing / encoding to secp256k1 points / field. RFC 9380 methods. */\nexport const secp256k1_hasher = /* @__PURE__ */ (() => createHasher(secp256k1.Point, (scalars) => {\n    const { x, y } = mapSWU(Fpk1.create(scalars[0]));\n    return isoMap(x, y);\n}, {\n    DST: 'secp256k1_XMD:SHA-256_SSWU_RO_',\n    encodeDST: 'secp256k1_XMD:SHA-256_SSWU_NU_',\n    p: Fpk1.ORDER,\n    m: 1,\n    k: 128,\n    expand: 'xmd',\n    hash: sha256,\n}))();\n/** @deprecated use `import { secp256k1_hasher } from '@noble/curves/secp256k1.js';` */\nexport const hashToCurve = /* @__PURE__ */ (() => secp256k1_hasher.hashToCurve)();\n/** @deprecated use `import { secp256k1_hasher } from '@noble/curves/secp256k1.js';` */\nexport const encodeToCurve = /* @__PURE__ */ (() => secp256k1_hasher.encodeToCurve)();\n//# sourceMappingURL=secp256k1.js.map","/**\n\nSHA1 (RFC 3174), MD5 (RFC 1321) and RIPEMD160 (RFC 2286) legacy, weak hash functions.\nDon't use them in a new protocol. What \"weak\" means:\n\n- Collisions can be made with 2^18 effort in MD5, 2^60 in SHA1, 2^80 in RIPEMD160.\n- No practical pre-image attacks (only theoretical, 2^123.4)\n- HMAC seems kinda ok: https://datatracker.ietf.org/doc/html/rfc6151\n * @module\n */\nimport { Chi, HashMD, Maj } from \"./_md.js\";\nimport { clean, createHasher, rotl } from \"./utils.js\";\n/** Initial SHA1 state */\nconst SHA1_IV = /* @__PURE__ */ Uint32Array.from([\n    0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0,\n]);\n// Reusable temporary buffer\nconst SHA1_W = /* @__PURE__ */ new Uint32Array(80);\n/** SHA1 legacy hash class. */\nexport class SHA1 extends HashMD {\n    constructor() {\n        super(64, 20, 8, false);\n        this.A = SHA1_IV[0] | 0;\n        this.B = SHA1_IV[1] | 0;\n        this.C = SHA1_IV[2] | 0;\n        this.D = SHA1_IV[3] | 0;\n        this.E = SHA1_IV[4] | 0;\n    }\n    get() {\n        const { A, B, C, D, E } = this;\n        return [A, B, C, D, E];\n    }\n    set(A, B, C, D, E) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n    }\n    process(view, offset) {\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA1_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 80; i++)\n            SHA1_W[i] = rotl(SHA1_W[i - 3] ^ SHA1_W[i - 8] ^ SHA1_W[i - 14] ^ SHA1_W[i - 16], 1);\n        // Compression function main loop, 80 rounds\n        let { A, B, C, D, E } = this;\n        for (let i = 0; i < 80; i++) {\n            let F, K;\n            if (i < 20) {\n                F = Chi(B, C, D);\n                K = 0x5a827999;\n            }\n            else if (i < 40) {\n                F = B ^ C ^ D;\n                K = 0x6ed9eba1;\n            }\n            else if (i < 60) {\n                F = Maj(B, C, D);\n                K = 0x8f1bbcdc;\n            }\n            else {\n                F = B ^ C ^ D;\n                K = 0xca62c1d6;\n            }\n            const T = (rotl(A, 5) + F + E + K + SHA1_W[i]) | 0;\n            E = D;\n            D = C;\n            C = rotl(B, 30);\n            B = A;\n            A = T;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        this.set(A, B, C, D, E);\n    }\n    roundClean() {\n        clean(SHA1_W);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0);\n        clean(this.buffer);\n    }\n}\n/** SHA1 (RFC 3174) legacy hash function. It was cryptographically broken. */\nexport const sha1 = /* @__PURE__ */ createHasher(() => new SHA1());\n/** Per-round constants */\nconst p32 = /* @__PURE__ */ Math.pow(2, 32);\nconst K = /* @__PURE__ */ Array.from({ length: 64 }, (_, i) => Math.floor(p32 * Math.abs(Math.sin(i + 1))));\n/** md5 initial state: same as sha1, but 4 u32 instead of 5. */\nconst MD5_IV = /* @__PURE__ */ SHA1_IV.slice(0, 4);\n// Reusable temporary buffer\nconst MD5_W = /* @__PURE__ */ new Uint32Array(16);\n/** MD5 legacy hash class. */\nexport class MD5 extends HashMD {\n    constructor() {\n        super(64, 16, 8, true);\n        this.A = MD5_IV[0] | 0;\n        this.B = MD5_IV[1] | 0;\n        this.C = MD5_IV[2] | 0;\n        this.D = MD5_IV[3] | 0;\n    }\n    get() {\n        const { A, B, C, D } = this;\n        return [A, B, C, D];\n    }\n    set(A, B, C, D) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n    }\n    process(view, offset) {\n        for (let i = 0; i < 16; i++, offset += 4)\n            MD5_W[i] = view.getUint32(offset, true);\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D } = this;\n        for (let i = 0; i < 64; i++) {\n            let F, g, s;\n            if (i < 16) {\n                F = Chi(B, C, D);\n                g = i;\n                s = [7, 12, 17, 22];\n            }\n            else if (i < 32) {\n                F = Chi(D, B, C);\n                g = (5 * i + 1) % 16;\n                s = [5, 9, 14, 20];\n            }\n            else if (i < 48) {\n                F = B ^ C ^ D;\n                g = (3 * i + 5) % 16;\n                s = [4, 11, 16, 23];\n            }\n            else {\n                F = C ^ (B | ~D);\n                g = (7 * i) % 16;\n                s = [6, 10, 15, 21];\n            }\n            F = F + A + K[i] + MD5_W[g];\n            A = D;\n            D = C;\n            C = B;\n            B = B + rotl(F, s[i % 4]);\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        this.set(A, B, C, D);\n    }\n    roundClean() {\n        clean(MD5_W);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0);\n        clean(this.buffer);\n    }\n}\n/**\n * MD5 (RFC 1321) legacy hash function. It was cryptographically broken.\n * MD5 architecture is similar to SHA1, with some differences:\n * - Reduced output length: 16 bytes (128 bit) instead of 20\n * - 64 rounds, instead of 80\n * - Little-endian: could be faster, but will require more code\n * - Non-linear index selection: huge speed-up for unroll\n * - Per round constants: more memory accesses, additional speed-up for unroll\n */\nexport const md5 = /* @__PURE__ */ createHasher(() => new MD5());\n// RIPEMD-160\nconst Rho160 = /* @__PURE__ */ Uint8Array.from([\n    7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,\n]);\nconst Id160 = /* @__PURE__ */ (() => Uint8Array.from(new Array(16).fill(0).map((_, i) => i)))();\nconst Pi160 = /* @__PURE__ */ (() => Id160.map((i) => (9 * i + 5) % 16))();\nconst idxLR = /* @__PURE__ */ (() => {\n    const L = [Id160];\n    const R = [Pi160];\n    const res = [L, R];\n    for (let i = 0; i < 4; i++)\n        for (let j of res)\n            j.push(j[i].map((k) => Rho160[k]));\n    return res;\n})();\nconst idxL = /* @__PURE__ */ (() => idxLR[0])();\nconst idxR = /* @__PURE__ */ (() => idxLR[1])();\n// const [idxL, idxR] = idxLR;\nconst shifts160 = /* @__PURE__ */ [\n    [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],\n    [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],\n    [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],\n    [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],\n    [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5],\n].map((i) => Uint8Array.from(i));\nconst shiftsL160 = /* @__PURE__ */ idxL.map((idx, i) => idx.map((j) => shifts160[i][j]));\nconst shiftsR160 = /* @__PURE__ */ idxR.map((idx, i) => idx.map((j) => shifts160[i][j]));\nconst Kl160 = /* @__PURE__ */ Uint32Array.from([\n    0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e,\n]);\nconst Kr160 = /* @__PURE__ */ Uint32Array.from([\n    0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000,\n]);\n// It's called f() in spec.\nfunction ripemd_f(group, x, y, z) {\n    if (group === 0)\n        return x ^ y ^ z;\n    if (group === 1)\n        return (x & y) | (~x & z);\n    if (group === 2)\n        return (x | ~y) ^ z;\n    if (group === 3)\n        return (x & z) | (y & ~z);\n    return x ^ (y | ~z);\n}\n// Reusable temporary buffer\nconst BUF_160 = /* @__PURE__ */ new Uint32Array(16);\nexport class RIPEMD160 extends HashMD {\n    constructor() {\n        super(64, 20, 8, true);\n        this.h0 = 0x67452301 | 0;\n        this.h1 = 0xefcdab89 | 0;\n        this.h2 = 0x98badcfe | 0;\n        this.h3 = 0x10325476 | 0;\n        this.h4 = 0xc3d2e1f0 | 0;\n    }\n    get() {\n        const { h0, h1, h2, h3, h4 } = this;\n        return [h0, h1, h2, h3, h4];\n    }\n    set(h0, h1, h2, h3, h4) {\n        this.h0 = h0 | 0;\n        this.h1 = h1 | 0;\n        this.h2 = h2 | 0;\n        this.h3 = h3 | 0;\n        this.h4 = h4 | 0;\n    }\n    process(view, offset) {\n        for (let i = 0; i < 16; i++, offset += 4)\n            BUF_160[i] = view.getUint32(offset, true);\n        // prettier-ignore\n        let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;\n        // Instead of iterating 0 to 80, we split it into 5 groups\n        // And use the groups in constants, functions, etc. Much simpler\n        for (let group = 0; group < 5; group++) {\n            const rGroup = 4 - group;\n            const hbl = Kl160[group], hbr = Kr160[group]; // prettier-ignore\n            const rl = idxL[group], rr = idxR[group]; // prettier-ignore\n            const sl = shiftsL160[group], sr = shiftsR160[group]; // prettier-ignore\n            for (let i = 0; i < 16; i++) {\n                const tl = (rotl(al + ripemd_f(group, bl, cl, dl) + BUF_160[rl[i]] + hbl, sl[i]) + el) | 0;\n                al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl; // prettier-ignore\n            }\n            // 2 loops are 10% faster\n            for (let i = 0; i < 16; i++) {\n                const tr = (rotl(ar + ripemd_f(rGroup, br, cr, dr) + BUF_160[rr[i]] + hbr, sr[i]) + er) | 0;\n                ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr; // prettier-ignore\n            }\n        }\n        // Add the compressed chunk to the current hash value\n        this.set((this.h1 + cl + dr) | 0, (this.h2 + dl + er) | 0, (this.h3 + el + ar) | 0, (this.h4 + al + br) | 0, (this.h0 + bl + cr) | 0);\n    }\n    roundClean() {\n        clean(BUF_160);\n    }\n    destroy() {\n        this.destroyed = true;\n        clean(this.buffer);\n        this.set(0, 0, 0, 0, 0);\n    }\n}\n/**\n * RIPEMD-160 - a legacy hash function from 1990s.\n * * https://homes.esat.kuleuven.be/~bosselae/ripemd160.html\n * * https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf\n */\nexport const ripemd160 = /* @__PURE__ */ createHasher(() => new RIPEMD160());\n//# sourceMappingURL=legacy.js.map","/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nfunction isBytes(a) {\n    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n/** Asserts something is Uint8Array. */\nfunction abytes(b, ...lengths) {\n    if (!isBytes(b))\n        throw new Error('Uint8Array expected');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);\n}\nfunction isArrayOf(isString, arr) {\n    if (!Array.isArray(arr))\n        return false;\n    if (arr.length === 0)\n        return true;\n    if (isString) {\n        return arr.every((item) => typeof item === 'string');\n    }\n    else {\n        return arr.every((item) => Number.isSafeInteger(item));\n    }\n}\n// no abytes: seems to have 10% slowdown. Why?!\nfunction afn(input) {\n    if (typeof input !== 'function')\n        throw new Error('function expected');\n    return true;\n}\nfunction astr(label, input) {\n    if (typeof input !== 'string')\n        throw new Error(`${label}: string expected`);\n    return true;\n}\nfunction anumber(n) {\n    if (!Number.isSafeInteger(n))\n        throw new Error(`invalid integer: ${n}`);\n}\nfunction aArr(input) {\n    if (!Array.isArray(input))\n        throw new Error('array expected');\n}\nfunction astrArr(label, input) {\n    if (!isArrayOf(true, input))\n        throw new Error(`${label}: array of strings expected`);\n}\nfunction anumArr(label, input) {\n    if (!isArrayOf(false, input))\n        throw new Error(`${label}: array of numbers expected`);\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction chain(...args) {\n    const id = (a) => a;\n    // Wrap call in closure so JIT can inline calls\n    const wrap = (a, b) => (c) => a(b(c));\n    // Construct chain of args[-1].encode(args[-2].encode([...]))\n    const encode = args.map((x) => x.encode).reduceRight(wrap, id);\n    // Construct chain of args[0].decode(args[1].decode(...))\n    const decode = args.map((x) => x.decode).reduce(wrap, id);\n    return { encode, decode };\n}\n/**\n * Encodes integer radix representation to array of strings using alphabet and back.\n * Could also be array of strings.\n * @__NO_SIDE_EFFECTS__\n */\nfunction alphabet(letters) {\n    // mapping 1 to \"b\"\n    const lettersA = typeof letters === 'string' ? letters.split('') : letters;\n    const len = lettersA.length;\n    astrArr('alphabet', lettersA);\n    // mapping \"b\" to 1\n    const indexes = new Map(lettersA.map((l, i) => [l, i]));\n    return {\n        encode: (digits) => {\n            aArr(digits);\n            return digits.map((i) => {\n                if (!Number.isSafeInteger(i) || i < 0 || i >= len)\n                    throw new Error(`alphabet.encode: digit index outside alphabet \"${i}\". Allowed: ${letters}`);\n                return lettersA[i];\n            });\n        },\n        decode: (input) => {\n            aArr(input);\n            return input.map((letter) => {\n                astr('alphabet.decode', letter);\n                const i = indexes.get(letter);\n                if (i === undefined)\n                    throw new Error(`Unknown letter: \"${letter}\". Allowed: ${letters}`);\n                return i;\n            });\n        },\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction join(separator = '') {\n    astr('join', separator);\n    return {\n        encode: (from) => {\n            astrArr('join.decode', from);\n            return from.join(separator);\n        },\n        decode: (to) => {\n            astr('join.decode', to);\n            return to.split(separator);\n        },\n    };\n}\n/**\n * Pad strings array so it has integer number of bits\n * @__NO_SIDE_EFFECTS__\n */\nfunction padding(bits, chr = '=') {\n    anumber(bits);\n    astr('padding', chr);\n    return {\n        encode(data) {\n            astrArr('padding.encode', data);\n            while ((data.length * bits) % 8)\n                data.push(chr);\n            return data;\n        },\n        decode(input) {\n            astrArr('padding.decode', input);\n            let end = input.length;\n            if ((end * bits) % 8)\n                throw new Error('padding: invalid, string should have whole number of bytes');\n            for (; end > 0 && input[end - 1] === chr; end--) {\n                const last = end - 1;\n                const byte = last * bits;\n                if (byte % 8 === 0)\n                    throw new Error('padding: invalid, string has too much padding');\n            }\n            return input.slice(0, end);\n        },\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction normalize(fn) {\n    afn(fn);\n    return { encode: (from) => from, decode: (to) => fn(to) };\n}\n/**\n * Slow: O(n^2) time complexity\n */\nfunction convertRadix(data, from, to) {\n    // base 1 is impossible\n    if (from < 2)\n        throw new Error(`convertRadix: invalid from=${from}, base cannot be less than 2`);\n    if (to < 2)\n        throw new Error(`convertRadix: invalid to=${to}, base cannot be less than 2`);\n    aArr(data);\n    if (!data.length)\n        return [];\n    let pos = 0;\n    const res = [];\n    const digits = Array.from(data, (d) => {\n        anumber(d);\n        if (d < 0 || d >= from)\n            throw new Error(`invalid integer: ${d}`);\n        return d;\n    });\n    const dlen = digits.length;\n    while (true) {\n        let carry = 0;\n        let done = true;\n        for (let i = pos; i < dlen; i++) {\n            const digit = digits[i];\n            const fromCarry = from * carry;\n            const digitBase = fromCarry + digit;\n            if (!Number.isSafeInteger(digitBase) ||\n                fromCarry / from !== carry ||\n                digitBase - digit !== fromCarry) {\n                throw new Error('convertRadix: carry overflow');\n            }\n            const div = digitBase / to;\n            carry = digitBase % to;\n            const rounded = Math.floor(div);\n            digits[i] = rounded;\n            if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase)\n                throw new Error('convertRadix: carry overflow');\n            if (!done)\n                continue;\n            else if (!rounded)\n                pos = i;\n            else\n                done = false;\n        }\n        res.push(carry);\n        if (done)\n            break;\n    }\n    for (let i = 0; i < data.length - 1 && data[i] === 0; i++)\n        res.push(0);\n    return res.reverse();\n}\nconst gcd = (a, b) => (b === 0 ? a : gcd(b, a % b));\nconst radix2carry = /* @__NO_SIDE_EFFECTS__ */ (from, to) => from + (to - gcd(from, to));\nconst powers = /* @__PURE__ */ (() => {\n    let res = [];\n    for (let i = 0; i < 40; i++)\n        res.push(2 ** i);\n    return res;\n})();\n/**\n * Implemented with numbers, because BigInt is 5x slower\n */\nfunction convertRadix2(data, from, to, padding) {\n    aArr(data);\n    if (from <= 0 || from > 32)\n        throw new Error(`convertRadix2: wrong from=${from}`);\n    if (to <= 0 || to > 32)\n        throw new Error(`convertRadix2: wrong to=${to}`);\n    if (radix2carry(from, to) > 32) {\n        throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);\n    }\n    let carry = 0;\n    let pos = 0; // bitwise position in current element\n    const max = powers[from];\n    const mask = powers[to] - 1;\n    const res = [];\n    for (const n of data) {\n        anumber(n);\n        if (n >= max)\n            throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);\n        carry = (carry << from) | n;\n        if (pos + from > 32)\n            throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);\n        pos += from;\n        for (; pos >= to; pos -= to)\n            res.push(((carry >> (pos - to)) & mask) >>> 0);\n        const pow = powers[pos];\n        if (pow === undefined)\n            throw new Error('invalid carry');\n        carry &= pow - 1; // clean carry, otherwise it will cause overflow\n    }\n    carry = (carry << (to - pos)) & mask;\n    if (!padding && pos >= from)\n        throw new Error('Excess padding');\n    if (!padding && carry > 0)\n        throw new Error(`Non-zero padding: ${carry}`);\n    if (padding && pos > 0)\n        res.push(carry >>> 0);\n    return res;\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction radix(num) {\n    anumber(num);\n    const _256 = 2 ** 8;\n    return {\n        encode: (bytes) => {\n            if (!isBytes(bytes))\n                throw new Error('radix.encode input should be Uint8Array');\n            return convertRadix(Array.from(bytes), _256, num);\n        },\n        decode: (digits) => {\n            anumArr('radix.decode', digits);\n            return Uint8Array.from(convertRadix(digits, num, _256));\n        },\n    };\n}\n/**\n * If both bases are power of same number (like `2**8 <-> 2**64`),\n * there is a linear algorithm. For now we have implementation for power-of-two bases only.\n * @__NO_SIDE_EFFECTS__\n */\nfunction radix2(bits, revPadding = false) {\n    anumber(bits);\n    if (bits <= 0 || bits > 32)\n        throw new Error('radix2: bits should be in (0..32]');\n    if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)\n        throw new Error('radix2: carry overflow');\n    return {\n        encode: (bytes) => {\n            if (!isBytes(bytes))\n                throw new Error('radix2.encode input should be Uint8Array');\n            return convertRadix2(Array.from(bytes), 8, bits, !revPadding);\n        },\n        decode: (digits) => {\n            anumArr('radix2.decode', digits);\n            return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));\n        },\n    };\n}\nfunction unsafeWrapper(fn) {\n    afn(fn);\n    return function (...args) {\n        try {\n            return fn.apply(null, args);\n        }\n        catch (e) { }\n    };\n}\nfunction checksum(len, fn) {\n    anumber(len);\n    afn(fn);\n    return {\n        encode(data) {\n            if (!isBytes(data))\n                throw new Error('checksum.encode: input should be Uint8Array');\n            const sum = fn(data).slice(0, len);\n            const res = new Uint8Array(data.length + len);\n            res.set(data);\n            res.set(sum, data.length);\n            return res;\n        },\n        decode(data) {\n            if (!isBytes(data))\n                throw new Error('checksum.decode: input should be Uint8Array');\n            const payload = data.slice(0, -len);\n            const oldChecksum = data.slice(-len);\n            const newChecksum = fn(payload).slice(0, len);\n            for (let i = 0; i < len; i++)\n                if (newChecksum[i] !== oldChecksum[i])\n                    throw new Error('Invalid checksum');\n            return payload;\n        },\n    };\n}\n// prettier-ignore\nexport const utils = {\n    alphabet, chain, checksum, convertRadix, convertRadix2, radix, radix2, join, padding,\n};\n// RFC 4648 aka RFC 3548\n// ---------------------\n/**\n * base16 encoding from RFC 4648.\n * @example\n * ```js\n * base16.encode(Uint8Array.from([0x12, 0xab]));\n * // => '12AB'\n * ```\n */\nexport const base16 = chain(radix2(4), alphabet('0123456789ABCDEF'), join(''));\n/**\n * base32 encoding from RFC 4648. Has padding.\n * Use `base32nopad` for unpadded version.\n * Also check out `base32hex`, `base32hexnopad`, `base32crockford`.\n * @example\n * ```js\n * base32.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'CKVQ===='\n * base32.decode('CKVQ====');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base32 = chain(radix2(5), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'), padding(5), join(''));\n/**\n * base32 encoding from RFC 4648. No padding.\n * Use `base32` for padded version.\n * Also check out `base32hex`, `base32hexnopad`, `base32crockford`.\n * @example\n * ```js\n * base32nopad.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'CKVQ'\n * base32nopad.decode('CKVQ');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base32nopad = chain(radix2(5), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'), join(''));\n/**\n * base32 encoding from RFC 4648. Padded. Compared to ordinary `base32`, slightly different alphabet.\n * Use `base32hexnopad` for unpadded version.\n * @example\n * ```js\n * base32hex.encode(Uint8Array.from([0x12, 0xab]));\n * // => '2ALG===='\n * base32hex.decode('2ALG====');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base32hex = chain(radix2(5), alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'), padding(5), join(''));\n/**\n * base32 encoding from RFC 4648. No padding. Compared to ordinary `base32`, slightly different alphabet.\n * Use `base32hex` for padded version.\n * @example\n * ```js\n * base32hexnopad.encode(Uint8Array.from([0x12, 0xab]));\n * // => '2ALG'\n * base32hexnopad.decode('2ALG');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base32hexnopad = chain(radix2(5), alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'), join(''));\n/**\n * base32 encoding from RFC 4648. Doug Crockford's version.\n * https://www.crockford.com/base32.html\n * @example\n * ```js\n * base32crockford.encode(Uint8Array.from([0x12, 0xab]));\n * // => '2ANG'\n * base32crockford.decode('2ANG');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base32crockford = chain(radix2(5), alphabet('0123456789ABCDEFGHJKMNPQRSTVWXYZ'), join(''), normalize((s) => s.toUpperCase().replace(/O/g, '0').replace(/[IL]/g, '1')));\n// Built-in base64 conversion https://caniuse.com/mdn-javascript_builtins_uint8array_frombase64\n// prettier-ignore\nconst hasBase64Builtin = /* @__PURE__ */ (() => typeof Uint8Array.from([]).toBase64 === 'function' &&\n    typeof Uint8Array.fromBase64 === 'function')();\nconst decodeBase64Builtin = (s, isUrl) => {\n    astr('base64', s);\n    const re = isUrl ? /^[A-Za-z0-9=_-]+$/ : /^[A-Za-z0-9=+/]+$/;\n    const alphabet = isUrl ? 'base64url' : 'base64';\n    if (s.length > 0 && !re.test(s))\n        throw new Error('invalid base64');\n    return Uint8Array.fromBase64(s, { alphabet, lastChunkHandling: 'strict' });\n};\n/**\n * base64 from RFC 4648. Padded.\n * Use `base64nopad` for unpadded version.\n * Also check out `base64url`, `base64urlnopad`.\n * Falls back to built-in function, when available.\n * @example\n * ```js\n * base64.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'Eqs='\n * base64.decode('Eqs=');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\n// prettier-ignore\nexport const base64 = hasBase64Builtin ? {\n    encode(b) { abytes(b); return b.toBase64(); },\n    decode(s) { return decodeBase64Builtin(s, false); },\n} : chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), padding(6), join(''));\n/**\n * base64 from RFC 4648. No padding.\n * Use `base64` for padded version.\n * @example\n * ```js\n * base64nopad.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'Eqs'\n * base64nopad.decode('Eqs');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base64nopad = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), join(''));\n/**\n * base64 from RFC 4648, using URL-safe alphabet. Padded.\n * Use `base64urlnopad` for unpadded version.\n * Falls back to built-in function, when available.\n * @example\n * ```js\n * base64url.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'Eqs='\n * base64url.decode('Eqs=');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\n// prettier-ignore\nexport const base64url = hasBase64Builtin ? {\n    encode(b) { abytes(b); return b.toBase64({ alphabet: 'base64url' }); },\n    decode(s) { return decodeBase64Builtin(s, true); },\n} : chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), padding(6), join(''));\n/**\n * base64 from RFC 4648, using URL-safe alphabet. No padding.\n * Use `base64url` for padded version.\n * @example\n * ```js\n * base64urlnopad.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'Eqs'\n * base64urlnopad.decode('Eqs');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base64urlnopad = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), join(''));\n// base58 code\n// -----------\nconst genBase58 = /* @__NO_SIDE_EFFECTS__ */ (abc) => chain(radix(58), alphabet(abc), join(''));\n/**\n * base58: base64 without ambigous characters +, /, 0, O, I, l.\n * Quadratic (O(n^2)) - so, can't be used on large inputs.\n * @example\n * ```js\n * base58.decode('01abcdef');\n * // => '3UhJW'\n * ```\n */\nexport const base58 = genBase58('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz');\n/**\n * base58: flickr version. Check out `base58`.\n */\nexport const base58flickr = genBase58('123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ');\n/**\n * base58: XRP version. Check out `base58`.\n */\nexport const base58xrp = genBase58('rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz');\n// Data len (index) -> encoded block len\nconst XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];\n/**\n * base58: XMR version. Check out `base58`.\n * Done in 8-byte blocks (which equals 11 chars in decoding). Last (non-full) block padded with '1' to size in XMR_BLOCK_LEN.\n * Block encoding significantly reduces quadratic complexity of base58.\n */\nexport const base58xmr = {\n    encode(data) {\n        let res = '';\n        for (let i = 0; i < data.length; i += 8) {\n            const block = data.subarray(i, i + 8);\n            res += base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], '1');\n        }\n        return res;\n    },\n    decode(str) {\n        let res = [];\n        for (let i = 0; i < str.length; i += 11) {\n            const slice = str.slice(i, i + 11);\n            const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);\n            const block = base58.decode(slice);\n            for (let j = 0; j < block.length - blockLen; j++) {\n                if (block[j] !== 0)\n                    throw new Error('base58xmr: wrong padding');\n            }\n            res = res.concat(Array.from(block.slice(block.length - blockLen)));\n        }\n        return Uint8Array.from(res);\n    },\n};\n/**\n * Method, which creates base58check encoder.\n * Requires function, calculating sha256.\n */\nexport const createBase58check = (sha256) => chain(checksum(4, (data) => sha256(sha256(data))), base58);\n/**\n * Use `createBase58check` instead.\n * @deprecated\n */\nexport const base58check = createBase58check;\nconst BECH_ALPHABET = chain(alphabet('qpzry9x8gf2tvdw0s3jn54khce6mua7l'), join(''));\nconst POLYMOD_GENERATORS = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];\nfunction bech32Polymod(pre) {\n    const b = pre >> 25;\n    let chk = (pre & 0x1ffffff) << 5;\n    for (let i = 0; i < POLYMOD_GENERATORS.length; i++) {\n        if (((b >> i) & 1) === 1)\n            chk ^= POLYMOD_GENERATORS[i];\n    }\n    return chk;\n}\nfunction bechChecksum(prefix, words, encodingConst = 1) {\n    const len = prefix.length;\n    let chk = 1;\n    for (let i = 0; i < len; i++) {\n        const c = prefix.charCodeAt(i);\n        if (c < 33 || c > 126)\n            throw new Error(`Invalid prefix (${prefix})`);\n        chk = bech32Polymod(chk) ^ (c >> 5);\n    }\n    chk = bech32Polymod(chk);\n    for (let i = 0; i < len; i++)\n        chk = bech32Polymod(chk) ^ (prefix.charCodeAt(i) & 0x1f);\n    for (let v of words)\n        chk = bech32Polymod(chk) ^ v;\n    for (let i = 0; i < 6; i++)\n        chk = bech32Polymod(chk);\n    chk ^= encodingConst;\n    return BECH_ALPHABET.encode(convertRadix2([chk % powers[30]], 30, 5, false));\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction genBech32(encoding) {\n    const ENCODING_CONST = encoding === 'bech32' ? 1 : 0x2bc830a3;\n    const _words = radix2(5);\n    const fromWords = _words.decode;\n    const toWords = _words.encode;\n    const fromWordsUnsafe = unsafeWrapper(fromWords);\n    function encode(prefix, words, limit = 90) {\n        astr('bech32.encode prefix', prefix);\n        if (isBytes(words))\n            words = Array.from(words);\n        anumArr('bech32.encode', words);\n        const plen = prefix.length;\n        if (plen === 0)\n            throw new TypeError(`Invalid prefix length ${plen}`);\n        const actualLength = plen + 7 + words.length;\n        if (limit !== false && actualLength > limit)\n            throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);\n        const lowered = prefix.toLowerCase();\n        const sum = bechChecksum(lowered, words, ENCODING_CONST);\n        return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}`;\n    }\n    function decode(str, limit = 90) {\n        astr('bech32.decode input', str);\n        const slen = str.length;\n        if (slen < 8 || (limit !== false && slen > limit))\n            throw new TypeError(`invalid string length: ${slen} (${str}). Expected (8..${limit})`);\n        // don't allow mixed case\n        const lowered = str.toLowerCase();\n        if (str !== lowered && str !== str.toUpperCase())\n            throw new Error(`String must be lowercase or uppercase`);\n        const sepIndex = lowered.lastIndexOf('1');\n        if (sepIndex === 0 || sepIndex === -1)\n            throw new Error(`Letter \"1\" must be present between prefix and data only`);\n        const prefix = lowered.slice(0, sepIndex);\n        const data = lowered.slice(sepIndex + 1);\n        if (data.length < 6)\n            throw new Error('Data must be at least 6 characters long');\n        const words = BECH_ALPHABET.decode(data).slice(0, -6);\n        const sum = bechChecksum(prefix, words, ENCODING_CONST);\n        if (!data.endsWith(sum))\n            throw new Error(`Invalid checksum in ${str}: expected \"${sum}\"`);\n        return { prefix, words };\n    }\n    const decodeUnsafe = unsafeWrapper(decode);\n    function decodeToBytes(str) {\n        const { prefix, words } = decode(str, false);\n        return { prefix, words, bytes: fromWords(words) };\n    }\n    function encodeFromBytes(prefix, bytes) {\n        return encode(prefix, toWords(bytes));\n    }\n    return {\n        encode,\n        decode,\n        encodeFromBytes,\n        decodeToBytes,\n        decodeUnsafe,\n        fromWords,\n        fromWordsUnsafe,\n        toWords,\n    };\n}\n/**\n * bech32 from BIP 173. Operates on words.\n * For high-level, check out scure-btc-signer:\n * https://github.com/paulmillr/scure-btc-signer.\n */\nexport const bech32 = genBech32('bech32');\n/**\n * bech32m from BIP 350. Operates on words.\n * It was to mitigate `bech32` weaknesses.\n * For high-level, check out scure-btc-signer:\n * https://github.com/paulmillr/scure-btc-signer.\n */\nexport const bech32m = genBech32('bech32m');\n/**\n * UTF-8-to-byte decoder. Uses built-in TextDecoder / TextEncoder.\n * @example\n * ```js\n * const b = utf8.decode(\"hey\"); // => new Uint8Array([ 104, 101, 121 ])\n * const str = utf8.encode(b); // \"hey\"\n * ```\n */\nexport const utf8 = {\n    encode: (data) => new TextDecoder().decode(data),\n    decode: (str) => new TextEncoder().encode(str),\n};\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\n// prettier-ignore\nconst hasHexBuiltin = /* @__PURE__ */ (() => typeof Uint8Array.from([]).toHex === 'function' &&\n    typeof Uint8Array.fromHex === 'function')();\n// prettier-ignore\nconst hexBuiltin = {\n    encode(data) { abytes(data); return data.toHex(); },\n    decode(s) { astr('hex', s); return Uint8Array.fromHex(s); },\n};\n/**\n * hex string decoder. Uses built-in function, when available.\n * @example\n * ```js\n * const b = hex.decode(\"0102ff\"); // => new Uint8Array([ 1, 2, 255 ])\n * const str = hex.encode(b); // \"0102ff\"\n * ```\n */\nexport const hex = hasHexBuiltin\n    ? hexBuiltin\n    : chain(radix2(4), alphabet('0123456789abcdef'), join(''), normalize((s) => {\n        if (typeof s !== 'string' || s.length % 2 !== 0)\n            throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);\n        return s.toLowerCase();\n    }));\n// prettier-ignore\nconst CODERS = {\n    utf8, hex, base16, base32, base64, base64url, base58, base58xmr\n};\nconst coderTypeError = 'Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr';\n/** @deprecated */\nexport const bytesToString = (type, bytes) => {\n    if (typeof type !== 'string' || !CODERS.hasOwnProperty(type))\n        throw new TypeError(coderTypeError);\n    if (!isBytes(bytes))\n        throw new TypeError('bytesToString() expects Uint8Array');\n    return CODERS[type].encode(bytes);\n};\n/** @deprecated */\nexport const str = bytesToString; // as in python, but for bytes only\n/** @deprecated */\nexport const stringToBytes = (type, str) => {\n    if (!CODERS.hasOwnProperty(type))\n        throw new TypeError(coderTypeError);\n    if (typeof str !== 'string')\n        throw new TypeError('stringToBytes() expects string');\n    return CODERS[type].decode(str);\n};\n/** @deprecated */\nexport const bytes = stringToBytes;\n//# sourceMappingURL=index.js.map","/**\n * @module BIP32 hierarchical deterministic (HD) wallets over secp256k1.\n * @example\n * ```js\n * import { HDKey } from \"@scure/bip32\";\n * const hdkey1 = HDKey.fromMasterSeed(seed);\n * const hdkey2 = HDKey.fromExtendedKey(base58key);\n * const hdkey3 = HDKey.fromJSON({ xpriv: string });\n *\n * // props\n * [hdkey1.depth, hdkey1.index, hdkey1.chainCode];\n * console.log(hdkey2.privateKey, hdkey2.publicKey);\n * console.log(hdkey3.derive(\"m/0/2147483647'/1\"));\n * const sig = hdkey3.sign(hash);\n * hdkey3.verify(hash, sig);\n * ```\n */\n/*! scure-bip32 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) */\nimport { mod } from '@noble/curves/abstract/modular';\nimport { secp256k1 as secp } from '@noble/curves/secp256k1';\nimport { hmac } from '@noble/hashes/hmac';\nimport { ripemd160 } from '@noble/hashes/legacy';\nimport { sha256, sha512 } from '@noble/hashes/sha2';\nimport { abytes, bytesToHex, concatBytes, createView, hexToBytes, utf8ToBytes, } from '@noble/hashes/utils';\nimport { createBase58check } from '@scure/base';\nconst Point = secp.ProjectivePoint;\nconst base58check = createBase58check(sha256);\nfunction bytesToNumber(bytes) {\n    abytes(bytes);\n    const h = bytes.length === 0 ? '0' : bytesToHex(bytes);\n    return BigInt('0x' + h);\n}\nfunction numberToBytes(num) {\n    if (typeof num !== 'bigint')\n        throw new Error('bigint expected');\n    return hexToBytes(num.toString(16).padStart(64, '0'));\n}\nconst MASTER_SECRET = utf8ToBytes('Bitcoin seed');\n// Bitcoin hardcoded by default\nconst BITCOIN_VERSIONS = { private: 0x0488ade4, public: 0x0488b21e };\nexport const HARDENED_OFFSET = 0x80000000;\nconst hash160 = (data) => ripemd160(sha256(data));\nconst fromU32 = (data) => createView(data).getUint32(0, false);\nconst toU32 = (n) => {\n    if (!Number.isSafeInteger(n) || n < 0 || n > 2 ** 32 - 1) {\n        throw new Error('invalid number, should be from 0 to 2**32-1, got ' + n);\n    }\n    const buf = new Uint8Array(4);\n    createView(buf).setUint32(0, n, false);\n    return buf;\n};\nexport class HDKey {\n    get fingerprint() {\n        if (!this.pubHash) {\n            throw new Error('No publicKey set!');\n        }\n        return fromU32(this.pubHash);\n    }\n    get identifier() {\n        return this.pubHash;\n    }\n    get pubKeyHash() {\n        return this.pubHash;\n    }\n    get privateKey() {\n        return this.privKeyBytes || null;\n    }\n    get publicKey() {\n        return this.pubKey || null;\n    }\n    get privateExtendedKey() {\n        const priv = this.privateKey;\n        if (!priv) {\n            throw new Error('No private key');\n        }\n        return base58check.encode(this.serialize(this.versions.private, concatBytes(new Uint8Array([0]), priv)));\n    }\n    get publicExtendedKey() {\n        if (!this.pubKey) {\n            throw new Error('No public key');\n        }\n        return base58check.encode(this.serialize(this.versions.public, this.pubKey));\n    }\n    static fromMasterSeed(seed, versions = BITCOIN_VERSIONS) {\n        abytes(seed);\n        if (8 * seed.length < 128 || 8 * seed.length > 512) {\n            throw new Error('HDKey: seed length must be between 128 and 512 bits; 256 bits is advised, got ' +\n                seed.length);\n        }\n        const I = hmac(sha512, MASTER_SECRET, seed);\n        return new HDKey({\n            versions,\n            chainCode: I.slice(32),\n            privateKey: I.slice(0, 32),\n        });\n    }\n    static fromExtendedKey(base58key, versions = BITCOIN_VERSIONS) {\n        // => version(4) || depth(1) || fingerprint(4) || index(4) || chain(32) || key(33)\n        const keyBuffer = base58check.decode(base58key);\n        const keyView = createView(keyBuffer);\n        const version = keyView.getUint32(0, false);\n        const opt = {\n            versions,\n            depth: keyBuffer[4],\n            parentFingerprint: keyView.getUint32(5, false),\n            index: keyView.getUint32(9, false),\n            chainCode: keyBuffer.slice(13, 45),\n        };\n        const key = keyBuffer.slice(45);\n        const isPriv = key[0] === 0;\n        if (version !== versions[isPriv ? 'private' : 'public']) {\n            throw new Error('Version mismatch');\n        }\n        if (isPriv) {\n            return new HDKey({ ...opt, privateKey: key.slice(1) });\n        }\n        else {\n            return new HDKey({ ...opt, publicKey: key });\n        }\n    }\n    static fromJSON(json) {\n        return HDKey.fromExtendedKey(json.xpriv);\n    }\n    constructor(opt) {\n        this.depth = 0;\n        this.index = 0;\n        this.chainCode = null;\n        this.parentFingerprint = 0;\n        if (!opt || typeof opt !== 'object') {\n            throw new Error('HDKey.constructor must not be called directly');\n        }\n        this.versions = opt.versions || BITCOIN_VERSIONS;\n        this.depth = opt.depth || 0;\n        this.chainCode = opt.chainCode || null;\n        this.index = opt.index || 0;\n        this.parentFingerprint = opt.parentFingerprint || 0;\n        if (!this.depth) {\n            if (this.parentFingerprint || this.index) {\n                throw new Error('HDKey: zero depth with non-zero index/parent fingerprint');\n            }\n        }\n        if (opt.publicKey && opt.privateKey) {\n            throw new Error('HDKey: publicKey and privateKey at same time.');\n        }\n        if (opt.privateKey) {\n            if (!secp.utils.isValidPrivateKey(opt.privateKey)) {\n                throw new Error('Invalid private key');\n            }\n            this.privKey =\n                typeof opt.privateKey === 'bigint' ? opt.privateKey : bytesToNumber(opt.privateKey);\n            this.privKeyBytes = numberToBytes(this.privKey);\n            this.pubKey = secp.getPublicKey(opt.privateKey, true);\n        }\n        else if (opt.publicKey) {\n            this.pubKey = Point.fromHex(opt.publicKey).toRawBytes(true); // force compressed point\n        }\n        else {\n            throw new Error('HDKey: no public or private key provided');\n        }\n        this.pubHash = hash160(this.pubKey);\n    }\n    derive(path) {\n        if (!/^[mM]'?/.test(path)) {\n            throw new Error('Path must start with \"m\" or \"M\"');\n        }\n        if (/^[mM]'?$/.test(path)) {\n            return this;\n        }\n        const parts = path.replace(/^[mM]'?\\//, '').split('/');\n        // tslint:disable-next-line\n        let child = this;\n        for (const c of parts) {\n            const m = /^(\\d+)('?)$/.exec(c);\n            const m1 = m && m[1];\n            if (!m || m.length !== 3 || typeof m1 !== 'string')\n                throw new Error('invalid child index: ' + c);\n            let idx = +m1;\n            if (!Number.isSafeInteger(idx) || idx >= HARDENED_OFFSET) {\n                throw new Error('Invalid index');\n            }\n            // hardened key\n            if (m[2] === \"'\") {\n                idx += HARDENED_OFFSET;\n            }\n            child = child.deriveChild(idx);\n        }\n        return child;\n    }\n    deriveChild(index) {\n        if (!this.pubKey || !this.chainCode) {\n            throw new Error('No publicKey or chainCode set');\n        }\n        let data = toU32(index);\n        if (index >= HARDENED_OFFSET) {\n            // Hardened\n            const priv = this.privateKey;\n            if (!priv) {\n                throw new Error('Could not derive hardened child key');\n            }\n            // Hardened child: 0x00 || ser256(kpar) || ser32(index)\n            data = concatBytes(new Uint8Array([0]), priv, data);\n        }\n        else {\n            // Normal child: serP(point(kpar)) || ser32(index)\n            data = concatBytes(this.pubKey, data);\n        }\n        const I = hmac(sha512, this.chainCode, data);\n        const childTweak = bytesToNumber(I.slice(0, 32));\n        const chainCode = I.slice(32);\n        if (!secp.utils.isValidPrivateKey(childTweak)) {\n            throw new Error('Tweak bigger than curve order');\n        }\n        const opt = {\n            versions: this.versions,\n            chainCode,\n            depth: this.depth + 1,\n            parentFingerprint: this.fingerprint,\n            index,\n        };\n        try {\n            // Private parent key -> private child key\n            if (this.privateKey) {\n                const added = mod(this.privKey + childTweak, secp.CURVE.n);\n                if (!secp.utils.isValidPrivateKey(added)) {\n                    throw new Error('The tweak was out of range or the resulted private key is invalid');\n                }\n                opt.privateKey = added;\n            }\n            else {\n                const added = Point.fromHex(this.pubKey).add(Point.fromPrivateKey(childTweak));\n                // Cryptographically impossible: hmac-sha512 preimage would need to be found\n                if (added.equals(Point.ZERO)) {\n                    throw new Error('The tweak was equal to negative P, which made the result key invalid');\n                }\n                opt.publicKey = added.toRawBytes(true);\n            }\n            return new HDKey(opt);\n        }\n        catch (err) {\n            return this.deriveChild(index + 1);\n        }\n    }\n    sign(hash) {\n        if (!this.privateKey) {\n            throw new Error('No privateKey set!');\n        }\n        abytes(hash, 32);\n        return secp.sign(hash, this.privKey).toCompactRawBytes();\n    }\n    verify(hash, signature) {\n        abytes(hash, 32);\n        abytes(signature, 64);\n        if (!this.publicKey) {\n            throw new Error('No publicKey set!');\n        }\n        let sig;\n        try {\n            sig = secp.Signature.fromCompact(signature);\n        }\n        catch (error) {\n            return false;\n        }\n        return secp.verify(sig, hash, this.publicKey);\n    }\n    wipePrivateData() {\n        this.privKey = undefined;\n        if (this.privKeyBytes) {\n            this.privKeyBytes.fill(0);\n            this.privKeyBytes = undefined;\n        }\n        return this;\n    }\n    toJSON() {\n        return {\n            xpriv: this.privateExtendedKey,\n            xpub: this.publicExtendedKey,\n        };\n    }\n    serialize(version, key) {\n        if (!this.chainCode) {\n            throw new Error('No chainCode set');\n        }\n        abytes(key, 33);\n        // version(4) || depth(1) || fingerprint(4) || index(4) || chain(32) || key(33)\n        return concatBytes(toU32(version), new Uint8Array([this.depth]), toU32(this.parentFingerprint), toU32(this.index), this.chainCode, key);\n    }\n}\n//# sourceMappingURL=index.js.map"],"names":["crypto","isBytes","a","anumber","n","abytes","b","lengths","ahash","h","aexists","instance","checkFinished","aoutput","out","min","clean","arrays","i","createView","arr","rotr","word","shift","rotl","hasHexBuiltin","hexes","_","bytesToHex","bytes","hex","asciis","asciiToBase16","ch","hexToBytes","hl","al","array","ai","hi","n1","n2","char","utf8ToBytes","str","toBytes","data","concatBytes","sum","res","pad","Hash","createHasher","hashCons","hashC","msg","tmp","randomBytes","bytesLength","_0n","_1n","_abool2","value","title","prefix","_abytes2","length","isBytes_","len","needsLen","ofLen","got","numberToHexUnpadded","num","hexToNumber","bytesToNumberBE","bytesToHex_","bytesToNumberLE","abytes_","numberToBytesBE","hexToBytes_","numberToBytesLE","ensureBytes","expectedLength","e","isPosBig","inRange","max","aInRange","bitLen","bitMask","createHmacDrbg","hashLen","qByteLen","hmacFn","u8n","u8of","byte","v","k","reset","reseed","seed","gen","sl","concatBytes_","pred","_validateObject","object","fields","optFields","checkField","fieldName","expectedType","isOpt","val","current","memoized","fn","map","arg","args","computed","_2n","_3n","_4n","_5n","_7n","_8n","_9n","_16n","mod","result","pow2","x","power","modulo","invert","number","u","q","r","m","assertIsSquare","Fp","root","sqrt3mod4","p1div4","sqrt5mod8","p5div8","nv","sqrt9mod16","P","Fp_","Field","tn","tonelliShanks","c1","c2","c3","c4","tv1","tv2","tv3","tv4","e1","e2","e3","Q","S","Z","_Fp","FpLegendre","cc","Q1div2","M","c","t","R","t_tmp","exponent","FpSqrt","FIELD_FIELDS","validateField","field","initial","opts","FpPow","p","d","FpInvertBatch","nums","passZero","inverted","multipliedAcc","acc","invertedAcc","p1mod2","powered","yes","zero","no","nLength","nBitLength","_nBitLength","nByteLength","ORDER","bitLenOrOpts","isLE","_nbitLength","_sqrt","modFromBytes","allowedLengths","_opts","BITS","BYTES","sqrtP","f","lhs","rhs","skipValidation","padded","scalar","lst","getFieldBytesLength","fieldOrder","bitLength","getMinHashLength","mapHashToField","key","fieldLen","minLen","reduced","setBigUint64","view","byteOffset","_32n","_u32_max","wh","wl","l","Chi","Maj","HashMD","blockLen","outputLen","padOffset","buffer","pos","take","dataView","oview","outLen","state","to","finished","destroyed","SHA256_IV","SHA512_IV","U32_MASK64","fromBig","le","split","Ah","Al","shrSH","_l","s","shrSL","rotrSH","rotrSL","rotrBH","rotrBL","add","Bh","Bl","add3L","Cl","add3H","low","Ch","add4L","Dl","add4H","Dh","add5L","El","add5H","Eh","SHA256_K","SHA256_W","SHA256","A","B","C","D","E","F","G","H","offset","W15","W2","s0","s1","sigma1","T1","T2","K512","u64.split","SHA512_Kh","SHA512_Kl","SHA512_W_H","SHA512_W_L","SHA512","Fh","Fl","Gh","Gl","Hh","Hl","W15h","W15l","s0h","u64.rotrSH","u64.shrSH","s0l","u64.rotrSL","u64.shrSL","W2h","W2l","s1h","u64.rotrBH","s1l","u64.rotrBL","SUMl","u64.add4L","SUMh","u64.add4H","sigma1h","sigma1l","CHIh","CHIl","T1ll","u64.add5L","T1h","u64.add5H","T1l","sigma0h","sigma0l","MAJh","MAJl","u64.add","All","u64.add3L","u64.add3H","sha256","sha512","HMAC","hash","_key","buf","oHash","iHash","hmac","message","negateCt","condition","item","neg","normalizeZ","points","invertedZs","validateW","W","bits","calcWOpts","scalarBits","windows","windowSize","maxNumber","mask","shiftBy","calcOffsets","window","wOpts","wbits","nextN","offsetStart","isZero","isNeg","isNegF","validateMSMPoints","validateMSMScalars","scalars","pointPrecomputes","pointWindowSizes","getW","assert0","wNAF","Point","elm","point","base","precomputes","wo","offsetF","transform","comp","prev","mulEndoUnsafe","k1","k2","p1","p2","pippenger","fieldN","plength","slength","MASK","buckets","lastBits","j","resI","sumI","createField","order","_createCurveFields","type","CURVE","curveOpts","FpFnLE","Fn","params","divNearest","den","_splitEndoScalar","basis","a1","b1","a2","b2","k1neg","k2neg","MAX_NUM","validateSigFormat","format","validateSigOpts","def","optsn","optName","abool","DERErr","DER","tag","dataLen","lenLen","first","isLong","lengthBytes","int","tlv","seqBytes","seqLeftBytes","rBytes","rLeftBytes","sBytes","sLeftBytes","sig","rs","ss","seq","_normFnElement","expected","weierstrassN","extraOpts","validated","cofactor","CURVE_ORDER","endo","getWLengths","assertCompressionIsSupported","pointToBytes","_c","isCompressed","y","bx","hasEvenY","pprefix","pointFromBytes","uncomp","head","tail","y2","weierstrassEquation","sqrtError","err","isYOdd","L","isValidXY","encodePoint","decodePoint","x2","x3","left","right","_4a3","_27b2","acoord","banZero","aprjpoint","other","splitEndoScalarN","toAffineMemo","iz","X","Y","is0","zz","assertValidMemo","finishEndo","endoBeta","k1p","k2p","isLazy","wnaf","X1","Y1","Z1","X2","Y2","Z2","U1","U2","b3","X3","Y3","Z3","t0","t1","t2","t3","t4","t5","fake","mul","k1f","k2f","sc","invertedZ","isTorsionFree","clearCofactor","privateKey","ecdh","ecdhOpts","randomBytes_","randomBytesWeb","isValidSecretKey","secretKey","isValidPublicKey","publicKey","publicKeyUncompressed","randomSecretKey","getPublicKey","keygen","isProbPub","getSharedSecret","secretKeyA","publicKeyB","ecdsa","ecdsaOpts","msgs","nobleHmac","fnBits","utils","defaultSigOpts","defaultSigOpts_format","isBiggerThanHalfOrder","HALF","validateRS","validateSigLength","size","sizer","Signature","recovery","recid","messageHash","FIELD_ORDER","rec","radj","ir","bits2int_modN","u1","u2","bits2int","delta","ORDER_MASK","int2octets","validateMsgAndHash","prehash","prepSig","lowS","extraEntropy","h1int","seedArgs","k2sig","kBytes","ik","normS","sign","tryParsingSig","sg","isHex","isObj","derError","verify","signature","is","recoverPublicKey","_weierstrass_legacy_opts_to_new","_ecdsa_legacy_opts_to_new","_ecdsa_new_output_to_legacy","_ecdsa","weierstrass","signs","createCurve","curveDef","defHash","create","secp256k1_CURVE","secp256k1_ENDO","sqrtMod","_6n","_11n","_22n","_23n","_44n","_88n","b6","b9","b11","b22","b44","b88","b176","b220","b223","Fpk1","secp256k1","Rho160","Id160","Pi160","idxLR","idxL","idxR","shifts160","shiftsL160","idx","shiftsR160","Kl160","Kr160","ripemd_f","group","z","BUF_160","RIPEMD160","h0","h1","h2","h3","h4","ar","bl","br","cl","cr","dl","dr","el","er","rGroup","hbl","hbr","rl","rr","sr","tl","tr","ripemd160","isArrayOf","isString","afn","input","astr","label","aArr","astrArr","anumArr","chain","id","wrap","encode","decode","alphabet","letters","lettersA","indexes","digits","letter","join","separator","from","convertRadix","dlen","carry","done","digit","fromCarry","digitBase","div","rounded","radix","_256","checksum","payload","oldChecksum","newChecksum","genBase58","abc","base58","createBase58check","secp","base58check","bytesToNumber","numberToBytes","MASTER_SECRET","BITCOIN_VERSIONS","HARDENED_OFFSET","hash160","fromU32","toU32","HDKey","priv","versions","I","base58key","keyBuffer","keyView","version","opt","isPriv","json","path","parts","child","m1","index","childTweak","chainCode","added"],"mappings":"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"}},
    {"offset": {"line": 5024, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@cashu+cashu-ts@2.9.0/node_modules/@cashu/cashu-ts/lib/NUT09-DNug3BMz.js","sources":["file:///home/maximoto/dev/sats-rover/node_modules/.pnpm/%40cashu%2Bcashu-ts%402.9.0/node_modules/%40cashu/cashu-ts/src/base64.ts","file:///home/maximoto/dev/sats-rover/node_modules/.pnpm/%40cashu%2Bcashu-ts%402.9.0/node_modules/%40cashu/cashu-ts/src/crypto/client/NUT09.ts"],"sourcesContent":["import { Bytes } from './utils/Bytes';\n\nfunction encodeUint8toBase64(uint8array: Uint8Array): string {\n\treturn Bytes.toBase64(uint8array);\n}\n\nfunction encodeUint8toBase64Url(bytes: Uint8Array): string {\n\treturn Bytes.toBase64(bytes)\n\t\t.replace(/\\+/g, '-') // Replace + with -\n\t\t.replace(/\\//g, '_') // Replace / with _\n\t\t.replace(/=+$/, ''); // Remove padding characters\n}\n\nfunction encodeBase64toUint8(base64String: string): Uint8Array {\n\treturn Bytes.fromBase64(base64String);\n}\n\nfunction encodeJsonToBase64(jsonObj: unknown): string {\n\tconst jsonString = JSON.stringify(jsonObj);\n\treturn base64urlFromBase64(Bytes.toBase64(Bytes.fromString(jsonString)));\n}\n\nfunction encodeBase64ToJson<T extends object>(base64String: string): T {\n\tconst jsonString = Bytes.toString(Bytes.fromBase64(base64urlToBase64(base64String)));\n\tconst jsonObj = JSON.parse(jsonString) as T;\n\treturn jsonObj;\n}\n\nfunction base64urlToBase64(str: string) {\n\treturn str.replace(/-/g, '+').replace(/_/g, '/').split('=')[0];\n\t// .replace(/./g, '=');\n}\n\nfunction base64urlFromBase64(str: string) {\n\treturn str.replace(/\\+/g, '-').replace(/\\//g, '_').split('=')[0];\n\t// .replace(/=/g, '.');\n}\n\nfunction isBase64String(s: string): boolean {\n\tif (typeof s !== 'string' || s.length === 0) return false;\n\n\t// Accept both base64 and base64url char sets\n\tconst base64url = /^[A-Za-z0-9\\-_]+={0,2}$/;\n\tconst base64 = /^[A-Za-z0-9+/]+={0,2}$/;\n\n\t// Quick character-set check\n\tif (!base64url.test(s) && !base64.test(s)) return false;\n\n\t// Normalize base64url to standard base64 for decoding\n\tconst normalized = s.replace(/-/g, '+').replace(/_/g, '/');\n\n\t// Padding: length must be multiple of 4. Add '=' padding if needed (but no more than 2)\n\tconst padLength = (4 - (normalized.length % 4)) % 4;\n\tif (padLength > 2) return false; // should never happen but keep safe\n\tconst padded = normalized + '='.repeat(padLength);\n\n\ttry {\n\t\tconst decoded = Bytes.fromBase64(padded);\n\n\t\t// Re-encode and compare to the original (allowing either standard or url-safe representation)\n\t\tconst reStandard = Bytes.toBase64(decoded);\n\t\tconst reUrl = reStandard.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=+$/, '');\n\n\t\t// Also compare against original normalized-without-padding variant\n\t\tconst originalNoPad = normalized.replace(/=+$/, '');\n\n\t\tif (reStandard.replace(/=+$/, '') === originalNoPad) return true;\n\t\tif (reUrl === originalNoPad) return true;\n\n\t\treturn false;\n\t} catch {\n\t\treturn false;\n\t}\n}\n\nexport {\n\tencodeUint8toBase64,\n\tencodeUint8toBase64Url,\n\tencodeBase64toUint8,\n\tencodeJsonToBase64,\n\tencodeBase64ToJson,\n\tisBase64String,\n};\n","import { hmac } from '@noble/hashes/hmac.js';\nimport { sha256 } from '@noble/hashes/sha2.js';\nimport { getKeysetIdInt } from '../common';\nimport { HDKey } from '@scure/bip32';\nimport { Bytes } from '../../utils/Bytes';\nimport { isBase64String } from '../../base64';\n\nconst STANDARD_DERIVATION_PATH = `m/129372'/0'`;\n\nenum DerivationType {\n\tSECRET = 0,\n\tBLINDING_FACTOR = 1,\n}\n\nexport const deriveSecret = (seed: Uint8Array, keysetId: string, counter: number): Uint8Array => {\n\tconst isValidHex = /^[a-fA-F0-9]+$/.test(keysetId);\n\tif (!isValidHex && isBase64String(keysetId)) {\n\t\treturn derive_deprecated(seed, keysetId, counter, DerivationType.SECRET);\n\t}\n\n\tif (isValidHex && keysetId.startsWith('00')) {\n\t\treturn derive_deprecated(seed, keysetId, counter, DerivationType.SECRET);\n\t} else if (isValidHex && keysetId.startsWith('01')) {\n\t\treturn derive(seed, keysetId, counter, DerivationType.SECRET);\n\t}\n\tthrow new Error(`Unrecognized keyset ID version ${keysetId.slice(0, 2)}`);\n};\n\nexport const deriveBlindingFactor = (\n\tseed: Uint8Array,\n\tkeysetId: string,\n\tcounter: number,\n): Uint8Array => {\n\tconst isValidHex = /^[a-fA-F0-9]+$/.test(keysetId);\n\tif (!isValidHex && isBase64String(keysetId)) {\n\t\treturn derive_deprecated(seed, keysetId, counter, DerivationType.BLINDING_FACTOR);\n\t}\n\n\tif (isValidHex && keysetId.startsWith('00')) {\n\t\treturn derive_deprecated(seed, keysetId, counter, DerivationType.BLINDING_FACTOR);\n\t} else if (isValidHex && keysetId.startsWith('01')) {\n\t\treturn derive(seed, keysetId, counter, DerivationType.BLINDING_FACTOR);\n\t}\n\tthrow new Error(`Unrecognized keyset ID version ${keysetId.slice(0, 2)}`);\n};\n\nconst derive = (\n\tseed: Uint8Array,\n\tkeysetId: string,\n\tcounter: number,\n\tsecretOrBlinding: DerivationType,\n): Uint8Array => {\n\tlet message = Bytes.concat(\n\t\tBytes.fromString('Cashu_KDF_HMAC_SHA256'),\n\t\tBytes.fromHex(keysetId),\n\t\tBytes.writeBigUint64BE(BigInt(counter)),\n\t);\n\n\tswitch (secretOrBlinding) {\n\t\tcase DerivationType.SECRET:\n\t\t\tmessage = Bytes.concat(message, Bytes.fromHex('00'));\n\t\t\tbreak;\n\t\tcase DerivationType.BLINDING_FACTOR:\n\t\t\tmessage = Bytes.concat(message, Bytes.fromHex('01'));\n\t}\n\n\t// Step 2: Compute HMAC-SHA256\n\treturn hmac(sha256, seed, message);\n};\n\nconst derive_deprecated = (\n\tseed: Uint8Array,\n\tkeysetId: string,\n\tcounter: number,\n\tsecretOrBlinding: DerivationType,\n): Uint8Array => {\n\tconst hdkey = HDKey.fromMasterSeed(seed);\n\tconst keysetIdInt = getKeysetIdInt(keysetId);\n\tconst derivationPath = `${STANDARD_DERIVATION_PATH}/${keysetIdInt}'/${counter}'/${secretOrBlinding}`;\n\tconst derived = hdkey.derive(derivationPath);\n\tif (derived.privateKey === null) {\n\t\tthrow new Error('Could not derive private key');\n\t}\n\treturn derived.privateKey;\n};\n"],"names":["encodeUint8toBase64Url","bytes","Bytes","encodeBase64toUint8","base64String","encodeJsonToBase64","jsonObj","jsonString","base64urlFromBase64","encodeBase64ToJson","base64urlToBase64","str","isBase64String","s","base64url","base64","normalized","padLength","padded","decoded","reStandard","reUrl","originalNoPad","STANDARD_DERIVATION_PATH","deriveSecret","seed","keysetId","counter","isValidHex","derive_deprecated","derive","deriveBlindingFactor","secretOrBlinding","message","hmac","sha256","hdkey","HDKey","keysetIdInt","getKeysetIdInt","derivationPath","derived"],"mappings":"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"}},
    {"offset": {"line": 5113, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@cashu+cashu-ts@2.9.0/node_modules/@cashu/cashu-ts/lib/crypto/common/NUT11.es.js","sources":["file:///home/maximoto/dev/sats-rover/node_modules/.pnpm/%40cashu%2Bcashu-ts%402.9.0/node_modules/%40cashu/cashu-ts/src/crypto/common/NUT11.ts"],"sourcesContent":["import { type Secret } from './index';\n\nexport const parseP2PKSecret = (secret: string | Uint8Array): Secret => {\n\ttry {\n\t\tif (secret instanceof Uint8Array) {\n\t\t\tsecret = new TextDecoder().decode(secret);\n\t\t}\n\t\treturn JSON.parse(secret) as Secret;\n\t} catch {\n\t\tthrow new Error(\"can't parse secret\");\n\t}\n};\n"],"names":["parseP2PKSecret","secret"],"mappings":";;;;AAEO,MAAMA,IAAkB,CAACC,MAAwC;IACvE,IAAI;QACH,OAAIA,aAAkB,cAAA,CACrBA,IAAS,IAAI,cAAc,MAAA,CAAOA,CAAM,CAAA,GAElC,KAAK,KAAA,CAAMA,CAAM;IACzB,EAAA,OAAQ;QACP,MAAM,IAAI,MAAM,oBAAoB;IACrC;AACD"}},
    {"offset": {"line": 5130, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@cashu+cashu-ts@2.9.0/node_modules/@cashu/cashu-ts/lib/crypto/client/NUT11.es.js","sources":["file:///home/maximoto/dev/sats-rover/node_modules/.pnpm/%40cashu%2Bcashu-ts%402.9.0/node_modules/%40cashu/cashu-ts/src/crypto/client/NUT11.ts"],"sourcesContent":["import { bytesToHex, hexToBytes } from '@noble/curves/utils.js';\nimport { sha256 } from '@noble/hashes/sha2.js';\nimport { schnorr } from '@noble/curves/secp256k1.js';\nimport { randomBytes } from '@noble/hashes/utils.js';\nimport { parseP2PKSecret } from '../common/NUT11';\nimport { type Secret, type Witness } from '../common/index';\nimport { type P2PKWitness, type Proof } from '../../model/types/index';\nimport { type BlindedMessage } from './index';\n\nexport const createP2PKsecret = (pubkey: string): string => {\n\tconst newSecret: Secret = [\n\t\t'P2PK',\n\t\t{\n\t\t\tnonce: bytesToHex(randomBytes(32)),\n\t\t\tdata: pubkey,\n\t\t},\n\t];\n\treturn JSON.stringify(newSecret);\n};\n\nexport const signP2PKSecret = (secret: string, privateKey: Uint8Array): string => {\n\tconst msghash = sha256(new TextEncoder().encode(secret));\n\tconst sig = schnorr.sign(msghash, privateKey);\n\treturn bytesToHex(sig);\n};\n\nexport const signBlindedMessage = (B_: string, privateKey: Uint8Array): string => {\n\tconst msgHash = sha256(new TextEncoder().encode(B_));\n\tconst sig = schnorr.sign(msgHash, privateKey);\n\treturn bytesToHex(sig);\n};\n\n/**\n * Verifies a Schnorr signature on a P2PK secret.\n *\n * @param signature - The Schnorr signature (hex-encoded).\n * @param secret - The Secret to verify.\n * @param pubkey - The Cashu P2PK public key (hex-encoded, X-only or with 02/03 prefix).\n * @returns {boolean} True if the signature is valid, false otherwise.\n */\nexport const verifyP2PKSecretSignature = (\n\tsignature: string,\n\tsecret: string,\n\tpubkey: string,\n): boolean => {\n\ttry {\n\t\tconst msghash = sha256(new TextEncoder().encode(secret));\n\t\t// Use X-only pubkey: strip 02/03 prefix if pubkey is 66 hex chars (33 bytes)\n\t\tconst pubkeyX = pubkey.length === 66 ? pubkey.slice(2) : pubkey;\n\t\tif (schnorr.verify(hexToBytes(signature), msghash, hexToBytes(pubkeyX))) {\n\t\t\treturn true;\n\t\t}\n\t} catch (e) {\n\t\tconsole.error('verifyP2PKsecret error:', e);\n\t}\n\treturn false; // no bueno\n};\n\n/**\n * Verifies a pubkey has signed a P2PK Proof.\n *\n * @param pubkey - The Cashu P2PK public key (hex-encoded, X-only or with 02/03 prefix).\n * @param proof - A Cashu proof.\n * @returns {boolean} True if one of the signatures is theirs, false otherwise.\n */\nexport const hasP2PKSignedProof = (pubkey: string, proof: Proof): boolean => {\n\tif (!proof.witness) {\n\t\treturn false;\n\t}\n\tconst signatures = getP2PKWitnessSignatures(proof.witness);\n\t// See if any of the signatures belong to this pubkey.\n\t// We need to do this as Schnorr signatures are non-deterministic.\n\treturn signatures.some((sig) => {\n\t\ttry {\n\t\t\treturn verifyP2PKSecretSignature(sig, proof.secret, pubkey);\n\t\t} catch {\n\t\t\treturn false; // Invalid signature, treat as not signed\n\t\t}\n\t});\n};\n\n/**\n * Returns the expected witness public keys from a NUT-11 P2PK secret.\n *\n * @param secretStr - The NUT-11 P2PK secret.\n * @returns {array} With the public keys or empty array.\n */\nexport function getP2PKExpectedKWitnessPubkeys(secretStr: string | Secret): string[] {\n\ttry {\n\t\t// Validate secret\n\t\tconst secret: Secret = typeof secretStr === 'string' ? parseP2PKSecret(secretStr) : secretStr;\n\t\tif (secret[0] !== 'P2PK') {\n\t\t\tthrow new Error('Invalid P2PK secret: must start with \"P2PK\"');\n\t\t}\n\t\tconst now = Math.floor(Date.now() / 1000);\n\t\tconst locktime = getP2PKLocktime(secret);\n\t\tif (locktime > now) {\n\t\t\t// Am interpretting NUT-11 as intending pubkeys to be usable for a\n\t\t\t// 1-of-m multisig if provided, even if n_sigs is not set\n\t\t\treturn getP2PKWitnessPubkeys(secret);\n\t\t}\n\t\treturn getP2PKWitnessRefundkeys(secret);\n\t} catch {\n\t\t// do nothing\n\t}\n\treturn []; // Unlocked, malformed or expired with no refund keys\n}\n\n/**\n * Returns ALL locktime witnesses from a NUT-11 P2PK secret NB: Does not specify if they are\n * expected to sign - see: getP2PKExpectedKWitnessPubkeys()\n *\n * @param secretStr - The NUT-11 P2PK secret.\n * @returns {array} With the public key(s or empty array.\n */\nexport function getP2PKWitnessPubkeys(secretStr: string | Secret): string[] {\n\t// Validate secret\n\tconst secret: Secret = typeof secretStr === 'string' ? parseP2PKSecret(secretStr) : secretStr;\n\tif (secret[0] !== 'P2PK') {\n\t\tthrow new Error('Invalid P2PK secret: must start with \"P2PK\"');\n\t}\n\tconst { data, tags } = secret[1];\n\tconst pubkeysTag = tags && tags.find((tag) => tag[0] === 'pubkeys');\n\tconst pubkeys = pubkeysTag && pubkeysTag.length > 1 ? pubkeysTag.slice(1) : [];\n\treturn [data, ...pubkeys].filter(Boolean);\n}\n\n/**\n * Returns ALL refund witnesses from a NUT-11 P2PK secret NB: Does not specify if they are expected\n * to sign - see: getP2PKExpectedKWitnessPubkeys()\n *\n * @param secretStr - The NUT-11 P2PK secret.\n * @returns {array} With the public keys or empty array.\n */\nexport function getP2PKWitnessRefundkeys(secretStr: string | Secret): string[] {\n\t// Validate secret\n\tconst secret: Secret = typeof secretStr === 'string' ? parseP2PKSecret(secretStr) : secretStr;\n\tif (secret[0] !== 'P2PK') {\n\t\tthrow new Error('Invalid P2PK secret: must start with \"P2PK\"');\n\t}\n\tconst { tags } = secret[1];\n\tconst refundTag = tags && tags.find((tag) => tag[0] === 'refund');\n\treturn refundTag && refundTag.length > 1 ? refundTag.slice(1).filter(Boolean) : [];\n}\n\n/**\n * Returns the locktime from a NUT-11 P2PK secret or Infinity if no locktime.\n *\n * @param secretStr - The NUT-11 P2PK secret.\n * @returns {number} The locktime unix timestamp or Infinity (permanent lock)\n */\nexport function getP2PKLocktime(secretStr: string | Secret): number {\n\t// Validate secret\n\tconst secret: Secret = typeof secretStr === 'string' ? parseP2PKSecret(secretStr) : secretStr;\n\tif (secret[0] !== 'P2PK') {\n\t\tthrow new Error('Invalid P2PK secret: must start with \"P2PK\"');\n\t}\n\tconst { tags } = secret[1];\n\tconst locktimeTag = tags && tags.find((tag) => tag[0] === 'locktime');\n\treturn locktimeTag && locktimeTag.length > 1 ? parseInt(locktimeTag[1], 10) : Infinity; // Permanent lock if not set\n}\n\n/**\n * Returns the number of signatures required from a NUT-11 P2PK secret.\n *\n * @param secretStr - The NUT-11 P2PK secret.\n * @returns {number} The number of signatories (n_sigs / n_sigs_refund) or 0 if secret is unlocked.\n */\nexport function getP2PKNSigs(secretStr: string | Secret): number {\n\t// Validate secret\n\tconst secret: Secret = typeof secretStr === 'string' ? parseP2PKSecret(secretStr) : secretStr;\n\tif (secret[0] !== 'P2PK') {\n\t\tthrow new Error('Invalid P2PK secret: must start with \"P2PK\"');\n\t}\n\t// Check for witnesses\n\tconst witness = getP2PKExpectedKWitnessPubkeys(secret);\n\tif (!witness.length) {\n\t\treturn 0; // unlocked if no witnesses needed\n\t}\n\t// Check for Lock multisig\n\tconst { tags } = secret[1];\n\tconst now = Math.floor(Date.now() / 1000);\n\tconst locktime = getP2PKLocktime(secret);\n\tif (locktime > now) {\n\t\tconst n_sigsTag = tags && tags.find((tag) => tag[0] === 'n_sigs');\n\t\treturn n_sigsTag && n_sigsTag.length > 1 ? parseInt(n_sigsTag[1], 10) : 1; // Default: 1\n\t}\n\t// Refund multisig\n\tconst n_sigs_refundTag = tags && tags.find((tag) => tag[0] === 'n_sigs_refund');\n\treturn n_sigs_refundTag && n_sigs_refundTag.length > 1 ? parseInt(n_sigs_refundTag[1], 10) : 1; // Default: 1\n}\n\n/**\n * Returns the sigflag from a NUT-11 P2PK secret.\n *\n * @param secretStr - The NUT-11 P2PK secret.\n * @returns {string} The sigflag or 'SIG_INPUTS' (default)\n */\nexport function getP2PKSigFlag(secretStr: string | Secret): string {\n\t// Validate secret\n\tconst secret: Secret = typeof secretStr === 'string' ? parseP2PKSecret(secretStr) : secretStr;\n\tif (secret[0] !== 'P2PK') {\n\t\tthrow new Error('Invalid P2PK secret: must start with \"P2PK\"');\n\t}\n\tconst { tags } = secret[1];\n\tconst sigFlagTag = tags && tags.find((tag) => tag[0] === 'sigflag');\n\treturn sigFlagTag && sigFlagTag.length > 1 ? sigFlagTag[1] : 'SIG_INPUTS';\n}\n\n/**\n * Gets witness signatures as an array.\n *\n * @type {array} of Signatures.\n */\nexport const getP2PKWitnessSignatures = (witness: string | P2PKWitness | undefined): string[] => {\n\tif (!witness) return [];\n\tif (typeof witness === 'string') {\n\t\ttry {\n\t\t\tconst parsed = JSON.parse(witness) as Witness;\n\t\t\treturn parsed.signatures || [];\n\t\t} catch (e) {\n\t\t\tconsole.error('Failed to parse witness string:', e);\n\t\t\treturn [];\n\t\t}\n\t}\n\treturn witness.signatures || [];\n};\n\n/**\n * Signs proofs with provided private key(s) if required NB: Will only sign if the proof requires a\n * signature from the key.\n *\n * @param proofs - An array of proofs to sign.\n * @param privateKey - A single private key or array of private keys.\n * @param beStrict - (Default: false) Throws Error if any signing attempt fails.\n */\nexport const signP2PKProofs = (\n\tproofs: Proof[],\n\tprivateKey: string | string[],\n\tbeStrict = false,\n): Proof[] => {\n\tconst privateKeys: string[] = Array.isArray(privateKey) ? privateKey : [privateKey];\n\treturn proofs.map((proof, index) => {\n\t\tlet signedProof = proof;\n\t\tfor (const priv of privateKeys) {\n\t\t\ttry {\n\t\t\t\tsignedProof = signP2PKProof(signedProof, priv);\n\t\t\t} catch (error: unknown) {\n\t\t\t\tconst message = error instanceof Error ? error.message : 'Unknown error';\n\t\t\t\tif (beStrict) {\n\t\t\t\t\tthrow new Error(`Failed signing proof #${index + 1}: ${message}`);\n\t\t\t\t}\n\t\t\t\tconsole.warn(`Proof #${index + 1}: ${message}`);\n\t\t\t}\n\t\t}\n\t\treturn signedProof;\n\t});\n};\n\n/**\n * Signs a single proof with the provided private key if required NB: Will only sign if the proof\n * requires a signature from the key.\n *\n * @param proof - A proof to sign.\n * @param privateKey - A single private key (hex string or Uint8Array).\n * @throws Error if signature is not required or proof is already signed.\n */\nexport const signP2PKProof = (proof: Proof, privateKey: string | Uint8Array): Proof => {\n\t// Check secret is P2PK\n\tconst parsed: Secret = parseP2PKSecret(proof.secret);\n\tif (parsed[0] !== 'P2PK') {\n\t\tthrow new Error('not a P2PK secret');\n\t}\n\t// Convert hex string to Uint8Array, or use Uint8Array directly\n\tconst privateKeyBytes = typeof privateKey === 'string' ? hexToBytes(privateKey) : privateKey;\n\t// Check if the private key is required to sign by checking its\n\t// X-only pubkey (no 02/03 prefix) against the expected witness pubkeys\n\t// NB: Nostr pubkeys prepend 02 by convention, ignoring actual Y-parity\n\tconst pubkey = bytesToHex(schnorr.getPublicKey(privateKeyBytes)); // x-only\n\tconst witnesses = getP2PKExpectedKWitnessPubkeys(parsed);\n\tif (!witnesses.length || !witnesses.some((w) => w.includes(pubkey))) {\n\t\tthrow new Error(`Signature not required from [02|03]${pubkey}`);\n\t}\n\t// Check if the public key has already signed\n\tconst signatures = getP2PKWitnessSignatures(proof.witness);\n\tconst alreadySigned = signatures.some((sig) => {\n\t\ttry {\n\t\t\treturn verifyP2PKSecretSignature(sig, proof.secret, pubkey);\n\t\t} catch {\n\t\t\treturn false; // Invalid signature, treat as not signed\n\t\t}\n\t});\n\tif (alreadySigned) {\n\t\tthrow new Error(`Proof already signed by [02|03]${pubkey}`);\n\t}\n\t// Add new signature\n\tconst signature = signP2PKSecret(proof.secret, privateKeyBytes);\n\tsignatures.push(signature);\n\treturn { ...proof, witness: { signatures } };\n};\n\nexport const getSignedOutput = (output: BlindedMessage, privateKey: Uint8Array): BlindedMessage => {\n\tconst B_ = output.B_.toHex(true);\n\tconst signature = signBlindedMessage(B_, privateKey);\n\toutput.witness = { signatures: [signature] };\n\treturn output;\n};\n\nexport const getSignedOutputs = (\n\toutputs: BlindedMessage[],\n\tprivateKey: Uint8Array,\n): BlindedMessage[] => {\n\treturn outputs.map((o) => getSignedOutput(o, privateKey));\n};\n"],"names":["createP2PKsecret","pubkey","newSecret","bytesToHex","randomBytes","signP2PKSecret","secret","privateKey","msghash","sha256","sig","schnorr","signBlindedMessage","B_","msgHash","verifyP2PKSecretSignature","signature","pubkeyX","hexToBytes","e","hasP2PKSignedProof","proof","getP2PKWitnessSignatures","getP2PKExpectedKWitnessPubkeys","secretStr","parseP2PKSecret","now","getP2PKLocktime","getP2PKWitnessPubkeys","getP2PKWitnessRefundkeys","data","tags","pubkeysTag","tag","pubkeys","refundTag","locktimeTag","getP2PKNSigs","n_sigsTag","n_sigs_refundTag","getP2PKSigFlag","sigFlagTag","witness","signP2PKProofs","proofs","beStrict","privateKeys","index","signedProof","priv","signP2PKProof","error","message","parsed","privateKeyBytes","witnesses","w","signatures","getSignedOutput","output","getSignedOutputs","outputs","o"],"mappings":"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"}},
    {"offset": {"line": 5305, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@cashu+cashu-ts@2.9.0/node_modules/@cashu/cashu-ts/lib/crypto/client/NUT20.es.js","sources":["file:///home/maximoto/dev/sats-rover/node_modules/.pnpm/%40cashu%2Bcashu-ts%402.9.0/node_modules/%40cashu/cashu-ts/src/crypto/client/NUT20.ts"],"sourcesContent":["import { schnorr } from '@noble/curves/secp256k1.js';\nimport { type SerializedBlindedMessage } from '../../model/types';\nimport { bytesToHex, hexToBytes } from '@noble/hashes/utils.js';\nimport { sha256 } from '@noble/hashes/sha2.js';\n\nfunction constructMessage(quote: string, blindedMessages: SerializedBlindedMessage[]): Uint8Array {\n\tlet message = quote;\n\tfor (const blindedMessage of blindedMessages) {\n\t\tmessage += blindedMessage.B_;\n\t}\n\tconst msgbytes = new TextEncoder().encode(message);\n\treturn sha256(msgbytes);\n}\n\nexport function signMintQuote(\n\tprivkey: string,\n\tquote: string,\n\tblindedMessages: SerializedBlindedMessage[],\n): string {\n\tconst message = constructMessage(quote, blindedMessages);\n\tconst privkeyBytes = hexToBytes(privkey);\n\tconst signature = schnorr.sign(message, privkeyBytes);\n\treturn bytesToHex(signature);\n}\n\nexport function verifyMintQuoteSignature(\n\tpubkey: string,\n\tquote: string,\n\tblindedMessages: SerializedBlindedMessage[],\n\tsignature: string,\n): boolean {\n\tconst sigbytes = hexToBytes(signature);\n\tlet pubkeyBytes = hexToBytes(pubkey);\n\tif (pubkeyBytes.length !== 33) return false;\n\tpubkeyBytes = pubkeyBytes.slice(1);\n\tconst message = constructMessage(quote, blindedMessages);\n\treturn schnorr.verify(sigbytes, message, pubkeyBytes);\n}\n"],"names":["constructMessage","quote","blindedMessages","message","blindedMessage","msgbytes","sha256","signMintQuote","privkey","privkeyBytes","hexToBytes","signature","schnorr","bytesToHex","verifyMintQuoteSignature","pubkey","sigbytes","pubkeyBytes"],"mappings":";;;;;;;;;;AAKA,SAASA,EAAiBC,CAAAA,EAAeC,CAAAA,EAAyD;IACjG,IAAIC,IAAUF;IACd,KAAA,MAAWG,KAAkBF,EAC5BC,KAAWC,EAAe,EAAA;IAE3B,MAAMC,IAAW,IAAI,cAAc,MAAA,CAAOF,CAAO;IACjD,WAAOG,iPAAAA,EAAOD,CAAQ;AACvB;AAEO,SAASE,EACfC,CAAAA,EACAP,CAAAA,EACAC,CAAAA,EACS;IACT,MAAMC,IAAUH,EAAiBC,GAAOC,CAAe,GACjDO,QAAeC,6OAAAA,EAAWF,CAAO,GACjCG,IAAYC,iPAAAA,CAAQ,IAAA,CAAKT,GAASM,CAAY;IACpD,WAAOI,6OAAAA,EAAWF,CAAS;AAC5B;AAEO,SAASG,EACfC,CAAAA,EACAd,CAAAA,EACAC,CAAAA,EACAS,CAAAA,EACU;IACV,MAAMK,QAAWN,6OAAAA,EAAWC,CAAS;IACrC,IAAIM,QAAcP,6OAAAA,EAAWK,CAAM;IACnC,IAAIE,EAAY,MAAA,KAAW,GAAI,CAAA,OAAO,CAAA;IACtCA,IAAcA,EAAY,KAAA,CAAM,CAAC;IACjC,MAAMd,IAAUH,EAAiBC,GAAOC,CAAe;IACvD,OAAOU,iPAAAA,CAAQ,MAAA,CAAOI,GAAUb,GAASc,CAAW;AACrD"}},
    {"offset": {"line": 5339, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@cashu+cashu-ts@2.9.0/node_modules/@cashu/cashu-ts/lib/crypto/client.es.js","sources":["file:///home/maximoto/dev/sats-rover/node_modules/.pnpm/%40cashu%2Bcashu-ts%402.9.0/node_modules/%40cashu/cashu-ts/src/crypto/client/index.ts"],"sourcesContent":["import { type WeierstrassPoint } from '@noble/curves/abstract/weierstrass.js';\nimport { secp256k1 } from '@noble/curves/secp256k1.js';\nimport { randomBytes } from '@noble/hashes/utils.js';\nimport { bytesToNumber } from '../util/utils';\nimport {\n\ttype BlindSignature,\n\ttype Proof,\n\ttype SerializedBlindedMessage,\n\ttype SerializedProof,\n\thashToCurve,\n\tpointFromHex,\n\ttype Witness,\n} from '../common/index.js';\nimport { getSignedOutput } from './NUT11';\n\nexport type BlindedMessage = {\n\tB_: WeierstrassPoint<bigint>;\n\tr: bigint;\n\tsecret: Uint8Array;\n\twitness?: Witness;\n};\n\nexport function createRandomBlindedMessage(privateKey?: Uint8Array): BlindedMessage {\n\treturn blindMessage(\n\t\trandomBytes(32),\n\t\tbytesToNumber(secp256k1.utils.randomSecretKey()),\n\t\tprivateKey,\n\t);\n}\n\nexport function blindMessage(\n\tsecret: Uint8Array,\n\tr?: bigint,\n\tprivateKey?: Uint8Array,\n): BlindedMessage {\n\tconst Y = hashToCurve(secret);\n\tif (!r) {\n\t\tr = bytesToNumber(secp256k1.utils.randomSecretKey());\n\t}\n\tconst rG = secp256k1.Point.BASE.multiply(r);\n\tconst B_ = Y.add(rG);\n\tif (privateKey !== undefined) {\n\t\treturn getSignedOutput({ B_, r, secret }, privateKey);\n\t}\n\treturn { B_, r, secret };\n}\n\nexport function unblindSignature(\n\tC_: WeierstrassPoint<bigint>,\n\tr: bigint,\n\tA: WeierstrassPoint<bigint>,\n): WeierstrassPoint<bigint> {\n\tconst C = C_.subtract(A.multiply(r));\n\treturn C;\n}\n\nexport function constructProofFromPromise(\n\tpromise: BlindSignature,\n\tr: bigint,\n\tsecret: Uint8Array,\n\tkey: WeierstrassPoint<bigint>,\n): Proof {\n\tconst A = key;\n\tconst C = unblindSignature(promise.C_, r, A);\n\tconst proof = {\n\t\tid: promise.id,\n\t\tamount: promise.amount,\n\t\tsecret,\n\t\tC,\n\t};\n\treturn proof;\n}\n\nexport const serializeProof = (proof: Proof): SerializedProof => {\n\treturn {\n\t\tamount: proof.amount,\n\t\tC: proof.C.toHex(true),\n\t\tid: proof.id,\n\t\tsecret: new TextDecoder().decode(proof.secret),\n\t\twitness: JSON.stringify(proof.witness),\n\t};\n};\n\nexport const deserializeProof = (proof: SerializedProof): Proof => {\n\treturn {\n\t\tamount: proof.amount,\n\t\tC: pointFromHex(proof.C),\n\t\tid: proof.id,\n\t\tsecret: new TextEncoder().encode(proof.secret),\n\t\twitness: proof.witness ? (JSON.parse(proof.witness) as Witness) : undefined,\n\t};\n};\nexport const serializeBlindedMessage = (\n\tbm: BlindedMessage,\n\tamount: number,\n): SerializedBlindedMessage => {\n\treturn {\n\t\tB_: bm.B_.toHex(true),\n\t\tamount: amount,\n\t};\n};\n"],"names":["createRandomBlindedMessage","privateKey","blindMessage","randomBytes","bytesToNumber","secp256k1","secret","r","Y","hashToCurve","rG","B_","getSignedOutput","unblindSignature","C_","A","constructProofFromPromise","promise","key","C","serializeProof","proof","deserializeProof","pointFromHex","serializeBlindedMessage","bm","amount"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;AAsBO,SAASA,EAA2BC,CAAAA,EAAyC;IACnF,OAAOC,MACNC,6OAAAA,EAAY,EAAE,OACdC,6OAAAA,EAAcC,iPAAAA,CAAU,KAAA,CAAM,eAAA,EAAiB,GAC/CJ;AAEF;AAEO,SAASC,EACfI,CAAAA,EACAC,CAAAA,EACAN,CAAAA,EACiB;IACjB,MAAMO,QAAIC,4PAAAA,EAAYH,CAAM;IACvBC,KAAAA,CACJA,QAAIH,6OAAAA,EAAcC,iPAAAA,CAAU,KAAA,CAAM,eAAA,CAAA,CAAiB,CAAA;IAEpD,MAAMK,IAAKL,iPAAAA,CAAU,KAAA,CAAM,IAAA,CAAK,QAAA,CAASE,CAAC,GACpCI,IAAKH,EAAE,GAAA,CAAIE,CAAE;IACnB,OAAIT,MAAe,KAAA,QACXW,yQAAAA,EAAgB;QAAE,IAAAD;QAAI,GAAAJ;QAAG,QAAAD;IAAA,GAAUL,CAAU,IAE9C;QAAE,IAAAU;QAAI,GAAAJ;QAAG,QAAAD;IAAA;AACjB;AAEO,SAASO,EACfC,CAAAA,EACAP,CAAAA,EACAQ,CAAAA,EAC2B;IAE3B,OADUD,EAAG,QAAA,CAASC,EAAE,QAAA,CAASR,CAAC,CAAC;AAEpC;AAEO,SAASS,EACfC,CAAAA,EACAV,CAAAA,EACAD,CAAAA,EACAY,CAAAA,EACQ;IACR,MAAMH,IAAIG,GACJC,IAAIN,EAAiBI,EAAQ,EAAA,EAAIV,GAAGQ,CAAC;IAO3C,OANc;QACb,IAAIE,EAAQ,EAAA;QACZ,QAAQA,EAAQ,MAAA;QAChB,QAAAX;QACA,GAAAa;IAAA;AAGF;AAEO,MAAMC,IAAiB,CAACC,IAAAA,CACvB;QACN,QAAQA,EAAM,MAAA;QACd,GAAGA,EAAM,CAAA,CAAE,KAAA,CAAM,CAAA,CAAI;QACrB,IAAIA,EAAM,EAAA;QACV,QAAQ,IAAI,YAAA,EAAc,MAAA,CAAOA,EAAM,MAAM;QAC7C,SAAS,KAAK,SAAA,CAAUA,EAAM,OAAO;IAAA,CAAA,GAI1BC,IAAmB,CAACD,IAAAA,CACzB;QACN,QAAQA,EAAM,MAAA;QACd,OAAGE,6PAAAA,EAAaF,EAAM,CAAC;QACvB,IAAIA,EAAM,EAAA;QACV,QAAQ,IAAI,YAAA,EAAc,MAAA,CAAOA,EAAM,MAAM;QAC7C,SAASA,EAAM,OAAA,GAAW,KAAK,KAAA,CAAMA,EAAM,OAAO,IAAgB,KAAA;IAAA,CAAA,GAGvDG,IAA0B,CACtCC,GACAC,IAAAA,CAEO;QACN,IAAID,EAAG,EAAA,CAAG,KAAA,CAAM,CAAA,CAAI;QACpB,QAAAC;IAAA,CAAA"}},
    {"offset": {"line": 5416, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@cashu+cashu-ts@2.9.0/node_modules/@cashu/cashu-ts/lib/cashu-ts.es.js","sources":["file:///home/maximoto/dev/sats-rover/node_modules/.pnpm/%40cashu%2Bcashu-ts%402.9.0/node_modules/%40cashu/cashu-ts/src/cbor.ts","file:///home/maximoto/dev/sats-rover/node_modules/.pnpm/%40cashu%2Bcashu-ts%402.9.0/node_modules/%40cashu/cashu-ts/src/model/PaymentRequest.ts","file:///home/maximoto/dev/sats-rover/node_modules/.pnpm/%40cashu%2Bcashu-ts%402.9.0/node_modules/%40cashu/cashu-ts/src/utils/Constants.ts","file:///home/maximoto/dev/sats-rover/node_modules/.pnpm/%40cashu%2Bcashu-ts%402.9.0/node_modules/%40cashu/cashu-ts/src/utils.ts","file:///home/maximoto/dev/sats-rover/node_modules/.pnpm/%40cashu%2Bcashu-ts%402.9.0/node_modules/%40cashu/cashu-ts/src/ws.ts","file:///home/maximoto/dev/sats-rover/node_modules/.pnpm/%40cashu%2Bcashu-ts%402.9.0/node_modules/%40cashu/cashu-ts/src/logger.ts","file:///home/maximoto/dev/sats-rover/node_modules/.pnpm/%40cashu%2Bcashu-ts%402.9.0/node_modules/%40cashu/cashu-ts/src/WSConnection.ts","file:///home/maximoto/dev/sats-rover/node_modules/.pnpm/%40cashu%2Bcashu-ts%402.9.0/node_modules/%40cashu/cashu-ts/src/model/types/mint/responses.ts","file:///home/maximoto/dev/sats-rover/node_modules/.pnpm/%40cashu%2Bcashu-ts%402.9.0/node_modules/%40cashu/cashu-ts/src/model/types/wallet/paymentRequests.ts","file:///home/maximoto/dev/sats-rover/node_modules/.pnpm/%40cashu%2Bcashu-ts%402.9.0/node_modules/%40cashu/cashu-ts/src/model/Errors.ts","file:///home/maximoto/dev/sats-rover/node_modules/.pnpm/%40cashu%2Bcashu-ts%402.9.0/node_modules/%40cashu/cashu-ts/src/request.ts","file:///home/maximoto/dev/sats-rover/node_modules/.pnpm/%40cashu%2Bcashu-ts%402.9.0/node_modules/%40cashu/cashu-ts/src/legacy/nut-05.ts","file:///home/maximoto/dev/sats-rover/node_modules/.pnpm/%40cashu%2Bcashu-ts%402.9.0/node_modules/%40cashu/cashu-ts/src/legacy/nut-04.ts","file:///home/maximoto/dev/sats-rover/node_modules/.pnpm/%40cashu%2Bcashu-ts%402.9.0/node_modules/%40cashu/cashu-ts/src/legacy/nut-06.ts","file:///home/maximoto/dev/sats-rover/node_modules/.pnpm/%40cashu%2Bcashu-ts%402.9.0/node_modules/%40cashu/cashu-ts/src/model/MintInfo.ts","file:///home/maximoto/dev/sats-rover/node_modules/.pnpm/%40cashu%2Bcashu-ts%402.9.0/node_modules/%40cashu/cashu-ts/src/CashuMint.ts","file:///home/maximoto/dev/sats-rover/node_modules/.pnpm/%40cashu%2Bcashu-ts%402.9.0/node_modules/%40cashu/cashu-ts/src/model/BlindedMessage.ts","file:///home/maximoto/dev/sats-rover/node_modules/.pnpm/%40cashu%2Bcashu-ts%402.9.0/node_modules/%40cashu/cashu-ts/src/model/OutputData.ts","file:///home/maximoto/dev/sats-rover/node_modules/.pnpm/%40cashu%2Bcashu-ts%402.9.0/node_modules/%40cashu/cashu-ts/src/CashuWallet.ts","file:///home/maximoto/dev/sats-rover/node_modules/.pnpm/%40cashu%2Bcashu-ts%402.9.0/node_modules/%40cashu/cashu-ts/src/auth/CashuAuthMint.ts","file:///home/maximoto/dev/sats-rover/node_modules/.pnpm/%40cashu%2Bcashu-ts%402.9.0/node_modules/%40cashu/cashu-ts/src/auth/CashuAuthWallet.ts","file:///home/maximoto/dev/sats-rover/node_modules/.pnpm/%40cashu%2Bcashu-ts%402.9.0/node_modules/%40cashu/cashu-ts/src/auth/index.ts"],"sourcesContent":["type SimpleValue = boolean | null | undefined;\n\nexport type ResultObject = { [key: string]: ResultValue };\nexport type ResultValue = SimpleValue | number | string | Uint8Array | ResultValue[] | ResultObject;\n\ntype ResultKeyType = Extract<ResultValue, number | string>;\nexport type ValidDecodedType = Extract<ResultValue, ResultObject>;\n\nfunction isResultKeyType(value: ResultValue): value is ResultKeyType {\n\treturn typeof value === 'number' || typeof value === 'string';\n}\n\ntype DecodeResult<T extends ResultValue> = {\n\tvalue: T;\n\toffset: number;\n};\n\nexport function encodeCBOR(value: unknown): Uint8Array {\n\tconst buffer: number[] = [];\n\tencodeItem(value, buffer);\n\treturn new Uint8Array(buffer);\n}\n\nfunction encodeItem(value: unknown, buffer: number[]) {\n\tif (value === null) {\n\t\tbuffer.push(0xf6);\n\t} else if (value === undefined) {\n\t\tbuffer.push(0xf7);\n\t} else if (typeof value === 'boolean') {\n\t\tbuffer.push(value ? 0xf5 : 0xf4);\n\t} else if (typeof value === 'number') {\n\t\tencodeUnsigned(value, buffer);\n\t} else if (typeof value === 'string') {\n\t\tencodeString(value, buffer);\n\t} else if (Array.isArray(value)) {\n\t\tencodeArray(value, buffer);\n\t} else if (value instanceof Uint8Array) {\n\t\tencodeByteString(value, buffer);\n\t} else if (\n\t\t// Defensive: POJO only (null/array handled above)\n\t\ttypeof value === 'object' &&\n\t\tvalue !== null &&\n\t\t!Array.isArray(value)\n\t) {\n\t\tencodeObject(value as Record<string, unknown>, buffer);\n\t} else {\n\t\tthrow new Error('Unsupported type');\n\t}\n}\n\nfunction encodeUnsigned(value: number, buffer: number[]) {\n\tif (value < 24) {\n\t\tbuffer.push(value);\n\t} else if (value < 256) {\n\t\tbuffer.push(0x18, value);\n\t} else if (value < 65536) {\n\t\tbuffer.push(0x19, value >> 8, value & 0xff);\n\t} else if (value < 4294967296) {\n\t\tbuffer.push(0x1a, value >> 24, (value >> 16) & 0xff, (value >> 8) & 0xff, value & 0xff);\n\t} else {\n\t\tthrow new Error('Unsupported integer size');\n\t}\n}\n\nfunction encodeByteString(value: Uint8Array, buffer: number[]) {\n\tconst length = value.length;\n\n\tif (length < 24) {\n\t\tbuffer.push(0x40 + length);\n\t} else if (length < 256) {\n\t\tbuffer.push(0x58, length);\n\t} else if (length < 65536) {\n\t\tbuffer.push(0x59, (length >> 8) & 0xff, length & 0xff);\n\t} else if (length < 4294967296) {\n\t\tbuffer.push(\n\t\t\t0x5a,\n\t\t\t(length >> 24) & 0xff,\n\t\t\t(length >> 16) & 0xff,\n\t\t\t(length >> 8) & 0xff,\n\t\t\tlength & 0xff,\n\t\t);\n\t} else {\n\t\tthrow new Error('Byte string too long to encode');\n\t}\n\n\tfor (let i = 0; i < value.length; i++) {\n\t\tbuffer.push(value[i]);\n\t}\n}\n\nfunction encodeString(value: string, buffer: number[]) {\n\tconst utf8 = new TextEncoder().encode(value);\n\tconst length = utf8.length;\n\n\tif (length < 24) {\n\t\tbuffer.push(0x60 + length);\n\t} else if (length < 256) {\n\t\tbuffer.push(0x78, length);\n\t} else if (length < 65536) {\n\t\tbuffer.push(0x79, (length >> 8) & 0xff, length & 0xff);\n\t} else if (length < 4294967296) {\n\t\tbuffer.push(\n\t\t\t0x7a,\n\t\t\t(length >> 24) & 0xff,\n\t\t\t(length >> 16) & 0xff,\n\t\t\t(length >> 8) & 0xff,\n\t\t\tlength & 0xff,\n\t\t);\n\t} else {\n\t\tthrow new Error('String too long to encode');\n\t}\n\n\tfor (let i = 0; i < utf8.length; i++) {\n\t\tbuffer.push(utf8[i]);\n\t}\n}\n\nfunction encodeArray(value: unknown[], buffer: number[]) {\n\tconst length = value.length;\n\tif (length < 24) {\n\t\tbuffer.push(0x80 | length);\n\t} else if (length < 256) {\n\t\tbuffer.push(0x98, length);\n\t} else if (length < 65536) {\n\t\tbuffer.push(0x99, length >> 8, length & 0xff);\n\t} else {\n\t\tthrow new Error('Unsupported array length');\n\t}\n\n\tfor (const item of value) {\n\t\tencodeItem(item, buffer);\n\t}\n}\n\nfunction encodeObject(value: Record<string, unknown>, buffer: number[]) {\n\tconst keys = Object.keys(value);\n\tencodeUnsigned(keys.length, buffer);\n\tbuffer[buffer.length - 1] |= 0xa0;\n\tfor (const key of keys) {\n\t\tencodeString(key, buffer);\n\t\tencodeItem(value[key], buffer);\n\t}\n}\n\nexport function decodeCBOR(data: Uint8Array): ResultValue {\n\tconst view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n\tconst result = decodeItem(view, 0);\n\treturn result.value;\n}\n\nfunction decodeItem(view: DataView, offset: number): DecodeResult<ResultValue> {\n\tif (offset >= view.byteLength) {\n\t\tthrow new Error('Unexpected end of data');\n\t}\n\tconst initialByte = view.getUint8(offset++);\n\tconst majorType = initialByte >> 5;\n\tconst additionalInfo = initialByte & 0x1f;\n\n\tswitch (majorType) {\n\t\tcase 0:\n\t\t\treturn decodeUnsigned(view, offset, additionalInfo);\n\t\tcase 1:\n\t\t\treturn decodeSigned(view, offset, additionalInfo);\n\t\tcase 2:\n\t\t\treturn decodeByteString(view, offset, additionalInfo);\n\t\tcase 3:\n\t\t\treturn decodeString(view, offset, additionalInfo);\n\t\tcase 4:\n\t\t\treturn decodeArray(view, offset, additionalInfo);\n\t\tcase 5:\n\t\t\treturn decodeMap(view, offset, additionalInfo);\n\t\tcase 7:\n\t\t\treturn decodeSimpleAndFloat(view, offset, additionalInfo);\n\t\tdefault:\n\t\t\tthrow new Error(`Unsupported major type: ${majorType}`);\n\t}\n}\n\nfunction decodeLength(\n\tview: DataView,\n\toffset: number,\n\tadditionalInfo: number,\n): DecodeResult<number> {\n\tif (additionalInfo < 24) return { value: additionalInfo, offset };\n\tif (additionalInfo === 24) return { value: view.getUint8(offset++), offset };\n\tif (additionalInfo === 25) {\n\t\tconst value = view.getUint16(offset, false);\n\t\toffset += 2;\n\t\treturn { value, offset };\n\t}\n\tif (additionalInfo === 26) {\n\t\tconst value = view.getUint32(offset, false);\n\t\toffset += 4;\n\t\treturn { value, offset };\n\t}\n\tif (additionalInfo === 27) {\n\t\tconst hi = view.getUint32(offset, false);\n\t\tconst lo = view.getUint32(offset + 4, false);\n\t\toffset += 8;\n\t\treturn { value: hi * 2 ** 32 + lo, offset };\n\t}\n\tthrow new Error(`Unsupported length: ${additionalInfo}`);\n}\n\nfunction decodeUnsigned(\n\tview: DataView,\n\toffset: number,\n\tadditionalInfo: number,\n): DecodeResult<number> {\n\tconst { value, offset: newOffset } = decodeLength(view, offset, additionalInfo);\n\treturn { value, offset: newOffset };\n}\n\nfunction decodeSigned(\n\tview: DataView,\n\toffset: number,\n\tadditionalInfo: number,\n): DecodeResult<number> {\n\tconst { value, offset: newOffset } = decodeLength(view, offset, additionalInfo);\n\treturn { value: -1 - value, offset: newOffset };\n}\n\nfunction decodeByteString(\n\tview: DataView,\n\toffset: number,\n\tadditionalInfo: number,\n): DecodeResult<Uint8Array> {\n\tconst { value: length, offset: newOffset } = decodeLength(view, offset, additionalInfo);\n\tif (newOffset + length > view.byteLength) {\n\t\tthrow new Error('Byte string length exceeds data length');\n\t}\n\tconst value = new Uint8Array(view.buffer, view.byteOffset + newOffset, length);\n\treturn { value, offset: newOffset + length };\n}\n\nfunction decodeString(\n\tview: DataView,\n\toffset: number,\n\tadditionalInfo: number,\n): DecodeResult<string> {\n\tconst { value: length, offset: newOffset } = decodeLength(view, offset, additionalInfo);\n\tif (newOffset + length > view.byteLength) {\n\t\tthrow new Error('String length exceeds data length');\n\t}\n\tconst bytes = new Uint8Array(view.buffer, view.byteOffset + newOffset, length);\n\tconst value = new TextDecoder().decode(bytes);\n\treturn { value, offset: newOffset + length };\n}\n\nfunction decodeArray(\n\tview: DataView,\n\toffset: number,\n\tadditionalInfo: number,\n): DecodeResult<ResultValue[]> {\n\tconst { value: length, offset: newOffset } = decodeLength(view, offset, additionalInfo);\n\tconst array = [];\n\tlet currentOffset = newOffset;\n\tfor (let i = 0; i < length; i++) {\n\t\tconst result = decodeItem(view, currentOffset);\n\t\tarray.push(result.value);\n\t\tcurrentOffset = result.offset;\n\t}\n\treturn { value: array, offset: currentOffset };\n}\n\nfunction decodeMap(\n\tview: DataView,\n\toffset: number,\n\tadditionalInfo: number,\n): DecodeResult<Record<string, ResultValue>> {\n\tconst { value: length, offset: newOffset } = decodeLength(view, offset, additionalInfo);\n\tconst map: { [key: string]: ResultValue } = {};\n\tlet currentOffset = newOffset;\n\tfor (let i = 0; i < length; i++) {\n\t\tconst keyResult = decodeItem(view, currentOffset);\n\t\tif (!isResultKeyType(keyResult.value)) {\n\t\t\tthrow new Error('Invalid key type');\n\t\t}\n\t\tconst valueResult = decodeItem(view, keyResult.offset);\n\t\tmap[keyResult.value] = valueResult.value;\n\t\tcurrentOffset = valueResult.offset;\n\t}\n\treturn { value: map, offset: currentOffset };\n}\n\nfunction decodeFloat16(uint16: number): number {\n\tconst exponent = (uint16 & 0x7c00) >> 10;\n\tconst fraction = uint16 & 0x03ff;\n\tconst sign = uint16 & 0x8000 ? -1 : 1;\n\n\tif (exponent === 0) {\n\t\treturn sign * 2 ** -14 * (fraction / 1024);\n\t} else if (exponent === 0x1f) {\n\t\treturn fraction ? NaN : sign * Infinity;\n\t}\n\treturn sign * 2 ** (exponent - 15) * (1 + fraction / 1024);\n}\n\nfunction decodeSimpleAndFloat(\n\tview: DataView,\n\toffset: number,\n\tadditionalInfo: number,\n): DecodeResult<SimpleValue | number> {\n\tif (additionalInfo < 24) {\n\t\tswitch (additionalInfo) {\n\t\t\tcase 20:\n\t\t\t\treturn { value: false, offset };\n\t\t\tcase 21:\n\t\t\t\treturn { value: true, offset };\n\t\t\tcase 22:\n\t\t\t\treturn { value: null, offset };\n\t\t\tcase 23:\n\t\t\t\treturn { value: undefined, offset };\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Unknown simple value: ${additionalInfo}`);\n\t\t}\n\t}\n\tif (additionalInfo === 24) return { value: view.getUint8(offset++), offset };\n\tif (additionalInfo === 25) {\n\t\tconst value = decodeFloat16(view.getUint16(offset, false));\n\t\toffset += 2;\n\t\treturn { value, offset };\n\t}\n\tif (additionalInfo === 26) {\n\t\tconst value = view.getFloat32(offset, false);\n\t\toffset += 4;\n\t\treturn { value, offset };\n\t}\n\tif (additionalInfo === 27) {\n\t\tconst value = view.getFloat64(offset, false);\n\t\toffset += 8;\n\t\treturn { value, offset };\n\t}\n\tthrow new Error(`Unknown simple or float value: ${additionalInfo}`);\n}\n","import { encodeBase64toUint8 } from '../base64';\nimport { decodeCBOR, encodeCBOR } from '../cbor';\nimport {\n\ttype RawPaymentRequest,\n\ttype RawTransport,\n\ttype NUT10Option,\n\ttype PaymentRequestTransport,\n\ttype PaymentRequestTransportType,\n} from './types';\nimport { Bytes } from '../utils/Bytes';\n\nexport class PaymentRequest {\n\tconstructor(\n\t\tpublic transport?: PaymentRequestTransport[],\n\t\tpublic id?: string,\n\t\tpublic amount?: number,\n\t\tpublic unit?: string,\n\t\tpublic mints?: string[],\n\t\tpublic description?: string,\n\t\tpublic singleUse: boolean = false,\n\t\tpublic nut10?: NUT10Option,\n\t) {}\n\n\ttoRawRequest() {\n\t\tconst rawRequest: RawPaymentRequest = {};\n\t\tif (this.transport) {\n\t\t\trawRequest.t = this.transport.map((t: PaymentRequestTransport) => ({\n\t\t\t\tt: t.type,\n\t\t\t\ta: t.target,\n\t\t\t\tg: t.tags,\n\t\t\t}));\n\t\t}\n\t\tif (this.id) {\n\t\t\trawRequest.i = this.id;\n\t\t}\n\t\tif (this.amount) {\n\t\t\trawRequest.a = this.amount;\n\t\t}\n\t\tif (this.unit) {\n\t\t\trawRequest.u = this.unit;\n\t\t}\n\t\tif (this.mints) {\n\t\t\trawRequest.m = this.mints;\n\t\t}\n\t\tif (this.description) {\n\t\t\trawRequest.d = this.description;\n\t\t}\n\t\tif (this.singleUse) {\n\t\t\trawRequest.s = this.singleUse;\n\t\t}\n\t\tif (this.nut10) {\n\t\t\trawRequest.nut10 = {\n\t\t\t\tk: this.nut10.kind,\n\t\t\t\td: this.nut10.data,\n\t\t\t\tt: this.nut10.tags,\n\t\t\t};\n\t\t}\n\t\treturn rawRequest;\n\t}\n\n\ttoEncodedRequest() {\n\t\tconst rawRequest: RawPaymentRequest = this.toRawRequest();\n\t\tconst data = encodeCBOR(rawRequest);\n\t\tconst encodedData = Bytes.toBase64(data);\n\t\treturn 'creq' + 'A' + encodedData;\n\t}\n\n\tgetTransport(type: PaymentRequestTransportType) {\n\t\treturn this.transport?.find((t: PaymentRequestTransport) => t.type === type);\n\t}\n\n\tstatic fromRawRequest(rawPaymentRequest: RawPaymentRequest): PaymentRequest {\n\t\tconst transports = rawPaymentRequest.t\n\t\t\t? rawPaymentRequest.t.map((t: RawTransport) => ({\n\t\t\t\t\ttype: t.t,\n\t\t\t\t\ttarget: t.a,\n\t\t\t\t\ttags: t.g,\n\t\t\t\t}))\n\t\t\t: undefined;\n\t\tconst nut10 = rawPaymentRequest.nut10\n\t\t\t? {\n\t\t\t\t\tkind: rawPaymentRequest.nut10.k,\n\t\t\t\t\tdata: rawPaymentRequest.nut10.d,\n\t\t\t\t\ttags: rawPaymentRequest.nut10.t,\n\t\t\t\t}\n\t\t\t: undefined;\n\t\treturn new PaymentRequest(\n\t\t\ttransports,\n\t\t\trawPaymentRequest.i,\n\t\t\trawPaymentRequest.a,\n\t\t\trawPaymentRequest.u,\n\t\t\trawPaymentRequest.m,\n\t\t\trawPaymentRequest.d,\n\t\t\trawPaymentRequest.s,\n\t\t\tnut10,\n\t\t);\n\t}\n\n\tstatic fromEncodedRequest(encodedRequest: string): PaymentRequest {\n\t\tif (!encodedRequest.startsWith('creq')) {\n\t\t\tthrow new Error('unsupported pr: invalid prefix');\n\t\t}\n\t\tconst version = encodedRequest[4];\n\t\tif (version !== 'A') {\n\t\t\tthrow new Error('unsupported pr version');\n\t\t}\n\t\tconst encodedData = encodedRequest.slice(5);\n\t\tconst data = encodeBase64toUint8(encodedData);\n\t\tconst decoded = decodeCBOR(data) as RawPaymentRequest;\n\t\treturn this.fromRawRequest(decoded);\n\t}\n}\n","/**\n * Per protocol definition since tokenV3 tokens have a prefix and a version number.\n */\nconst TOKEN_VERSION = 'A';\nconst TOKEN_PREFIX = 'cashu';\n\nexport { TOKEN_VERSION, TOKEN_PREFIX };\n","import { verifyDLEQProof_reblind } from './crypto/client/NUT12';\nimport { type DLEQ, pointFromHex } from './crypto/common';\nimport { bytesToHex, hexToBytes } from '@noble/curves/utils.js';\nimport { sha256 } from '@noble/hashes/sha2.js';\nimport {\n\tencodeBase64ToJson,\n\tencodeBase64toUint8,\n\tencodeJsonToBase64,\n\tencodeUint8toBase64Url,\n\tisBase64String,\n} from './base64';\nimport { decodeCBOR, encodeCBOR } from './cbor';\nimport { PaymentRequest } from './model/PaymentRequest';\nimport type {\n\tTokenMetadata,\n\tDeprecatedToken,\n\tKeys,\n\tMintKeys,\n\tMintKeyset,\n\tProof,\n\tSerializedDLEQ,\n\tToken,\n\tTokenV4Template,\n\tV4DLEQTemplate,\n\tV4InnerToken,\n\tV4ProofTemplate,\n} from './model/types';\nimport { TOKEN_PREFIX, TOKEN_VERSION } from './utils/Constants';\nimport { Bytes } from './utils/Bytes';\n\n/**\n * Splits the amount into denominations of the provided @param keyset.\n *\n * @param value Amount to split.\n * @param keyset Keys to look up split amounts.\n * @param split? Optional custom split amounts.\n * @param order? Optional order for split amounts (default: \"asc\")\n * @returns Array of split amounts.\n * @throws Error if @param split amount is greater than @param value amount.\n */\nexport function splitAmount(\n\tvalue: number,\n\tkeyset: Keys,\n\tsplit?: number[],\n\torder?: 'desc' | 'asc',\n): number[] {\n\tif (split) {\n\t\tconst totalSplitAmount = sumArray(split);\n\n\t\t// Special case: explicit \"zero-total\" outputs (restore or NUT-08 blanks)\n\t\tif (value === 0 && totalSplitAmount === 0) {\n\t\t\treturn split;\n\t\t}\n\n\t\t// Normal positive-value paths: ignore zeros for validation and totals\n\t\tconst positive = split.filter((amt) => amt > 0);\n\t\tconst totalPositive = sumArray(positive);\n\t\tif (totalPositive > value) {\n\t\t\tthrow new Error(`Split is greater than total amount: ${totalPositive} > ${value}`);\n\t\t}\n\t\tif (positive.some((amt) => !hasCorrespondingKey(amt, keyset))) {\n\t\t\tthrow new Error('Provided amount preferences do not match the amounts of the mint keyset.');\n\t\t}\n\n\t\t// if caller supplied an exact custom split, preserve their order\n\t\tif (totalPositive === value) {\n\t\t\treturn positive;\n\t\t}\n\n\t\t// Work only with validated positive amounts from here on\n\t\tsplit = positive;\n\t\tvalue -= totalPositive;\n\t} else {\n\t\tsplit = [];\n\t}\n\n\t// Denomination fill for the remaining value\n\tconst sortedKeyAmounts = getKeysetAmounts(keyset, 'desc');\n\tif (!sortedKeyAmounts || sortedKeyAmounts.length === 0) {\n\t\tthrow new Error('Cannot split amount, keyset is inactive or contains no keys');\n\t}\n\tsortedKeyAmounts.forEach((amt: number) => {\n\t\tif (value <= 0 || amt <= 0) return;\n\t\tconst q = Math.floor(value / amt);\n\t\tfor (let i = 0; i < q; ++i) split.push(amt);\n\t\tvalue %= amt;\n\t});\n\tif (value !== 0) {\n\t\tthrow new Error(`Unable to split remaining amount: ${value}`);\n\t}\n\n\t// Only sort when we performed a fill; exact custom splits returned earlier\n\treturn split.sort((a, b) => (order === 'desc' ? b - a : a - b));\n}\n\n/**\n * Creates a list of amounts to keep based on the proofs we have and the proofs we want to reach.\n *\n * @param proofsWeHave Complete set of proofs stored (from current mint)\n * @param amountToKeep Amount to keep.\n * @param keys Keys of current keyset.\n * @param targetCount The target number of proofs to reach.\n * @returns An array of amounts to keep.\n */\nexport function getKeepAmounts(\n\tproofsWeHave: Proof[],\n\tamountToKeep: number,\n\tkeys: Keys,\n\ttargetCount: number,\n): number[] {\n\t// determines amounts we need to reach the targetCount for each amount based on the amounts of the proofs we have\n\t// it tries to select amounts so that the proofs we have and the proofs we want reach the targetCount\n\tconst amountsWeWant: number[] = [];\n\tconst amountsWeHave = proofsWeHave.map((p: Proof) => p.amount);\n\tconst sortedKeyAmounts = getKeysetAmounts(keys, 'asc');\n\tsortedKeyAmounts.forEach((amt) => {\n\t\tconst countWeHave = amountsWeHave.filter((a) => a === amt).length;\n\t\tconst countWeWant = Math.max(targetCount - countWeHave, 0);\n\t\tfor (let i = 0; i < countWeWant; ++i) {\n\t\t\tif (amountsWeWant.reduce((a, b) => a + b, 0) + amt > amountToKeep) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tamountsWeWant.push(amt);\n\t\t}\n\t});\n\t// use splitAmount to fill the rest between the sum of amountsWeHave and amountToKeep\n\tconst amountDiff = amountToKeep - amountsWeWant.reduce((a, b) => a + b, 0);\n\tif (amountDiff) {\n\t\tconst remainingAmounts = splitAmount(amountDiff, keys);\n\t\tremainingAmounts.forEach((amt: number) => {\n\t\t\tamountsWeWant.push(amt);\n\t\t});\n\t}\n\treturn amountsWeWant.sort((a, b) => a - b);\n}\n/**\n * Returns the amounts in the keyset sorted by the order specified.\n *\n * @param keyset To search in.\n * @param order Order to sort the amounts in.\n * @returns The amounts in the keyset sorted by the order specified.\n */\nexport function getKeysetAmounts(keyset: Keys, order: 'asc' | 'desc' = 'desc'): number[] {\n\tif (order == 'desc') {\n\t\treturn Object.keys(keyset)\n\t\t\t.map((k: string) => parseInt(k))\n\t\t\t.sort((a: number, b: number) => b - a);\n\t}\n\treturn Object.keys(keyset)\n\t\t.map((k: string) => parseInt(k))\n\t\t.sort((a: number, b: number) => a - b);\n}\n\n/**\n * Checks if the provided amount is in the keyset.\n *\n * @param amount Amount to check.\n * @param keyset To search in.\n * @returns True if the amount is in the keyset, false otherwise.\n */\nexport function hasCorrespondingKey(amount: number, keyset: Keys): boolean {\n\treturn amount in keyset;\n}\n\n/**\n * Converts a bytes array to a number.\n *\n * @param bytes To convert to number.\n * @returns Number.\n */\nexport function bytesToNumber(bytes: Uint8Array): bigint {\n\treturn hexToNumber(bytesToHex(bytes));\n}\n\n/**\n * Converts a hex string to a number.\n *\n * @param hex To convert to number.\n * @returns Number.\n */\nexport function hexToNumber(hex: string): bigint {\n\treturn BigInt(`0x${hex}`);\n}\n\n/**\n * Converts a number to a hex string of 64 characters.\n *\n * @param number (bigint) to conver to hex.\n * @returns Hex string start-padded to 64 characters.\n */\nexport function numberToHexPadded64(number: bigint): string {\n\treturn number.toString(16).padStart(64, '0');\n}\n\nexport function isValidHex(str: string) {\n\treturn /^[a-f0-9]*$/i.test(str);\n}\n\n/**\n * Checks wether a proof or a list of proofs contains a non-hex id.\n *\n * @param p Proof or list of proofs.\n * @returns Boolean.\n */\nexport function hasNonHexId(p: Proof | Proof[]) {\n\tif (Array.isArray(p)) {\n\t\treturn p.some((proof) => !isValidHex(proof.id));\n\t}\n\treturn !isValidHex(p.id);\n}\n\n//used for json serialization\nexport function bigIntStringify<T>(_key: unknown, value: T) {\n\treturn typeof value === 'bigint' ? value.toString() : value;\n}\n\n/**\n * Helper function to encode a v3 cashu token.\n *\n * @param token To encode.\n * @returns Encoded token.\n */\nexport function getEncodedTokenV3(token: Token, removeDleq?: boolean): string {\n\tif (!hasNonHexId(token.proofs)) {\n\t\ttoken.proofs = convertToShortKeysetId(token.proofs);\n\t}\n\tif (removeDleq) {\n\t\ttoken.proofs = stripDleq(token.proofs);\n\t}\n\tconst v3TokenObj: DeprecatedToken = { token: [{ mint: token.mint, proofs: token.proofs }] };\n\tif (token.unit) {\n\t\tv3TokenObj.unit = token.unit;\n\t}\n\tif (token.memo) {\n\t\tv3TokenObj.memo = token.memo;\n\t}\n\treturn TOKEN_PREFIX + TOKEN_VERSION + encodeJsonToBase64(v3TokenObj);\n}\n\n/*\n * Convert a keyset ID into short form\n */\nfunction convertToShortKeysetId(proofs: Proof[]) {\n\treturn proofs.map((p) => {\n\t\tconst newP = { ...p };\n\t\tnewP.id = newP.id.slice(0, 16);\n\t\treturn newP;\n\t});\n}\n\n/**\n * Helper function to encode a cashu token (defaults to v4 if keyset id allows it)\n *\n * @param token\n * @param [opts]\n */\nexport function getEncodedToken(\n\ttoken: Token,\n\topts?: { version?: 3 | 4; removeDleq?: boolean },\n): string {\n\t// Find out if it's a base64 keyset\n\tconst nonHex = hasNonHexId(token.proofs);\n\tif (nonHex || opts?.version === 3) {\n\t\tif (opts?.version === 4) {\n\t\t\tthrow new Error('can not encode to v4 token if proofs contain non-hex keyset id');\n\t\t}\n\t\treturn getEncodedTokenV3(token, opts?.removeDleq);\n\t}\n\treturn getEncodedTokenV4(token, opts?.removeDleq);\n}\n\nexport function getEncodedTokenV4(token: Token, removeDleq?: boolean): string {\n\tif (removeDleq) {\n\t\ttoken.proofs = stripDleq(token.proofs);\n\t}\n\t// Make sure each DLEQ has its blinding factor\n\ttoken.proofs.forEach((p) => {\n\t\tif (p.dleq && p.dleq.r == undefined) {\n\t\t\tthrow new Error('Missing blinding factor in included DLEQ proof');\n\t\t}\n\t});\n\tconst nonHex = hasNonHexId(token.proofs);\n\tif (nonHex) {\n\t\tthrow new Error('can not encode to v4 token if proofs contain non-hex keyset id');\n\t}\n\t// Map keyset IDs to short IDs\n\ttoken.proofs = convertToShortKeysetId(token.proofs);\n\n\tconst tokenTemplate = templateFromToken(token);\n\n\tconst encodedData = encodeCBOR(tokenTemplate);\n\tconst prefix = 'cashu';\n\tconst version = 'B';\n\tconst base64Data = encodeUint8toBase64Url(encodedData);\n\treturn prefix + version + base64Data;\n}\n\nfunction templateFromToken(token: Token): TokenV4Template {\n\tconst idMap: { [id: string]: Proof[] } = {};\n\tconst mint = token.mint;\n\tfor (let i = 0; i < token.proofs.length; i++) {\n\t\tconst proof = token.proofs[i];\n\t\tif (idMap[proof.id]) {\n\t\t\tidMap[proof.id].push(proof);\n\t\t} else {\n\t\t\tidMap[proof.id] = [proof];\n\t\t}\n\t}\n\tconst tokenTemplate: TokenV4Template = {\n\t\tm: mint,\n\t\tu: token.unit || 'sat',\n\t\tt: Object.keys(idMap).map(\n\t\t\t(id: string): V4InnerToken => ({\n\t\t\t\ti: hexToBytes(id),\n\t\t\t\tp: idMap[id].map(\n\t\t\t\t\t(p: Proof): V4ProofTemplate => ({\n\t\t\t\t\t\ta: p.amount,\n\t\t\t\t\t\ts: p.secret,\n\t\t\t\t\t\tc: hexToBytes(p.C),\n\t\t\t\t\t\t...(p.dleq && {\n\t\t\t\t\t\t\td: {\n\t\t\t\t\t\t\t\te: hexToBytes(p.dleq.e),\n\t\t\t\t\t\t\t\ts: hexToBytes(p.dleq.s),\n\t\t\t\t\t\t\t\tr: hexToBytes(p.dleq.r ?? '00'),\n\t\t\t\t\t\t\t} as V4DLEQTemplate,\n\t\t\t\t\t\t}),\n\t\t\t\t\t\t...(p.witness && {\n\t\t\t\t\t\t\tw: JSON.stringify(p.witness),\n\t\t\t\t\t\t}),\n\t\t\t\t\t}),\n\t\t\t\t),\n\t\t\t}),\n\t\t),\n\t} as TokenV4Template;\n\tif (token.memo) {\n\t\ttokenTemplate.d = token.memo;\n\t}\n\treturn tokenTemplate;\n}\n\nfunction tokenFromTemplate(template: TokenV4Template): Token {\n\tconst proofs: Proof[] = [];\n\ttemplate.t.forEach((t) =>\n\t\tt.p.forEach((p) => {\n\t\t\tproofs.push({\n\t\t\t\tsecret: p.s,\n\t\t\t\tC: bytesToHex(p.c),\n\t\t\t\tamount: p.a,\n\t\t\t\tid: bytesToHex(t.i),\n\t\t\t\t...(p.d && {\n\t\t\t\t\tdleq: {\n\t\t\t\t\t\tr: bytesToHex(p.d.r),\n\t\t\t\t\t\ts: bytesToHex(p.d.s),\n\t\t\t\t\t\te: bytesToHex(p.d.e),\n\t\t\t\t\t} as SerializedDLEQ,\n\t\t\t\t}),\n\t\t\t\t...(p.w && {\n\t\t\t\t\twitness: p.w,\n\t\t\t\t}),\n\t\t\t});\n\t\t}),\n\t);\n\tconst decodedToken: Token = { mint: template.m, proofs, unit: template.u || 'sat' };\n\tif (template.d) {\n\t\tdecodedToken.memo = template.d;\n\t}\n\treturn decodedToken;\n}\n\n/**\n * Helper function to decode cashu tokens into object.\n *\n * @param token An encoded cashu token (cashuAey...)\n * @returns Cashu token object.\n */\nexport function getDecodedToken(tokenString: string, keysets?: MintKeyset[]) {\n\ttokenString = removePrefix(tokenString);\n\n\tconst token = handleTokens(tokenString);\n\ttoken.proofs = mapShortKeysetIds(token.proofs, keysets);\n\treturn token;\n}\n\n/**\n * Returns the metadata of a cashu token.\n *\n * @param token An encoded cashu token (cashuAey...)\n * @returns Token metadata.\n */\nexport function getTokenMetadata(token: string): TokenMetadata {\n\ttoken = removePrefix(token);\n\tconst tokenObj = handleTokens(token);\n\treturn {\n\t\tunit: tokenObj.unit || 'sat',\n\t\tmint: tokenObj.mint,\n\t\tamount: sumProofs(tokenObj.proofs),\n\t\tincompleteProofs: tokenObj.proofs.map((p) => ({\n\t\t\tsecret: p.secret,\n\t\t\tC: p.C,\n\t\t\tamount: p.amount,\n\t\t\t...(p.dleq && {\n\t\t\t\tdleq: p.dleq,\n\t\t\t}),\n\t\t})),\n\t\t...(tokenObj.memo && { memo: tokenObj.memo }),\n\t};\n}\n\n/**\n * Helper function to decode different versions of cashu tokens into an object.\n *\n * @param token An encoded cashu token (cashuAey...)\n * @returns Cashu Token object.\n */\nexport function handleTokens(token: string): Token {\n\tconst version = token.slice(0, 1);\n\tconst encodedToken = token.slice(1);\n\tif (version === 'A') {\n\t\tconst parsedV3Token = encodeBase64ToJson<DeprecatedToken>(encodedToken);\n\t\tif (parsedV3Token.token.length > 1) {\n\t\t\tthrow new Error('Multi entry token are not supported');\n\t\t}\n\t\tconst entry = parsedV3Token.token[0];\n\t\tconst tokenObj: Token = {\n\t\t\tmint: entry.mint,\n\t\t\tproofs: entry.proofs,\n\t\t\tunit: parsedV3Token.unit || 'sat',\n\t\t};\n\t\tif (parsedV3Token.memo) {\n\t\t\ttokenObj.memo = parsedV3Token.memo;\n\t\t}\n\t\treturn tokenObj;\n\t} else if (version === 'B') {\n\t\tconst uInt8Token = encodeBase64toUint8(encodedToken);\n\t\tconst tokenData = decodeCBOR(uInt8Token) as TokenV4Template;\n\t\treturn tokenFromTemplate(tokenData);\n\t}\n\tthrow new Error('Token version is not supported');\n}\n\n/**\n * Returns the keyset id of a set of keys.\n *\n * @param keys Keys object to derive keyset id from.\n * @param unit (optional) the unit of the keyset.\n * @param expiry (optional) expiry of the keyset.\n * @param versionByte (optional) version of the keyset ID. Default is 0.\n * @param isDeprecatedBase64 (optional) true if the keyset ID should be derived as a deprecated v0\n *   base64 keyset ID.\n * @returns Keyset id of the keys.\n * @throws If keyset versionByte is not valid.\n */\nexport function deriveKeysetId(\n\tkeys: Keys,\n\tunit?: string,\n\texpiry?: number,\n\tversionByte: number = 0,\n\tisDeprecatedBase64: boolean = false,\n) {\n\tif (isDeprecatedBase64) {\n\t\tconst pubkeysConcat = Object.entries(keys)\n\t\t\t.sort((a: [string, string], b: [string, string]) => +a[0] - +b[0])\n\t\t\t.map(([, pubKey]: [unknown, string]) => pubKey)\n\t\t\t.reduce((prev: string, curr: string) => prev + curr, '');\n\t\tconst hash = sha256(new TextEncoder().encode(pubkeysConcat));\n\t\tconst b64 = Bytes.toBase64(hash);\n\t\treturn b64.slice(0, 12);\n\t}\n\n\tlet pubkeysConcat = Object.entries(keys)\n\t\t.sort((a: [string, string], b: [string, string]) => +a[0] - +b[0])\n\t\t.map(([, pubKey]: [unknown, string]) => hexToBytes(pubKey))\n\t\t.reduce((prev: Uint8Array, curr: Uint8Array) => mergeUInt8Arrays(prev, curr), new Uint8Array());\n\n\tlet hash;\n\tlet hashHex;\n\tswitch (versionByte) {\n\t\tcase 0:\n\t\t\thash = sha256(pubkeysConcat);\n\t\t\thashHex = Bytes.toHex(hash).slice(0, 14);\n\t\t\treturn '00' + hashHex;\n\t\tcase 1:\n\t\t\tif (!unit) {\n\t\t\t\tthrow new Error('Cannot compute keyset ID version 01: unit is required.');\n\t\t\t}\n\t\t\tpubkeysConcat = mergeUInt8Arrays(pubkeysConcat, Bytes.fromString('unit:' + unit));\n\t\t\tif (expiry) {\n\t\t\t\tpubkeysConcat = mergeUInt8Arrays(\n\t\t\t\t\tpubkeysConcat,\n\t\t\t\t\tBytes.fromString('final_expiry:' + expiry.toString()),\n\t\t\t\t);\n\t\t\t}\n\t\t\thash = sha256(pubkeysConcat);\n\t\t\thashHex = Bytes.toHex(hash);\n\t\t\treturn '01' + hashHex;\n\t\tdefault:\n\t\t\tthrow new Error(`Unrecognized keyset ID version: ${versionByte}`);\n\t}\n}\n\nexport function mergeUInt8Arrays(a1: Uint8Array, a2: Uint8Array): Uint8Array {\n\t// sum of individual array lengths\n\tconst mergedArray = new Uint8Array(a1.length + a2.length);\n\tmergedArray.set(a1);\n\tmergedArray.set(a2, a1.length);\n\treturn mergedArray;\n}\n\nexport function sortProofsById(proofs: Proof[]) {\n\treturn proofs.sort((a: Proof, b: Proof) => a.id.localeCompare(b.id));\n}\n\nexport function isObj(v: unknown): v is object {\n\treturn typeof v === 'object';\n}\n\nexport function checkResponse(data: { error?: string; detail?: string }) {\n\tif (!isObj(data)) return;\n\tif ('error' in data && data.error) {\n\t\tthrow new Error(data.error);\n\t}\n\tif ('detail' in data && data.detail) {\n\t\tthrow new Error(data.detail);\n\t}\n}\n\nexport function joinUrls(...parts: string[]): string {\n\treturn parts.map((part: string) => part.replace(/(^\\/+|\\/+$)/g, '')).join('/');\n}\n\nexport function sanitizeUrl(url: string): string {\n\treturn url.replace(/\\/$/, '');\n}\n\nexport function sumProofs(proofs: Proof[]) {\n\treturn proofs.reduce((acc: number, proof: Proof) => acc + proof.amount, 0);\n}\n\nexport function decodePaymentRequest(paymentRequest: string) {\n\treturn PaymentRequest.fromEncodedRequest(paymentRequest);\n}\n\nexport class MessageNode {\n\tprivate _value: string;\n\tprivate _next: MessageNode | null;\n\n\tpublic get value(): string {\n\t\treturn this._value;\n\t}\n\tpublic set value(message: string) {\n\t\tthis._value = message;\n\t}\n\tpublic get next(): MessageNode | null {\n\t\treturn this._next;\n\t}\n\tpublic set next(node: MessageNode | null) {\n\t\tthis._next = node;\n\t}\n\n\tconstructor(message: string) {\n\t\tthis._value = message;\n\t\tthis._next = null;\n\t}\n}\n\nexport class MessageQueue {\n\tprivate _first: MessageNode | null;\n\tprivate _last: MessageNode | null;\n\n\tpublic get first(): MessageNode | null {\n\t\treturn this._first;\n\t}\n\tpublic set first(messageNode: MessageNode | null) {\n\t\tthis._first = messageNode;\n\t}\n\tpublic get last(): MessageNode | null {\n\t\treturn this._last;\n\t}\n\tpublic set last(messageNode: MessageNode | null) {\n\t\tthis._last = messageNode;\n\t}\n\tprivate _size: number;\n\tpublic get size(): number {\n\t\treturn this._size;\n\t}\n\tpublic set size(v: number) {\n\t\tthis._size = v;\n\t}\n\n\tconstructor() {\n\t\tthis._first = null;\n\t\tthis._last = null;\n\t\tthis._size = 0;\n\t}\n\tenqueue(message: string): boolean {\n\t\tconst newNode = new MessageNode(message);\n\t\tif (this._size === 0 || !this._last) {\n\t\t\tthis._first = newNode;\n\t\t\tthis._last = newNode;\n\t\t} else {\n\t\t\tthis._last.next = newNode;\n\t\t\tthis._last = newNode;\n\t\t}\n\t\tthis._size++;\n\t\treturn true;\n\t}\n\tdequeue(): string | null {\n\t\tif (this._size === 0 || !this._first) return null;\n\n\t\tconst prev = this._first;\n\t\tthis._first = prev.next;\n\t\tprev.next = null;\n\n\t\tthis._size--;\n\t\treturn prev.value;\n\t}\n}\n/**\n * Removes all traces of DLEQs from a list of proofs.\n *\n * @param proofs The list of proofs that dleq should be stripped from.\n */\nexport function stripDleq(proofs: Proof[]): Array<Omit<Proof, 'dleq'>> {\n\treturn proofs.map((p) => {\n\t\tconst newP = { ...p };\n\t\tdelete newP['dleq'];\n\t\treturn newP;\n\t});\n}\n\n/**\n * Check that the keyset hashes to the specified ID.\n *\n * @param keys The keyset to be verified.\n * @returns True if the verification was successful, false otherwise.\n * @throws Error if the keyset ID version is unrecognized.\n */\nexport function verifyKeysetId(keys: MintKeys): boolean {\n\tconst isBase64 = isBase64String(keys.id);\n\tconst isValidHex = /^[a-fA-F0-9]+$/.test(keys.id);\n\tconst versionByte = isValidHex ? hexToBytes(keys.id)[0] : 0;\n\treturn (\n\t\tderiveKeysetId(\n\t\t\tkeys.keys,\n\t\t\tkeys.unit,\n\t\t\tkeys.final_expiry,\n\t\t\tversionByte,\n\t\t\tisBase64 && !isValidHex,\n\t\t) === keys.id\n\t);\n}\n\n/**\n * Maps the short keyset IDs stored in the token to actual keyset IDs that were fetched from the\n * Mint.\n */\nfunction mapShortKeysetIds(proofs: Proof[], keysets?: MintKeyset[]): Proof[] {\n\tconst newProofs = [];\n\tfor (const proof of proofs) {\n\t\tlet idBytes;\n\t\ttry {\n\t\t\tidBytes = hexToBytes(proof.id);\n\t\t} catch {\n\t\t\t// Base64 keysets don't need conversion\n\t\t\tnewProofs.push(proof);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (idBytes[0] === 0x00) {\n\t\t\tnewProofs.push(proof);\n\t\t} else if (idBytes[0] === 0x01) {\n\t\t\tif (!keysets) {\n\t\t\t\tthrow new Error('A short keyset ID v2 was encountered, but got no keysets to map it to.');\n\t\t\t}\n\t\t\t// Look for a match: prefix(keyset ID) == short ID\n\t\t\tlet found = false;\n\t\t\tfor (const keyset of keysets) {\n\t\t\t\tif (proof.id === keyset.id.slice(0, proof.id.length)) {\n\t\t\t\t\tproof.id = keyset.id;\n\t\t\t\t\tnewProofs.push(proof);\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!found) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Couldn't map short keyset ID ${proof.id} to any known keysets of the current Mint`,\n\t\t\t\t);\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new Error(`Unknown keyset ID version: ${idBytes[0]}`);\n\t\t}\n\t}\n\n\treturn newProofs;\n}\n\n/**\n * Checks that the proof has a valid DLEQ proof according to keyset `keys`\n *\n * @param proof The proof subject to verification.\n * @param keyset The Mint's keyset to be used for verification.\n * @returns True if verification succeeded, false otherwise.\n * @throws Error if @param proof does not match any key in @param keyset.\n */\nexport function hasValidDleq(proof: Proof, keyset: MintKeys): boolean {\n\tif (proof.dleq == undefined) {\n\t\treturn false;\n\t}\n\tconst dleq = {\n\t\te: hexToBytes(proof.dleq.e),\n\t\ts: hexToBytes(proof.dleq.s),\n\t\tr: hexToNumber(proof.dleq.r ?? '00'),\n\t} as DLEQ;\n\tif (!hasCorrespondingKey(proof.amount, keyset.keys)) {\n\t\tthrow new Error(`undefined key for amount ${proof.amount}`);\n\t}\n\tconst key = keyset.keys[proof.amount];\n\treturn verifyDLEQProof_reblind(\n\t\tnew TextEncoder().encode(proof.secret),\n\t\tdleq,\n\t\tpointFromHex(proof.C),\n\t\tpointFromHex(key),\n\t);\n}\n\n/**\n * Helper function to encode a cashu auth token authA.\n *\n * @param proof\n */\nexport function getEncodedAuthToken(proof: Proof): string {\n\tconst token = {\n\t\tid: proof.id,\n\t\tsecret: proof.secret,\n\t\tC: proof.C,\n\t};\n\tconst base64Data = encodeJsonToBase64(token);\n\tconst prefix = 'auth';\n\tconst version = 'A';\n\treturn prefix + version + base64Data;\n}\n\nfunction concatByteArrays(...arrays: Uint8Array[]): Uint8Array {\n\tconst totalLength = arrays.reduce((a, c) => a + c.length, 0);\n\tconst byteArray = new Uint8Array(totalLength);\n\tlet pointer = 0;\n\tfor (let i = 0; i < arrays.length; i++) {\n\t\tbyteArray.set(arrays[i], pointer);\n\t\tpointer = pointer + arrays[i].length;\n\t}\n\treturn byteArray;\n}\n\nexport function getEncodedTokenBinary(token: Token): Uint8Array {\n\tconst utf8Encoder = new TextEncoder();\n\tconst template = templateFromToken(token);\n\tconst binaryTemplate = encodeCBOR(template);\n\tconst prefix = utf8Encoder.encode('craw');\n\tconst version = utf8Encoder.encode('B');\n\treturn concatByteArrays(prefix, version, binaryTemplate);\n}\n\nexport function getDecodedTokenBinary(bytes: Uint8Array): Token {\n\tconst utfDecoder = new TextDecoder();\n\tconst prefix = utfDecoder.decode(bytes.slice(0, 4));\n\tconst version = utfDecoder.decode(new Uint8Array([bytes[4]]));\n\tif (prefix !== 'craw' || version !== 'B') {\n\t\tthrow new Error('not a valid binary token');\n\t}\n\tconst binaryToken = bytes.slice(5);\n\tconst decoded = decodeCBOR(binaryToken) as TokenV4Template;\n\treturn tokenFromTemplate(decoded);\n}\n\nfunction sumArray(arr: number[]) {\n\treturn arr.reduce((a, c) => a + c, 0);\n}\n\nfunction removePrefix(token: string): string {\n\tconst uriPrefixes = ['web+cashu://', 'cashu://', 'cashu:', 'cashu'];\n\turiPrefixes.forEach((prefix: string) => {\n\t\tif (!token.startsWith(prefix)) {\n\t\t\treturn;\n\t\t}\n\t\ttoken = token.slice(prefix.length);\n\t});\n\treturn token;\n}\n","let _WS: typeof WebSocket | undefined;\n\nif (typeof WebSocket !== 'undefined') {\n\t_WS = WebSocket;\n}\n\nexport function injectWebSocketImpl(ws: typeof WebSocket) {\n\t_WS = ws;\n}\n\nexport function getWebSocketImpl() {\n\tif (_WS === undefined) {\n\t\tthrow new Error('WebSocket implementation not initialized');\n\t}\n\treturn _WS;\n}\n","/**\n * Defines the available log levels for the logger. Log levels are ordered from most severe (FATAL)\n * to least severe (TRACE).\n */\nexport const LogLevel = {\n\tFATAL: 'FATAL',\n\tERROR: 'ERROR',\n\tWARN: 'WARN',\n\tINFO: 'INFO',\n\tDEBUG: 'DEBUG',\n\tTRACE: 'TRACE',\n} as const;\n\n/**\n * Defines the available log levels for the logger. Log levels are ordered from most severe (FATAL)\n * to least severe (TRACE).\n */\nexport type LogLevel = (typeof LogLevel)[keyof typeof LogLevel];\n\nexport interface Logger {\n\tfatal(message: string, context?: Record<string, unknown>): void;\n\terror(message: string, context?: Record<string, unknown>): void;\n\twarn(message: string, context?: Record<string, unknown>): void;\n\tinfo(message: string, context?: Record<string, unknown>): void;\n\tdebug(message: string, context?: Record<string, unknown>): void;\n\ttrace(message: string, context?: Record<string, unknown>): void;\n\tlog(level: LogLevel, message: string, context?: Record<string, unknown>): void;\n}\n\n// The default logger implementation - does nothing\n/* eslint-disable @typescript-eslint/no-empty-function */\nexport const NULL_LOGGER: Logger = {\n\tfatal() {},\n\terror() {},\n\twarn() {},\n\tinfo() {},\n\tdebug() {},\n\ttrace() {},\n\tlog() {},\n};\n/* eslint-enable @typescript-eslint/no-empty-function */\n\n/**\n * Outputs messages to the console based on the specified log level.\n *\n * Supports placeholder substitution in messages (e.g., `{key}`) using values from the optional\n * `context` object. Context keys not used in substitution are appended to the output as additional\n * data. Each log message is prefixed with the log level in square brackets (e.g., `[INFO]`).\n *\n * @example Const logger = new ConsoleLogger(LogLevel.DEBUG); logger.info('User {username} logged\n * in', { username: 'alice', ip: '127.0.0.1' }); // Output: [INFO] User alice logged in { ip:\n * \"127.0.0.1\" }\n */\nexport class ConsoleLogger implements Logger {\n\tprivate minLevel: LogLevel;\n\tpublic static readonly SEVERITY: Record<LogLevel, number> = {\n\t\t[LogLevel.FATAL]: 0,\n\t\t[LogLevel.ERROR]: 1,\n\t\t[LogLevel.WARN]: 2,\n\t\t[LogLevel.INFO]: 3,\n\t\t[LogLevel.DEBUG]: 4,\n\t\t[LogLevel.TRACE]: 5,\n\t};\n\tconstructor(minLevel: LogLevel = LogLevel.INFO) {\n\t\tthis.minLevel = minLevel;\n\t}\n\n\tprivate logToConsole(level: LogLevel, message: string, context?: Record<string, unknown>): void {\n\t\tif (ConsoleLogger.SEVERITY[level] > ConsoleLogger.SEVERITY[this.minLevel]) return;\n\t\tconst levelPrefix = `[${level}] `;\n\t\tlet interpolatedMessage = message;\n\t\tconst usedKeys = new Set<string>();\n\t\tif (context) {\n\t\t\tconst processedContext = Object.fromEntries(\n\t\t\t\tObject.entries(context).map(([key, value]) => [\n\t\t\t\t\tkey,\n\t\t\t\t\tvalue instanceof Error ? { message: value.message, stack: value.stack } : value,\n\t\t\t\t]),\n\t\t\t);\n\t\t\tinterpolatedMessage = message.replace(/\\{(\\w+)\\}/g, (match: string, key: string) => {\n\t\t\t\tif (key in processedContext && processedContext[key] !== undefined) {\n\t\t\t\t\tusedKeys.add(key);\n\t\t\t\t\tconst value: unknown = processedContext[key];\n\t\t\t\t\tif (typeof value === 'string') return value;\n\t\t\t\t\tif (typeof value === 'number' || typeof value === 'boolean') return value.toString();\n\t\t\t\t\tif (value == null) return '';\n\t\t\t\t\treturn JSON.stringify(value);\n\t\t\t\t}\n\t\t\t\treturn match;\n\t\t\t});\n\t\t\tconst filteredContext = Object.fromEntries(\n\t\t\t\tObject.entries(processedContext).filter(([key]) => !usedKeys.has(key)),\n\t\t\t);\n\t\t\tconst consoleMethod = this.getConsoleMethod(level);\n\t\t\tif (Object.keys(filteredContext).length > 0) {\n\t\t\t\tconsoleMethod(levelPrefix + interpolatedMessage, filteredContext);\n\t\t\t} else {\n\t\t\t\tconsoleMethod(levelPrefix + interpolatedMessage);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.getConsoleMethod(level)(levelPrefix + interpolatedMessage);\n\t\t}\n\t}\n\t// Note: NOT static as test suite needs to spy on the output\n\tprivate getConsoleMethod(level: LogLevel): (message: string, ...args: unknown[]) => void {\n\t\tswitch (level) {\n\t\t\tcase LogLevel.FATAL:\n\t\t\tcase LogLevel.ERROR:\n\t\t\t\treturn console.error;\n\t\t\tcase LogLevel.WARN:\n\t\t\t\treturn console.warn;\n\t\t\tcase LogLevel.INFO:\n\t\t\t\treturn console.info;\n\t\t\tcase LogLevel.DEBUG:\n\t\t\t\treturn console.debug;\n\t\t\tcase LogLevel.TRACE:\n\t\t\t\treturn console.trace;\n\t\t\tdefault:\n\t\t\t\t// We could throw, but that's a bit aggressive for a logging class\n\t\t\t\t// so just use a regular console.log()\n\t\t\t\treturn console.log;\n\t\t}\n\t}\n\t// Interface methods\n\tfatal(message: string, context?: Record<string, unknown>): void {\n\t\tthis.logToConsole(LogLevel.FATAL, message, context);\n\t}\n\terror(message: string, context?: Record<string, unknown>): void {\n\t\tthis.logToConsole(LogLevel.ERROR, message, context);\n\t}\n\twarn(message: string, context?: Record<string, unknown>): void {\n\t\tthis.logToConsole(LogLevel.WARN, message, context);\n\t}\n\tinfo(message: string, context?: Record<string, unknown>): void {\n\t\tthis.logToConsole(LogLevel.INFO, message, context);\n\t}\n\tdebug(message: string, context?: Record<string, unknown>): void {\n\t\tthis.logToConsole(LogLevel.DEBUG, message, context);\n\t}\n\ttrace(message: string, context?: Record<string, unknown>): void {\n\t\tthis.logToConsole(LogLevel.TRACE, message, context);\n\t}\n\tlog(level: LogLevel, message: string, context?: Record<string, unknown>): void {\n\t\tthis.logToConsole(level, message, context);\n\t}\n}\n\n/**\n * Creates a timer to measure elapsed time in milliseconds.\n *\n * @example Const timer = measureTime(); // ... some code ... const duration = timer.elapsed();\n *\n * @returns An object with an `elapsed` method to retrieve the duration since the timer started.\n */\nexport function measureTime() {\n\tconst start = Date.now();\n\treturn {\n\t\telapsed: () => {\n\t\t\treturn Date.now() - start;\n\t\t},\n\t};\n}\n","import { MessageQueue } from './utils';\nimport { type JsonRpcMessage, type JsonRpcReqParams, type RpcSubId } from './model/types';\nimport { type OnOpenError, type OnOpenSuccess } from './model/types/wallet/websocket';\nimport { getWebSocketImpl } from './ws';\nimport { type Logger, NULL_LOGGER } from './logger';\n\n// Internal interface for RPC listeners\ninterface RpcListener {\n\tcallback: () => void;\n\terrorCallback: (e: Error) => void;\n}\n\nexport class ConnectionManager {\n\tprivate static instance: ConnectionManager;\n\tprivate connectionMap: Map<string, WSConnection> = new Map();\n\n\tstatic getInstance() {\n\t\tif (!ConnectionManager.instance) {\n\t\t\tConnectionManager.instance = new ConnectionManager();\n\t\t}\n\t\treturn ConnectionManager.instance;\n\t}\n\n\tgetConnection(url: string, logger?: Logger): WSConnection {\n\t\tif (this.connectionMap.has(url)) {\n\t\t\treturn this.connectionMap.get(url) as WSConnection;\n\t\t}\n\t\tconst newConn = new WSConnection(url, logger);\n\t\tthis.connectionMap.set(url, newConn);\n\t\treturn newConn;\n\t}\n}\n\nexport class WSConnection {\n\tpublic readonly url: URL;\n\tprivate readonly _WS: typeof WebSocket;\n\tprivate ws: WebSocket | undefined;\n\tprivate connectionPromise: Promise<void> | undefined;\n\tprivate subListeners: { [subId: string]: Array<(payload: unknown) => void> } = {};\n\tprivate rpcListeners: { [rpcSubId: string]: RpcListener } = {};\n\tprivate messageQueue: MessageQueue;\n\tprivate handlingInterval?: number;\n\tprivate rpcId = 0;\n\tprivate _logger: Logger;\n\tprivate onCloseCallbacks: Array<(e: CloseEvent) => void> = [];\n\n\tconstructor(url: string, logger?: Logger) {\n\t\tthis._WS = getWebSocketImpl();\n\t\tthis.url = new URL(url);\n\t\tthis.messageQueue = new MessageQueue();\n\t\tthis._logger = logger ?? NULL_LOGGER;\n\t}\n\n\tconnect() {\n\t\tif (!this.connectionPromise) {\n\t\t\tthis.connectionPromise = new Promise((resolve: OnOpenSuccess, reject: OnOpenError) => {\n\t\t\t\ttry {\n\t\t\t\t\tthis.ws = new this._WS(this.url.toString());\n\t\t\t\t\tthis.onCloseCallbacks = [];\n\t\t\t\t} catch (err: unknown) {\n\t\t\t\t\treject(err instanceof Error ? err : new Error(String(err)));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis.ws.onopen = () => {\n\t\t\t\t\tresolve();\n\t\t\t\t};\n\t\t\t\tthis.ws.onerror = () => {\n\t\t\t\t\treject(new Error('Failed to open WebSocket'));\n\t\t\t\t};\n\t\t\t\tthis.ws.onmessage = (e: MessageEvent) => {\n\t\t\t\t\tthis.messageQueue.enqueue(e.data as string);\n\t\t\t\t\tif (!this.handlingInterval) {\n\t\t\t\t\t\tthis.handlingInterval = setInterval(\n\t\t\t\t\t\t\tthis.handleNextMessage.bind(this),\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t) as unknown as number;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tthis.ws.onclose = (e: CloseEvent) => {\n\t\t\t\t\tthis.connectionPromise = undefined;\n\t\t\t\t\tthis.onCloseCallbacks.forEach((cb) => cb(e));\n\t\t\t\t};\n\t\t\t});\n\t\t}\n\t\treturn this.connectionPromise;\n\t}\n\n\tsendRequest(method: 'subscribe', params: JsonRpcReqParams): void;\n\tsendRequest(method: 'unsubscribe', params: { subId: string }): void;\n\tsendRequest(method: 'subscribe' | 'unsubscribe', params: Partial<JsonRpcReqParams>) {\n\t\tif (this.ws?.readyState !== 1) {\n\t\t\tif (method === 'unsubscribe') {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis._logger.error('Attempted sendRequest, but socket was not open');\n\t\t\tthrow new Error('Socket not open');\n\t\t}\n\t\tconst id = this.rpcId;\n\t\tthis.rpcId++;\n\t\tconst message = JSON.stringify({ jsonrpc: '2.0', method, params, id });\n\t\tthis.ws?.send(message);\n\t}\n\n\t/**\n\t * @deprecated Use cancelSubscription for JSONRPC compliance.\n\t */\n\tcloseSubscription(subId: string) {\n\t\tthis.ws?.send(JSON.stringify(['CLOSE', subId]));\n\t}\n\n\taddSubListener<TPayload = unknown>(subId: string, callback: (payload: TPayload) => void) {\n\t\t(this.subListeners[subId] = this.subListeners[subId] || []).push(\n\t\t\tcallback as (payload: unknown) => void,\n\t\t);\n\t}\n\n\tprivate addRpcListener(\n\t\tcallback: () => void,\n\t\terrorCallback: (e: Error) => void,\n\t\tid: Exclude<RpcSubId, null>,\n\t) {\n\t\tthis.rpcListeners[id] = { callback, errorCallback };\n\t}\n\n\tprivate removeRpcListener(id: Exclude<RpcSubId, null>) {\n\t\tdelete this.rpcListeners[id];\n\t}\n\n\tprivate removeListener<TPayload = unknown>(subId: string, callback: (payload: TPayload) => void) {\n\t\tif (!this.subListeners[subId]) {\n\t\t\treturn;\n\t\t}\n\t\tif (this.subListeners[subId].length === 1) {\n\t\t\tdelete this.subListeners[subId];\n\t\t\treturn;\n\t\t}\n\t\tthis.subListeners[subId] = this.subListeners[subId].filter(\n\t\t\t(fn) => fn !== (callback as (payload: unknown) => void),\n\t\t);\n\t}\n\n\tasync ensureConnection() {\n\t\tif (this.ws?.readyState !== 1) {\n\t\t\tawait this.connect();\n\t\t}\n\t}\n\n\tprivate handleNextMessage() {\n\t\tif (this.messageQueue.size === 0) {\n\t\t\tclearInterval(this.handlingInterval);\n\t\t\tthis.handlingInterval = undefined;\n\t\t\treturn;\n\t\t}\n\t\tconst message = this.messageQueue.dequeue() as string;\n\t\tlet parsed;\n\t\ttry {\n\t\t\tparsed = JSON.parse(message) as JsonRpcMessage;\n\t\t\tif ('result' in parsed && parsed.id != undefined) {\n\t\t\t\tif (this.rpcListeners[parsed.id]) {\n\t\t\t\t\tthis.rpcListeners[parsed.id].callback();\n\t\t\t\t\tthis.removeRpcListener(parsed.id);\n\t\t\t\t}\n\t\t\t} else if ('error' in parsed && parsed.id != undefined) {\n\t\t\t\tif (this.rpcListeners[parsed.id]) {\n\t\t\t\t\tthis.rpcListeners[parsed.id].errorCallback(new Error(parsed.error.message));\n\t\t\t\t\tthis.removeRpcListener(parsed.id);\n\t\t\t\t}\n\t\t\t} else if ('method' in parsed) {\n\t\t\t\tif ('id' in parsed) {\n\t\t\t\t\t// Do nothing as mints should not send requests\n\t\t\t\t} else {\n\t\t\t\t\tconst subId = parsed.params?.subId;\n\t\t\t\t\tif (!subId) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif (this.subListeners[subId]?.length > 0) {\n\t\t\t\t\t\tconst notification = parsed;\n\t\t\t\t\t\tthis.subListeners[subId].forEach((cb) => cb(notification.params?.payload));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tthis._logger.error('Error doing handleNextMessage', { e });\n\t\t\treturn;\n\t\t}\n\t}\n\n\tcreateSubscription<TPayload = unknown>(\n\t\tparams: Omit<JsonRpcReqParams, 'subId'>,\n\t\tcallback: (payload: TPayload) => void,\n\t\terrorCallback: (e: Error) => void,\n\t): string {\n\t\tif (this.ws?.readyState !== 1) {\n\t\t\tthis._logger.error('Attempted createSubscription, but socket was not open');\n\t\t\tthrow new Error('Socket is not open');\n\t\t}\n\t\tconst subId = (Math.random() + 1).toString(36).substring(7);\n\t\tthis.addRpcListener(\n\t\t\t() => {\n\t\t\t\tthis.addSubListener(subId, callback);\n\t\t\t},\n\t\t\terrorCallback,\n\t\t\tthis.rpcId,\n\t\t);\n\t\tthis.sendRequest('subscribe', { ...params, subId });\n\t\tthis.rpcId++;\n\t\treturn subId;\n\t}\n\n\t/**\n\t * Cancels a subscription, sending an unsubscribe request and handling responses.\n\t *\n\t * @param subId The subscription ID to cancel.\n\t * @param callback The original payload callback to remove.\n\t * @param errorCallback Optional callback for unsubscribe errors (defaults to logging).\n\t */\n\tcancelSubscription<TPayload = unknown>(\n\t\tsubId: string,\n\t\tcallback: (payload: TPayload) => void,\n\t\terrorCallback?: (e: Error) => void,\n\t) {\n\t\tthis.removeListener(subId, callback);\n\t\tthis.addRpcListener(\n\t\t\t() => {\n\t\t\t\tthis._logger.info('Unsubscribed {subId}', { subId });\n\t\t\t},\n\t\t\terrorCallback || ((e: Error) => this._logger.error('Unsubscribe failed', { e })),\n\t\t\tthis.rpcId,\n\t\t);\n\t\tthis.sendRequest('unsubscribe', { subId });\n\t}\n\n\tget activeSubscriptions() {\n\t\treturn Object.keys(this.subListeners);\n\t}\n\n\tclose() {\n\t\tif (this.ws) {\n\t\t\tthis.ws?.close();\n\t\t}\n\t}\n\n\tonClose(callback: (e: CloseEvent) => void) {\n\t\tthis.onCloseCallbacks.push(callback);\n\t}\n}\n","import { type SerializedBlindedMessage } from '../wallet';\n\n/**\n * Cashu api error.\n */\nexport type ApiError = {\n\t/**\n\t * Error message.\n\t */\n\terror?: string;\n\t/**\n\t * HTTP error code.\n\t */\n\tcode?: number;\n\t/**\n\t * Detailed error message.\n\t */\n\tdetail?: string;\n};\n\n/**\n * Entries of CheckStateResponse with state of the proof.\n */\nexport type ProofState = {\n\tY: string;\n\tstate: CheckStateEnum;\n\twitness: string | null;\n};\n\n/**\n * Enum for the state of a proof.\n */\nexport const CheckStateEnum = {\n\tUNSPENT: 'UNSPENT',\n\tPENDING: 'PENDING',\n\tSPENT: 'SPENT',\n} as const;\nexport type CheckStateEnum = (typeof CheckStateEnum)[keyof typeof CheckStateEnum];\n\n/**\n * Response when checking proofs if they are spendable. Should not rely on this for receiving, since\n * it can be easily cheated.\n */\nexport type CheckStateResponse = {\n\tstates: ProofState[];\n} & ApiError;\n\n/**\n * Response from mint at /info endpoint.\n */\nexport type GetInfoResponse = {\n\tname: string;\n\tpubkey: string;\n\tversion: string;\n\tdescription?: string;\n\tdescription_long?: string;\n\ticon_url?: string;\n\tcontact: MintContactInfo[];\n\tnuts: {\n\t\t'4': {\n\t\t\t// Minting\n\t\t\tmethods: SwapMethod[];\n\t\t\tdisabled: boolean;\n\t\t};\n\t\t'5': {\n\t\t\t// Melting\n\t\t\tmethods: SwapMethod[];\n\t\t\tdisabled: boolean;\n\t\t};\n\t\t'7'?: {\n\t\t\t// Token state check\n\t\t\tsupported: boolean;\n\t\t};\n\t\t'8'?: {\n\t\t\t// Overpaid melt fees\n\t\t\tsupported: boolean;\n\t\t};\n\t\t'9'?: {\n\t\t\t// Restore\n\t\t\tsupported: boolean;\n\t\t};\n\t\t'10'?: {\n\t\t\t// Spending conditions\n\t\t\tsupported: boolean;\n\t\t};\n\t\t'11'?: {\n\t\t\t// P2PK\n\t\t\tsupported: boolean;\n\t\t};\n\t\t'12'?: {\n\t\t\t// DLEQ\n\t\t\tsupported: boolean;\n\t\t};\n\t\t'14'?: {\n\t\t\t// HTLCs\n\t\t\tsupported: boolean;\n\t\t};\n\t\t'15'?: {\n\t\t\t// MPP\n\t\t\tmethods: MPPMethod[];\n\t\t};\n\t\t'17'?: {\n\t\t\t// WebSockets\n\t\t\tsupported: WebSocketSupport[];\n\t\t};\n\t\t'20'?: {\n\t\t\t// Locked Mint Quote\n\t\t\tsupported: boolean;\n\t\t};\n\t\t'22'?: {\n\t\t\t// Blind Authentication\n\t\t\tbat_max_mint: number;\n\t\t\tprotected_endpoints: Array<{ method: 'GET' | 'POST'; path: string }>;\n\t\t};\n\t};\n\tmotd?: string;\n};\n\n/**\n * Response from the mint after requesting a melt quote.\n */\nexport type PartialMeltQuoteResponse = {\n\t/**\n\t * Quote ID.\n\t */\n\tquote: string;\n\t/**\n\t * Amount to be melted.\n\t */\n\tamount: number;\n\t/**\n\t * Fee reserve to be added to the amount.\n\t */\n\tfee_reserve: number;\n\t/**\n\t * State of the melt quote.\n\t */\n\tstate: MeltQuoteState;\n\t/**\n\t * Timestamp of when the quote expires.\n\t */\n\texpiry: number;\n\t/**\n\t * Preimage of the paid invoice. is null if it the invoice has not been paid yet. can be null,\n\t * depending on which LN-backend the mint uses.\n\t */\n\tpayment_preimage: string | null;\n\t/**\n\t * Return/Change from overpaid fees. This happens due to Lighting fee estimation being inaccurate.\n\t */\n\tchange?: SerializedBlindedSignature[];\n\t/**\n\t * Payment request for the melt quote.\n\t */\n\trequest?: string;\n\t/**\n\t * Unit of the melt quote.\n\t */\n\tunit?: string;\n} & ApiError;\n\nexport type MeltQuoteResponse = PartialMeltQuoteResponse & { request: string; unit: string };\n\n/**\n * Response from the mint after requesting a BOLT12 melt quote. Contains payment details and state\n * for paying Lightning Network offers.\n */\nexport type Bolt12MeltQuoteResponse = MeltQuoteResponse;\n\nexport const MeltQuoteState = {\n\tUNPAID: 'UNPAID',\n\tPENDING: 'PENDING',\n\tPAID: 'PAID',\n} as const;\nexport type MeltQuoteState = (typeof MeltQuoteState)[keyof typeof MeltQuoteState];\n\nexport type MintContactInfo = {\n\tmethod: string;\n\tinfo: string;\n};\n\nexport const MintQuoteState = {\n\tUNPAID: 'UNPAID',\n\tPAID: 'PAID',\n\tISSUED: 'ISSUED',\n} as const;\nexport type MintQuoteState = (typeof MintQuoteState)[keyof typeof MintQuoteState];\n\n/**\n * Response from the mint after requesting a mint.\n */\nexport type PartialMintQuoteResponse = {\n\t/**\n\t * Payment request.\n\t */\n\trequest: string;\n\t/**\n\t * Quote ID.\n\t */\n\tquote: string;\n\t/**\n\t * State of the mint quote.\n\t */\n\tstate: MintQuoteState;\n\t/**\n\t * Timestamp of when the quote expires.\n\t */\n\texpiry: number;\n\t/**\n\t * Public key the quote is locked to.\n\t */\n\tpubkey?: string;\n\t/**\n\t * Unit of the quote.\n\t */\n\tunit?: string;\n\t/**\n\t * Amount requested for mint quote.\n\t */\n\tamount?: number;\n} & ApiError;\n\nexport type MintQuoteResponse = PartialMintQuoteResponse & { amount: number; unit: string };\n\nexport type LockedMintQuoteResponse = MintQuoteResponse & { pubkey: string };\n\n/**\n * Response from the mint after requesting a BOLT12 mint quote. Contains a Lightning Network offer\n * and tracks payment/issuance amounts.\n */\nexport type Bolt12MintQuoteResponse = {\n\t/**\n\t * Quote identifier.\n\t */\n\tquote: string;\n\t/**\n\t * BOLT12 offer that can be paid to mint tokens.\n\t */\n\trequest: string;\n\t/**\n\t * Requested amount. This is null for amount-less offers.\n\t */\n\tamount: number | null;\n\t/**\n\t * Unit of the amount.\n\t */\n\tunit: string;\n\t/**\n\t * Unix timestamp when quote expires.\n\t */\n\texpiry: number | null;\n\t/**\n\t * Public key that locked this quote.\n\t */\n\tpubkey: string;\n\t/**\n\t * The amount that has been paid to the mint via the bolt12 offer. The difference between this and\n\t * `amount_issued` can be minted.\n\t */\n\tamount_paid: number;\n\t/**\n\t * The amount of ecash that has been issued for the given mint quote.\n\t */\n\tamount_issued: number;\n};\n\n/**\n * Response from the mint after requesting a mint.\n */\nexport type MintResponse = {\n\tsignatures: SerializedBlindedSignature[];\n} & ApiError;\n\n/**\n * Response from mint at /v1/restore endpoint.\n */\nexport type PostRestoreResponse = {\n\toutputs: SerializedBlindedMessage[];\n\tsignatures: SerializedBlindedSignature[];\n};\n\n/*\n * Zero-Knowledge that BlindedSignature\n * was generated using a specific public key\n */\nexport type SerializedDLEQ = {\n\ts: string;\n\te: string;\n\tr?: string;\n};\n\n/**\n * Blinded signature as it is received from the mint.\n */\nexport type SerializedBlindedSignature = {\n\t/**\n\t * Keyset id for indicating which public key was used to sign the blinded message.\n\t */\n\tid: string;\n\t/**\n\t * Amount denominated in Satoshi.\n\t */\n\tamount: number;\n\t/**\n\t * Blinded signature.\n\t */\n\tC_: string;\n\t/**\n\t * DLEQ Proof.\n\t */\n\tdleq?: SerializedDLEQ;\n};\n\n/**\n * Ecash to other MoE swap method, displayed in @type {GetInfoResponse}\n */\nexport type SwapMethod = {\n\tmethod: string;\n\tunit: string;\n\tmin_amount: number;\n\tmax_amount: number;\n\toptions?: {\n\t\tdescription?: boolean;\n\t};\n};\n\n/**\n * Response from the mint after performing a split action.\n */\nexport type SwapResponse = {\n\t/**\n\t * Represents the outputs after the split.\n\t */\n\tsignatures: SerializedBlindedSignature[];\n} & ApiError;\n\n/**\n * MPP supported methods.\n */\nexport type MPPMethod = {\n\tmethod: string;\n\tunit: string;\n};\n\n/**\n * WebSocket supported methods.\n */\nexport type WebSocketSupport = {\n\tmethod: string;\n\tunit: string;\n\tcommands: string[];\n};\n\n/**\n * Response from the mint after blind auth minting.\n */\nexport type BlindAuthMintResponse = {\n\tsignatures: SerializedBlindedSignature[];\n} & ApiError;\n","import { type Proof } from './index';\n\nexport type RawTransport = {\n\tt: PaymentRequestTransportType; // type\n\ta: string; // target\n\tg?: string[][]; // tags\n};\n\nexport type RawNUT10Option = {\n\tk: string; // kind\n\td: string; // data\n\tt: string[][]; // tags\n};\n\nexport type RawPaymentRequest = {\n\ti?: string; // id\n\ta?: number; // amount\n\tu?: string; // unit\n\ts?: boolean; // single use\n\tm?: string[]; // mints\n\td?: string; // description\n\tt?: RawTransport[]; // transports\n\tnut10?: RawNUT10Option;\n};\n\nexport type PaymentRequestTransport = {\n\ttype: PaymentRequestTransportType;\n\ttarget: string;\n\ttags?: string[][];\n};\n\nexport enum PaymentRequestTransportType {\n\tPOST = 'post',\n\tNOSTR = 'nostr',\n}\n\nexport type PaymentRequestPayload = {\n\tid?: string;\n\tmemo?: string;\n\tunit: string;\n\tmint: string;\n\tproofs: Proof[];\n};\n\n/**\n * Used to express a spending condition that proofs should be encumbered with.\n */\nexport type NUT10Option = {\n\t/**\n\t * The kind of spending condition.\n\t */\n\tkind: string;\n\t/**\n\t * Expresses the spending condition relative to the kind.\n\t */\n\tdata: string;\n\t/**\n\t * Tags associated with the spending condition for additional data.\n\t */\n\ttags: string[][];\n};\n","/**\n * This error is thrown when a HTTP response is not 2XX nor a protocol error.\n */\nexport class HttpResponseError extends Error {\n\tstatus: number;\n\tconstructor(message: string, status: number) {\n\t\tsuper(message);\n\t\tthis.status = status;\n\t\tthis.name = 'HttpResponseError';\n\t\tObject.setPrototypeOf(this, HttpResponseError.prototype);\n\t}\n}\n\n/**\n * This error is thrown when a network request fails.\n */\nexport class NetworkError extends Error {\n\tconstructor(message: string) {\n\t\tsuper(message);\n\t\tthis.name = 'NetworkError';\n\t\tObject.setPrototypeOf(this, NetworkError.prototype);\n\t}\n}\n\n/**\n * This error is thrown when a [protocol\n * error](https://github.com/cashubtc/nuts/blob/main/00.md#errors) occurs. See error codes\n * [here](https://github.com/cashubtc/nuts/blob/main/error_codes.md).\n */\nexport class MintOperationError extends HttpResponseError {\n\tcode: number;\n\tconstructor(code: number, detail: string) {\n\t\tsuper(detail || 'Unknown mint operation error', 400);\n\t\tthis.code = code;\n\t\tthis.name = 'MintOperationError';\n\t\tObject.setPrototypeOf(this, MintOperationError.prototype);\n\t}\n}\n","import { HttpResponseError, NetworkError, MintOperationError } from './model/Errors';\nimport { type Logger, NULL_LOGGER } from './logger';\nimport { type ApiError } from './model/types/mint/responses';\n\ntype RequestArgs = {\n\tendpoint: string;\n\trequestBody?: Record<string, unknown>;\n\theaders?: Record<string, string>;\n};\n\ntype RequestOptions = RequestArgs & Omit<RequestInit, 'body' | 'headers'>;\n\nlet globalRequestOptions: Partial<RequestOptions> = {};\nlet requestLogger = NULL_LOGGER;\n\n/**\n * An object containing any custom settings that you want to apply to the global fetch method.\n *\n * @param options See possible options here:\n *   https://developer.mozilla.org/en-US/docs/Web/API/fetch#options.\n */\nexport function setGlobalRequestOptions(options: Partial<RequestOptions>): void {\n\tglobalRequestOptions = options;\n}\n\n/**\n * Allows a logger to be set.\n *\n * @param {Logger} logger The logger instance to use.\n */\nexport function setRequestLogger(logger: Logger): void {\n\trequestLogger = logger;\n}\n\nasync function _request({\n\tendpoint,\n\trequestBody,\n\theaders: requestHeaders,\n\t...options\n}: RequestOptions): Promise<unknown> {\n\tconst body = requestBody ? JSON.stringify(requestBody) : undefined;\n\tconst headers = {\n\t\t...{ Accept: 'application/json, text/plain, */*' },\n\t\t...(body ? { 'Content-Type': 'application/json' } : undefined),\n\t\t...requestHeaders,\n\t};\n\n\tlet response: Response;\n\ttry {\n\t\tresponse = await fetch(endpoint, { body, headers, ...options });\n\t} catch (err) {\n\t\t// A fetch() promise only rejects when the request fails,\n\t\t// for example, because of a badly-formed request URL or a network error.\n\t\tthrow new NetworkError(err instanceof Error ? err.message : 'Network request failed');\n\t}\n\n\tif (!response.ok) {\n\t\tlet errorData: ApiError;\n\t\ttry {\n\t\t\terrorData = (await response.json()) as ApiError;\n\t\t} catch {\n\t\t\terrorData = { error: 'bad response' };\n\t\t}\n\n\t\tif (\n\t\t\tresponse.status === 400 &&\n\t\t\t'code' in errorData &&\n\t\t\ttypeof errorData.code === 'number' &&\n\t\t\t'detail' in errorData &&\n\t\t\ttypeof errorData.detail === 'string'\n\t\t) {\n\t\t\tthrow new MintOperationError(errorData.code, errorData.detail);\n\t\t}\n\n\t\tlet errorMessage = 'HTTP request failed';\n\t\tif ('error' in errorData && typeof errorData.error === 'string') {\n\t\t\terrorMessage = errorData.error;\n\t\t} else if ('detail' in errorData && typeof errorData.detail === 'string') {\n\t\t\terrorMessage = errorData.detail;\n\t\t}\n\n\t\tthrow new HttpResponseError(errorMessage, response.status);\n\t}\n\n\ttry {\n\t\treturn await response.json();\n\t} catch (err) {\n\t\trequestLogger.error('Failed to parse HTTP response', { err });\n\t\tthrow new HttpResponseError('bad response', response.status);\n\t}\n}\n\nexport default async function request<T>(options: RequestOptions): Promise<T> {\n\tconst data = await _request({ ...options, ...globalRequestOptions });\n\treturn data as T;\n}\n","import type { PartialMeltQuoteResponse } from '../model/types/index';\nimport { MeltQuoteState } from '../model/types/index';\nimport type { Logger } from '../logger';\n\nexport type MeltQuoteResponsePaidDeprecated = {\n\tpaid?: boolean;\n};\n\nexport function handleMeltQuoteResponseDeprecated(\n\tresponse: PartialMeltQuoteResponse & MeltQuoteResponsePaidDeprecated,\n\tlogger: Logger,\n): PartialMeltQuoteResponse {\n\t// if the response MeltQuoteResponse has a \"paid\" flag, we monkey patch it to the state enum\n\tif (!response.state) {\n\t\tlogger.warn(\n\t\t\t\"Field 'state' not found in MeltQuoteResponse. Update NUT-05 of mint: https://github.com/cashubtc/nuts/pull/136)\",\n\t\t);\n\t\tif (typeof response.paid === 'boolean') {\n\t\t\tresponse.state = response.paid ? MeltQuoteState.PAID : MeltQuoteState.UNPAID;\n\t\t}\n\t}\n\treturn response;\n}\n","import type { PartialMintQuoteResponse } from '../model/types/index';\nimport { MintQuoteState } from '../model/types/index';\nimport type { Logger } from '../logger';\n\nexport type MintQuoteResponsePaidDeprecated = {\n\tpaid?: boolean;\n};\n\nexport function handleMintQuoteResponseDeprecated(\n\tresponse: PartialMintQuoteResponse & MintQuoteResponsePaidDeprecated,\n\tlogger: Logger,\n): PartialMintQuoteResponse {\n\t// if the response MeltQuoteResponse has a \"paid\" flag, we monkey patch it to the state enum\n\tif (!response.state) {\n\t\tlogger.warn(\n\t\t\t\"Field 'state' not found in MintQuoteResponse. Update NUT-04 of mint: https://github.com/cashubtc/nuts/pull/141)\",\n\t\t);\n\t\tif (typeof response.paid === 'boolean') {\n\t\t\tresponse.state = response.paid ? MintQuoteState.PAID : MintQuoteState.UNPAID;\n\t\t}\n\t}\n\treturn response;\n}\n","import type { MintContactInfo, GetInfoResponse } from '../model/types/index';\nimport type { Logger } from '../logger';\n\nexport function handleMintInfoContactFieldDeprecated(data: GetInfoResponse, logger: Logger) {\n\t// Monkey patch old contact field [\"email\", \"me@mail.com\"] Array<[string, string]>; to new contact field [{method: \"email\", info: \"me@mail.com\"}] Array<MintContactInfo>\n\t// This is to maintain backwards compatibility with older versions of the mint\n\tif (Array.isArray(data?.contact) && data?.contact.length > 0) {\n\t\tdata.contact = data.contact.map((contact: MintContactInfo) => {\n\t\t\tif (\n\t\t\t\tArray.isArray(contact) &&\n\t\t\t\tcontact.length === 2 &&\n\t\t\t\ttypeof contact[0] === 'string' &&\n\t\t\t\ttypeof contact[1] === 'string'\n\t\t\t) {\n\t\t\t\tlogger.warn(\n\t\t\t\t\t`Mint returned deprecated 'contact' field: Update NUT-06: https://github.com/cashubtc/nuts/pull/117`,\n\t\t\t\t);\n\t\t\t\treturn { method: contact[0], info: contact[1] } as MintContactInfo;\n\t\t\t}\n\t\t\treturn contact;\n\t\t});\n\t}\n\treturn data;\n}\n","import {\n\ttype GetInfoResponse,\n\ttype MPPMethod,\n\ttype SwapMethod,\n\ttype WebSocketSupport,\n} from './types';\n\nexport class MintInfo {\n\tprivate readonly _mintInfo: GetInfoResponse;\n\tprivate readonly _protectedEnpoints?: {\n\t\tcache: {\n\t\t\t[url: string]: boolean;\n\t\t};\n\t\tapiReturn: Array<{ method: 'GET' | 'POST'; regex: RegExp; cachedValue?: boolean }>;\n\t};\n\n\tconstructor(info: GetInfoResponse) {\n\t\tthis._mintInfo = info;\n\t\tif (info.nuts[22]) {\n\t\t\tthis._protectedEnpoints = {\n\t\t\t\tcache: {},\n\t\t\t\tapiReturn: info.nuts[22].protected_endpoints.map((o) => ({\n\t\t\t\t\tmethod: o.method,\n\t\t\t\t\tregex: new RegExp(o.path),\n\t\t\t\t})),\n\t\t\t};\n\t\t}\n\t}\n\n\tisSupported(num: 4 | 5): { disabled: boolean; params: SwapMethod[] };\n\tisSupported(num: 7 | 8 | 9 | 10 | 11 | 12 | 14 | 20): { supported: boolean };\n\tisSupported(num: 17): { supported: boolean; params?: WebSocketSupport[] };\n\tisSupported(num: 15): { supported: boolean; params?: MPPMethod[] };\n\tisSupported(num: number) {\n\t\tswitch (num) {\n\t\t\tcase 4:\n\t\t\tcase 5: {\n\t\t\t\treturn this.checkMintMelt(num);\n\t\t\t}\n\t\t\tcase 7:\n\t\t\tcase 8:\n\t\t\tcase 9:\n\t\t\tcase 10:\n\t\t\tcase 11:\n\t\t\tcase 12:\n\t\t\tcase 14:\n\t\t\tcase 20: {\n\t\t\t\treturn this.checkGenericNut(num);\n\t\t\t}\n\t\t\tcase 17: {\n\t\t\t\treturn this.checkNut17();\n\t\t\t}\n\t\t\tcase 15: {\n\t\t\t\treturn this.checkNut15();\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\tthrow new Error('nut is not supported by cashu-ts');\n\t\t\t}\n\t\t}\n\t}\n\n\trequiresBlindAuthToken(path: string) {\n\t\tif (!this._protectedEnpoints) {\n\t\t\treturn false;\n\t\t}\n\t\tif (typeof this._protectedEnpoints.cache[path] === 'boolean') {\n\t\t\treturn this._protectedEnpoints.cache[path];\n\t\t}\n\t\tconst isProtectedEndpoint = this._protectedEnpoints.apiReturn.some((e) => e.regex.test(path));\n\t\tthis._protectedEnpoints.cache[path] = isProtectedEndpoint;\n\t\treturn isProtectedEndpoint;\n\t}\n\n\tprivate checkGenericNut(num: 7 | 8 | 9 | 10 | 11 | 12 | 14 | 20) {\n\t\tif (this._mintInfo.nuts[num]?.supported) {\n\t\t\treturn { supported: true };\n\t\t}\n\t\treturn { supported: false };\n\t}\n\tprivate checkMintMelt(num: 4 | 5) {\n\t\tconst mintMeltInfo = this._mintInfo.nuts[num];\n\t\tif (mintMeltInfo && mintMeltInfo.methods.length > 0 && !mintMeltInfo.disabled) {\n\t\t\treturn { disabled: false, params: mintMeltInfo.methods };\n\t\t}\n\t\treturn { disabled: true, params: mintMeltInfo.methods };\n\t}\n\tprivate checkNut17() {\n\t\tif (this._mintInfo.nuts[17] && this._mintInfo.nuts[17].supported.length > 0) {\n\t\t\treturn { supported: true, params: this._mintInfo.nuts[17].supported };\n\t\t}\n\t\treturn { supported: false };\n\t}\n\tprivate checkNut15() {\n\t\tif (this._mintInfo.nuts[15] && this._mintInfo.nuts[15].methods.length > 0) {\n\t\t\treturn { supported: true, params: this._mintInfo.nuts[15].methods };\n\t\t}\n\t\treturn { supported: false };\n\t}\n\n\tget contact() {\n\t\treturn this._mintInfo.contact;\n\t}\n\n\tget description() {\n\t\treturn this._mintInfo.description;\n\t}\n\n\tget description_long() {\n\t\treturn this._mintInfo.description_long;\n\t}\n\n\tget name() {\n\t\treturn this._mintInfo.name;\n\t}\n\n\tget pubkey() {\n\t\treturn this._mintInfo.pubkey;\n\t}\n\n\tget nuts() {\n\t\treturn this._mintInfo.nuts;\n\t}\n\n\tget version() {\n\t\treturn this._mintInfo.version;\n\t}\n\n\tget motd() {\n\t\treturn this._mintInfo.motd;\n\t}\n\n\t/**\n\t * Checks if the mint supports creating BOLT12 offers with a description.\n\t *\n\t * @returns True if the mint supports offers with a description, false otherwise.\n\t */\n\tget supportsBolt12Description() {\n\t\treturn this._mintInfo.nuts[4]?.methods.some(\n\t\t\t(method) => method.method === 'bolt12' && method.options?.description === true,\n\t\t);\n\t}\n}\n","import { ConnectionManager, type WSConnection } from './WSConnection';\nimport type {\n\tCheckStatePayload,\n\tCheckStateResponse,\n\tGetInfoResponse,\n\tMeltPayload,\n\tMintActiveKeys,\n\tMintAllKeysets,\n\tPostRestoreResponse,\n\tSerializedBlindedMessage,\n\tSwapPayload,\n\tSwapResponse,\n\tMintQuotePayload,\n\tMintPayload,\n\tMintResponse,\n\tPostRestorePayload,\n\tMeltQuotePayload,\n\tMeltQuoteResponse,\n\tPartialMintQuoteResponse,\n\tPartialMeltQuoteResponse,\n\tBolt12MintQuotePayload,\n\tBolt12MintQuoteResponse,\n\tBolt12MeltQuoteResponse,\n} from './model/types/index';\nimport { MeltQuoteState } from './model/types/index';\nimport request, { setRequestLogger } from './request';\nimport { isObj, joinUrls, sanitizeUrl } from './utils';\nimport {\n\ttype MeltQuoteResponsePaidDeprecated,\n\thandleMeltQuoteResponseDeprecated,\n} from './legacy/nut-05';\nimport {\n\ttype MintQuoteResponsePaidDeprecated,\n\thandleMintQuoteResponseDeprecated,\n} from './legacy/nut-04';\nimport { handleMintInfoContactFieldDeprecated } from './legacy/nut-06';\nimport { MintInfo } from './model/MintInfo';\nimport { type Logger, NULL_LOGGER } from './logger';\n\n/**\n * Class represents Cashu Mint API. This class contains Lower level functions that are implemented\n * by CashuWallet.\n */\nclass CashuMint {\n\tprivate ws?: WSConnection;\n\tprivate _mintInfo?: MintInfo;\n\tprivate _authTokenGetter?: () => Promise<string>;\n\tprivate _checkNut22 = false;\n\tprivate _logger: Logger;\n\t/**\n\t * @param _mintUrl Requires mint URL to create this object.\n\t * @param _customRequest If passed, use custom request implementation for network communication\n\t *   with the mint.\n\t * @param [authTokenGetter] A function that is called by the CashuMint instance to obtain a NUT-22\n\t *   BlindedAuthToken (e.g. from a database or localstorage)\n\t */\n\tconstructor(\n\t\tprivate _mintUrl: string,\n\t\tprivate _customRequest?: typeof request,\n\t\tauthTokenGetter?: () => Promise<string>,\n\t\toptions?: {\n\t\t\tlogger?: Logger;\n\t\t},\n\t) {\n\t\tthis._mintUrl = sanitizeUrl(_mintUrl);\n\t\tthis._customRequest = _customRequest;\n\t\tif (authTokenGetter) {\n\t\t\tthis._checkNut22 = true;\n\t\t\tthis._authTokenGetter = authTokenGetter;\n\t\t}\n\t\tthis._logger = options?.logger ?? NULL_LOGGER;\n\t\tsetRequestLogger(this._logger);\n\t}\n\n\t//TODO: v3 - refactor CashuMint to take two or less args.\n\n\tget mintUrl() {\n\t\treturn this._mintUrl;\n\t}\n\n\t/**\n\t * Fetches mints info at the /info endpoint.\n\t *\n\t * @param mintUrl\n\t * @param customRequest\n\t */\n\tpublic static async getInfo(\n\t\tmintUrl: string,\n\t\tcustomRequest?: typeof request,\n\t\tlogger?: Logger,\n\t): Promise<GetInfoResponse> {\n\t\tconst mintLogger = logger ?? NULL_LOGGER;\n\t\tconst requestInstance = customRequest || request;\n\t\tconst response = await requestInstance<GetInfoResponse>({\n\t\t\tendpoint: joinUrls(mintUrl, '/v1/info'),\n\t\t});\n\t\tconst data = handleMintInfoContactFieldDeprecated(response, mintLogger);\n\t\treturn data;\n\t}\n\t/**\n\t * Fetches mints info at the /info endpoint.\n\t */\n\tasync getInfo(): Promise<GetInfoResponse> {\n\t\treturn CashuMint.getInfo(this._mintUrl, this._customRequest, this._logger);\n\t}\n\n\tasync getLazyMintInfo(): Promise<MintInfo> {\n\t\tif (this._mintInfo) {\n\t\t\treturn this._mintInfo;\n\t\t}\n\t\tconst data = await CashuMint.getInfo(this._mintUrl, this._customRequest);\n\t\tthis._mintInfo = new MintInfo(data);\n\t\treturn this._mintInfo;\n\t}\n\n\t/**\n\t * Performs a swap operation with ecash inputs and outputs.\n\t *\n\t * @param mintUrl\n\t * @param swapPayload Payload containing inputs and outputs.\n\t * @param customRequest\n\t * @returns Signed outputs.\n\t */\n\tpublic static async swap(\n\t\tmintUrl: string,\n\t\tswapPayload: SwapPayload,\n\t\tcustomRequest?: typeof request,\n\t\tblindAuthToken?: string,\n\t): Promise<SwapResponse> {\n\t\tconst requestInstance = customRequest || request;\n\t\tconst headers: Record<string, string> = blindAuthToken ? { 'Blind-auth': blindAuthToken } : {};\n\t\tconst data = await requestInstance<SwapResponse>({\n\t\t\tendpoint: joinUrls(mintUrl, '/v1/swap'),\n\t\t\tmethod: 'POST',\n\t\t\trequestBody: swapPayload,\n\t\t\theaders,\n\t\t});\n\n\t\tif (!isObj(data) || !Array.isArray(data?.signatures)) {\n\t\t\tthrow new Error(data.detail ?? 'bad response');\n\t\t}\n\n\t\treturn data;\n\t}\n\t/**\n\t * Performs a swap operation with ecash inputs and outputs.\n\t *\n\t * @param swapPayload Payload containing inputs and outputs.\n\t * @returns Signed outputs.\n\t */\n\tasync swap(swapPayload: SwapPayload): Promise<SwapResponse> {\n\t\tconst blindAuthToken = await this.handleBlindAuth('/v1/swap');\n\t\treturn CashuMint.swap(this._mintUrl, swapPayload, this._customRequest, blindAuthToken);\n\t}\n\n\t/**\n\t * Requests a new mint quote from the mint.\n\t *\n\t * @param mintUrl\n\t * @param mintQuotePayload Payload for creating a new mint quote.\n\t * @param customRequest\n\t * @returns The mint will create and return a new mint quote containing a payment request for the\n\t *   specified amount and unit.\n\t */\n\tpublic static async createMintQuote(\n\t\tmintUrl: string,\n\t\tmintQuotePayload: MintQuotePayload,\n\t\tcustomRequest?: typeof request,\n\t\tblindAuthToken?: string,\n\t\tlogger?: Logger,\n\t): Promise<PartialMintQuoteResponse> {\n\t\tconst mintLogger = logger ?? NULL_LOGGER;\n\t\tconst requestInstance = customRequest || request;\n\t\tconst headers: Record<string, string> = blindAuthToken ? { 'Blind-auth': blindAuthToken } : {};\n\t\tconst response = await requestInstance<\n\t\t\tPartialMintQuoteResponse & MintQuoteResponsePaidDeprecated\n\t\t>({\n\t\t\tendpoint: joinUrls(mintUrl, '/v1/mint/quote/bolt11'),\n\t\t\tmethod: 'POST',\n\t\t\trequestBody: mintQuotePayload,\n\t\t\theaders,\n\t\t});\n\t\tconst data = handleMintQuoteResponseDeprecated(response, mintLogger);\n\t\treturn data;\n\t}\n\t/**\n\t * Requests a new mint quote from the mint.\n\t *\n\t * @param mintQuotePayload Payload for creating a new mint quote.\n\t * @returns The mint will create and return a new mint quote containing a payment request for the\n\t *   specified amount and unit.\n\t */\n\tasync createMintQuote(mintQuotePayload: MintQuotePayload): Promise<PartialMintQuoteResponse> {\n\t\tconst blindAuthToken = await this.handleBlindAuth('/v1/mint/quote/bolt11');\n\t\treturn CashuMint.createMintQuote(\n\t\t\tthis._mintUrl,\n\t\t\tmintQuotePayload,\n\t\t\tthis._customRequest,\n\t\t\tblindAuthToken,\n\t\t);\n\t}\n\n\t/**\n\t * Requests a new BOLT12 mint quote from the mint using Lightning Network offers.\n\t *\n\t * @param mintUrl The mint's base URL.\n\t * @param mintQuotePayload Payload containing amount, unit, optional description, and required\n\t *   pubkey.\n\t * @param customRequest Optional custom request implementation.\n\t * @param blindAuthToken Optional authentication token for NUT-22.\n\t * @returns A mint quote containing a BOLT12 offer.\n\t */\n\tpublic static async createMintQuoteBolt12(\n\t\tmintUrl: string,\n\t\tmintQuotePayload: Bolt12MintQuotePayload,\n\t\tcustomRequest?: typeof request,\n\t\tblindAuthToken?: string,\n\t): Promise<Bolt12MintQuoteResponse> {\n\t\tconst requestInstance = customRequest || request;\n\t\tconst headers: Record<string, string> = blindAuthToken ? { 'Blind-auth': blindAuthToken } : {};\n\t\tconst response = await requestInstance<Bolt12MintQuoteResponse>({\n\t\t\tendpoint: joinUrls(mintUrl, '/v1/mint/quote/bolt12'),\n\t\t\tmethod: 'POST',\n\t\t\trequestBody: mintQuotePayload,\n\t\t\theaders,\n\t\t});\n\t\treturn response;\n\t}\n\n\t/**\n\t * Requests a new BOLT12 mint quote from the mint using Lightning Network offers.\n\t *\n\t * @param mintQuotePayload Payload containing amount, unit, optional description, and required\n\t *   pubkey.\n\t * @returns A mint quote containing a BOLT12 offer.\n\t */\n\tasync createMintQuoteBolt12(\n\t\tmintQuotePayload: Bolt12MintQuotePayload,\n\t): Promise<Bolt12MintQuoteResponse> {\n\t\tconst blindAuthToken = await this.handleBlindAuth('/v1/mint/quote/bolt12');\n\t\treturn CashuMint.createMintQuoteBolt12(\n\t\t\tthis._mintUrl,\n\t\t\tmintQuotePayload,\n\t\t\tthis._customRequest,\n\t\t\tblindAuthToken,\n\t\t);\n\t}\n\n\t/**\n\t * Gets an existing mint quote from the mint.\n\t *\n\t * @param mintUrl\n\t * @param quote Quote ID.\n\t * @param customRequest\n\t * @returns The mint will create and return a Lightning invoice for the specified amount.\n\t */\n\tpublic static async checkMintQuote(\n\t\tmintUrl: string,\n\t\tquote: string,\n\t\tcustomRequest?: typeof request,\n\t\tblindAuthToken?: string,\n\t\tlogger?: Logger,\n\t): Promise<PartialMintQuoteResponse> {\n\t\tconst mintLogger = logger ?? NULL_LOGGER;\n\t\tconst requestInstance = customRequest || request;\n\t\tconst headers: Record<string, string> = blindAuthToken ? { 'Blind-auth': blindAuthToken } : {};\n\t\tconst response = await requestInstance<\n\t\t\tPartialMintQuoteResponse & MintQuoteResponsePaidDeprecated\n\t\t>({\n\t\t\tendpoint: joinUrls(mintUrl, '/v1/mint/quote/bolt11', quote),\n\t\t\tmethod: 'GET',\n\t\t\theaders,\n\t\t});\n\n\t\tconst data = handleMintQuoteResponseDeprecated(response, mintLogger);\n\t\treturn data;\n\t}\n\t/**\n\t * Gets an existing mint quote from the mint.\n\t *\n\t * @param quote Quote ID.\n\t * @returns The mint will create and return a Lightning invoice for the specified amount.\n\t */\n\tasync checkMintQuote(quote: string): Promise<PartialMintQuoteResponse> {\n\t\tconst blindAuthToken = await this.handleBlindAuth(`/v1/mint/quote/bolt11/${quote}`);\n\t\treturn CashuMint.checkMintQuote(this._mintUrl, quote, this._customRequest, blindAuthToken);\n\t}\n\n\t/**\n\t * Gets an existing BOLT12 mint quote from the mint.\n\t *\n\t * @param mintUrl The mint's base URL.\n\t * @param quote Quote ID to check.\n\t * @param customRequest Optional custom request implementation.\n\t * @param blindAuthToken Optional authentication token for NUT-22.\n\t * @returns Updated quote with current payment and issuance amounts.\n\t */\n\tpublic static async checkMintQuoteBolt12(\n\t\tmintUrl: string,\n\t\tquote: string,\n\t\tcustomRequest?: typeof request,\n\t\tblindAuthToken?: string,\n\t): Promise<Bolt12MintQuoteResponse> {\n\t\tconst requestInstance = customRequest || request;\n\t\tconst headers: Record<string, string> = blindAuthToken ? { 'Blind-auth': blindAuthToken } : {};\n\t\tconst response = await requestInstance<Bolt12MintQuoteResponse>({\n\t\t\tendpoint: joinUrls(mintUrl, '/v1/mint/quote/bolt12', quote),\n\t\t\tmethod: 'GET',\n\t\t\theaders,\n\t\t});\n\t\treturn response;\n\t}\n\n\t/**\n\t * Gets an existing BOLT12 mint quote from the mint.\n\t *\n\t * @param quote Quote ID to check.\n\t * @returns Updated quote with current payment and issuance amounts.\n\t */\n\tasync checkMintQuoteBolt12(quote: string): Promise<Bolt12MintQuoteResponse> {\n\t\tconst blindAuthToken = await this.handleBlindAuth(`/v1/mint/quote/bolt12/${quote}`);\n\t\treturn CashuMint.checkMintQuoteBolt12(\n\t\t\tthis._mintUrl,\n\t\t\tquote,\n\t\t\tthis._customRequest,\n\t\t\tblindAuthToken,\n\t\t);\n\t}\n\n\t/**\n\t * Mints new tokens by requesting blind signatures on the provided outputs.\n\t *\n\t * @param mintUrl\n\t * @param mintPayload Payload containing the outputs to get blind signatures on.\n\t * @param customRequest\n\t * @returns Serialized blinded signatures.\n\t */\n\tpublic static async mint(\n\t\tmintUrl: string,\n\t\tmintPayload: MintPayload,\n\t\tcustomRequest?: typeof request,\n\t\tblindAuthToken?: string,\n\t) {\n\t\tconst requestInstance = customRequest || request;\n\t\tconst headers: Record<string, string> = blindAuthToken ? { 'Blind-auth': blindAuthToken } : {};\n\t\tconst data = await requestInstance<MintResponse>({\n\t\t\tendpoint: joinUrls(mintUrl, '/v1/mint/bolt11'),\n\t\t\tmethod: 'POST',\n\t\t\trequestBody: mintPayload,\n\t\t\theaders,\n\t\t});\n\n\t\tif (!isObj(data) || !Array.isArray(data?.signatures)) {\n\t\t\tthrow new Error('bad response');\n\t\t}\n\n\t\treturn data;\n\t}\n\t/**\n\t * Mints new tokens by requesting blind signatures on the provided outputs.\n\t *\n\t * @param mintPayload Payload containing the outputs to get blind signatures on.\n\t * @returns Serialized blinded signatures.\n\t */\n\tasync mint(mintPayload: MintPayload) {\n\t\tconst blindAuthToken = await this.handleBlindAuth('/v1/mint/bolt11');\n\t\treturn CashuMint.mint(this._mintUrl, mintPayload, this._customRequest, blindAuthToken);\n\t}\n\n\t/**\n\t * Mints new tokens using a BOLT12 quote by requesting blind signatures on the provided outputs.\n\t *\n\t * @param mintUrl The mint's base URL.\n\t * @param mintPayload Payload containing the quote ID and outputs to get blind signatures on.\n\t * @param customRequest Optional custom request implementation.\n\t * @param blindAuthToken Optional authentication token for NUT-22.\n\t * @returns Serialized blinded signatures for the requested outputs.\n\t */\n\tpublic static async mintBolt12(\n\t\tmintUrl: string,\n\t\tmintPayload: MintPayload,\n\t\tcustomRequest?: typeof request,\n\t\tblindAuthToken?: string,\n\t): Promise<MintResponse> {\n\t\tconst requestInstance = customRequest || request;\n\t\tconst headers: Record<string, string> = blindAuthToken ? { 'Blind-auth': blindAuthToken } : {};\n\t\tconst data = await requestInstance<MintResponse>({\n\t\t\tendpoint: joinUrls(mintUrl, '/v1/mint/bolt12'),\n\t\t\tmethod: 'POST',\n\t\t\trequestBody: mintPayload,\n\t\t\theaders,\n\t\t});\n\n\t\tif (!isObj(data) || !Array.isArray(data?.signatures)) {\n\t\t\tthrow new Error('bad response');\n\t\t}\n\n\t\treturn data;\n\t}\n\n\t/**\n\t * Mints new tokens using a BOLT12 quote by requesting blind signatures on the provided outputs.\n\t *\n\t * @param mintPayload Payload containing the quote ID and outputs to get blind signatures on.\n\t * @returns Serialized blinded signatures for the requested outputs.\n\t */\n\tasync mintBolt12(mintPayload: MintPayload): Promise<MintResponse> {\n\t\tconst blindAuthToken = await this.handleBlindAuth('/v1/mint/bolt12');\n\t\treturn CashuMint.mintBolt12(this._mintUrl, mintPayload, this._customRequest, blindAuthToken);\n\t}\n\n\t/**\n\t * Requests a new melt quote from the mint.\n\t *\n\t * @param mintUrl\n\t * @param MeltQuotePayload\n\t * @returns\n\t */\n\tpublic static async createMeltQuote(\n\t\tmintUrl: string,\n\t\tmeltQuotePayload: MeltQuotePayload,\n\t\tcustomRequest?: typeof request,\n\t\tblindAuthToken?: string,\n\t\tlogger?: Logger,\n\t): Promise<PartialMeltQuoteResponse> {\n\t\tconst mintLogger = logger ?? NULL_LOGGER;\n\t\tconst requestInstance = customRequest || request;\n\t\tconst headers: Record<string, string> = blindAuthToken ? { 'Blind-auth': blindAuthToken } : {};\n\t\tconst response = await requestInstance<\n\t\t\tPartialMeltQuoteResponse & MeltQuoteResponsePaidDeprecated\n\t\t>({\n\t\t\tendpoint: joinUrls(mintUrl, '/v1/melt/quote/bolt11'),\n\t\t\tmethod: 'POST',\n\t\t\trequestBody: meltQuotePayload,\n\t\t\theaders,\n\t\t});\n\n\t\tconst data = handleMeltQuoteResponseDeprecated(response, mintLogger);\n\n\t\tif (\n\t\t\t!isObj(data) ||\n\t\t\ttypeof data?.amount !== 'number' ||\n\t\t\ttypeof data?.fee_reserve !== 'number' ||\n\t\t\ttypeof data?.quote !== 'string'\n\t\t) {\n\t\t\tthrow new Error('bad response');\n\t\t}\n\t\treturn data;\n\t}\n\n\t/**\n\t * Requests a new melt quote from the mint.\n\t *\n\t * @param MeltQuotePayload\n\t * @returns\n\t */\n\tasync createMeltQuote(meltQuotePayload: MeltQuotePayload): Promise<PartialMeltQuoteResponse> {\n\t\tconst blindAuthToken = await this.handleBlindAuth('/v1/melt/quote/bolt11');\n\t\treturn CashuMint.createMeltQuote(\n\t\t\tthis._mintUrl,\n\t\t\tmeltQuotePayload,\n\t\t\tthis._customRequest,\n\t\t\tblindAuthToken,\n\t\t);\n\t}\n\n\t/**\n\t * Requests a new BOLT12 melt quote from the mint for paying a Lightning Network offer. For\n\t * amount-less offers, specify the amount in options.amountless.amount_msat.\n\t *\n\t * @param mintUrl The mint's base URL.\n\t * @param meltQuotePayload Payload containing the BOLT12 offer to pay and unit.\n\t * @param customRequest Optional custom request implementation.\n\t * @param blindAuthToken Optional authentication token for NUT-22.\n\t * @returns Melt quote with amount, fee reserve, and payment state.\n\t */\n\tpublic static async createMeltQuoteBolt12(\n\t\tmintUrl: string,\n\t\tmeltQuotePayload: MeltQuotePayload,\n\t\tcustomRequest?: typeof request,\n\t\tblindAuthToken?: string,\n\t): Promise<Bolt12MeltQuoteResponse> {\n\t\tconst requestInstance = customRequest || request;\n\t\tconst headers: Record<string, string> = blindAuthToken ? { 'Blind-auth': blindAuthToken } : {};\n\t\tconst response = await requestInstance<Bolt12MeltQuoteResponse>({\n\t\t\tendpoint: joinUrls(mintUrl, '/v1/melt/quote/bolt12'),\n\t\t\tmethod: 'POST',\n\t\t\trequestBody: meltQuotePayload,\n\t\t\theaders,\n\t\t});\n\t\treturn response;\n\t}\n\n\t/**\n\t * Requests a new BOLT12 melt quote from the mint for paying a Lightning Network offer. For\n\t * amount-less offers, specify the amount in options.amountless.amount_msat.\n\t *\n\t * @param meltQuotePayload Payload containing the BOLT12 offer to pay and unit.\n\t * @returns Melt quote with amount, fee reserve, and payment state.\n\t */\n\tasync createMeltQuoteBolt12(\n\t\tmeltQuotePayload: MeltQuotePayload,\n\t): Promise<Bolt12MeltQuoteResponse> {\n\t\tconst blindAuthToken = await this.handleBlindAuth('/v1/melt/quote/bolt12');\n\t\treturn CashuMint.createMeltQuoteBolt12(\n\t\t\tthis._mintUrl,\n\t\t\tmeltQuotePayload,\n\t\t\tthis._customRequest,\n\t\t\tblindAuthToken,\n\t\t);\n\t}\n\n\t/**\n\t * Gets an existing melt quote.\n\t *\n\t * @param mintUrl\n\t * @param quote Quote ID.\n\t * @returns\n\t */\n\tpublic static async checkMeltQuote(\n\t\tmintUrl: string,\n\t\tquote: string,\n\t\tcustomRequest?: typeof request,\n\t\tblindAuthToken?: string,\n\t\tlogger?: Logger,\n\t): Promise<PartialMeltQuoteResponse> {\n\t\tconst mintLogger = logger ?? NULL_LOGGER;\n\t\tconst requestInstance = customRequest || request;\n\t\tconst headers: Record<string, string> = blindAuthToken ? { 'Blind-auth': blindAuthToken } : {};\n\t\tconst response = await requestInstance<MeltQuoteResponse & MeltQuoteResponsePaidDeprecated>({\n\t\t\tendpoint: joinUrls(mintUrl, '/v1/melt/quote/bolt11', quote),\n\t\t\tmethod: 'GET',\n\t\t\theaders,\n\t\t});\n\n\t\tconst data = handleMeltQuoteResponseDeprecated(response, mintLogger);\n\n\t\tif (\n\t\t\t!isObj(data) ||\n\t\t\ttypeof data?.amount !== 'number' ||\n\t\t\ttypeof data?.fee_reserve !== 'number' ||\n\t\t\ttypeof data?.quote !== 'string' ||\n\t\t\ttypeof data?.state !== 'string' ||\n\t\t\t!Object.values(MeltQuoteState).includes(data.state)\n\t\t) {\n\t\t\tthrow new Error('bad response');\n\t\t}\n\n\t\treturn data;\n\t}\n\t/**\n\t * Gets an existing melt quote.\n\t *\n\t * @param quote Quote ID.\n\t * @returns\n\t */\n\tasync checkMeltQuote(quote: string): Promise<PartialMeltQuoteResponse> {\n\t\tconst blindAuthToken = await this.handleBlindAuth(`/v1/melt/quote/bolt11/${quote}`);\n\t\treturn CashuMint.checkMeltQuote(this._mintUrl, quote, this._customRequest, blindAuthToken);\n\t}\n\n\t/**\n\t * Gets an existing BOLT12 melt quote from the mint. Returns current payment state (UNPAID,\n\t * PENDING, or PAID) and payment preimage if paid.\n\t *\n\t * @param mintUrl The mint's base URL.\n\t * @param quote Quote ID to check.\n\t * @param customRequest Optional custom request implementation.\n\t * @param blindAuthToken Optional authentication token for NUT-22.\n\t * @returns Updated quote with current payment state and preimage if available.\n\t */\n\tpublic static async checkMeltQuoteBolt12(\n\t\tmintUrl: string,\n\t\tquote: string,\n\t\tcustomRequest?: typeof request,\n\t\tblindAuthToken?: string,\n\t): Promise<Bolt12MeltQuoteResponse> {\n\t\tconst requestInstance = customRequest || request;\n\t\tconst headers: Record<string, string> = blindAuthToken ? { 'Blind-auth': blindAuthToken } : {};\n\t\tconst response = await requestInstance<Bolt12MeltQuoteResponse>({\n\t\t\tendpoint: joinUrls(mintUrl, '/v1/melt/quote/bolt12', quote),\n\t\t\tmethod: 'GET',\n\t\t\theaders,\n\t\t});\n\t\treturn response;\n\t}\n\n\t/**\n\t * Gets an existing BOLT12 melt quote from the mint. Returns current payment state (UNPAID,\n\t * PENDING, or PAID) and payment preimage if paid.\n\t *\n\t * @param quote Quote ID to check.\n\t * @returns Updated quote with current payment state and preimage if available.\n\t */\n\tasync checkMeltQuoteBolt12(quote: string): Promise<Bolt12MeltQuoteResponse> {\n\t\tconst blindAuthToken = await this.handleBlindAuth(`/v1/melt/quote/bolt12/${quote}`);\n\t\treturn CashuMint.checkMeltQuoteBolt12(\n\t\t\tthis._mintUrl,\n\t\t\tquote,\n\t\t\tthis._customRequest,\n\t\t\tblindAuthToken,\n\t\t);\n\t}\n\n\t/**\n\t * Requests the mint to pay for a Bolt11 payment request by providing ecash as inputs to be spent.\n\t * The inputs contain the amount and the fee_reserves for a Lightning payment. The payload can\n\t * also contain blank outputs in order to receive back overpaid Lightning fees.\n\t *\n\t * @param mintUrl\n\t * @param meltPayload\n\t * @param customRequest\n\t * @returns\n\t */\n\tpublic static async melt(\n\t\tmintUrl: string,\n\t\tmeltPayload: MeltPayload,\n\t\tcustomRequest?: typeof request,\n\t\tblindAuthToken?: string,\n\t\tlogger?: Logger,\n\t): Promise<PartialMeltQuoteResponse> {\n\t\tconst mintLogger = logger ?? NULL_LOGGER;\n\t\tconst requestInstance = customRequest || request;\n\t\tconst headers: Record<string, string> = blindAuthToken ? { 'Blind-auth': blindAuthToken } : {};\n\t\tconst response = await requestInstance<MeltQuoteResponse & MeltQuoteResponsePaidDeprecated>({\n\t\t\tendpoint: joinUrls(mintUrl, '/v1/melt/bolt11'),\n\t\t\tmethod: 'POST',\n\t\t\trequestBody: meltPayload,\n\t\t\theaders,\n\t\t});\n\n\t\tconst data = handleMeltQuoteResponseDeprecated(response, mintLogger);\n\n\t\tif (\n\t\t\t!isObj(data) ||\n\t\t\ttypeof data?.state !== 'string' ||\n\t\t\t!Object.values(MeltQuoteState).includes(data.state)\n\t\t) {\n\t\t\tthrow new Error('bad response');\n\t\t}\n\n\t\treturn data;\n\t}\n\t/**\n\t * Ask mint to perform a melt operation. This pays a lightning invoice and destroys tokens\n\t * matching its amount + fees.\n\t *\n\t * @param meltPayload\n\t * @returns\n\t */\n\tasync melt(meltPayload: MeltPayload): Promise<PartialMeltQuoteResponse> {\n\t\tconst blindAuthToken = await this.handleBlindAuth('/v1/melt/bolt11');\n\t\treturn CashuMint.melt(this._mintUrl, meltPayload, this._customRequest, blindAuthToken);\n\t}\n\n\t/**\n\t * Requests the mint to pay a BOLT12 offer by providing ecash inputs to be spent. The inputs must\n\t * cover the amount plus fee reserves. Optional outputs can be included to receive change for\n\t * overpaid Lightning fees.\n\t *\n\t * @param mintUrl The mint's base URL.\n\t * @param meltPayload Payload containing quote ID, inputs, and optional outputs for change.\n\t * @param customRequest Optional custom request implementation.\n\t * @param blindAuthToken Optional authentication token for NUT-22.\n\t * @returns Payment result with state and optional change signatures.\n\t */\n\tpublic static async meltBolt12(\n\t\tmintUrl: string,\n\t\tmeltPayload: MeltPayload,\n\t\tcustomRequest?: typeof request,\n\t\tblindAuthToken?: string,\n\t): Promise<Bolt12MeltQuoteResponse> {\n\t\tconst requestInstance = customRequest || request;\n\t\tconst headers: Record<string, string> = blindAuthToken ? { 'Blind-auth': blindAuthToken } : {};\n\t\tconst data = await requestInstance<Bolt12MeltQuoteResponse>({\n\t\t\tendpoint: joinUrls(mintUrl, '/v1/melt/bolt12'),\n\t\t\tmethod: 'POST',\n\t\t\trequestBody: meltPayload,\n\t\t\theaders,\n\t\t});\n\t\treturn data;\n\t}\n\n\t/**\n\t * Requests the mint to pay a BOLT12 offer by providing ecash inputs to be spent. The inputs must\n\t * cover the amount plus fee reserves. Optional outputs can be included to receive change for\n\t * overpaid Lightning fees.\n\t *\n\t * @param meltPayload Payload containing quote ID, inputs, and optional outputs for change.\n\t * @returns Payment result with state and optional change signatures.\n\t */\n\tasync meltBolt12(meltPayload: MeltPayload): Promise<Bolt12MeltQuoteResponse> {\n\t\tconst blindAuthToken = await this.handleBlindAuth('/v1/melt/bolt12');\n\t\treturn CashuMint.meltBolt12(this._mintUrl, meltPayload, this._customRequest, blindAuthToken);\n\t}\n\n\t/**\n\t * Checks if specific proofs have already been redeemed.\n\t *\n\t * @param mintUrl\n\t * @param checkPayload\n\t * @param customRequest\n\t * @returns Redeemed and unredeemed ordered list of booleans.\n\t */\n\tpublic static async check(\n\t\tmintUrl: string,\n\t\tcheckPayload: CheckStatePayload,\n\t\tcustomRequest?: typeof request,\n\t): Promise<CheckStateResponse> {\n\t\tconst requestInstance = customRequest || request;\n\t\tconst data = await requestInstance<CheckStateResponse>({\n\t\t\tendpoint: joinUrls(mintUrl, '/v1/checkstate'),\n\t\t\tmethod: 'POST',\n\t\t\trequestBody: checkPayload,\n\t\t});\n\n\t\tif (!isObj(data) || !Array.isArray(data?.states)) {\n\t\t\tthrow new Error('bad response');\n\t\t}\n\n\t\treturn data;\n\t}\n\n\t/**\n\t * Get the mints public keys.\n\t *\n\t * @param mintUrl\n\t * @param keysetId Optional param to get the keys for a specific keyset. If not specified, the\n\t *   keys from all active keysets are fetched.\n\t * @param customRequest\n\t * @returns\n\t */\n\tpublic static async getKeys(\n\t\tmintUrl: string,\n\t\tkeysetId?: string,\n\t\tcustomRequest?: typeof request,\n\t): Promise<MintActiveKeys> {\n\t\t// backwards compatibility for base64 encoded keyset ids\n\t\tif (keysetId) {\n\t\t\t// make the keysetId url safe\n\t\t\tkeysetId = keysetId.replace(/\\//g, '_').replace(/\\+/g, '-');\n\t\t}\n\t\tconst requestInstance = customRequest || request;\n\t\tconst data = await requestInstance<MintActiveKeys>({\n\t\t\tendpoint: keysetId ? joinUrls(mintUrl, '/v1/keys', keysetId) : joinUrls(mintUrl, '/v1/keys'),\n\t\t});\n\n\t\tif (!isObj(data) || !Array.isArray(data.keysets)) {\n\t\t\tthrow new Error('bad response');\n\t\t}\n\n\t\treturn data;\n\t}\n\t/**\n\t * Get the mints public keys.\n\t *\n\t * @param keysetId Optional param to get the keys for a specific keyset. If not specified, the\n\t *   keys from all active keysets are fetched.\n\t * @returns The mints public keys.\n\t */\n\tasync getKeys(keysetId?: string, mintUrl?: string): Promise<MintActiveKeys> {\n\t\tconst allKeys = await CashuMint.getKeys(\n\t\t\tmintUrl || this._mintUrl,\n\t\t\tkeysetId,\n\t\t\tthis._customRequest,\n\t\t);\n\t\treturn allKeys;\n\t}\n\t/**\n\t * Get the mints keysets in no specific order.\n\t *\n\t * @param mintUrl\n\t * @param customRequest\n\t * @returns All the mints past and current keysets.\n\t */\n\tpublic static async getKeySets(\n\t\tmintUrl: string,\n\t\tcustomRequest?: typeof request,\n\t): Promise<MintAllKeysets> {\n\t\tconst requestInstance = customRequest || request;\n\t\treturn requestInstance<MintAllKeysets>({ endpoint: joinUrls(mintUrl, '/v1/keysets') });\n\t}\n\n\t/**\n\t * Get the mints keysets in no specific order.\n\t *\n\t * @returns All the mints past and current keysets.\n\t */\n\tasync getKeySets(): Promise<MintAllKeysets> {\n\t\treturn CashuMint.getKeySets(this._mintUrl, this._customRequest);\n\t}\n\n\t/**\n\t * Checks if specific proofs have already been redeemed.\n\t *\n\t * @param checkPayload\n\t * @returns Redeemed and unredeemed ordered list of booleans.\n\t */\n\tasync check(checkPayload: CheckStatePayload): Promise<CheckStateResponse> {\n\t\treturn CashuMint.check(this._mintUrl, checkPayload, this._customRequest);\n\t}\n\n\tpublic static async restore(\n\t\tmintUrl: string,\n\t\trestorePayload: PostRestorePayload,\n\t\tcustomRequest?: typeof request,\n\t): Promise<PostRestoreResponse> {\n\t\tconst requestInstance = customRequest || request;\n\t\tconst data = await requestInstance<PostRestoreResponse>({\n\t\t\tendpoint: joinUrls(mintUrl, '/v1/restore'),\n\t\t\tmethod: 'POST',\n\t\t\trequestBody: restorePayload,\n\t\t});\n\n\t\tif (!isObj(data) || !Array.isArray(data?.outputs) || !Array.isArray(data?.signatures)) {\n\t\t\tthrow new Error('bad response');\n\t\t}\n\n\t\treturn data;\n\t}\n\n\tasync restore(restorePayload: {\n\t\toutputs: SerializedBlindedMessage[];\n\t}): Promise<PostRestoreResponse> {\n\t\treturn CashuMint.restore(this._mintUrl, restorePayload, this._customRequest);\n\t}\n\n\t/**\n\t * Tries to establish a websocket connection with the websocket mint url according to NUT-17.\n\t */\n\tasync connectWebSocket() {\n\t\tif (this.ws) {\n\t\t\tawait this.ws.ensureConnection();\n\t\t} else {\n\t\t\tconst mintUrl = new URL(this._mintUrl);\n\t\t\tconst wsSegment = 'v1/ws';\n\t\t\tif (mintUrl.pathname) {\n\t\t\t\tif (mintUrl.pathname.endsWith('/')) {\n\t\t\t\t\tmintUrl.pathname += wsSegment;\n\t\t\t\t} else {\n\t\t\t\t\tmintUrl.pathname += '/' + wsSegment;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.ws = ConnectionManager.getInstance().getConnection(\n\t\t\t\t`${mintUrl.protocol === 'https:' ? 'wss' : 'ws'}://${mintUrl.host}${mintUrl.pathname}`,\n\t\t\t);\n\t\t\ttry {\n\t\t\t\tawait this.ws.connect();\n\t\t\t} catch (e) {\n\t\t\t\tthis._logger.error('Failed to connect to WebSocket...', { e });\n\t\t\t\tthrow new Error('Failed to connect to WebSocket...');\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Closes a websocket connection.\n\t */\n\tdisconnectWebSocket() {\n\t\tif (this.ws) {\n\t\t\tthis.ws.close();\n\t\t}\n\t}\n\n\tget webSocketConnection() {\n\t\treturn this.ws;\n\t}\n\n\tasync handleBlindAuth(path: string) {\n\t\tif (!this._checkNut22) {\n\t\t\treturn;\n\t\t}\n\t\tconst info = await this.getLazyMintInfo();\n\t\tif (info.requiresBlindAuthToken(path)) {\n\t\t\tif (!this._authTokenGetter) {\n\t\t\t\tthrow new Error('Can not call a protected endpoint without authProofGetter');\n\t\t\t}\n\t\t\treturn this._authTokenGetter();\n\t\t}\n\t\treturn undefined;\n\t}\n}\n\nexport { CashuMint };\n","import { type SerializedBlindedMessage } from './types/index';\nimport { type WeierstrassPoint } from '@noble/curves/abstract/weierstrass.js';\n\nclass BlindedMessage {\n\tamount: number;\n\tB_: WeierstrassPoint<bigint>;\n\tid: string;\n\tconstructor(amount: number, B_: WeierstrassPoint<bigint>, id: string) {\n\t\tthis.amount = amount;\n\t\tthis.B_ = B_;\n\t\tthis.id = id;\n\t}\n\tgetSerializedBlindedMessage(): SerializedBlindedMessage {\n\t\treturn { amount: this.amount, B_: this.B_.toHex(true), id: this.id };\n\t}\n}\nexport { BlindedMessage };\n","import {\n\ttype MintKeys,\n\ttype Proof,\n\ttype SerializedBlindedMessage,\n\ttype SerializedBlindedSignature,\n\ttype SerializedDLEQ,\n} from './types';\nimport { blindMessage, constructProofFromPromise, serializeProof } from '../crypto/client/index';\nimport { BlindedMessage } from './BlindedMessage';\nimport { bytesToHex, hexToBytes, randomBytes } from '@noble/hashes/utils.js';\nimport { type DLEQ, pointFromHex } from '../crypto/common/index';\nimport { bytesToNumber, numberToHexPadded64, splitAmount } from '../utils';\nimport { deriveBlindingFactor, deriveSecret } from '../crypto/client/NUT09';\n\nexport interface OutputDataLike {\n\tblindedMessage: SerializedBlindedMessage;\n\tblindingFactor: bigint;\n\tsecret: Uint8Array;\n\n\ttoProof: (signature: SerializedBlindedSignature, keyset: MintKeys) => Proof;\n}\n\nexport type OutputDataFactory = (amount: number, keys: MintKeys) => OutputDataLike;\n\nexport function isOutputDataFactory(\n\tvalue: OutputData[] | OutputDataFactory,\n): value is OutputDataFactory {\n\treturn typeof value === 'function';\n}\n\nconst RESERVED_P2PK_TAGS = new Set(['locktime', 'pubkeys', 'n_sigs', 'refund', 'n_sigs_refund']);\nconst MAX_SECRET_LENGTH = 1024;\n\nexport class OutputData implements OutputDataLike {\n\tblindedMessage: SerializedBlindedMessage;\n\tblindingFactor: bigint;\n\tsecret: Uint8Array;\n\n\tconstructor(blindedMessage: SerializedBlindedMessage, blidingFactor: bigint, secret: Uint8Array) {\n\t\tthis.secret = secret;\n\t\tthis.blindingFactor = blidingFactor;\n\t\tthis.blindedMessage = blindedMessage;\n\t}\n\n\ttoProof(sig: SerializedBlindedSignature, keyset: MintKeys) {\n\t\tlet dleq: DLEQ | undefined;\n\t\tif (sig.dleq) {\n\t\t\tdleq = {\n\t\t\t\ts: hexToBytes(sig.dleq.s),\n\t\t\t\te: hexToBytes(sig.dleq.e),\n\t\t\t\tr: this.blindingFactor,\n\t\t\t};\n\t\t}\n\t\tconst blindSignature = {\n\t\t\tid: sig.id,\n\t\t\tamount: sig.amount,\n\t\t\tC_: pointFromHex(sig.C_),\n\t\t\tdleq: dleq,\n\t\t};\n\t\tconst A = pointFromHex(keyset.keys[sig.amount]);\n\t\tconst proof = constructProofFromPromise(blindSignature, this.blindingFactor, this.secret, A);\n\t\tconst serializedProof = {\n\t\t\t...serializeProof(proof),\n\t\t\t...(dleq && {\n\t\t\t\tdleq: {\n\t\t\t\t\ts: bytesToHex(dleq.s),\n\t\t\t\t\te: bytesToHex(dleq.e),\n\t\t\t\t\tr: numberToHexPadded64(dleq.r ?? BigInt(0)),\n\t\t\t\t} as SerializedDLEQ,\n\t\t\t}),\n\t\t} as Proof;\n\t\treturn serializedProof;\n\t}\n\n\tstatic createP2PKData(\n\t\tp2pk: {\n\t\t\tpubkey: string | string[];\n\t\t\tlocktime?: number;\n\t\t\trefundKeys?: string[];\n\t\t\trequiredSignatures?: number;\n\t\t\trequiredRefundSignatures?: number;\n\t\t\tadditionalTags?: Array<[key: string, ...values: string[]]>;\n\t\t},\n\t\tamount: number,\n\t\tkeyset: MintKeys,\n\t\tcustomSplit?: number[],\n\t) {\n\t\tconst amounts = splitAmount(amount, keyset.keys, customSplit);\n\t\treturn amounts.map((a) => this.createSingleP2PKData(p2pk, a, keyset.id));\n\t}\n\n\tstatic createSingleP2PKData(\n\t\tp2pk: {\n\t\t\tpubkey: string | string[];\n\t\t\tlocktime?: number;\n\t\t\trefundKeys?: string[];\n\t\t\trequiredSignatures?: number;\n\t\t\trequiredRefundSignatures?: number;\n\t\t\tadditionalTags?: Array<[key: string, ...values: string[]]>;\n\t\t},\n\t\tamount: number,\n\t\tkeysetId: string,\n\t) {\n\t\t// normalise keys and clamp required signature counts to available keys\n\t\tconst lockKeys: string[] = Array.isArray(p2pk.pubkey) ? p2pk.pubkey : [p2pk.pubkey];\n\t\tconst refundKeys: string[] = p2pk.refundKeys ?? [];\n\t\tconst reqLock = Math.max(1, Math.min(p2pk.requiredSignatures ?? 1, lockKeys.length));\n\t\tconst reqRefund = Math.max(\n\t\t\t1,\n\t\t\tMath.min(p2pk.requiredRefundSignatures ?? 1, refundKeys.length || 1),\n\t\t);\n\n\t\t// Init vars\n\t\tconst data = lockKeys[0];\n\t\tconst pubkeys = lockKeys.slice(1);\n\t\tconst refund = refundKeys;\n\n\t\t// build P2PK Tags (NUT-11)\n\t\tconst tags: string[][] = [];\n\n\t\tconst ts = p2pk.locktime ?? NaN;\n\t\tif (Number.isSafeInteger(ts) && ts >= 0) {\n\t\t\ttags.push(['locktime', String(ts)]);\n\t\t}\n\n\t\tif (pubkeys.length > 0) {\n\t\t\ttags.push(['pubkeys', ...pubkeys]);\n\t\t\tif (reqLock > 1) {\n\t\t\t\ttags.push(['n_sigs', String(reqLock)]);\n\t\t\t}\n\t\t}\n\n\t\tif (refund.length > 0) {\n\t\t\ttags.push(['refund', ...refund]);\n\t\t\tif (reqRefund > 1) {\n\t\t\t\ttags.push(['n_sigs_refund', String(reqRefund)]);\n\t\t\t}\n\t\t}\n\n\t\t// Append additional tags if any\n\t\tif (p2pk.additionalTags?.length) {\n\t\t\tconst normalized = p2pk.additionalTags.map(([k, ...vals], i) => {\n\t\t\t\tif (typeof k !== 'string' || !k) {\n\t\t\t\t\tthrow new Error(`additionalTags[${i}][0] must be a non empty string`);\n\t\t\t\t}\n\t\t\t\tif (RESERVED_P2PK_TAGS.has(k)) {\n\t\t\t\t\tthrow new Error(`additionalTags must not use reserved key \"${k}\"`);\n\t\t\t\t}\n\t\t\t\treturn [k, ...vals.map(String)]; // all to strings\n\t\t\t});\n\t\t\ttags.push(...normalized);\n\t\t}\n\n\t\t// Construct secret\n\t\tconst newSecret: [string, { nonce: string; data: string; tags: string[][] }] = [\n\t\t\t'P2PK',\n\t\t\t{\n\t\t\t\tnonce: bytesToHex(randomBytes(32)),\n\t\t\t\tdata: data,\n\t\t\t\ttags,\n\t\t\t},\n\t\t];\n\t\tconst parsed = JSON.stringify(newSecret);\n\n\t\t// Check secret length, counting Unicode code points\n\t\t// Same semantics as Nutshell python: len(str)\n\t\tconst charCount = [...parsed].length;\n\t\tif (charCount > MAX_SECRET_LENGTH) {\n\t\t\tthrow new Error(`Secret too long (${charCount} characters), maximum is ${MAX_SECRET_LENGTH}`);\n\t\t}\n\t\t// blind the message\n\t\tconst secretBytes = new TextEncoder().encode(parsed);\n\t\tconst { r, B_ } = blindMessage(secretBytes);\n\n\t\t// create OutputData\n\t\treturn new OutputData(\n\t\t\tnew BlindedMessage(amount, B_, keysetId).getSerializedBlindedMessage(),\n\t\t\tr,\n\t\t\tsecretBytes,\n\t\t);\n\t}\n\n\tstatic createRandomData(amount: number, keyset: MintKeys, customSplit?: number[]) {\n\t\tconst amounts = splitAmount(amount, keyset.keys, customSplit);\n\t\treturn amounts.map((a) => this.createSingleRandomData(a, keyset.id));\n\t}\n\n\tstatic createSingleRandomData(amount: number, keysetId: string) {\n\t\tconst randomHex = bytesToHex(randomBytes(32));\n\t\tconst secretBytes = new TextEncoder().encode(randomHex);\n\t\tconst { r, B_ } = blindMessage(secretBytes);\n\t\treturn new OutputData(\n\t\t\tnew BlindedMessage(amount, B_, keysetId).getSerializedBlindedMessage(),\n\t\t\tr,\n\t\t\tsecretBytes,\n\t\t);\n\t}\n\n\tstatic createDeterministicData(\n\t\tamount: number,\n\t\tseed: Uint8Array,\n\t\tcounter: number,\n\t\tkeyset: MintKeys,\n\t\tcustomSplit?: number[],\n\t): OutputData[] {\n\t\tconst amounts = splitAmount(amount, keyset.keys, customSplit);\n\t\treturn amounts.map((a, i) =>\n\t\t\tthis.createSingleDeterministicData(a, seed, counter + i, keyset.id),\n\t\t);\n\t}\n\n\tstatic createSingleDeterministicData(\n\t\tamount: number,\n\t\tseed: Uint8Array,\n\t\tcounter: number,\n\t\tkeysetId: string,\n\t) {\n\t\tconst secretBytes = deriveSecret(seed, keysetId, counter);\n\t\tconst secretBytesAsHex = bytesToHex(secretBytes);\n\t\tconst utf8SecretBytes = new TextEncoder().encode(secretBytesAsHex);\n\t\tconst deterministicR = bytesToNumber(deriveBlindingFactor(seed, keysetId, counter));\n\t\tconst { r, B_ } = blindMessage(utf8SecretBytes, deterministicR);\n\t\treturn new OutputData(\n\t\t\tnew BlindedMessage(amount, B_, keysetId).getSerializedBlindedMessage(),\n\t\t\tr,\n\t\t\tutf8SecretBytes,\n\t\t);\n\t}\n}\n","import { signP2PKProofs } from './crypto/client/NUT11';\nimport { hashToCurve } from './crypto/common/index';\nimport { type CashuMint } from './CashuMint';\nimport { MintInfo } from './model/MintInfo';\nimport { type Logger, NULL_LOGGER, measureTime } from './logger';\nimport type {\n\tGetInfoResponse,\n\tMeltProofOptions,\n\tMintProofOptions,\n\tMintQuoteResponse,\n\tOutputAmounts,\n\tProofState,\n\tReceiveOptions,\n\tRestoreOptions,\n\tSendOptions,\n\tSerializedBlindedSignature,\n\tSwapOptions,\n\tMeltPayload,\n\tMeltProofsResponse,\n\tMeltQuotePayload,\n\tMeltQuoteResponse,\n\tMintKeys,\n\tMintKeyset,\n\tMintPayload,\n\tMintQuotePayload,\n\tProof,\n\tSendResponse,\n\tToken,\n\tMPPOption,\n\tMeltQuoteOptions,\n\tSwapTransaction,\n\tLockedMintQuoteResponse,\n\tPartialMintQuoteResponse,\n\tPartialMeltQuoteResponse,\n\tBolt12MintQuotePayload,\n\tBolt12MintQuoteResponse,\n\tBolt12MeltQuoteResponse,\n} from './model/types/index';\nimport { MintQuoteState, MeltQuoteState } from './model/types/index';\nimport { type SubscriptionCanceller } from './model/types/wallet/websocket';\nimport {\n\tgetDecodedToken,\n\tgetKeepAmounts,\n\thasValidDleq,\n\tisValidHex,\n\tsplitAmount,\n\tstripDleq,\n\tsumProofs,\n\tverifyKeysetId,\n} from './utils';\nimport { signMintQuote } from './crypto/client/NUT20';\nimport {\n\tOutputData,\n\ttype OutputDataFactory,\n\ttype OutputDataLike,\n\tisOutputDataFactory,\n} from './model/OutputData';\n\n/**\n * The default number of proofs per denomination to keep in a wallet.\n */\nconst DEFAULT_DENOMINATION_TARGET = 3;\n\n/**\n * The default unit for the wallet, if not specified in constructor.\n */\nconst DEFAULT_UNIT = 'sat';\n\n/**\n * Class that represents a Cashu wallet. This class should act as the entry point for this library.\n */\nclass CashuWallet {\n\tprivate _keys: Map<string, MintKeys> = new Map();\n\tprivate _keysetId: string | undefined;\n\tprivate _keysets: MintKeyset[] = [];\n\tprivate _seed: Uint8Array | undefined = undefined;\n\tprivate _unit = DEFAULT_UNIT;\n\tprivate _mintInfo: MintInfo | undefined = undefined;\n\tprivate _denominationTarget = DEFAULT_DENOMINATION_TARGET;\n\tprivate _keepFactory: OutputDataFactory | undefined;\n\tprivate _logger: Logger;\n\n\tmint: CashuMint;\n\n\t/**\n\t * @param mint Cashu mint instance is used to make api calls.\n\t * @param options.unit Optionally set unit (default is 'sat')\n\t * @param options.keys Public keys from the mint (will be fetched from mint if not provided)\n\t * @param options.keysets Keysets from the mint (will be fetched from mint if not provided)\n\t * @param options.mintInfo Mint info from the mint (will be fetched from mint if not provided)\n\t * @param options.denominationTarget Target number proofs per denomination (default: see @constant\n\t *   DEFAULT_DENOMINATION_TARGET)\n\t * @param options.bip39seed BIP39 seed for deterministic secrets.\n\t * @param options.keepFactory A function that will be used by all parts of the library that\n\t *   produce proofs to be kept (change, etc.). This can lead to poor performance, in which case\n\t *   the seed should be directly provided.\n\t */\n\tconstructor(\n\t\tmint: CashuMint,\n\t\toptions?: {\n\t\t\tunit?: string;\n\t\t\tkeys?: MintKeys[] | MintKeys;\n\t\t\tkeysets?: MintKeyset[];\n\t\t\tmintInfo?: GetInfoResponse;\n\t\t\tbip39seed?: Uint8Array;\n\t\t\tdenominationTarget?: number;\n\t\t\tkeepFactory?: OutputDataFactory;\n\t\t\tlogger?: Logger;\n\t\t},\n\t) {\n\t\tthis.mint = mint;\n\t\tthis._logger = options?.logger ?? NULL_LOGGER;\n\n\t\t// When we decide to stop v2 support we should push the warming to console.\n\t\t// Inform consumers that there is a new v3 and they should upgrade.\n\t\t// Keep this log lightweight and safe to run in browser and node environments\n\t\t// if (typeof console !== 'undefined' && typeof console.warn === 'function') {\n\t\t// \tconsole.warn(\n\t\t// \t\t'cashu-ts v3 has been released. Please upgrade to access the latest features. v2 is now in minimal maintenance mode.',\n\t\t// \t);\n\t\t// }\n\t\tthis._logger.warn(\n\t\t\t'cashu-ts v3 has been released. Please upgrade to access the latest features. v2 is now in minimal maintenance mode.',\n\t\t);\n\t\tlet keys: MintKeys[] = [];\n\t\tif (options?.keys && !Array.isArray(options.keys)) {\n\t\t\tkeys = [options.keys];\n\t\t} else if (options?.keys && Array.isArray(options?.keys)) {\n\t\t\tkeys = options?.keys;\n\t\t}\n\t\tif (keys) keys.forEach((key: MintKeys) => this._keys.set(key.id, key));\n\t\tif (options?.unit) this._unit = options?.unit;\n\t\tif (options?.keysets) this._keysets = options.keysets;\n\t\tif (options?.mintInfo) this._mintInfo = new MintInfo(options.mintInfo);\n\t\tif (options?.denominationTarget) {\n\t\t\tthis._denominationTarget = options.denominationTarget;\n\t\t}\n\n\t\tif (options?.bip39seed) {\n\t\t\tif (options.bip39seed instanceof Uint8Array) {\n\t\t\t\tthis._seed = options.bip39seed;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthrow new Error('bip39seed must be a valid UInt8Array');\n\t\t}\n\t\tif (options?.keepFactory) {\n\t\t\tthis._keepFactory = options.keepFactory;\n\t\t}\n\t}\n\n\tget unit(): string {\n\t\treturn this._unit;\n\t}\n\tget keys(): Map<string, MintKeys> {\n\t\treturn this._keys;\n\t}\n\tget keysetId(): string {\n\t\tif (!this._keysetId) {\n\t\t\tthrow new Error('No keysetId set');\n\t\t}\n\t\treturn this._keysetId;\n\t}\n\tset keysetId(keysetId: string) {\n\t\tthis._keysetId = keysetId;\n\t}\n\tget keysets(): MintKeyset[] {\n\t\treturn this._keysets;\n\t}\n\tget mintInfo(): MintInfo {\n\t\tif (!this._mintInfo) {\n\t\t\tthrow new Error('Mint info not loaded');\n\t\t}\n\t\treturn this._mintInfo;\n\t}\n\n\t/**\n\t * Get information about the mint.\n\t *\n\t * @returns Mint info.\n\t */\n\tasync getMintInfo(): Promise<MintInfo> {\n\t\tconst infoRes = await this.mint.getInfo();\n\t\tthis._mintInfo = new MintInfo(infoRes);\n\t\treturn this._mintInfo;\n\t}\n\n\t/**\n\t * Get stored information about the mint or request it if not loaded.\n\t *\n\t * @returns Mint info.\n\t */\n\tasync lazyGetMintInfo(): Promise<MintInfo> {\n\t\tif (!this._mintInfo) {\n\t\t\treturn await this.getMintInfo();\n\t\t}\n\t\treturn this._mintInfo;\n\t}\n\n\t/**\n\t * Load mint information, keysets and keys. This function can be called if no keysets are passed\n\t * in the constructor.\n\t */\n\tasync loadMint() {\n\t\tawait Promise.all([\n\t\t\tthis.getMintInfo(),\n\t\t\tthis.getKeys(), // NB: also runs getKeySets()\n\t\t]);\n\t}\n\n\t/**\n\t * Choose a keyset to activate based on the lowest input fee.\n\t *\n\t * Note: this function will filter out deprecated base64 keysets.\n\t *\n\t * @param keysets Keysets to choose from.\n\t * @returns Active keyset.\n\t */\n\tgetActiveKeyset(keysets: MintKeyset[]): MintKeyset {\n\t\tlet activeKeysets = keysets.filter((k: MintKeyset) => k.active && k.unit === this._unit);\n\n\t\t// Only consider keysets that are hex\n\t\tactiveKeysets = activeKeysets.filter((k: MintKeyset) => isValidHex(k.id));\n\n\t\tconst activeKeyset = activeKeysets.sort(\n\t\t\t(a: MintKeyset, b: MintKeyset) => (a.input_fee_ppk ?? 0) - (b.input_fee_ppk ?? 0),\n\t\t)[0];\n\t\tif (!activeKeyset) {\n\t\t\tthrow new Error('No active keyset found');\n\t\t}\n\t\treturn activeKeyset;\n\t}\n\n\t/**\n\t * Get keysets from the mint with the unit of the wallet.\n\t *\n\t * @returns Keysets with wallet's unit.\n\t */\n\tasync getKeySets(): Promise<MintKeyset[]> {\n\t\tconst allKeysets = await this.mint.getKeySets();\n\t\tconst unitKeysets = allKeysets.keysets.filter((k: MintKeyset) => k.unit === this._unit);\n\t\tthis._keysets = unitKeysets;\n\t\treturn this._keysets;\n\t}\n\n\t/**\n\t * Get all active keys from the mint and set the keyset with the lowest fees as the active wallet\n\t * keyset.\n\t *\n\t * @returns Keyset.\n\t */\n\tasync getAllKeys(): Promise<MintKeys[]> {\n\t\tconst keysets = await this.mint.getKeys();\n\t\tkeysets.keysets.forEach((k) => {\n\t\t\tif (!verifyKeysetId(k)) {\n\t\t\t\tthrow new Error(`Couldn't verify keyset ID ${k.id}`);\n\t\t\t}\n\t\t});\n\t\tthis._keys = new Map(keysets.keysets.map((k: MintKeys) => [k.id, k]));\n\t\tthis.keysetId = this.getActiveKeyset(this._keysets).id;\n\t\treturn keysets.keysets;\n\t}\n\n\t/**\n\t * Get public keys from the mint. If keys were already fetched, it will return those.\n\t *\n\t * If `keysetId` is set, it will fetch and return that specific keyset. Otherwise, we select an\n\t * active keyset with the unit of the wallet.\n\t *\n\t * @param keysetId Optional keysetId to get keys for.\n\t * @param forceRefresh? If set to true, it will force refresh the keyset from the mint.\n\t * @returns Keyset.\n\t */\n\tasync getKeys(keysetId?: string, forceRefresh?: boolean): Promise<MintKeys> {\n\t\tif (!(this._keysets.length > 0) || forceRefresh) {\n\t\t\tawait this.getKeySets();\n\t\t}\n\t\t// no keyset id is chosen, let's choose one\n\t\tif (!keysetId) {\n\t\t\tconst localKeyset = this.getActiveKeyset(this._keysets);\n\t\t\tkeysetId = localKeyset.id;\n\t\t}\n\t\t// make sure we have keyset for this id\n\t\tif (!this._keysets.find((k: MintKeyset) => k.id === keysetId)) {\n\t\t\tawait this.getKeySets();\n\t\t\tif (!this._keysets.find((k: MintKeyset) => k.id === keysetId)) {\n\t\t\t\tthrow new Error(`could not initialize keys. No keyset with id '${keysetId}' found`);\n\t\t\t}\n\t\t}\n\n\t\t// make sure we have keys for this id\n\t\tif (!this._keys.get(keysetId)) {\n\t\t\tconst keys = await this.mint.getKeys(keysetId);\n\t\t\tif (!verifyKeysetId(keys.keysets[0])) {\n\t\t\t\tthrow new Error(`Couldn't verify keyset ID ${keys.keysets[0].id}`);\n\t\t\t}\n\t\t\tthis._keys.set(keysetId, keys.keysets[0]);\n\t\t}\n\n\t\t// set and return\n\t\tthis.keysetId = keysetId;\n\t\treturn this._keys.get(keysetId) as MintKeys;\n\t}\n\n\t/**\n\t * Asserts amount is a positive integer.\n\t *\n\t * @param amount To check.\n\t * @param op Caller method name (or other identifier) for debug.\n\t * @throws If not.\n\t */\n\tprivate assertAmount(amount: unknown, op: string): asserts amount is number {\n\t\tif (typeof amount !== 'number' || !Number.isInteger(amount) || amount <= 0) {\n\t\t\tthrow new Error(`Amount must be a positive integer, method: ${op}`);\n\t\t}\n\t}\n\n\t/**\n\t * Receive an encoded or raw Cashu token (only supports single tokens. It will only process the\n\t * first token in the token array)\n\t *\n\t * @param {string | Token} token - Cashu token, either as string or decoded.\n\t * @param {ReceiveOptions} [options] - Optional configuration for token processing.\n\t * @returns New token with newly created proofs, token entries that had errors.\n\t */\n\tasync receive(token: string | Token, options?: ReceiveOptions): Promise<Proof[]> {\n\t\tconst { requireDleq, keysetId, outputAmounts, counter, pubkey, privkey, outputData, p2pk } =\n\t\t\toptions || {};\n\n\t\t// Fetch the keysets if we don't have them\n\t\tif (this._keysets.length === 0) {\n\t\t\tawait this.getKeySets();\n\t\t}\n\t\tif (typeof token === 'string') {\n\t\t\ttoken = getDecodedToken(token, this._keysets);\n\t\t}\n\t\tconst keys = await this.getKeys(keysetId);\n\t\tif (requireDleq) {\n\t\t\tif (token.proofs.some((p: Proof) => !hasValidDleq(p, keys))) {\n\t\t\t\tthrow new Error('Token contains proofs with invalid DLEQ');\n\t\t\t}\n\t\t}\n\t\tconst amount = sumProofs(token.proofs) - this.getFeesForProofs(token.proofs);\n\t\tlet newOutputData: { send: OutputDataLike[] | OutputDataFactory } | undefined = undefined;\n\t\tif (outputData) {\n\t\t\tnewOutputData = { send: outputData };\n\t\t} else if (this._keepFactory) {\n\t\t\tnewOutputData = { send: this._keepFactory };\n\t\t}\n\t\tconst swapTransaction = this.createSwapPayload(\n\t\t\tamount,\n\t\t\ttoken.proofs,\n\t\t\tkeys,\n\t\t\toutputAmounts,\n\t\t\tcounter,\n\t\t\tpubkey,\n\t\t\tprivkey,\n\t\t\tnewOutputData,\n\t\t\tp2pk,\n\t\t);\n\t\tconst { signatures } = await this.mint.swap(swapTransaction.payload);\n\t\tconst proofs = swapTransaction.outputData.map((d, i) => d.toProof(signatures[i], keys));\n\t\tconst orderedProofs: Proof[] = [];\n\t\tswapTransaction.sortedIndices.forEach((s, o) => {\n\t\t\torderedProofs[s] = proofs[o];\n\t\t});\n\t\treturn orderedProofs;\n\t}\n\n\t/**\n\t * Send proofs of a given amount, by providing at least the required amount of proofs.\n\t *\n\t * @param amount Amount to send.\n\t * @param proofs Array of proofs (accumulated amount of proofs must be >= than amount)\n\t * @param {SendOptions} [options] - Optional parameters for configuring the send operation.\n\t * @returns {SendResponse}\n\t */\n\tasync send(amount: number, proofs: Proof[], options?: SendOptions): Promise<SendResponse> {\n\t\tconst {\n\t\t\toffline,\n\t\t\tincludeFees,\n\t\t\tincludeDleq,\n\t\t\tkeysetId,\n\t\t\toutputAmounts,\n\t\t\tpubkey,\n\t\t\tprivkey,\n\t\t\toutputData,\n\t\t} = options || {};\n\t\tthis.assertAmount(amount, 'send');\n\t\tif (includeDleq) {\n\t\t\tproofs = proofs.filter((p: Proof) => p.dleq != undefined);\n\t\t}\n\t\tif (sumProofs(proofs) < amount) {\n\t\t\tthrow new Error('Not enough funds available to send');\n\t\t}\n\t\tconst { keep: keepProofsOffline, send: sendProofOffline } = this.selectProofsToSend(\n\t\t\tproofs,\n\t\t\tamount,\n\t\t\toptions?.includeFees,\n\t\t);\n\t\tconst expectedFee = includeFees ? this.getFeesForProofs(sendProofOffline) : 0;\n\t\tif (\n\t\t\t!offline &&\n\t\t\t(sumProofs(sendProofOffline) != amount + expectedFee || // if the exact amount cannot be selected\n\t\t\t\toutputAmounts ||\n\t\t\t\tpubkey ||\n\t\t\t\tprivkey ||\n\t\t\t\tkeysetId ||\n\t\t\t\toutputData) // these options require a swap\n\t\t) {\n\t\t\tconst sendRes = await this.swap(amount, proofs, options);\n\t\t\tconst { keep, send } = sendRes;\n\t\t\tconst serialized = sendRes.serialized;\n\n\t\t\treturn { keep, send, serialized };\n\t\t}\n\n\t\tif (sumProofs(sendProofOffline) < amount + expectedFee) {\n\t\t\tthrow new Error('Not enough funds available to send');\n\t\t}\n\n\t\treturn { keep: keepProofsOffline, send: sendProofOffline };\n\t}\n\n\t/**\n\t * Selects proofs to send based on amount and fee inclusion.\n\t *\n\t * @remarks\n\t * Uses an adapted Randomized Greedy with Local Improvement (RGLI) algorithm, which has a time\n\t * complexity O(n log n) and space complexity O(n).\n\t * @param proofs Array of Proof objects available to select from.\n\t * @param amountToSend The target amount to send.\n\t * @param includeFees Optional boolean to include fees; Default: false.\n\t * @returns SendResponse containing proofs to keep and proofs to send.\n\t * @see https://crypto.ethz.ch/publications/files/Przyda02.pdf\n\t */\n\tselectProofsToSend(proofs: Proof[], amountToSend: number, includeFees = false): SendResponse {\n\t\tthis.assertAmount(amountToSend, 'selectProofsToSend');\n\t\t// Init vars\n\t\tconst MAX_TRIALS = 60; // 40-80 is optimal (per RGLI paper)\n\t\tconst MAX_OVRPCT = 0; // Acceptable close match overage (percent)\n\t\tconst MAX_OVRAMT = 0; // Acceptable close match overage (absolute)\n\t\tconst MAX_TIMEMS = 1000; // Halt new trials if over time (in ms)\n\t\tconst MAX_P2SWAP = 5000; // Max number of Phase 2 improvement swaps\n\t\tconst exactMatch = false; // Allows close match (> amountToSend + fee)\n\t\tconst timer = measureTime(); // start the clock\n\t\tlet bestSubset: ProofWithFee[] | null = null;\n\t\tlet bestDelta = Infinity;\n\t\tlet bestAmount = 0;\n\t\tlet bestFeePPK = 0;\n\n\t\t/**\n\t\t * Helper Functions.\n\t\t */\n\t\tinterface ProofWithFee {\n\t\t\tproof: Proof;\n\t\t\texFee: number;\n\t\t\tppkfee: number;\n\t\t}\n\t\t// Calculate net amount after fees\n\t\tconst sumExFees = (amount: number, feePPK: number): number => {\n\t\t\treturn amount - (includeFees ? Math.ceil(feePPK / 1000) : 0);\n\t\t};\n\t\t// Shuffle array for randomization\n\t\tconst shuffleArray = <T>(array: T[]): T[] => {\n\t\t\tconst shuffled = [...array];\n\t\t\tfor (let i = shuffled.length - 1; i > 0; i--) {\n\t\t\t\tconst j = Math.floor(Math.random() * (i + 1));\n\t\t\t\t[shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];\n\t\t\t}\n\t\t\treturn shuffled;\n\t\t};\n\t\t// Performs a binary search on a sorted (ascending) array of ProofWithFee objects by exFee.\n\t\t// If lessOrEqual=true, returns the rightmost index where exFee <= value\n\t\t// If lessOrEqual=false, returns the leftmost index where exFee >= value\n\t\tconst binarySearchIndex = (\n\t\t\tarr: ProofWithFee[],\n\t\t\tvalue: number,\n\t\t\tlessOrEqual: boolean,\n\t\t): number | null => {\n\t\t\tlet left = 0,\n\t\t\t\tright = arr.length - 1,\n\t\t\t\tresult: number | null = null;\n\t\t\twhile (left <= right) {\n\t\t\t\tconst mid = Math.floor((left + right) / 2);\n\t\t\t\tconst midValue = arr[mid].exFee;\n\t\t\t\tif (lessOrEqual ? midValue <= value : midValue >= value) {\n\t\t\t\t\tresult = mid;\n\t\t\t\t\tif (lessOrEqual) left = mid + 1;\n\t\t\t\t\telse right = mid - 1;\n\t\t\t\t} else {\n\t\t\t\t\tif (lessOrEqual) right = mid - 1;\n\t\t\t\t\telse left = mid + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn lessOrEqual ? result : left < arr.length ? left : null;\n\t\t};\n\t\t// Insert into array of ProofWithFee objects sorted by exFee\n\t\tconst insertSorted = (arr: ProofWithFee[], obj: ProofWithFee): void => {\n\t\t\tconst value = obj.exFee;\n\t\t\tlet left = 0,\n\t\t\t\tright = arr.length;\n\t\t\twhile (left < right) {\n\t\t\t\tconst mid = Math.floor((left + right) / 2);\n\t\t\t\tif (arr[mid].exFee < value) left = mid + 1;\n\t\t\t\telse right = mid;\n\t\t\t}\n\t\t\tarr.splice(left, 0, obj);\n\t\t};\n\t\t// \"Delta\" is the excess over amountToSend including fees\n\t\t// plus a tiebreaker to favour lower PPK keysets\n\t\t// NB: Solutions under amountToSend are invalid (delta: Infinity)\n\t\tconst calculateDelta = (amount: number, feePPK: number): number => {\n\t\t\tconst netSum = sumExFees(amount, feePPK);\n\t\t\tif (netSum < amountToSend) return Infinity; // no good\n\t\t\treturn amount + feePPK / 1000 - amountToSend;\n\t\t};\n\n\t\t/**\n\t\t * Pre-processing.\n\t\t */\n\t\tlet totalAmount = 0;\n\t\tlet totalFeePPK = 0;\n\t\tconst proofWithFees = proofs.map((p) => {\n\t\t\tconst ppkfee = this.getProofFeePPK(p);\n\t\t\tconst exFee = includeFees ? p.amount - ppkfee / 1000 : p.amount;\n\t\t\tconst obj = { proof: p, exFee, ppkfee };\n\t\t\t// Sum all economical proofs (filtered below)\n\t\t\tif (!includeFees || exFee > 0) {\n\t\t\t\ttotalAmount += p.amount;\n\t\t\t\ttotalFeePPK += ppkfee;\n\t\t\t}\n\t\t\treturn obj;\n\t\t});\n\n\t\t// Filter uneconomical proofs (totals computed above)\n\t\tlet spendableProofs = includeFees\n\t\t\t? proofWithFees.filter((obj) => obj.exFee > 0)\n\t\t\t: proofWithFees;\n\n\t\t// Sort by exFee ascending\n\t\tspendableProofs.sort((a, b) => a.exFee - b.exFee);\n\n\t\t// Remove proofs too large to be useful and adjust totals\n\t\t// Exact Match: Keep proofs where exFee <= amountToSend\n\t\t// Close Match: Keep proofs where exFee <= nextBiggerExFee\n\t\tif (spendableProofs.length > 0) {\n\t\t\tlet endIndex;\n\t\t\tif (exactMatch) {\n\t\t\t\tconst rightIndex = binarySearchIndex(spendableProofs, amountToSend, true);\n\t\t\t\tendIndex = rightIndex !== null ? rightIndex + 1 : 0;\n\t\t\t} else {\n\t\t\t\tconst biggerIndex = binarySearchIndex(spendableProofs, amountToSend, false);\n\t\t\t\tif (biggerIndex !== null) {\n\t\t\t\t\tconst nextBiggerExFee = spendableProofs[biggerIndex].exFee;\n\t\t\t\t\tconst rightIndex = binarySearchIndex(spendableProofs, nextBiggerExFee, true);\n\t\t\t\t\tif (rightIndex === null) {\n\t\t\t\t\t\tthrow new Error('Unexpected null rightIndex in binary search');\n\t\t\t\t\t}\n\t\t\t\t\tendIndex = rightIndex + 1;\n\t\t\t\t} else {\n\t\t\t\t\t// Keep all proofs if all exFee < amountToSend\n\t\t\t\t\tendIndex = spendableProofs.length;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Adjust totals for removed proofs\n\t\t\tfor (let i = endIndex; i < spendableProofs.length; i++) {\n\t\t\t\ttotalAmount -= spendableProofs[i].proof.amount;\n\t\t\t\ttotalFeePPK -= spendableProofs[i].ppkfee;\n\t\t\t}\n\t\t\tspendableProofs = spendableProofs.slice(0, endIndex);\n\t\t}\n\n\t\t// Validate using precomputed totals\n\t\tconst totalNetSum = sumExFees(totalAmount, totalFeePPK);\n\t\tif (amountToSend <= 0 || amountToSend > totalNetSum) {\n\t\t\treturn { keep: proofs, send: [] };\n\t\t}\n\n\t\t// Max acceptable amount for non-exact matches\n\t\tconst maxOverAmount = Math.min(\n\t\t\tMath.ceil(amountToSend * (1 + MAX_OVRPCT / 100)),\n\t\t\tamountToSend + MAX_OVRAMT,\n\t\t\ttotalNetSum,\n\t\t);\n\n\t\t/**\n\t\t * RGLI algorithm: Runs multiple trials (up to MAX_TRIALS) Each trial starts with randomized\n\t\t * greedy subset (S) and then tries to improve that subset to get a valid solution. NOTE: Fees\n\t\t * are dynamic, based on number of proofs (PPK), so we perform all calculations based on net\n\t\t * amounts.\n\t\t */\n\t\tfor (let trial = 0; trial < MAX_TRIALS; trial++) {\n\t\t\t// PHASE 1: Randomized Greedy Selection\n\t\t\t// Add proofs up to amountToSend (after adjusting for fees)\n\t\t\t// for exact match or the first amount over target otherwise\n\t\t\tconst S: ProofWithFee[] = [];\n\t\t\tlet amount = 0;\n\t\t\tlet feePPK = 0;\n\t\t\tfor (const obj of shuffleArray(spendableProofs)) {\n\t\t\t\tconst newAmount = amount + obj.proof.amount;\n\t\t\t\tconst newFeePPK = feePPK + obj.ppkfee;\n\t\t\t\tconst netSum = sumExFees(newAmount, newFeePPK);\n\t\t\t\tif (exactMatch && netSum > amountToSend) break;\n\t\t\t\tS.push(obj);\n\t\t\t\tamount = newAmount;\n\t\t\t\tfeePPK = newFeePPK;\n\t\t\t\tif (netSum >= amountToSend) break;\n\t\t\t}\n\n\t\t\t// PHASE 2: Local Improvement\n\t\t\t// Examine all the amounts found in the first phase, and find the\n\t\t\t// amount not in the current solution (others), which would get us\n\t\t\t// closest to the amountToSend.\n\n\t\t\t// Calculate the \"others\" array (note: spendableProofs is sorted ASC)\n\t\t\t// Using set.has() for filtering gives faster lookups: O(n+m)\n\t\t\t// Using array.includes() would be way slower: O(n*m)\n\t\t\tconst SSet = new Set(S);\n\t\t\tconst others = spendableProofs.filter((obj) => !SSet.has(obj));\n\t\t\t// Generate a random order for accessing the trial subset ('S')\n\t\t\tconst indices = shuffleArray(Array.from({ length: S.length }, (_, i) => i)).slice(\n\t\t\t\t0,\n\t\t\t\tMAX_P2SWAP,\n\t\t\t);\n\t\t\tfor (const i of indices) {\n\t\t\t\t// Exact or acceptable close match solution found?\n\t\t\t\tconst netSum = sumExFees(amount, feePPK);\n\t\t\t\tif (\n\t\t\t\t\tnetSum === amountToSend ||\n\t\t\t\t\t(!exactMatch && netSum >= amountToSend && netSum <= maxOverAmount)\n\t\t\t\t) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t// Get details for proof being replaced (objP), and temporarily\n\t\t\t\t// calculate the subset amount/fee with that proof removed.\n\t\t\t\tconst objP = S[i];\n\t\t\t\tconst tempAmount = amount - objP.proof.amount;\n\t\t\t\tconst tempFeePPK = feePPK - objP.ppkfee;\n\t\t\t\tconst tempNetSum = sumExFees(tempAmount, tempFeePPK);\n\t\t\t\tconst target = amountToSend - tempNetSum;\n\n\t\t\t\t// Find a better replacement proof (objQ) and swap it in\n\t\t\t\t// Exact match can only replace larger to close on the target\n\t\t\t\t// Close match can replace larger or smaller as needed, but will\n\t\t\t\t// not replace larger unless it closes on the target\n\t\t\t\tconst qIndex = binarySearchIndex(others, target, exactMatch);\n\t\t\t\tif (qIndex !== null) {\n\t\t\t\t\tconst objQ = others[qIndex];\n\t\t\t\t\tif (!exactMatch || objQ.exFee > objP.exFee) {\n\t\t\t\t\t\tif (target >= 0 || objQ.exFee <= objP.exFee) {\n\t\t\t\t\t\t\tS[i] = objQ;\n\t\t\t\t\t\t\tamount = tempAmount + objQ.proof.amount;\n\t\t\t\t\t\t\tfeePPK = tempFeePPK + objQ.ppkfee;\n\t\t\t\t\t\t\tothers.splice(qIndex, 1);\n\t\t\t\t\t\t\tinsertSorted(others, objP);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Update best solution\n\t\t\tconst delta = calculateDelta(amount, feePPK);\n\t\t\tif (delta < bestDelta) {\n\t\t\t\tthis._logger.debug(\n\t\t\t\t\t'selectProofsToSend: best solution found in trial #{trial} - amount: {amount}, delta: {delta}',\n\t\t\t\t\t{ trial, amount, delta },\n\t\t\t\t);\n\t\t\t\tbestSubset = [...S].sort((a, b) => b.exFee - a.exFee); // copy & sort\n\t\t\t\tbestDelta = delta;\n\t\t\t\tbestAmount = amount;\n\t\t\t\tbestFeePPK = feePPK;\n\n\t\t\t\t// \"PHASE 3\": Final check to make sure we haven't overpaid fees\n\t\t\t\t// and see if we can improve the solution. This is an adaptation\n\t\t\t\t// to the original RGLI, which helps us identify close match and\n\t\t\t\t// optimal fee solutions more consistently\n\t\t\t\tconst tempS = [...bestSubset]; // copy\n\t\t\t\twhile (tempS.length > 1 && bestDelta > 0) {\n\t\t\t\t\tconst objP = tempS.pop() as ProofWithFee;\n\t\t\t\t\tconst tempAmount = amount - objP.proof.amount;\n\t\t\t\t\tconst tempFeePPK = feePPK - objP.ppkfee;\n\t\t\t\t\tconst tempDelta = calculateDelta(tempAmount, tempFeePPK);\n\t\t\t\t\tif (tempDelta == Infinity) break;\n\t\t\t\t\tif (tempDelta < bestDelta) {\n\t\t\t\t\t\tbestSubset = [...tempS];\n\t\t\t\t\t\tbestDelta = tempDelta;\n\t\t\t\t\t\tbestAmount = tempAmount;\n\t\t\t\t\t\tbestFeePPK = tempFeePPK;\n\t\t\t\t\t\tamount = tempAmount;\n\t\t\t\t\t\tfeePPK = tempFeePPK;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Check if solution is acceptable\n\t\t\tif (bestSubset && bestDelta < Infinity) {\n\t\t\t\tconst bestSum = sumExFees(bestAmount, bestFeePPK);\n\t\t\t\tif (\n\t\t\t\t\tbestSum === amountToSend ||\n\t\t\t\t\t(!exactMatch && bestSum >= amountToSend && bestSum <= maxOverAmount)\n\t\t\t\t) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Time limit reached?\n\t\t\tif (timer.elapsed() > MAX_TIMEMS) {\n\t\t\t\tif (exactMatch) {\n\t\t\t\t\tthrow new Error('Proof selection took too long. Try again with a smaller proof set.');\n\t\t\t\t} else {\n\t\t\t\t\tthis._logger.warn('Proof selection took too long. Returning best selection so far.');\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Return Result\n\t\tif (bestSubset && bestDelta < Infinity) {\n\t\t\tconst bestProofs = bestSubset.map((obj) => obj.proof);\n\t\t\tconst bestSubsetSet = new Set(bestProofs);\n\t\t\tconst keep = proofs.filter((p) => !bestSubsetSet.has(p));\n\t\t\tthis._logger.info('Proof selection took {time}ms', { time: timer.elapsed() });\n\t\t\treturn { keep, send: bestProofs };\n\t\t}\n\t\treturn { keep: proofs, send: [] };\n\t}\n\n\t/**\n\t * Calculates the fees based on inputs (proofs)\n\t *\n\t * @param proofs Input proofs to calculate fees for.\n\t * @returns Fee amount.\n\t * @throws Throws an error if the proofs keyset is unknown.\n\t */\n\tgetFeesForProofs(proofs: Proof[]): number {\n\t\tconst sumPPK = proofs.reduce((a, c) => a + this.getProofFeePPK(c), 0);\n\t\treturn Math.ceil(sumPPK / 1000);\n\t}\n\n\t/**\n\t * Returns the current fee PPK for a proof according to the cached keyset.\n\t *\n\t * @param proof {Proof} A single proof.\n\t * @returns FeePPK {number} The feePPK for the selected proof.\n\t * @throws Throws an error if the proofs keyset is unknown.\n\t */\n\tprivate getProofFeePPK(proof: Proof) {\n\t\tconst keyset = this._keysets.find((k) => k.id === proof.id);\n\t\tif (!keyset) {\n\t\t\tthrow new Error(`Could not get fee. No keyset found for keyset id: ${proof.id}`);\n\t\t}\n\t\treturn keyset?.input_fee_ppk || 0;\n\t}\n\n\t/**\n\t * Calculates the fees based on inputs for a given keyset.\n\t *\n\t * @param nInputs Number of inputs.\n\t * @param keysetId KeysetId used to lookup `input_fee_ppk`\n\t * @returns Fee amount.\n\t */\n\tgetFeesForKeyset(nInputs: number, keysetId: string): number {\n\t\tconst fees = Math.floor(\n\t\t\tMath.max(\n\t\t\t\t(nInputs * (this._keysets.find((k: MintKeyset) => k.id === keysetId)?.input_fee_ppk || 0) +\n\t\t\t\t\t999) /\n\t\t\t\t\t1000,\n\t\t\t\t0,\n\t\t\t),\n\t\t);\n\t\treturn fees;\n\t}\n\n\t/**\n\t * Splits and creates sendable tokens if no amount is specified, the amount is implied by the\n\t * cumulative amount of all proofs if both amount and preference are set, but the preference\n\t * cannot fulfill the amount, then we use the default split.\n\t *\n\t * @param {SwapOptions} [options] - Optional parameters for configuring the swap operation.\n\t * @returns Promise of the change- and send-proofs.\n\t */\n\tasync swap(amount: number, proofs: Proof[], options?: SwapOptions): Promise<SendResponse> {\n\t\tthis.assertAmount(amount, 'swap');\n\t\tlet { outputAmounts } = options || {};\n\t\tconst { includeFees, keysetId, counter, pubkey, privkey, proofsWeHave, outputData, p2pk } =\n\t\t\toptions || {};\n\t\tconst keyset = await this.getKeys(keysetId);\n\n\t\tlet amountToSend = amount;\n\t\tconst amountAvailable = sumProofs(proofs);\n\t\t// send output selection\n\t\tlet sendAmounts = outputAmounts?.sendAmounts || splitAmount(amountToSend, keyset.keys);\n\n\t\tif (includeFees) {\n\t\t\tlet outputFee = this.getFeesForKeyset(sendAmounts.length, keyset.id);\n\t\t\tlet sendAmountsFee = splitAmount(outputFee, keyset.keys);\n\t\t\twhile (\n\t\t\t\tthis.getFeesForKeyset(sendAmounts.concat(sendAmountsFee).length, keyset.id) > outputFee\n\t\t\t) {\n\t\t\t\toutputFee++;\n\t\t\t\tsendAmountsFee = splitAmount(outputFee, keyset.keys);\n\t\t\t}\n\t\t\tsendAmounts = sendAmounts.concat(sendAmountsFee);\n\t\t\tamountToSend += outputFee;\n\t\t}\n\n\t\t// include the fees to spend the the outputs of the swap\n\t\t// input selection, needs fees because of the swap\n\t\tconst { keep: keepProofs, send: sendProofs } = this.selectProofsToSend(\n\t\t\tproofs,\n\t\t\tamountToSend,\n\t\t\ttrue, // inc. fees\n\t\t);\n\n\t\tconst amountToKeep = sumProofs(sendProofs) - this.getFeesForProofs(sendProofs) - amountToSend;\n\n\t\tif (amountToKeep < 0) {\n\t\t\tthrow new Error('Not enough balance to send');\n\t\t}\n\n\t\t// keep output selection\n\t\tlet keepAmounts;\n\t\tif (!outputAmounts?.keepAmounts && !proofsWeHave) {\n\t\t\tkeepAmounts = splitAmount(amountToKeep, keyset.keys);\n\t\t} else if (!outputAmounts?.keepAmounts && proofsWeHave) {\n\t\t\tkeepAmounts = getKeepAmounts(\n\t\t\t\tproofsWeHave,\n\t\t\t\tamountToKeep,\n\t\t\t\tkeyset.keys,\n\t\t\t\tthis._denominationTarget,\n\t\t\t);\n\t\t} else if (outputAmounts) {\n\t\t\tif (outputAmounts.keepAmounts?.reduce((a: number, b: number) => a + b, 0) != amountToKeep) {\n\t\t\t\tthrow new Error('Keep amounts do not match amount to keep');\n\t\t\t}\n\t\t\tkeepAmounts = outputAmounts.keepAmounts;\n\t\t}\n\n\t\tif (amountToSend + this.getFeesForProofs(sendProofs) > amountAvailable) {\n\t\t\tthis._logger.error(\n\t\t\t\t`Not enough funds available (${amountAvailable}) for swap amountToSend: ${amountToSend} + fee: ${this.getFeesForProofs(\n\t\t\t\t\tsendProofs,\n\t\t\t\t)} | length: ${sendProofs.length}`,\n\t\t\t);\n\t\t\tthrow new Error(`Not enough funds available for swap`);\n\t\t}\n\n\t\toutputAmounts = {\n\t\t\tkeepAmounts: keepAmounts,\n\t\t\tsendAmounts: sendAmounts,\n\t\t};\n\n\t\tconst keepOutputData = outputData?.keep || this._keepFactory;\n\t\tconst sendOutputData = outputData?.send;\n\n\t\tconst swapTransaction = this.createSwapPayload(\n\t\t\tamountToSend,\n\t\t\tsendProofs,\n\t\t\tkeyset,\n\t\t\toutputAmounts,\n\t\t\tcounter,\n\t\t\tpubkey,\n\t\t\tprivkey,\n\t\t\t{ keep: keepOutputData, send: sendOutputData },\n\t\t\tp2pk,\n\t\t);\n\t\tconst { signatures } = await this.mint.swap(swapTransaction.payload);\n\t\tconst swapProofs = swapTransaction.outputData.map((d, i) => d.toProof(signatures[i], keyset));\n\t\tconst splitProofsToKeep: Proof[] = [];\n\t\tconst splitProofsToSend: Proof[] = [];\n\t\tconst reorderedKeepVector = Array(swapTransaction.keepVector.length);\n\t\tconst reorderedProofs = Array(swapProofs.length);\n\t\tswapTransaction.sortedIndices.forEach((s, i) => {\n\t\t\treorderedKeepVector[s] = swapTransaction.keepVector[i];\n\t\t\treorderedProofs[s] = swapProofs[i];\n\t\t});\n\t\treorderedProofs.forEach((p: Proof, i) => {\n\t\t\tif (reorderedKeepVector[i]) {\n\t\t\t\tsplitProofsToKeep.push(p);\n\t\t\t} else {\n\t\t\t\tsplitProofsToSend.push(p);\n\t\t\t}\n\t\t});\n\t\treturn {\n\t\t\tkeep: [...splitProofsToKeep, ...keepProofs],\n\t\t\tsend: splitProofsToSend,\n\t\t};\n\t}\n\n\t/**\n\t * Restores batches of deterministic proofs until no more signatures are returned from the mint.\n\t *\n\t * @param [gapLimit=300] The amount of empty counters that should be returned before restoring\n\t *   ends (defaults to 300). Default is `300`\n\t * @param [batchSize=100] The amount of proofs that should be restored at a time (defaults to\n\t *   100). Default is `100`\n\t * @param [counter=0] The counter that should be used as a starting point (defaults to 0). Default\n\t *   is `0`\n\t * @param [keysetId] Which keysetId to use for the restoration. If none is passed the instance's\n\t *   default one will be used.\n\t */\n\tasync batchRestore(\n\t\tgapLimit = 300,\n\t\tbatchSize = 100,\n\t\tcounter = 0,\n\t\tkeysetId?: string,\n\t): Promise<{ proofs: Proof[]; lastCounterWithSignature?: number }> {\n\t\tconst requiredEmptyBatches = Math.ceil(gapLimit / batchSize);\n\t\tconst restoredProofs: Proof[] = [];\n\n\t\tlet lastCounterWithSignature: undefined | number;\n\t\tlet emptyBatchesFound = 0;\n\n\t\twhile (emptyBatchesFound < requiredEmptyBatches) {\n\t\t\tconst restoreRes = await this.restore(counter, batchSize, { keysetId });\n\t\t\tif (restoreRes.proofs.length > 0) {\n\t\t\t\temptyBatchesFound = 0;\n\t\t\t\trestoredProofs.push(...restoreRes.proofs);\n\t\t\t\tlastCounterWithSignature = restoreRes.lastCounterWithSignature;\n\t\t\t} else {\n\t\t\t\temptyBatchesFound++;\n\t\t\t}\n\t\t\tcounter += batchSize;\n\t\t}\n\t\treturn { proofs: restoredProofs, lastCounterWithSignature };\n\t}\n\n\t/**\n\t * Regenerates.\n\t *\n\t * @param start Set starting point for count (first cycle for each keyset should usually be 0)\n\t * @param count Set number of blinded messages that should be generated.\n\t * @param options.keysetId Set a custom keysetId to restore from. keysetIds can be loaded with\n\t *   `CashuMint.getKeySets()`\n\t */\n\tasync restore(\n\t\tstart: number,\n\t\tcount: number,\n\t\toptions?: RestoreOptions,\n\t): Promise<{ proofs: Proof[]; lastCounterWithSignature?: number }> {\n\t\tconst { keysetId } = options || {};\n\t\tconst keys = await this.getKeys(keysetId);\n\t\tif (!this._seed) {\n\t\t\tthrow new Error('CashuWallet must be initialized with a seed to use restore');\n\t\t}\n\t\t// create deterministic blank outputs for unknown restore amounts\n\t\t// Note: zero amount + zero denomination passes splitAmount validation\n\t\tconst zeros = Array(count).fill(0);\n\t\tconst outputData = OutputData.createDeterministicData(0, this._seed, start, keys, zeros);\n\n\t\tconst { outputs, signatures } = await this.mint.restore({\n\t\t\toutputs: outputData.map((d) => d.blindedMessage),\n\t\t});\n\n\t\tconst signatureMap: { [sig: string]: SerializedBlindedSignature } = {};\n\t\toutputs.forEach((o, i) => (signatureMap[o.B_] = signatures[i]));\n\n\t\tconst restoredProofs: Proof[] = [];\n\t\tlet lastCounterWithSignature: number | undefined;\n\n\t\tfor (let i = 0; i < outputData.length; i++) {\n\t\t\tconst matchingSig = signatureMap[outputData[i].blindedMessage.B_];\n\t\t\tif (matchingSig) {\n\t\t\t\tlastCounterWithSignature = start + i;\n\t\t\t\toutputData[i].blindedMessage.amount = matchingSig.amount;\n\t\t\t\trestoredProofs.push(outputData[i].toProof(matchingSig, keys));\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tproofs: restoredProofs,\n\t\t\tlastCounterWithSignature,\n\t\t};\n\t}\n\n\t/**\n\t * Requests a mint quote from the mint. Response returns a Lightning payment request for the\n\t * requested given amount and unit.\n\t *\n\t * @param amount Amount requesting for mint.\n\t * @param description Optional description for the mint quote.\n\t * @param pubkey Optional public key to lock the quote to.\n\t * @returns The mint will return a mint quote with a Lightning invoice for minting tokens of the\n\t *   specified amount and unit.\n\t */\n\tasync createMintQuote(amount: number, description?: string): Promise<MintQuoteResponse> {\n\t\tthis.assertAmount(amount, 'createMintQuote');\n\t\tconst mintQuotePayload: MintQuotePayload = {\n\t\t\tunit: this._unit,\n\t\t\tamount: amount,\n\t\t\tdescription: description,\n\t\t};\n\t\tconst res = await this.mint.createMintQuote(mintQuotePayload);\n\t\treturn { ...res, amount: res.amount || amount, unit: res.unit || this.unit };\n\t}\n\n\t/**\n\t * Requests a mint quote from the mint that is locked to a public key.\n\t *\n\t * @param amount Amount requesting for mint.\n\t * @param pubkey Public key to lock the quote to.\n\t * @param description Optional description for the mint quote.\n\t * @returns The mint will return a mint quote with a Lightning invoice for minting tokens of the\n\t *   specified amount and unit. The quote will be locked to the specified `pubkey`.\n\t */\n\tasync createLockedMintQuote(\n\t\tamount: number,\n\t\tpubkey: string,\n\t\tdescription?: string,\n\t): Promise<LockedMintQuoteResponse> {\n\t\tthis.assertAmount(amount, 'createLockedMintQuote');\n\t\tconst { supported } = (await this.lazyGetMintInfo()).isSupported(20);\n\t\tif (!supported) {\n\t\t\tthrow new Error('Mint does not support NUT-20');\n\t\t}\n\t\tconst mintQuotePayload: MintQuotePayload = {\n\t\t\tunit: this._unit,\n\t\t\tamount: amount,\n\t\t\tdescription: description,\n\t\t\tpubkey: pubkey,\n\t\t};\n\t\tconst res = await this.mint.createMintQuote(mintQuotePayload);\n\t\tif (typeof res.pubkey !== 'string') {\n\t\t\tthrow new Error('Mint returned unlocked mint quote');\n\t\t} else {\n\t\t\tconst pubkey = res.pubkey;\n\t\t\treturn { ...res, pubkey, amount: res.amount || amount, unit: res.unit || this.unit };\n\t\t}\n\t}\n\n\t/**\n\t * Requests a mint quote from the mint. Response returns a Lightning BOLT12 offer for the\n\t * requested given amount and unit.\n\t *\n\t * @param pubkey Public key to lock the quote to.\n\t * @param options.amount BOLT12 offer amount requesting for mint. If not specified, the offer will\n\t *   be amountless.\n\t * @param options.description Description for the mint quote.\n\t * @returns The mint will return a mint quote with a Lightning invoice for minting tokens of the\n\t *   specified amount and unit.\n\t */\n\tasync createMintQuoteBolt12(\n\t\tpubkey: string,\n\t\toptions?: {\n\t\t\tamount?: number;\n\t\t\tdescription?: string;\n\t\t},\n\t): Promise<Bolt12MintQuoteResponse> {\n\t\t// Check if mint supports description for bolt12\n\t\tconst mintInfo = await this.lazyGetMintInfo();\n\t\tif (options?.description && !mintInfo.supportsBolt12Description) {\n\t\t\tthrow new Error('Mint does not support description for bolt12');\n\t\t}\n\n\t\tconst mintQuotePayload: Bolt12MintQuotePayload = {\n\t\t\tpubkey: pubkey,\n\t\t\tunit: this._unit,\n\t\t\tamount: options?.amount,\n\t\t\tdescription: options?.description,\n\t\t};\n\n\t\treturn this.mint.createMintQuoteBolt12(mintQuotePayload);\n\t}\n\n\t/**\n\t * Gets an existing mint quote from the mint.\n\t *\n\t * @param quote Quote ID.\n\t * @returns The mint will create and return a Lightning invoice for the specified amount.\n\t */\n\tasync checkMintQuote(quote: MintQuoteResponse): Promise<MintQuoteResponse>;\n\tasync checkMintQuote(quote: string): Promise<PartialMintQuoteResponse>;\n\tasync checkMintQuote(\n\t\tquote: string | MintQuoteResponse,\n\t): Promise<MintQuoteResponse | PartialMintQuoteResponse> {\n\t\tconst quoteId = typeof quote === 'string' ? quote : quote.quote;\n\t\tconst baseRes = await this.mint.checkMintQuote(quoteId);\n\t\tif (typeof quote === 'string') {\n\t\t\treturn baseRes;\n\t\t}\n\t\treturn { ...baseRes, amount: baseRes.amount || quote.amount, unit: baseRes.unit || quote.unit };\n\t}\n\n\t/**\n\t * Gets an existing BOLT12 mint quote from the mint.\n\t *\n\t * @param quote Quote ID.\n\t * @returns The latest mint quote for the given quote ID.\n\t */\n\tasync checkMintQuoteBolt12(quote: string): Promise<Bolt12MintQuoteResponse> {\n\t\treturn this.mint.checkMintQuoteBolt12(quote);\n\t}\n\n\t/**\n\t * Mint proofs for a given mint quote.\n\t *\n\t * @param amount Amount to request.\n\t * @param {string} quote - ID of mint quote (when quote is a string)\n\t * @param {LockedMintQuote} quote - Containing the quote ID and unlocking private key (when quote\n\t *   is a LockedMintQuote)\n\t * @param {MintProofOptions} [options] - Optional parameters for configuring the Mint Proof\n\t *   operation.\n\t * @returns Proofs.\n\t */\n\tasync mintProofs(\n\t\tamount: number,\n\t\tquote: MintQuoteResponse,\n\t\toptions: MintProofOptions & { privateKey: string },\n\t): Promise<Proof[]>;\n\tasync mintProofs(amount: number, quote: string, options?: MintProofOptions): Promise<Proof[]>;\n\tasync mintProofs(\n\t\tamount: number,\n\t\tquote: string | MintQuoteResponse,\n\t\toptions?: MintProofOptions & { privateKey?: string },\n\t): Promise<Proof[]> {\n\t\treturn this._mintProofs('bolt11', amount, quote, options);\n\t}\n\n\t/**\n\t * Mint proofs for a given mint quote.\n\t *\n\t * @param amount Amount to request. This must be less than or equal to the `quote.amountPaid -\n\t *   quote.amountIssued`\n\t * @param {string} quote - ID of mint quote.\n\t * @param {string} privateKey - Private key to unlock the quote.\n\t * @param {MintProofOptions} [options] - Optional parameters for configuring the Mint Proof\n\t *   operation.\n\t * @returns Proofs.\n\t */\n\tasync mintProofsBolt12(\n\t\tamount: number,\n\t\tquote: Bolt12MintQuoteResponse,\n\t\tprivateKey: string,\n\t\toptions?: MintProofOptions,\n\t): Promise<Proof[]> {\n\t\treturn this._mintProofs('bolt12', amount, quote, { ...options, privateKey });\n\t}\n\n\t/**\n\t * Requests a melt quote from the mint. Response returns amount and fees for a given unit in order\n\t * to pay a Lightning invoice.\n\t *\n\t * @param invoice LN invoice that needs to get a fee estimate.\n\t * @returns The mint will create and return a melt quote for the invoice with an amount and fee\n\t *   reserve.\n\t */\n\tasync createMeltQuote(invoice: string): Promise<MeltQuoteResponse> {\n\t\tconst meltQuotePayload: MeltQuotePayload = {\n\t\t\tunit: this._unit,\n\t\t\trequest: invoice,\n\t\t};\n\t\tconst meltQuote = await this.mint.createMeltQuote(meltQuotePayload);\n\t\treturn {\n\t\t\t...meltQuote,\n\t\t\tunit: meltQuote.unit || this.unit,\n\t\t\trequest: meltQuote.request || invoice,\n\t\t};\n\t}\n\n\t/**\n\t * Requests a melt quote from the mint. Response returns amount and fees for a given unit in order\n\t * to pay a BOLT12 offer.\n\t *\n\t * @param offer BOLT12 offer that needs to get a fee estimate.\n\t * @param amountMsat Amount in millisatoshis for amount-less offers. If this is defined and the\n\t *   offer has an amount, they **MUST** be equal.\n\t * @returns The mint will create and return a melt quote for the offer with an amount and fee\n\t *   reserve.\n\t */\n\tasync createMeltQuoteBolt12(\n\t\toffer: string,\n\t\tamountMsat?: number,\n\t): Promise<Bolt12MeltQuoteResponse> {\n\t\treturn this.mint.createMeltQuoteBolt12({\n\t\t\tunit: this._unit,\n\t\t\trequest: offer,\n\t\t\toptions: amountMsat\n\t\t\t\t? {\n\t\t\t\t\t\tamountless: {\n\t\t\t\t\t\t\tamount_msat: amountMsat,\n\t\t\t\t\t\t},\n\t\t\t\t\t}\n\t\t\t\t: undefined,\n\t\t});\n\t}\n\n\t/**\n\t * Requests a multi path melt quote from the mint.\n\t *\n\t * @param invoice LN invoice that needs to get a fee estimate.\n\t * @param partialAmount The partial amount of the invoice's total to be paid by this instance.\n\t * @returns The mint will create and return a melt quote for the invoice with an amount and fee\n\t *   reserve.\n\t */\n\tasync createMultiPathMeltQuote(\n\t\tinvoice: string,\n\t\tmillisatPartialAmount: number,\n\t): Promise<MeltQuoteResponse> {\n\t\tthis.assertAmount(millisatPartialAmount, 'createMultiPathMeltQuote');\n\t\tconst { supported, params } = (await this.lazyGetMintInfo()).isSupported(15);\n\t\tif (!supported) {\n\t\t\tthrow new Error('Mint does not support NUT-15');\n\t\t}\n\t\tif (!params?.some((p) => p.method === 'bolt11' && p.unit === this.unit)) {\n\t\t\tthrow new Error(`Mint does not support MPP for bolt11 and ${this.unit}`);\n\t\t}\n\t\tconst mppOption: MPPOption = {\n\t\t\tamount: millisatPartialAmount,\n\t\t};\n\t\tconst meltOptions: MeltQuoteOptions = {\n\t\t\tmpp: mppOption,\n\t\t};\n\t\tconst meltQuotePayload: MeltQuotePayload = {\n\t\t\tunit: this._unit,\n\t\t\trequest: invoice,\n\t\t\toptions: meltOptions,\n\t\t};\n\t\tconst meltQuote = await this.mint.createMeltQuote(meltQuotePayload);\n\t\treturn { ...meltQuote, request: invoice, unit: this._unit };\n\t}\n\n\t/**\n\t * Return an existing melt quote from the mint.\n\t *\n\t * @param quote ID of the melt quote.\n\t * @returns The mint will return an existing melt quote.\n\t */\n\tasync checkMeltQuote(quote: string): Promise<PartialMeltQuoteResponse>;\n\tasync checkMeltQuote(quote: MeltQuoteResponse): Promise<MeltQuoteResponse>;\n\tasync checkMeltQuote(\n\t\tquote: string | MeltQuoteResponse,\n\t): Promise<MeltQuoteResponse | PartialMeltQuoteResponse> {\n\t\tconst quoteId = typeof quote === 'string' ? quote : quote.quote;\n\t\tconst meltQuote = await this.mint.checkMeltQuote(quoteId);\n\t\tif (typeof quote === 'string') {\n\t\t\treturn meltQuote;\n\t\t}\n\t\treturn { ...meltQuote, request: quote.request, unit: quote.unit };\n\t}\n\n\tasync checkMeltQuoteBolt12(quote: string): Promise<Bolt12MeltQuoteResponse> {\n\t\treturn this.mint.checkMeltQuoteBolt12(quote);\n\t}\n\n\t/**\n\t * Melt proofs for a melt quote. proofsToSend must be at least amount+fee_reserve form the melt\n\t * quote. This function does not perform coin selection!. Returns melt quote and change proofs.\n\t *\n\t * @param meltQuote ID of the melt quote.\n\t * @param proofsToSend Proofs to melt.\n\t * @param {MeltProofOptions} [options] - Optional parameters for configuring the Melting Proof\n\t *   operation.\n\t * @returns\n\t */\n\tasync meltProofs(\n\t\tmeltQuote: MeltQuoteResponse,\n\t\tproofsToSend: Proof[],\n\t\toptions?: MeltProofOptions,\n\t): Promise<MeltProofsResponse> {\n\t\treturn this._meltProofs('bolt11', meltQuote, proofsToSend, options);\n\t}\n\n\t/**\n\t * Melt proofs for a melt quote. proofsToSend must be at least amount+fee_reserve form the melt\n\t * quote. This function does not perform coin selection!. Returns melt quote and change proofs.\n\t *\n\t * @param meltQuote ID of the melt quote.\n\t * @param proofsToSend Proofs to melt.\n\t * @param {MeltProofOptions} [options] - Optional parameters for configuring the Melting Proof\n\t *   operation.\n\t * @returns\n\t */\n\tasync meltProofsBolt12(\n\t\tmeltQuote: Bolt12MeltQuoteResponse,\n\t\tproofsToSend: Proof[],\n\t\toptions?: MeltProofOptions,\n\t): Promise<{\n\t\tquote: Bolt12MeltQuoteResponse;\n\t\tchange: Proof[];\n\t}> {\n\t\treturn this._meltProofs('bolt12', meltQuote, proofsToSend, options);\n\t}\n\n\t/**\n\t * Creates a split payload.\n\t *\n\t * @param amount Amount to send.\n\t * @param proofsToSend Proofs to split*\n\t * @param outputAmounts? Optionally specify the output's amounts to keep and to send.\n\t * @param counter? Optionally set counter to derive secret deterministically. CashuWallet class\n\t *   must be initialized with seed phrase to take effect.\n\t * @param pubkey? Optionally locks ecash to pubkey. Will not be deterministic, even if counter is\n\t *   set!\n\t * @param privkey? Will create a signature on the @param proofsToSend secrets if set.\n\t * @param customOutputData? Optionally specify your own OutputData (blinded messages)\n\t * @param p2pk? Optionally specify options to lock the proofs according to NUT-11.\n\t * @returns\n\t */\n\tprivate createSwapPayload(\n\t\tamount: number,\n\t\tproofsToSend: Proof[],\n\t\tkeyset: MintKeys,\n\t\toutputAmounts?: OutputAmounts,\n\t\tcounter?: number,\n\t\tpubkey?: string,\n\t\tprivkey?: string,\n\t\tcustomOutputData?: {\n\t\t\tkeep?: OutputDataLike[] | OutputDataFactory;\n\t\t\tsend?: OutputDataLike[] | OutputDataFactory;\n\t\t},\n\t\tp2pk?: {\n\t\t\tpubkey: string | string[];\n\t\t\tlocktime?: number;\n\t\t\trefundKeys?: string[];\n\t\t\trequiredSignatures?: number;\n\t\t\trequiredRefundSignatures?: number;\n\t\t\tadditionalTags?: Array<[key: string, ...values: string[]]>;\n\t\t},\n\t): SwapTransaction {\n\t\tconst totalAmount = proofsToSend.reduce((total: number, curr: Proof) => total + curr.amount, 0);\n\t\tif (outputAmounts && outputAmounts.sendAmounts && !outputAmounts.keepAmounts) {\n\t\t\toutputAmounts.keepAmounts = splitAmount(\n\t\t\t\ttotalAmount - amount - this.getFeesForProofs(proofsToSend),\n\t\t\t\tkeyset.keys,\n\t\t\t);\n\t\t}\n\t\tconst keepAmount = totalAmount - amount - this.getFeesForProofs(proofsToSend);\n\t\tlet keepOutputData: OutputDataLike[] = [];\n\t\tlet sendOutputData: OutputDataLike[] = [];\n\n\t\tif (customOutputData?.keep) {\n\t\t\tif (isOutputDataFactory(customOutputData.keep)) {\n\t\t\t\tconst factory = customOutputData.keep;\n\t\t\t\tconst amounts = splitAmount(keepAmount, keyset.keys);\n\t\t\t\tamounts.forEach((a) => {\n\t\t\t\t\tkeepOutputData.push(factory(a, keyset));\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tkeepOutputData = customOutputData.keep;\n\t\t\t}\n\t\t} else {\n\t\t\tkeepOutputData = this.createOutputData(\n\t\t\t\tkeepAmount,\n\t\t\t\tkeyset,\n\t\t\t\tcounter,\n\t\t\t\tundefined,\n\t\t\t\toutputAmounts?.keepAmounts,\n\t\t\t\tundefined,\n\t\t\t\tthis._keepFactory,\n\t\t\t);\n\t\t}\n\n\t\tif (customOutputData?.send) {\n\t\t\tif (isOutputDataFactory(customOutputData.send)) {\n\t\t\t\tconst factory = customOutputData.send;\n\t\t\t\tconst amounts = splitAmount(amount, keyset.keys);\n\t\t\t\tamounts.forEach((a) => {\n\t\t\t\t\tsendOutputData.push(factory(a, keyset));\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tsendOutputData = customOutputData.send;\n\t\t\t}\n\t\t} else {\n\t\t\tsendOutputData = this.createOutputData(\n\t\t\t\tamount,\n\t\t\t\tkeyset,\n\t\t\t\tcounter ? counter + keepOutputData.length : undefined,\n\t\t\t\tpubkey,\n\t\t\t\toutputAmounts?.sendAmounts,\n\t\t\t\tp2pk,\n\t\t\t);\n\t\t}\n\n\t\tif (privkey) {\n\t\t\tproofsToSend = signP2PKProofs(proofsToSend, privkey);\n\t\t}\n\n\t\tproofsToSend = stripDleq(proofsToSend);\n\n\t\t// Ensure witnesses are serialized before sending to mint\n\t\tproofsToSend = proofsToSend.map((p: Proof) => {\n\t\t\tconst witness =\n\t\t\t\tp.witness && typeof p.witness !== 'string' ? JSON.stringify(p.witness) : p.witness;\n\t\t\treturn { ...p, witness };\n\t\t});\n\n\t\tconst mergedBlindingData = [...keepOutputData, ...sendOutputData];\n\t\tconst indices = mergedBlindingData\n\t\t\t.map((_, i) => i)\n\t\t\t.sort(\n\t\t\t\t(a, b) =>\n\t\t\t\t\tmergedBlindingData[a].blindedMessage.amount - mergedBlindingData[b].blindedMessage.amount,\n\t\t\t);\n\t\tconst keepVector: boolean[] = [\n\t\t\t...Array.from({ length: keepOutputData.length }, () => true),\n\t\t\t...Array.from({ length: sendOutputData.length }, () => false),\n\t\t];\n\n\t\tconst sortedOutputData: OutputDataLike[] = indices.map((i) => mergedBlindingData[i]);\n\t\tconst sortedKeepVector: boolean[] = indices.map((i) => keepVector[i]);\n\n\t\treturn {\n\t\t\tpayload: {\n\t\t\t\tinputs: proofsToSend,\n\t\t\t\toutputs: sortedOutputData.map((d) => d.blindedMessage),\n\t\t\t},\n\t\t\toutputData: sortedOutputData,\n\t\t\tkeepVector: sortedKeepVector,\n\t\t\tsortedIndices: indices,\n\t\t};\n\t}\n\n\t/**\n\t * Get an array of the states of proofs from the mint (as an array of CheckStateEnum's)\n\t *\n\t * @param proofs (only the `secret` field is required)\n\t * @returns\n\t */\n\tasync checkProofsStates(proofs: Proof[]): Promise<ProofState[]> {\n\t\tconst enc = new TextEncoder();\n\t\tconst Ys = proofs.map((p: Proof) => hashToCurve(enc.encode(p.secret)).toHex(true));\n\t\t// TODO: Replace this with a value from the info endpoint of the mint eventually\n\t\tconst BATCH_SIZE = 100;\n\t\tconst states: ProofState[] = [];\n\t\tfor (let i = 0; i < Ys.length; i += BATCH_SIZE) {\n\t\t\tconst YsSlice = Ys.slice(i, i + BATCH_SIZE);\n\t\t\tconst { states: batchStates } = await this.mint.check({\n\t\t\t\tYs: YsSlice,\n\t\t\t});\n\t\t\tconst stateMap: { [y: string]: ProofState } = {};\n\t\t\tbatchStates.forEach((s) => {\n\t\t\t\tstateMap[s.Y] = s;\n\t\t\t});\n\t\t\tfor (let j = 0; j < YsSlice.length; j++) {\n\t\t\t\tconst state = stateMap[YsSlice[j]];\n\t\t\t\tif (!state) {\n\t\t\t\t\tthrow new Error('Could not find state for proof with Y: ' + YsSlice[j]);\n\t\t\t\t}\n\t\t\t\tstates.push(state);\n\t\t\t}\n\t\t}\n\t\treturn states;\n\t}\n\n\t/**\n\t * Register a callback to be called whenever a mint quote's state changes.\n\t *\n\t * @param quoteIds List of mint quote IDs that should be subscribed to.\n\t * @param callback Callback function that will be called whenever a mint quote state changes.\n\t * @param errorCallback\n\t * @returns\n\t */\n\tasync onMintQuoteUpdates(\n\t\tquoteIds: string[],\n\t\tcallback: (payload: MintQuoteResponse) => void,\n\t\terrorCallback: (e: Error) => void,\n\t): Promise<SubscriptionCanceller> {\n\t\tawait this.mint.connectWebSocket();\n\t\tif (!this.mint.webSocketConnection) {\n\t\t\tthrow new Error('failed to establish WebSocket connection.');\n\t\t}\n\t\tconst subId = this.mint.webSocketConnection.createSubscription(\n\t\t\t{ kind: 'bolt11_mint_quote', filters: quoteIds },\n\t\t\tcallback,\n\t\t\terrorCallback,\n\t\t);\n\t\treturn () => {\n\t\t\tthis.mint.webSocketConnection?.cancelSubscription(subId, callback);\n\t\t};\n\t}\n\n\t/**\n\t * Register a callback to be called whenever a melt quote's state changes.\n\t *\n\t * @param quoteIds List of melt quote IDs that should be subscribed to.\n\t * @param callback Callback function that will be called whenever a melt quote state changes.\n\t * @param errorCallback\n\t * @returns\n\t */\n\tasync onMeltQuotePaid(\n\t\tquoteId: string,\n\t\tcallback: (payload: MeltQuoteResponse) => void,\n\t\terrorCallback: (e: Error) => void,\n\t): Promise<SubscriptionCanceller> {\n\t\treturn this.onMeltQuoteUpdates(\n\t\t\t[quoteId],\n\t\t\t(p) => {\n\t\t\t\tif (p.state === MeltQuoteState.PAID) {\n\t\t\t\t\tcallback(p);\n\t\t\t\t}\n\t\t\t},\n\t\t\terrorCallback,\n\t\t);\n\t}\n\n\t/**\n\t * Register a callback to be called when a single mint quote gets paid.\n\t *\n\t * @param quoteId Mint quote id that should be subscribed to.\n\t * @param callback Callback function that will be called when this mint quote gets paid.\n\t * @param errorCallback\n\t * @returns\n\t */\n\tasync onMintQuotePaid(\n\t\tquoteId: string,\n\t\tcallback: (payload: MintQuoteResponse) => void,\n\t\terrorCallback: (e: Error) => void,\n\t): Promise<SubscriptionCanceller> {\n\t\treturn this.onMintQuoteUpdates(\n\t\t\t[quoteId],\n\t\t\t(p) => {\n\t\t\t\tif (p.state === MintQuoteState.PAID) {\n\t\t\t\t\tcallback(p);\n\t\t\t\t}\n\t\t\t},\n\t\t\terrorCallback,\n\t\t);\n\t}\n\n\t/**\n\t * Register a callback to be called when a single melt quote gets paid.\n\t *\n\t * @param quoteId Melt quote id that should be subscribed to.\n\t * @param callback Callback function that will be called when this melt quote gets paid.\n\t * @param errorCallback\n\t * @returns\n\t */\n\tasync onMeltQuoteUpdates(\n\t\tquoteIds: string[],\n\t\tcallback: (payload: MeltQuoteResponse) => void,\n\t\terrorCallback: (e: Error) => void,\n\t): Promise<SubscriptionCanceller> {\n\t\tawait this.mint.connectWebSocket();\n\t\tif (!this.mint.webSocketConnection) {\n\t\t\tthrow new Error('failed to establish WebSocket connection.');\n\t\t}\n\t\tconst subId = this.mint.webSocketConnection.createSubscription(\n\t\t\t{ kind: 'bolt11_melt_quote', filters: quoteIds },\n\t\t\tcallback,\n\t\t\terrorCallback,\n\t\t);\n\t\treturn () => {\n\t\t\tthis.mint.webSocketConnection?.cancelSubscription(subId, callback);\n\t\t};\n\t}\n\n\t/**\n\t * Register a callback to be called whenever a subscribed proof state changes.\n\t *\n\t * @param proofs List of proofs that should be subscribed to.\n\t * @param callback Callback function that will be called whenever a proof's state changes.\n\t * @param errorCallback\n\t * @returns\n\t */\n\tasync onProofStateUpdates(\n\t\tproofs: Proof[],\n\t\tcallback: (payload: ProofState & { proof: Proof }) => void,\n\t\terrorCallback: (e: Error) => void,\n\t): Promise<SubscriptionCanceller> {\n\t\tawait this.mint.connectWebSocket();\n\t\tif (!this.mint.webSocketConnection) {\n\t\t\tthrow new Error('failed to establish WebSocket connection.');\n\t\t}\n\t\tconst enc = new TextEncoder();\n\t\tconst proofMap: { [y: string]: Proof } = {};\n\t\tfor (let i = 0; i < proofs.length; i++) {\n\t\t\tconst y = hashToCurve(enc.encode(proofs[i].secret)).toHex(true);\n\t\t\tproofMap[y] = proofs[i];\n\t\t}\n\t\tconst ys = Object.keys(proofMap);\n\t\tconst subId = this.mint.webSocketConnection.createSubscription(\n\t\t\t{ kind: 'proof_state', filters: ys },\n\t\t\t(p: ProofState) => {\n\t\t\t\tcallback({ ...p, proof: proofMap[p.Y] });\n\t\t\t},\n\t\t\terrorCallback,\n\t\t);\n\t\treturn () => {\n\t\t\tthis.mint.webSocketConnection?.cancelSubscription(subId, callback);\n\t\t};\n\t}\n\n\t/**\n\t * Creates blinded messages for a according to @param amounts.\n\t *\n\t * @param amount Array of amounts to create blinded messages for.\n\t * @param counter? Optionally set counter to derive secret deterministically. CashuWallet class\n\t *   must be initialized with seed phrase to take effect.\n\t * @param pubkey? Optionally locks ecash to pubkey. Will not be deterministic, even if counter is\n\t *   set!\n\t * @param outputAmounts? Optionally specify the output's amounts to keep and to send.\n\t * @param p2pk? Optionally specify options to lock the proofs according to NUT-11.\n\t * @param factory? Optionally specify a custom function that produces OutputData (blinded\n\t *   messages)\n\t * @returns Blinded messages, secrets, rs, and amounts.\n\t */\n\tprivate createOutputData(\n\t\tamount: number,\n\t\tkeyset: MintKeys,\n\t\tcounter?: number,\n\t\tpubkey?: string,\n\t\toutputAmounts?: number[],\n\t\tp2pk?: {\n\t\t\tpubkey: string | string[];\n\t\t\tlocktime?: number;\n\t\t\trefundKeys?: string[];\n\t\t\trequiredSignatures?: number;\n\t\t\trequiredRefundSignatures?: number;\n\t\t\tadditionalTags?: Array<[key: string, ...values: string[]]>;\n\t\t},\n\t\tfactory?: OutputDataFactory,\n\t): OutputDataLike[] {\n\t\tlet outputData: OutputDataLike[];\n\t\tif (pubkey) {\n\t\t\toutputData = OutputData.createP2PKData(\n\t\t\t\t{ pubkey, additionalTags: p2pk?.additionalTags },\n\t\t\t\tamount,\n\t\t\t\tkeyset,\n\t\t\t\toutputAmounts,\n\t\t\t);\n\t\t} else if (counter || counter === 0) {\n\t\t\tif (!this._seed) {\n\t\t\t\tthrow new Error('cannot create deterministic messages without seed');\n\t\t\t}\n\t\t\toutputData = OutputData.createDeterministicData(\n\t\t\t\tamount,\n\t\t\t\tthis._seed,\n\t\t\t\tcounter,\n\t\t\t\tkeyset,\n\t\t\t\toutputAmounts,\n\t\t\t);\n\t\t} else if (p2pk) {\n\t\t\toutputData = OutputData.createP2PKData(p2pk, amount, keyset, outputAmounts);\n\t\t} else if (factory) {\n\t\t\tconst amounts = splitAmount(amount, keyset.keys);\n\t\t\toutputData = amounts.map((a) => factory(a, keyset));\n\t\t} else {\n\t\t\toutputData = OutputData.createRandomData(amount, keyset, outputAmounts);\n\t\t}\n\t\treturn outputData;\n\t}\n\n\t/**\n\t * Creates NUT-08 blank outputs (fee returns) for a given fee reserve See:\n\t * https://github.com/cashubtc/nuts/blob/main/08.md.\n\t *\n\t * @param amount Amount to cover with blank outputs.\n\t * @param keysetId Mint keysetId.\n\t * @param counter? Optionally set counter to derive secret deterministically. CashuWallet class\n\t *   must be initialized with seed phrase to take effect.\n\t * @returns Blinded messages, secrets, and rs.\n\t */\n\tprivate createBlankOutputs(\n\t\tamount: number,\n\t\tkeyset: MintKeys,\n\t\tcounter?: number,\n\t\tfactory?: OutputDataFactory,\n\t): OutputDataLike[] {\n\t\tlet count = Math.ceil(Math.log2(amount)) || 1;\n\t\t//Prevent count from being -Infinity\n\t\tif (count < 0) {\n\t\t\tcount = 0;\n\t\t}\n\t\t// Note: zero amount + zero denomination passes splitAmount validation\n\t\tconst zeros = count ? Array(count).fill(0) : [];\n\t\treturn this.createOutputData(0, keyset, counter, undefined, zeros, undefined, factory);\n\t}\n\n\t/**\n\t * Mints proofs for a given mint quote created with the bolt11 or bolt12 method.\n\t *\n\t * @param method Payment method of the quote.\n\t * @param amount Amount to mint.\n\t * @param quote The bolt11 or bolt12 mint quote.\n\t * @param options Optional parameters for configuring the Mint Proof operation.\n\t * @returns Proofs.\n\t */\n\tprivate async _mintProofs<T extends 'bolt11' | 'bolt12'>(\n\t\tmethod: T,\n\t\tamount: number,\n\t\tquote: string | (T extends 'bolt11' ? MintQuoteResponse : Bolt12MintQuoteResponse),\n\t\toptions?: MintProofOptions & { privateKey?: string },\n\t): Promise<Proof[]> {\n\t\tthis.assertAmount(amount, '_mintProofs');\n\t\tlet { outputAmounts } = options || {};\n\t\tconst { counter, pubkey, p2pk, keysetId, proofsWeHave, outputData, privateKey } = options || {};\n\n\t\tconst keyset = await this.getKeys(keysetId);\n\t\tif (!outputAmounts && proofsWeHave) {\n\t\t\toutputAmounts = {\n\t\t\t\tkeepAmounts: getKeepAmounts(proofsWeHave, amount, keyset.keys, this._denominationTarget),\n\t\t\t\tsendAmounts: [],\n\t\t\t};\n\t\t}\n\t\tlet newBlindingData: OutputData[] = [];\n\t\tif (outputData) {\n\t\t\tif (isOutputDataFactory(outputData)) {\n\t\t\t\tconst amounts = splitAmount(amount, keyset.keys, outputAmounts?.keepAmounts);\n\t\t\t\tfor (let i = 0; i < amounts.length; i++) {\n\t\t\t\t\tnewBlindingData.push(outputData(amounts[i], keyset));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnewBlindingData = outputData;\n\t\t\t}\n\t\t} else if (this._keepFactory) {\n\t\t\tconst amounts = splitAmount(amount, keyset.keys, outputAmounts?.keepAmounts);\n\t\t\tfor (let i = 0; i < amounts.length; i++) {\n\t\t\t\tnewBlindingData.push(this._keepFactory(amounts[i], keyset));\n\t\t\t}\n\t\t} else {\n\t\t\tnewBlindingData = this.createOutputData(\n\t\t\t\tamount,\n\t\t\t\tkeyset,\n\t\t\t\tcounter,\n\t\t\t\tpubkey,\n\t\t\t\toutputAmounts?.keepAmounts,\n\t\t\t\tp2pk,\n\t\t\t);\n\t\t}\n\t\tconst blindedMessages = newBlindingData.map((d) => d.blindedMessage);\n\t\tconst mintPayload: MintPayload = {\n\t\t\toutputs: blindedMessages,\n\t\t\tquote: typeof quote === 'string' ? quote : quote.quote,\n\t\t};\n\t\tif (typeof quote !== 'string' && quote.pubkey) {\n\t\t\tif (!privateKey) {\n\t\t\t\tthrow new Error('Can not sign locked quote without private key');\n\t\t\t}\n\t\t\tmintPayload.signature = signMintQuote(privateKey, quote.quote, blindedMessages);\n\t\t}\n\t\tif (method === 'bolt12') {\n\t\t\tconst { signatures } = await this.mint.mintBolt12(mintPayload);\n\t\t\treturn newBlindingData.map((d, i) => d.toProof(signatures[i], keyset));\n\t\t}\n\t\tconst { signatures } = await this.mint.mint(mintPayload);\n\t\treturn newBlindingData.map((d, i) => d.toProof(signatures[i], keyset));\n\t}\n\n\t/**\n\t * Melt proofs for a given melt quote created with the bolt11 or bolt12 method.\n\t *\n\t * @param method Payment method of the quote.\n\t * @param meltQuote The bolt11 or bolt12 melt quote.\n\t * @param proofsToSend Proofs to melt.\n\t * @param options Optional parameters for configuring the Melting Proof operation.\n\t * @returns Melt quote and change proofs.\n\t */\n\tprivate async _meltProofs<T extends 'bolt11' | 'bolt12'>(\n\t\tmethod: T,\n\t\tmeltQuote: T extends 'bolt11' ? MeltQuoteResponse : Bolt12MeltQuoteResponse,\n\t\tproofsToSend: Proof[],\n\t\toptions?: MeltProofOptions,\n\t): Promise<MeltProofsResponse> {\n\t\tconst { keysetId, counter, privkey } = options || {};\n\t\tconst keys = await this.getKeys(keysetId);\n\t\tconst outputData = this.createBlankOutputs(\n\t\t\tsumProofs(proofsToSend) - meltQuote.amount,\n\t\t\tkeys,\n\t\t\tcounter,\n\t\t\tthis._keepFactory,\n\t\t);\n\t\tif (privkey != undefined) {\n\t\t\tproofsToSend = signP2PKProofs(proofsToSend, privkey);\n\t\t}\n\n\t\tproofsToSend = stripDleq(proofsToSend);\n\n\t\t// Ensure witnesses are serialized before sending to mint\n\t\tproofsToSend = proofsToSend.map((p: Proof) => {\n\t\t\tconst witness =\n\t\t\t\tp.witness && typeof p.witness !== 'string' ? JSON.stringify(p.witness) : p.witness;\n\t\t\treturn { ...p, witness };\n\t\t});\n\n\t\tconst meltPayload: MeltPayload = {\n\t\t\tquote: meltQuote.quote,\n\t\t\tinputs: proofsToSend,\n\t\t\toutputs: outputData.map((d) => d.blindedMessage),\n\t\t};\n\t\tif (method === 'bolt12') {\n\t\t\tconst meltResponse = await this.mint.meltBolt12(meltPayload);\n\t\t\treturn {\n\t\t\t\tquote: { ...meltResponse, unit: meltQuote.unit, request: meltQuote.request },\n\t\t\t\tchange: meltResponse.change?.map((s, i) => outputData[i].toProof(s, keys)) ?? [],\n\t\t\t};\n\t\t}\n\t\tconst meltResponse = await this.mint.melt(meltPayload);\n\t\treturn {\n\t\t\tquote: { ...meltResponse, unit: meltQuote.unit, request: meltQuote.request },\n\t\t\tchange: meltResponse.change?.map((s, i) => outputData[i].toProof(s, keys)) ?? [],\n\t\t};\n\t}\n}\n\nexport { CashuWallet };\n","import {\n\ttype BlindAuthMintPayload,\n\ttype BlindAuthMintResponse,\n\ttype MintActiveKeys,\n\ttype MintAllKeysets,\n} from '../model/types';\nimport request from '../request';\nimport { isObj, joinUrls, sanitizeUrl } from '../utils';\n\n/**\n * Class represents Cashu Auth Mint API. This class contains Lower level functions that are\n * implemented by CashuAuthWallet.\n */\nclass CashuAuthMint {\n\t/**\n\t * @param _mintUrl Requires mint URL to create this object.\n\t * @param _customRequest If passed, use custom request implementation for network communication\n\t *   with the mint.\n\t */\n\tconstructor(\n\t\tprivate _mintUrl: string,\n\t\tprivate _customRequest?: typeof request,\n\t) {\n\t\tthis._mintUrl = sanitizeUrl(_mintUrl);\n\t\tthis._customRequest = _customRequest;\n\t}\n\n\tget mintUrl() {\n\t\treturn this._mintUrl;\n\t}\n\n\t/**\n\t * Mints new Blinded Authentication tokens by requesting blind signatures on the provided outputs.\n\t *\n\t * @param mintUrl\n\t * @param mintPayload Payload containing the outputs to get blind signatures on.\n\t * @param clearAuthToken A NUT-21 clear auth token.\n\t * @param customRequest\n\t * @returns Serialized blinded signatures.\n\t */\n\tpublic static async mint(\n\t\tmintUrl: string,\n\t\tmintPayload: BlindAuthMintPayload,\n\t\tclearAuthToken: string,\n\t\tcustomRequest?: typeof request,\n\t) {\n\t\tconst requestInstance = customRequest || request;\n\t\tconst headers = {\n\t\t\t'Clear-auth': `${clearAuthToken}`,\n\t\t};\n\t\tconst data = await requestInstance<BlindAuthMintResponse>({\n\t\t\tendpoint: joinUrls(mintUrl, '/v1/auth/blind/mint'),\n\t\t\tmethod: 'POST',\n\t\t\trequestBody: mintPayload,\n\t\t\theaders,\n\t\t});\n\n\t\tif (!isObj(data) || !Array.isArray(data?.signatures)) {\n\t\t\tthrow new Error('bad response');\n\t\t}\n\n\t\treturn data;\n\t}\n\t/**\n\t * Mints new Blinded Authentication tokens by requesting blind signatures on the provided outputs.\n\t *\n\t * @param mintPayload Payload containing the outputs to get blind signatures on.\n\t * @param clearAuthToken A NUT-21 clear auth token.\n\t * @returns Serialized blinded signatures.\n\t */\n\tasync mint(mintPayload: BlindAuthMintPayload, clearAuthToken: string) {\n\t\treturn CashuAuthMint.mint(this._mintUrl, mintPayload, clearAuthToken, this._customRequest);\n\t}\n\n\t/**\n\t * Get the mints public NUT-22 keys.\n\t *\n\t * @param mintUrl\n\t * @param keysetId Optional param to get the keys for a specific keyset. If not specified, the\n\t *   keys from all active keysets are fetched.\n\t * @param customRequest\n\t * @returns\n\t */\n\tpublic static async getKeys(\n\t\tmintUrl: string,\n\t\tkeysetId?: string,\n\t\tcustomRequest?: typeof request,\n\t): Promise<MintActiveKeys> {\n\t\tconst requestInstance = customRequest || request;\n\t\tconst data = await requestInstance<MintActiveKeys>({\n\t\t\tendpoint: keysetId\n\t\t\t\t? joinUrls(mintUrl, '/v1/auth/blind/keys', keysetId)\n\t\t\t\t: joinUrls(mintUrl, '/v1/auth/blind/keys'),\n\t\t});\n\n\t\tif (!isObj(data) || !Array.isArray(data.keysets)) {\n\t\t\tthrow new Error('bad response');\n\t\t}\n\n\t\treturn data;\n\t}\n\t/**\n\t * Get the mints public NUT-22 keys.\n\t *\n\t * @param keysetId Optional param to get the keys for a specific keyset. If not specified, the\n\t *   keys from all active keysets are fetched.\n\t * @returns The mints public keys.\n\t */\n\tasync getKeys(keysetId?: string, mintUrl?: string): Promise<MintActiveKeys> {\n\t\tconst allKeys = await CashuAuthMint.getKeys(\n\t\t\tmintUrl || this._mintUrl,\n\t\t\tkeysetId,\n\t\t\tthis._customRequest,\n\t\t);\n\t\treturn allKeys;\n\t}\n\t/**\n\t * Get the mints NUT-22 keysets in no specific order.\n\t *\n\t * @param mintUrl\n\t * @param customRequest\n\t * @returns All the mints past and current keysets.\n\t */\n\tpublic static async getKeySets(\n\t\tmintUrl: string,\n\t\tcustomRequest?: typeof request,\n\t): Promise<MintAllKeysets> {\n\t\tconst requestInstance = customRequest || request;\n\t\treturn requestInstance<MintAllKeysets>({\n\t\t\tendpoint: joinUrls(mintUrl, '/v1/auth/blind/keysets'),\n\t\t});\n\t}\n\n\t/**\n\t * Get the mints NUT-22 keysets in no specific order.\n\t *\n\t * @returns All the mints past and current keysets.\n\t */\n\tasync getKeySets(): Promise<MintAllKeysets> {\n\t\treturn CashuAuthMint.getKeySets(this._mintUrl, this._customRequest);\n\t}\n}\n\nexport { CashuAuthMint };\n","import { OutputData } from '../model/OutputData';\nimport {\n\ttype BlindAuthMintPayload,\n\ttype MintKeys,\n\ttype MintKeyset,\n\ttype Proof,\n} from '../model/types';\nimport { hasValidDleq } from '../utils';\nimport { type CashuAuthMint } from './CashuAuthMint';\n\n/**\n * Class that represents a Cashu NUT-22 wallet.\n */\nclass CashuAuthWallet {\n\tprivate _keys: Map<string, MintKeys> = new Map();\n\tprivate _keysetId: string | undefined;\n\tprivate _keysets: MintKeyset[] = [];\n\tprivate _unit = 'auth';\n\n\tmint: CashuAuthMint;\n\n\t/**\n\t * @param mint NUT-22 auth mint instance.\n\t * @param options.keys Public keys from the mint (will be fetched from mint if not provided)\n\t * @param options.keysets Keysets from the mint (will be fetched from mint if not provided)\n\t */\n\tconstructor(\n\t\tmint: CashuAuthMint,\n\t\toptions?: {\n\t\t\tkeys?: MintKeys[] | MintKeys;\n\t\t\tkeysets?: MintKeyset[];\n\t\t},\n\t) {\n\t\tthis.mint = mint;\n\t\tlet keys: MintKeys[] = [];\n\t\tif (options?.keys && !Array.isArray(options.keys)) {\n\t\t\tkeys = [options.keys];\n\t\t} else if (options?.keys && Array.isArray(options?.keys)) {\n\t\t\tkeys = options?.keys;\n\t\t}\n\t\tif (keys) keys.forEach((key: MintKeys) => this._keys.set(key.id, key));\n\t\tif (options?.keysets) this._keysets = options.keysets;\n\t}\n\n\tget keys(): Map<string, MintKeys> {\n\t\treturn this._keys;\n\t}\n\tget keysetId(): string {\n\t\tif (!this._keysetId) {\n\t\t\tthrow new Error('No keysetId set');\n\t\t}\n\t\treturn this._keysetId;\n\t}\n\tset keysetId(keysetId: string) {\n\t\tthis._keysetId = keysetId;\n\t}\n\tget keysets(): MintKeyset[] {\n\t\treturn this._keysets;\n\t}\n\n\t/**\n\t * Load mint information, keysets and keys. This function can be called if no keysets are passed\n\t * in the constructor.\n\t */\n\tasync loadMint() {\n\t\tawait this.getKeySets();\n\t\tawait this.getKeys();\n\t}\n\n\t/**\n\t * Choose a keyset to activate based on the lowest input fee.\n\t *\n\t * Note: this function will filter out deprecated base64 keysets.\n\t *\n\t * @param keysets Keysets to choose from.\n\t * @returns Active keyset.\n\t */\n\tgetActiveKeyset(keysets: MintKeyset[]): MintKeyset {\n\t\tlet activeKeysets = keysets.filter((k: MintKeyset) => k.active);\n\n\t\t// we only consider keyset IDs that start with \"00\"\n\t\tactiveKeysets = activeKeysets.filter((k: MintKeyset) => k.id.startsWith('00'));\n\n\t\tconst activeKeyset = activeKeysets.sort(\n\t\t\t(a: MintKeyset, b: MintKeyset) => (a.input_fee_ppk ?? 0) - (b.input_fee_ppk ?? 0),\n\t\t)[0];\n\t\tif (!activeKeyset) {\n\t\t\tthrow new Error('No active keyset found');\n\t\t}\n\t\treturn activeKeyset;\n\t}\n\n\t/**\n\t * Get keysets from the mint with the unit of the wallet.\n\t *\n\t * @returns Keysets with wallet's unit.\n\t */\n\tasync getKeySets(): Promise<MintKeyset[]> {\n\t\tconst allKeysets = await this.mint.getKeySets();\n\t\tconst unitKeysets = allKeysets.keysets.filter((k: MintKeyset) => k.unit === this._unit);\n\t\tthis._keysets = unitKeysets;\n\t\treturn this._keysets;\n\t}\n\n\t/**\n\t * Get all active keys from the mint and set the keyset with the lowest fees as the active wallet\n\t * keyset.\n\t *\n\t * @returns Keyset.\n\t */\n\tasync getAllKeys(): Promise<MintKeys[]> {\n\t\tconst keysets = await this.mint.getKeys();\n\t\tthis._keys = new Map(keysets.keysets.map((k: MintKeys) => [k.id, k]));\n\t\tthis.keysetId = this.getActiveKeyset(this._keysets).id;\n\t\treturn keysets.keysets;\n\t}\n\n\t/**\n\t * Get public keys from the mint. If keys were already fetched, it will return those.\n\t *\n\t * If `keysetId` is set, it will fetch and return that specific keyset. Otherwise, we select an\n\t * active keyset with the unit of the wallet.\n\t *\n\t * @param keysetId Optional keysetId to get keys for.\n\t * @param forceRefresh? If set to true, it will force refresh the keyset from the mint.\n\t * @returns Keyset.\n\t */\n\tasync getKeys(keysetId?: string, forceRefresh?: boolean): Promise<MintKeys> {\n\t\tif (!(this._keysets.length > 0) || forceRefresh) {\n\t\t\tawait this.getKeySets();\n\t\t}\n\t\t// no keyset id is chosen, let's choose one\n\t\tif (!keysetId) {\n\t\t\tconst localKeyset = this.getActiveKeyset(this._keysets);\n\t\t\tkeysetId = localKeyset.id;\n\t\t}\n\t\t// make sure we have keyset for this id\n\t\tif (!this._keysets.find((k: MintKeyset) => k.id === keysetId)) {\n\t\t\tawait this.getKeySets();\n\t\t\tif (!this._keysets.find((k: MintKeyset) => k.id === keysetId)) {\n\t\t\t\tthrow new Error(`could not initialize keys. No keyset with id '${keysetId}' found`);\n\t\t\t}\n\t\t}\n\n\t\t// make sure we have keys for this id\n\t\tif (!this._keys.get(keysetId)) {\n\t\t\tconst keys = await this.mint.getKeys(keysetId);\n\t\t\tthis._keys.set(keysetId, keys.keysets[0]);\n\t\t}\n\n\t\t// set and return\n\t\tthis.keysetId = keysetId;\n\t\treturn this._keys.get(keysetId) as MintKeys;\n\t}\n\n\t/**\n\t * Mint proofs for a given mint quote.\n\t *\n\t * @param amount Amount to request.\n\t * @param clearAuthToken ClearAuthToken to mint.\n\t * @param options.keysetId? Optionally set keysetId for blank outputs for returned change.\n\t * @returns Proofs.\n\t */\n\tasync mintProofs(\n\t\tamount: number,\n\t\tclearAuthToken: string,\n\t\toptions?: {\n\t\t\tkeysetId?: string;\n\t\t},\n\t): Promise<Proof[]> {\n\t\tconst keyset = await this.getKeys(options?.keysetId);\n\t\tconst outputData = OutputData.createRandomData(amount, keyset);\n\n\t\tconst mintPayload: BlindAuthMintPayload = {\n\t\t\toutputs: outputData.map((d) => d.blindedMessage),\n\t\t};\n\t\tconst { signatures } = await this.mint.mint(mintPayload, clearAuthToken);\n\t\tconst authProofs = outputData.map((d, i) => d.toProof(signatures[i], keyset));\n\t\tif (authProofs.some((p) => !hasValidDleq(p, keyset))) {\n\t\t\tthrow new Error('Mint returned auth proofs with invalid DLEQ');\n\t\t}\n\t\treturn authProofs;\n\t}\n}\n\nexport { CashuAuthWallet };\n","import { CashuAuthMint } from './CashuAuthMint';\nimport { CashuAuthWallet } from './CashuAuthWallet';\nimport { encodeJsonToBase64 } from '../base64';\nimport { type Proof } from '../model/types';\n\n/**\n * Helper function to encode a cashu auth token authA.\n *\n * @param proof\n */\nexport function getEncodedAuthToken(proof: Proof): string {\n\tconst token = {\n\t\tid: proof.id,\n\t\tsecret: proof.secret,\n\t\tC: proof.C,\n\t};\n\tconst base64Data = encodeJsonToBase64(token);\n\tconst prefix = 'auth';\n\tconst version = 'A';\n\treturn prefix + version + base64Data;\n}\n\nexport async function getBlindedAuthToken(amount: number, url: string, clearAuthToken: string) {\n\tconst authMint = new CashuAuthMint(url);\n\tconst authWallet = new CashuAuthWallet(authMint);\n\tconst authProofs = await authWallet.mintProofs(amount, clearAuthToken);\n\treturn authProofs.map((p) => getEncodedAuthToken(p));\n}\n\nexport { CashuAuthMint, CashuAuthWallet };\n"],"names":["isResultKeyType","value","encodeCBOR","buffer","encodeItem","encodeUnsigned","encodeString","encodeArray","encodeByteString","encodeObject","length","i","utf8","item","keys","key","decodeCBOR","data","view","decodeItem","offset","initialByte","majorType","additionalInfo","decodeUnsigned","decodeSigned","decodeByteString","decodeString","decodeArray","decodeMap","decodeSimpleAndFloat","decodeLength","hi","lo","newOffset","bytes","array","currentOffset","result","map","keyResult","valueResult","decodeFloat16","uint16","exponent","fraction","sign","PaymentRequest","transport","id","amount","unit","mints","description","singleUse","nut10","rawRequest","t","Bytes","type","rawPaymentRequest","transports","encodedRequest","encodedData","encodeBase64toUint8","decoded","TOKEN_VERSION","TOKEN_PREFIX","splitAmount","keyset","split","order","totalSplitAmount","sumArray","positive","amt","totalPositive","hasCorrespondingKey","sortedKeyAmounts","getKeysetAmounts","q","a","b","getKeepAmounts","proofsWeHave","amountToKeep","targetCount","amountsWeWant","amountsWeHave","p","countWeHave","countWeWant","amountDiff","k","bytesToNumber","hexToNumber","bytesToHex","hex","numberToHexPadded64","number","isValidHex","str","hasNonHexId","proof","getEncodedTokenV3","token","removeDleq","convertToShortKeysetId","stripDleq","v3TokenObj","encodeJsonToBase64","proofs","newP","getEncodedToken","opts","getEncodedTokenV4","tokenTemplate","templateFromToken","prefix","version","base64Data","encodeUint8toBase64Url","idMap","mint","hexToBytes","tokenFromTemplate","template","decodedToken","getDecodedToken","tokenString","keysets","removePrefix","handleTokens","mapShortKeysetIds","getTokenMetadata","tokenObj","sumProofs","encodedToken","parsedV3Token","encodeBase64ToJson","entry","uInt8Token","tokenData","deriveKeysetId","expiry","versionByte","isDeprecatedBase64","pubkeysConcat","pubKey","prev","curr","hash","sha256","mergeUInt8Arrays","hashHex","a1","a2","mergedArray","isObj","v","joinUrls","parts","part","sanitizeUrl","url","acc","decodePaymentRequest","paymentRequest","MessageNode","message","node","MessageQueue","messageNode","newNode","verifyKeysetId","isBase64","isBase64String","newProofs","idBytes","found","hasValidDleq","dleq","verifyDLEQProof_reblind","pointFromHex","concatByteArrays","arrays","totalLength","c","byteArray","pointer","getEncodedTokenBinary","utf8Encoder","binaryTemplate","getDecodedTokenBinary","utfDecoder","binaryToken","arr","_WS","injectWebSocketImpl","ws","getWebSocketImpl","LogLevel","NULL_LOGGER","_ConsoleLogger","minLevel","level","context","levelPrefix","interpolatedMessage","usedKeys","processedContext","match","filteredContext","consoleMethod","ConsoleLogger","measureTime","start","ConnectionManager","logger","newConn","WSConnection","resolve","reject","err","e","cb","method","params","subId","callback","errorCallback","fn","parsed","notification","CheckStateEnum","MeltQuoteState","MintQuoteState","PaymentRequestTransportType","HttpResponseError","status","NetworkError","MintOperationError","code","detail","globalRequestOptions","requestLogger","setGlobalRequestOptions","options","setRequestLogger","_request","endpoint","requestBody","requestHeaders","body","headers","response","errorData","errorMessage","request","handleMeltQuoteResponseDeprecated","handleMintQuoteResponseDeprecated","handleMintInfoContactFieldDeprecated","contact","MintInfo","info","o","num","path","isProtectedEndpoint","mintMeltInfo","CashuMint","_mintUrl","_customRequest","authTokenGetter","mintUrl","customRequest","mintLogger","swapPayload","blindAuthToken","requestInstance","mintQuotePayload","quote","mintPayload","meltQuotePayload","meltPayload","checkPayload","keysetId","restorePayload","wsSegment","BlindedMessage","B_","isOutputDataFactory","RESERVED_P2PK_TAGS","MAX_SECRET_LENGTH","OutputData","blindedMessage","blidingFactor","secret","sig","blindSignature","A","constructProofFromPromise","serializeProof","p2pk","customSplit","lockKeys","refundKeys","reqLock","reqRefund","pubkeys","refund","tags","ts","normalized","vals","newSecret","randomBytes","charCount","secretBytes","r","blindMessage","randomHex","seed","counter","deriveSecret","secretBytesAsHex","utf8SecretBytes","deterministicR","deriveBlindingFactor","DEFAULT_DENOMINATION_TARGET","DEFAULT_UNIT","CashuWallet","infoRes","activeKeysets","activeKeyset","unitKeysets","forceRefresh","op","requireDleq","outputAmounts","pubkey","privkey","outputData","newOutputData","swapTransaction","signatures","d","orderedProofs","s","offline","includeFees","includeDleq","keepProofsOffline","sendProofOffline","expectedFee","sendRes","keep","send","serialized","amountToSend","MAX_TRIALS","MAX_OVRPCT","MAX_OVRAMT","MAX_TIMEMS","MAX_P2SWAP","exactMatch","timer","bestSubset","bestDelta","bestAmount","bestFeePPK","sumExFees","feePPK","shuffleArray","shuffled","j","binarySearchIndex","lessOrEqual","left","right","mid","midValue","insertSorted","obj","calculateDelta","totalAmount","totalFeePPK","proofWithFees","ppkfee","exFee","spendableProofs","endIndex","biggerIndex","nextBiggerExFee","rightIndex","totalNetSum","maxOverAmount","trial","S","newAmount","newFeePPK","netSum","SSet","others","indices","_","objP","tempAmount","tempFeePPK","tempNetSum","target","qIndex","objQ","delta","tempS","tempDelta","bestSum","bestProofs","bestSubsetSet","sumPPK","nInputs","amountAvailable","sendAmounts","outputFee","sendAmountsFee","keepProofs","sendProofs","keepAmounts","keepOutputData","sendOutputData","swapProofs","splitProofsToKeep","splitProofsToSend","reorderedKeepVector","reorderedProofs","gapLimit","batchSize","requiredEmptyBatches","restoredProofs","lastCounterWithSignature","emptyBatchesFound","restoreRes","count","zeros","outputs","signatureMap","matchingSig","res","supported","mintInfo","quoteId","baseRes","privateKey","invoice","meltQuote","offer","amountMsat","millisatPartialAmount","meltOptions","proofsToSend","customOutputData","total","keepAmount","factory","signP2PKProofs","witness","mergedBlindingData","keepVector","sortedOutputData","sortedKeepVector","enc","Ys","hashToCurve","BATCH_SIZE","states","YsSlice","batchStates","stateMap","state","quoteIds","proofMap","y","ys","newBlindingData","amounts","blindedMessages","signMintQuote","meltResponse","CashuAuthMint","clearAuthToken","CashuAuthWallet","authProofs","getEncodedAuthToken","getBlindedAuthToken","authMint"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAQA,SAASA,GAAgBC,CAAAA,EAA4C;IACpE,OAAO,OAAOA,KAAU,YAAY,OAAOA,KAAU;AACtD;AAOO,SAASC,GAAWD,CAAAA,EAA4B;IACtD,MAAME,IAAmB,CAAA,CAAA;IACzB,OAAAC,GAAWH,GAAOE,CAAM,GACjB,IAAI,WAAWA,CAAM;AAC7B;AAEA,SAASC,GAAWH,CAAAA,EAAgBE,CAAAA,EAAkB;IACrD,IAAIF,MAAU,MACbE,EAAO,IAAA,CAAK,GAAI;SAAA,IACNF,MAAU,KAAA,GACpBE,EAAO,IAAA,CAAK,GAAI;SAAA,IACN,OAAOF,KAAU,WAC3BE,EAAO,IAAA,CAAKF,IAAQ,MAAO,GAAI;SAAA,IACrB,OAAOA,KAAU,UAC3BI,GAAeJ,GAAOE,CAAM;SAAA,IAClB,OAAOF,KAAU,UAC3BK,GAAaL,GAAOE,CAAM;SAAA,IAChB,MAAM,OAAA,CAAQF,CAAK,GAC7BM,GAAYN,GAAOE,CAAM;SAAA,IACfF,aAAiB,YAC3BO,GAAiBP,GAAOE,CAAM;SAAA,IAAA,kDAAA;IAG9B,OAAOF,KAAU,YACjBA,MAAU,QACV,CAAC,MAAM,OAAA,CAAQA,CAAK,GAEpBQ,GAAaR,GAAkCE,CAAM;SAErD,MAAM,IAAI,MAAM,kBAAkB;AAEpC;AAEA,SAASE,GAAeJ,CAAAA,EAAeE,CAAAA,EAAkB;IACxD,IAAIF,IAAQ,IACXE,EAAO,IAAA,CAAKF,CAAK;SAAA,IACPA,IAAQ,KAClBE,EAAO,IAAA,CAAK,IAAMF,CAAK;SAAA,IACbA,IAAQ,OAClBE,EAAO,IAAA,CAAK,IAAMF,KAAS,GAAGA,IAAQ,GAAI;SAAA,IAChCA,IAAQ,YAClBE,EAAO,IAAA,CAAK,IAAMF,KAAS,IAAKA,KAAS,KAAM,KAAOA,KAAS,IAAK,KAAMA,IAAQ,GAAI;SAEtF,MAAM,IAAI,MAAM,0BAA0B;AAE5C;AAEA,SAASO,GAAiBP,CAAAA,EAAmBE,CAAAA,EAAkB;IAC9D,MAAMO,IAAST,EAAM,MAAA;IAErB,IAAIS,IAAS,IACZP,EAAO,IAAA,CAAK,KAAOO,CAAM;SAAA,IACfA,IAAS,KACnBP,EAAO,IAAA,CAAK,IAAMO,CAAM;SAAA,IACdA,IAAS,OACnBP,EAAO,IAAA,CAAK,IAAOO,KAAU,IAAK,KAAMA,IAAS,GAAI;SAAA,IAC3CA,IAAS,YACnBP,EAAO,IAAA,CACN,IACCO,KAAU,KAAM,KAChBA,KAAU,KAAM,KAChBA,KAAU,IAAK,KAChBA,IAAS;SAGV,MAAM,IAAI,MAAM,gCAAgC;IAGjD,IAAA,IAASC,IAAI,GAAGA,IAAIV,EAAM,MAAA,EAAQU,IACjCR,EAAO,IAAA,CAAKF,CAAAA,CAAMU,CAAC,CAAC;AAEtB;AAEA,SAASL,GAAaL,CAAAA,EAAeE,CAAAA,EAAkB;IACtD,MAAMS,IAAO,IAAI,cAAc,MAAA,CAAOX,CAAK,GACrCS,IAASE,EAAK,MAAA;IAEpB,IAAIF,IAAS,IACZP,EAAO,IAAA,CAAK,KAAOO,CAAM;SAAA,IACfA,IAAS,KACnBP,EAAO,IAAA,CAAK,KAAMO,CAAM;SAAA,IACdA,IAAS,OACnBP,EAAO,IAAA,CAAK,KAAOO,KAAU,IAAK,KAAMA,IAAS,GAAI;SAAA,IAC3CA,IAAS,YACnBP,EAAO,IAAA,CACN,KACCO,KAAU,KAAM,KAChBA,KAAU,KAAM,KAChBA,KAAU,IAAK,KAChBA,IAAS;SAGV,MAAM,IAAI,MAAM,2BAA2B;IAG5C,IAAA,IAASC,IAAI,GAAGA,IAAIC,EAAK,MAAA,EAAQD,IAChCR,EAAO,IAAA,CAAKS,CAAAA,CAAKD,CAAC,CAAC;AAErB;AAEA,SAASJ,GAAYN,CAAAA,EAAkBE,CAAAA,EAAkB;IACxD,MAAMO,IAAST,EAAM,MAAA;IACrB,IAAIS,IAAS,IACZP,EAAO,IAAA,CAAK,MAAOO,CAAM;SAAA,IACfA,IAAS,KACnBP,EAAO,IAAA,CAAK,KAAMO,CAAM;SAAA,IACdA,IAAS,OACnBP,EAAO,IAAA,CAAK,KAAMO,KAAU,GAAGA,IAAS,GAAI;SAE5C,MAAM,IAAI,MAAM,0BAA0B;IAG3C,KAAA,MAAWG,KAAQZ,EAClBG,GAAWS,GAAMV,CAAM;AAEzB;AAEA,SAASM,GAAaR,CAAAA,EAAgCE,CAAAA,EAAkB;IACvE,MAAMW,IAAO,OAAO,IAAA,CAAKb,CAAK;IAC9BI,GAAeS,EAAK,MAAA,EAAQX,CAAM,GAClCA,CAAAA,CAAOA,EAAO,MAAA,GAAS,CAAC,CAAA,IAAK;IAC7B,KAAA,MAAWY,KAAOD,EACjBR,GAAaS,GAAKZ,CAAM,GACxBC,GAAWH,CAAAA,CAAMc,CAAG,CAAA,EAAGZ,CAAM;AAE/B;AAEO,SAASa,GAAWC,CAAAA,EAA+B;IACzD,MAAMC,IAAO,IAAI,SAASD,EAAK,MAAA,EAAQA,EAAK,UAAA,EAAYA,EAAK,UAAU;IAEvE,OADeE,GAAWD,GAAM,CAAC,EACnB,KAAA;AACf;AAEA,SAASC,GAAWD,CAAAA,EAAgBE,CAAAA,EAA2C;IAC9E,IAAIA,KAAUF,EAAK,UAAA,EAClB,MAAM,IAAI,MAAM,wBAAwB;IAEzC,MAAMG,IAAcH,EAAK,QAAA,CAASE,GAAQ,GACpCE,IAAYD,KAAe,GAC3BE,IAAiBF,IAAc;IAErC,OAAQC,GAAA;QACP,KAAK;YACJ,OAAOE,GAAeN,GAAME,GAAQG,CAAc;QACnD,KAAK;YACJ,OAAOE,GAAaP,GAAME,GAAQG,CAAc;QACjD,KAAK;YACJ,OAAOG,GAAiBR,GAAME,GAAQG,CAAc;QACrD,KAAK;YACJ,OAAOI,GAAaT,GAAME,GAAQG,CAAc;QACjD,KAAK;YACJ,OAAOK,GAAYV,GAAME,GAAQG,CAAc;QAChD,KAAK;YACJ,OAAOM,GAAUX,GAAME,GAAQG,CAAc;QAC9C,KAAK;YACJ,OAAOO,GAAqBZ,GAAME,GAAQG,CAAc;QACzD;YACC,MAAM,IAAI,MAAM,CAAA,wBAAA,EAA2BD,CAAS,EAAE;IAAA;AAEzD;AAEA,SAASS,EACRb,CAAAA,EACAE,CAAAA,EACAG,CAAAA,EACuB;IACvB,IAAIA,IAAiB,GAAI,CAAA,OAAO;QAAE,OAAOA;QAAgB,QAAAH;IAAA;IACzD,IAAIG,MAAmB,GAAI,CAAA,OAAO;QAAE,OAAOL,EAAK,QAAA,CAASE,GAAQ;QAAG,QAAAA;IAAA;IACpE,IAAIG,MAAmB,IAAI;QAC1B,MAAMtB,IAAQiB,EAAK,SAAA,CAAUE,GAAQ,CAAA,CAAK;QAC1C,OAAAA,KAAU,GACH;YAAE,OAAAnB;YAAO,QAAAmB;QAAA;IACjB;IACA,IAAIG,MAAmB,IAAI;QAC1B,MAAMtB,IAAQiB,EAAK,SAAA,CAAUE,GAAQ,CAAA,CAAK;QAC1C,OAAAA,KAAU,GACH;YAAE,OAAAnB;YAAO,QAAAmB;QAAA;IACjB;IACA,IAAIG,MAAmB,IAAI;QAC1B,MAAMS,IAAKd,EAAK,SAAA,CAAUE,GAAQ,CAAA,CAAK,GACjCa,IAAKf,EAAK,SAAA,CAAUE,IAAS,GAAG,CAAA,CAAK;QAC3C,OAAAA,KAAU,GACH;YAAE,OAAOY,IAAK,KAAK,KAAKC;YAAI,QAAAb;QAAA;IACpC;IACA,MAAM,IAAI,MAAM,CAAA,oBAAA,EAAuBG,CAAc,EAAE;AACxD;AAEA,SAASC,GACRN,CAAAA,EACAE,CAAAA,EACAG,CAAAA,EACuB;IACvB,MAAM,EAAE,OAAAtB,CAAAA,EAAO,QAAQiC,CAAAA,CAAA,CAAA,GAAcH,EAAab,GAAME,GAAQG,CAAc;IAC9E,OAAO;QAAE,OAAAtB;QAAO,QAAQiC;IAAA;AACzB;AAEA,SAAST,GACRP,CAAAA,EACAE,CAAAA,EACAG,CAAAA,EACuB;IACvB,MAAM,EAAE,OAAAtB,CAAAA,EAAO,QAAQiC,CAAAA,CAAA,CAAA,GAAcH,EAAab,GAAME,GAAQG,CAAc;IAC9E,OAAO;QAAE,OAAO,CAAA,IAAKtB;QAAO,QAAQiC;IAAA;AACrC;AAEA,SAASR,GACRR,CAAAA,EACAE,CAAAA,EACAG,CAAAA,EAC2B;IAC3B,MAAM,EAAE,OAAOb,CAAAA,EAAQ,QAAQwB,CAAAA,EAAAA,GAAcH,EAAab,GAAME,GAAQG,CAAc;IACtF,IAAIW,IAAYxB,IAASQ,EAAK,UAAA,EAC7B,MAAM,IAAI,MAAM,wCAAwC;IAGzD,OAAO;QAAE,OADK,IAAI,WAAWA,EAAK,MAAA,EAAQA,EAAK,UAAA,GAAagB,GAAWxB,CAAM;QAC7D,QAAQwB,IAAYxB;IAAA;AACrC;AAEA,SAASiB,GACRT,CAAAA,EACAE,CAAAA,EACAG,CAAAA,EACuB;IACvB,MAAM,EAAE,OAAOb,CAAAA,EAAQ,QAAQwB,CAAAA,EAAAA,GAAcH,EAAab,GAAME,GAAQG,CAAc;IACtF,IAAIW,IAAYxB,IAASQ,EAAK,UAAA,EAC7B,MAAM,IAAI,MAAM,mCAAmC;IAEpD,MAAMiB,IAAQ,IAAI,WAAWjB,EAAK,MAAA,EAAQA,EAAK,UAAA,GAAagB,GAAWxB,CAAM;IAE7E,OAAO;QAAE,OADK,IAAI,cAAc,MAAA,CAAOyB,CAAK;QAC5B,QAAQD,IAAYxB;IAAA;AACrC;AAEA,SAASkB,GACRV,CAAAA,EACAE,CAAAA,EACAG,CAAAA,EAC8B;IAC9B,MAAM,EAAE,OAAOb,CAAAA,EAAQ,QAAQwB,CAAAA,EAAAA,GAAcH,EAAab,GAAME,GAAQG,CAAc,GAChFa,IAAQ,CAAA,CAAA;IACd,IAAIC,IAAgBH;IACpB,IAAA,IAAS,IAAI,GAAG,IAAIxB,GAAQ,IAAK;QAChC,MAAM4B,IAASnB,GAAWD,GAAMmB,CAAa;QAC7CD,EAAM,IAAA,CAAKE,EAAO,KAAK,GACvBD,IAAgBC,EAAO,MAAA;IACxB;IACA,OAAO;QAAE,OAAOF;QAAO,QAAQC;IAAA;AAChC;AAEA,SAASR,GACRX,CAAAA,EACAE,CAAAA,EACAG,CAAAA,EAC4C;IAC5C,MAAM,EAAE,OAAOb,CAAAA,EAAQ,QAAQwB,CAAAA,EAAAA,GAAcH,EAAab,GAAME,GAAQG,CAAc,GAChFgB,IAAsC,CAAA;IAC5C,IAAIF,IAAgBH;IACpB,IAAA,IAAS,IAAI,GAAG,IAAIxB,GAAQ,IAAK;QAChC,MAAM8B,IAAYrB,GAAWD,GAAMmB,CAAa;QAChD,IAAI,CAACrC,GAAgBwC,EAAU,KAAK,GACnC,MAAM,IAAI,MAAM,kBAAkB;QAEnC,MAAMC,IAActB,GAAWD,GAAMsB,EAAU,MAAM;QACrDD,CAAAA,CAAIC,EAAU,KAAK,CAAA,GAAIC,EAAY,KAAA,EACnCJ,IAAgBI,EAAY,MAAA;IAC7B;IACA,OAAO;QAAE,OAAOF;QAAK,QAAQF;IAAA;AAC9B;AAEA,SAASK,GAAcC,CAAAA,EAAwB;IAC9C,MAAMC,IAAAA,CAAYD,IAAS,KAAA,KAAW,IAChCE,IAAWF,IAAS,MACpBG,IAAOH,IAAS,QAAS,CAAA,IAAK;IAEpC,OAAIC,MAAa,IACTE,IAAO,KAAK,CAAA,KAAA,CAAOD,IAAW,IAAA,IAC3BD,MAAa,KAChBC,IAAW,MAAMC,IAAO,CAAA,IAAA,CAAA,IAEzBA,IAAO,KAAA,CAAMF,IAAW,EAAA,IAAA,CAAO,IAAIC,IAAW,IAAA;AACtD;AAEA,SAASf,GACRZ,CAAAA,EACAE,CAAAA,EACAG,CAAAA,EACqC;IACrC,IAAIA,IAAiB,IACpB,OAAQA,GAAA;QACP,KAAK;YACJ,OAAO;gBAAE,OAAO,CAAA;gBAAO,QAAAH;YAAA;QACxB,KAAK;YACJ,OAAO;gBAAE,OAAO,CAAA;gBAAM,QAAAA;YAAA;QACvB,KAAK;YACJ,OAAO;gBAAE,OAAO;gBAAM,QAAAA;YAAA;QACvB,KAAK;YACJ,OAAO;gBAAE,OAAO,KAAA;gBAAW,QAAAA;YAAA;QAC5B;YACC,MAAM,IAAI,MAAM,CAAA,sBAAA,EAAyBG,CAAc,EAAE;IAAA;IAG5D,IAAIA,MAAmB,GAAI,CAAA,OAAO;QAAE,OAAOL,EAAK,QAAA,CAASE,GAAQ;QAAG,QAAAA;IAAA;IACpE,IAAIG,MAAmB,IAAI;QAC1B,MAAMtB,IAAQyC,GAAcxB,EAAK,SAAA,CAAUE,GAAQ,CAAA,CAAK,CAAC;QACzD,OAAAA,KAAU,GACH;YAAE,OAAAnB;YAAO,QAAAmB;QAAA;IACjB;IACA,IAAIG,MAAmB,IAAI;QAC1B,MAAMtB,IAAQiB,EAAK,UAAA,CAAWE,GAAQ,CAAA,CAAK;QAC3C,OAAAA,KAAU,GACH;YAAE,OAAAnB;YAAO,QAAAmB;QAAA;IACjB;IACA,IAAIG,MAAmB,IAAI;QAC1B,MAAMtB,IAAQiB,EAAK,UAAA,CAAWE,GAAQ,CAAA,CAAK;QAC3C,OAAAA,KAAU,GACH;YAAE,OAAAnB;YAAO,QAAAmB;QAAA;IACjB;IACA,MAAM,IAAI,MAAM,CAAA,+BAAA,EAAkCG,CAAc,EAAE;AACnE;ACnUO,MAAMwB,GAAe;IAC3B,YACQC,CAAAA,EACAC,CAAAA,EACAC,CAAAA,EACAC,CAAAA,EACAC,CAAAA,EACAC,CAAAA,EACAC,IAAqB,CAAA,CAAA,EACrBC,CAAAA,CACN;QARM,IAAA,CAAA,SAAA,GAAAP,GACA,IAAA,CAAA,EAAA,GAAAC,GACA,IAAA,CAAA,MAAA,GAAAC,GACA,IAAA,CAAA,IAAA,GAAAC,GACA,IAAA,CAAA,KAAA,GAAAC,GACA,IAAA,CAAA,WAAA,GAAAC,GACA,IAAA,CAAA,SAAA,GAAAC,GACA,IAAA,CAAA,KAAA,GAAAC;IACL;IAEH,eAAe;QACd,MAAMC,IAAgC,CAAA;QACtC,OAAI,IAAA,CAAK,SAAA,IAAA,CACRA,EAAW,CAAA,GAAI,IAAA,CAAK,SAAA,CAAU,GAAA,CAAI,CAACC,IAAAA,CAAgC;gBAClE,GAAGA,EAAE,IAAA;gBACL,GAAGA,EAAE,MAAA;gBACL,GAAGA,EAAE,IAAA;YAAA,CAAA,CACJ,CAAA,GAEC,IAAA,CAAK,EAAA,IAAA,CACRD,EAAW,CAAA,GAAI,IAAA,CAAK,EAAA,GAEjB,IAAA,CAAK,MAAA,IAAA,CACRA,EAAW,CAAA,GAAI,IAAA,CAAK,MAAA,GAEjB,IAAA,CAAK,IAAA,IAAA,CACRA,EAAW,CAAA,GAAI,IAAA,CAAK,IAAA,GAEjB,IAAA,CAAK,KAAA,IAAA,CACRA,EAAW,CAAA,GAAI,IAAA,CAAK,KAAA,GAEjB,IAAA,CAAK,WAAA,IAAA,CACRA,EAAW,CAAA,GAAI,IAAA,CAAK,WAAA,GAEjB,IAAA,CAAK,SAAA,IAAA,CACRA,EAAW,CAAA,GAAI,IAAA,CAAK,SAAA,GAEjB,IAAA,CAAK,KAAA,IAAA,CACRA,EAAW,KAAA,GAAQ;YAClB,GAAG,IAAA,CAAK,KAAA,CAAM,IAAA;YACd,GAAG,IAAA,CAAK,KAAA,CAAM,IAAA;YACd,GAAG,IAAA,CAAK,KAAA,CAAM,IAAA;QAAA,CAAA,GAGTA;IACR;IAEA,mBAAmB;QAClB,MAAMA,IAAgC,IAAA,CAAK,YAAA,CAAA,GACrCvC,IAAOf,GAAWsD,CAAU;QAElC,OAAO,UADaE,6OAAAA,CAAM,QAAA,CAASzC,CAAI;IAExC;IAEA,aAAa0C,CAAAA,EAAmC;QAC/C,OAAO,IAAA,CAAK,SAAA,EAAW,KAAK,CAACF,IAA+BA,EAAE,IAAA,KAASE,CAAI;IAC5E;IAEA,OAAO,eAAeC,CAAAA,EAAsD;QAC3E,MAAMC,IAAaD,EAAkB,CAAA,GAClCA,EAAkB,CAAA,CAAE,GAAA,CAAI,CAACH,IAAAA,CAAqB;gBAC9C,MAAMA,EAAE,CAAA;gBACR,QAAQA,EAAE,CAAA;gBACV,MAAMA,EAAE,CAAA;YAAA,CAAA,CACP,IACD,KAAA,GACGF,IAAQK,EAAkB,KAAA,GAC7B;YACA,MAAMA,EAAkB,KAAA,CAAM,CAAA;YAC9B,MAAMA,EAAkB,KAAA,CAAM,CAAA;YAC9B,MAAMA,EAAkB,KAAA,CAAM,CAAA;QAAA,IAE9B,KAAA;QACH,OAAO,IAAIb,GACVc,GACAD,EAAkB,CAAA,EAClBA,EAAkB,CAAA,EAClBA,EAAkB,CAAA,EAClBA,EAAkB,CAAA,EAClBA,EAAkB,CAAA,EAClBA,EAAkB,CAAA,EAClBL;IAEF;IAEA,OAAO,mBAAmBO,CAAAA,EAAwC;QACjE,IAAI,CAACA,EAAe,UAAA,CAAW,MAAM,GACpC,MAAM,IAAI,MAAM,gCAAgC;QAGjD,IADgBA,CAAAA,CAAe,CAAC,CAAA,KAChB,KACf,MAAM,IAAI,MAAM,wBAAwB;QAEzC,MAAMC,IAAcD,EAAe,KAAA,CAAM,CAAC,GACpC7C,QAAO+C,6OAAAA,EAAoBD,CAAW,GACtCE,IAAUjD,GAAWC,CAAI;QAC/B,OAAO,IAAA,CAAK,cAAA,CAAegD,CAAO;IACnC;AACD;AC5GA,MAAMC,KAAgB,KAChBC,KAAe;ACoCd,SAASC,EACfnE,CAAAA,EACAoE,CAAAA,EACAC,CAAAA,EACAC,CAAAA,EACW;IACX,IAAID,GAAO;QACV,MAAME,IAAmBC,GAASH,CAAK;QAGvC,IAAIrE,MAAU,KAAKuE,MAAqB,GACvC,OAAOF;QAIR,MAAMI,IAAWJ,EAAM,MAAA,CAAO,CAACK,IAAQA,IAAM,CAAC,GACxCC,IAAgBH,GAASC,CAAQ;QACvC,IAAIE,IAAgB3E,GACnB,MAAM,IAAI,MAAM,CAAA,oCAAA,EAAuC2E,CAAa,CAAA,GAAA,EAAM3E,CAAK,EAAE;QAElF,IAAIyE,EAAS,IAAA,CAAK,CAACC,IAAQ,CAACE,GAAoBF,GAAKN,CAAM,CAAC,GAC3D,MAAM,IAAI,MAAM,0EAA0E;QAI3F,IAAIO,MAAkB3E,GACrB,OAAOyE;QAIRJ,IAAQI,GACRzE,KAAS2E;IACV,OACCN,IAAQ,CAAA,CAAA;IAIT,MAAMQ,IAAmBC,GAAiBV,GAAQ,MAAM;IACxD,IAAI,CAACS,KAAoBA,EAAiB,MAAA,KAAW,GACpD,MAAM,IAAI,MAAM,6DAA6D;IAQ9E,IANAA,EAAiB,OAAA,CAAQ,CAACH,MAAgB;QACzC,IAAI1E,KAAS,KAAK0E,KAAO,EAAG,CAAA;QAC5B,MAAMK,IAAI,KAAK,KAAA,CAAM/E,IAAQ0E,CAAG;QAChC,IAAA,IAAS,IAAI,GAAG,IAAIK,GAAG,EAAE,EAAG,AAAAV,EAAM,IAAA,CAAKK,CAAG;QAC1C1E,KAAS0E;IACV,CAAC,GACG1E,MAAU,GACb,MAAM,IAAI,MAAM,CAAA,kCAAA,EAAqCA,CAAK,EAAE;IAI7D,OAAOqE,EAAM,IAAA,CAAK,CAACW,GAAGC,IAAkCD,IAAIC,CAAE;AAC/D;AAWO,SAASC,GACfC,CAAAA,EACAC,CAAAA,EACAvE,CAAAA,EACAwE,CAAAA,EACW;IAGX,MAAMC,IAA0B,CAAA,CAAA,EAC1BC,IAAgBJ,EAAa,GAAA,CAAI,CAACK,IAAaA,EAAE,MAAM;IACpCV,GAAiBjE,GAAM,KAAK,EACpC,OAAA,CAAQ,CAAC6D,MAAQ;QACjC,MAAMe,IAAcF,EAAc,MAAA,CAAO,CAACP,IAAMA,MAAMN,CAAG,EAAE,MAAA,EACrDgB,IAAc,KAAK,GAAA,CAAIL,IAAcI,GAAa,CAAC;QACzD,IAAA,IAAS/E,IAAI,GAAGA,IAAIgF,KACf,CAAA,CAAAJ,EAAc,MAAA,CAAO,CAACN,GAAGC,IAAMD,IAAIC,GAAG,CAAC,IAAIP,IAAMU,CAAAA,GADrB,EAAE1E,EAIlC4E,EAAc,IAAA,CAAKZ,CAAG;IAExB,CAAC;IAED,MAAMiB,IAAaP,IAAeE,EAAc,MAAA,CAAO,CAACN,GAAGC,IAAMD,IAAIC,GAAG,CAAC;IACzE,OAAIU,KACsBxB,EAAYwB,GAAY9E,CAAI,EACpC,OAAA,CAAQ,CAAC6D,MAAgB;QACzCY,EAAc,IAAA,CAAKZ,CAAG;IACvB,CAAC,GAEKY,EAAc,IAAA,CAAK,CAACN,GAAGC,IAAMD,IAAIC,CAAC;AAC1C;AAQO,SAASH,GAAiBV,CAAAA,EAAcE,IAAwB,MAAA,EAAkB;IACxF,OAAIA,KAAS,SACL,OAAO,IAAA,CAAKF,CAAM,EACvB,GAAA,CAAI,CAACwB,IAAc,SAASA,CAAC,CAAC,EAC9B,IAAA,CAAK,CAACZ,GAAWC,IAAcA,IAAID,CAAC,IAEhC,OAAO,IAAA,CAAKZ,CAAM,EACvB,GAAA,CAAI,CAACwB,IAAc,SAASA,CAAC,CAAC,EAC9B,IAAA,CAAK,CAACZ,GAAWC,IAAcD,IAAIC,CAAC;AACvC;AASO,SAASL,GAAoB3B,CAAAA,EAAgBmB,CAAAA,EAAuB;IAC1E,OAAOnB,KAAUmB;AAClB;AAQO,SAASyB,GAAc3D,CAAAA,EAA2B;IACxD,OAAO4D,OAAYC,6OAAAA,EAAW7D,CAAK,CAAC;AACrC;AAQO,SAAS4D,GAAYE,CAAAA,EAAqB;IAChD,OAAO,OAAO,CAAA,EAAA,EAAKA,CAAG,EAAE;AACzB;AAQO,SAASC,GAAoBC,CAAAA,EAAwB;IAC3D,OAAOA,EAAO,QAAA,CAAS,EAAE,EAAE,QAAA,CAAS,IAAI,GAAG;AAC5C;AAEO,SAASC,GAAWC,CAAAA,EAAa;IACvC,OAAO,eAAe,IAAA,CAAKA,CAAG;AAC/B;AAQO,SAASC,GAAYb,CAAAA,EAAoB;IAC/C,OAAI,MAAM,OAAA,CAAQA,CAAC,IACXA,EAAE,IAAA,CAAK,CAACc,IAAU,CAACH,GAAWG,EAAM,EAAE,CAAC,IAExC,CAACH,GAAWX,EAAE,EAAE;AACxB;AAaO,SAASe,GAAkBC,CAAAA,EAAcC,CAAAA,EAA8B;IACxEJ,GAAYG,EAAM,MAAM,KAAA,CAC5BA,EAAM,MAAA,GAASE,GAAuBF,EAAM,MAAM,CAAA,GAE/CC,KAAAA,CACHD,EAAM,MAAA,GAASG,GAAUH,EAAM,MAAM,CAAA;IAEtC,MAAMI,IAA8B;QAAE,OAAO;YAAC;gBAAE,MAAMJ,EAAM,IAAA;gBAAM,QAAQA,EAAM,MAAA;YAAA,CAAQ;SAAA;IAAA;IACxF,OAAIA,EAAM,IAAA,IAAA,CACTI,EAAW,IAAA,GAAOJ,EAAM,IAAA,GAErBA,EAAM,IAAA,IAAA,CACTI,EAAW,IAAA,GAAOJ,EAAM,IAAA,GAElBtC,KAAeD,SAAgB4C,6OAAAA,EAAmBD,CAAU;AACpE;AAKA,SAASF,GAAuBI,CAAAA,EAAiB;IAChD,OAAOA,EAAO,GAAA,CAAI,CAACtB,MAAM;QACxB,MAAMuB,IAAO;YAAE,GAAGvB,CAAAA;QAAA;QAClB,OAAAuB,EAAK,EAAA,GAAKA,EAAK,EAAA,CAAG,KAAA,CAAM,GAAG,EAAE,GACtBA;IACR,CAAC;AACF;AAQO,SAASC,GACfR,CAAAA,EACAS,CAAAA,EACS;IAGT,IADeZ,GAAYG,EAAM,MAAM,KACzBS,GAAM,YAAY,GAAG;QAClC,IAAIA,GAAM,YAAY,GACrB,MAAM,IAAI,MAAM,gEAAgE;QAEjF,OAAOV,GAAkBC,GAAOS,GAAM,UAAU;IACjD;IACA,OAAOC,GAAkBV,GAAOS,GAAM,UAAU;AACjD;AAEO,SAASC,GAAkBV,CAAAA,EAAcC,CAAAA,EAA8B;IAW7E,IAVIA,KAAAA,CACHD,EAAM,MAAA,GAASG,GAAUH,EAAM,MAAM,CAAA,GAGtCA,EAAM,MAAA,CAAO,OAAA,CAAQ,CAAChB,MAAM;QAC3B,IAAIA,EAAE,IAAA,IAAQA,EAAE,IAAA,CAAK,CAAA,IAAK,MACzB,MAAM,IAAI,MAAM,gDAAgD;IAElE,CAAC,GACca,GAAYG,EAAM,MAAM,GAEtC,MAAM,IAAI,MAAM,gEAAgE;IAGjFA,EAAM,MAAA,GAASE,GAAuBF,EAAM,MAAM;IAElD,MAAMW,IAAgBC,GAAkBZ,CAAK,GAEvC1C,IAAc7D,GAAWkH,CAAa,GACtCE,IAAS,SACTC,IAAU,KACVC,QAAaC,6OAAAA,EAAuB1D,CAAW;IACrD,OAAOuD,IAASC,IAAUC;AAC3B;AAEA,SAASH,GAAkBZ,CAAAA,EAA+B;IACzD,MAAMiB,IAAmC,CAAA,GACnCC,IAAOlB,EAAM,IAAA;IACnB,IAAA,IAAS9F,IAAI,GAAGA,IAAI8F,EAAM,MAAA,CAAO,MAAA,EAAQ9F,IAAK;QAC7C,MAAM4F,IAAQE,EAAM,MAAA,CAAO9F,CAAC,CAAA;QACxB+G,CAAAA,CAAMnB,EAAM,EAAE,CAAA,GACjBmB,CAAAA,CAAMnB,EAAM,EAAE,CAAA,CAAE,IAAA,CAAKA,CAAK,IAE1BmB,CAAAA,CAAMnB,EAAM,EAAE,CAAA,GAAI;YAACA,CAAK;SAAA;IAE1B;IACA,MAAMa,IAAiC;QACtC,GAAGO;QACH,GAAGlB,EAAM,IAAA,IAAQ;QACjB,GAAG,OAAO,IAAA,CAAKiB,CAAK,EAAE,GAAA,CACrB,CAACzE,IAAAA,CAA8B;gBAC9B,OAAG2E,6OAAAA,EAAW3E,CAAE;gBAChB,GAAGyE,CAAAA,CAAMzE,CAAE,CAAA,CAAE,GAAA,CACZ,CAACwC,IAAAA,CAA+B;wBAC/B,GAAGA,EAAE,MAAA;wBACL,GAAGA,EAAE,MAAA;wBACL,OAAGmC,6OAAAA,EAAWnC,EAAE,CAAC;wBACjB,GAAIA,EAAE,IAAA,IAAQ;4BACb,GAAG;gCACF,OAAGmC,6OAAAA,EAAWnC,EAAE,IAAA,CAAK,CAAC;gCACtB,OAAGmC,6OAAAA,EAAWnC,EAAE,IAAA,CAAK,CAAC;gCACtB,OAAGmC,6OAAAA,EAAWnC,EAAE,IAAA,CAAK,CAAA,IAAK,IAAI;4BAAA;wBAC/B,CAAA;wBAED,GAAIA,EAAE,OAAA,IAAW;4BAChB,GAAG,KAAK,SAAA,CAAUA,EAAE,OAAO;wBAAA,CAAA;oBAC5B,CAAA;YAEF,CAAA;IAEF;IAED,OAAIgB,EAAM,IAAA,IAAA,CACTW,EAAc,CAAA,GAAIX,EAAM,IAAA,GAElBW;AACR;AAEA,SAASS,GAAkBC,CAAAA,EAAkC;IAC5D,MAAMf,IAAkB,CAAA,CAAA;IACxBe,EAAS,CAAA,CAAE,OAAA,CAAQ,CAACrE,IACnBA,EAAE,CAAA,CAAE,OAAA,CAAQ,CAACgC,MAAM;YAClBsB,EAAO,IAAA,CAAK;gBACX,QAAQtB,EAAE,CAAA;gBACV,OAAGO,6OAAAA,EAAWP,EAAE,CAAC;gBACjB,QAAQA,EAAE,CAAA;gBACV,QAAIO,6OAAAA,EAAWvC,EAAE,CAAC;gBAClB,GAAIgC,EAAE,CAAA,IAAK;oBACV,MAAM;wBACL,OAAGO,6OAAAA,EAAWP,EAAE,CAAA,CAAE,CAAC;wBACnB,OAAGO,6OAAAA,EAAWP,EAAE,CAAA,CAAE,CAAC;wBACnB,OAAGO,6OAAAA,EAAWP,EAAE,CAAA,CAAE,CAAC;oBAAA;gBACpB,CAAA;gBAED,GAAIA,EAAE,CAAA,IAAK;oBACV,SAASA,EAAE,CAAA;gBAAA,CAAA;YACZ,CACA;QACF,CAAC;IAEF,MAAMsC,IAAsB;QAAE,MAAMD,EAAS,CAAA;QAAG,QAAAf;QAAQ,MAAMe,EAAS,CAAA,IAAK;IAAA;IAC5E,OAAIA,EAAS,CAAA,IAAA,CACZC,EAAa,IAAA,GAAOD,EAAS,CAAA,GAEvBC;AACR;AAQO,SAASC,GAAgBC,CAAAA,EAAqBC,CAAAA,EAAwB;IAC5ED,IAAcE,GAAaF,CAAW;IAEtC,MAAMxB,IAAQ2B,GAAaH,CAAW;IACtC,OAAAxB,EAAM,MAAA,GAAS4B,GAAkB5B,EAAM,MAAA,EAAQyB,CAAO,GAC/CzB;AACR;AAQO,SAAS6B,GAAiB7B,CAAAA,EAA8B;IAC9DA,IAAQ0B,GAAa1B,CAAK;IAC1B,MAAM8B,IAAWH,GAAa3B,CAAK;IACnC,OAAO;QACN,MAAM8B,EAAS,IAAA,IAAQ;QACvB,MAAMA,EAAS,IAAA;QACf,QAAQC,EAAUD,EAAS,MAAM;QACjC,kBAAkBA,EAAS,MAAA,CAAO,GAAA,CAAI,CAAC9C,IAAAA,CAAO;gBAC7C,QAAQA,EAAE,MAAA;gBACV,GAAGA,EAAE,CAAA;gBACL,QAAQA,EAAE,MAAA;gBACV,GAAIA,EAAE,IAAA,IAAQ;oBACb,MAAMA,EAAE,IAAA;gBAAA,CAAA;YACT,CAAA,CACC;QACF,GAAI8C,EAAS,IAAA,IAAQ;YAAE,MAAMA,EAAS,IAAA;QAAA,CAAA;IAAK;AAE7C;AAQO,SAASH,GAAa3B,CAAAA,EAAsB;IAClD,MAAMc,IAAUd,EAAM,KAAA,CAAM,GAAG,CAAC,GAC1BgC,IAAehC,EAAM,KAAA,CAAM,CAAC;IAClC,IAAIc,MAAY,KAAK;QACpB,MAAMmB,QAAgBC,6OAAAA,EAAoCF,CAAY;QACtE,IAAIC,EAAc,KAAA,CAAM,MAAA,GAAS,GAChC,MAAM,IAAI,MAAM,qCAAqC;QAEtD,MAAME,IAAQF,EAAc,KAAA,CAAM,CAAC,CAAA,EAC7BH,IAAkB;YACvB,MAAMK,EAAM,IAAA;YACZ,QAAQA,EAAM,MAAA;YACd,MAAMF,EAAc,IAAA,IAAQ;QAAA;QAE7B,OAAIA,EAAc,IAAA,IAAA,CACjBH,EAAS,IAAA,GAAOG,EAAc,IAAA,GAExBH;IACR,OAAA,IAAWhB,MAAY,KAAK;QAC3B,MAAMsB,QAAa7E,6OAAAA,EAAoByE,CAAY,GAC7CK,IAAY9H,GAAW6H,CAAU;QACvC,OAAOhB,GAAkBiB,CAAS;IACnC;IACA,MAAM,IAAI,MAAM,gCAAgC;AACjD;AAcO,SAASC,GACfjI,CAAAA,EACAqC,CAAAA,EACA6F,CAAAA,EACAC,IAAsB,CAAA,EACtBC,IAA8B,CAAA,CAAA,EAC7B;IACD,IAAIA,GAAoB;QACvB,MAAMC,IAAgB,OAAO,OAAA,CAAQrI,CAAI,EACvC,IAAA,CAAK,CAACmE,GAAqBC,IAAwB,CAACD,CAAAA,CAAE,CAAC,CAAA,GAAI,CAACC,CAAAA,CAAE,CAAC,CAAC,EAChE,GAAA,CAAI,CAAC,GAAGkE,CAAM,CAAA,GAAyBA,CAAM,EAC7C,MAAA,CAAO,CAACC,GAAcC,IAAiBD,IAAOC,GAAM,EAAE,GAClDC,QAAOC,iPAAAA,EAAO,IAAI,cAAc,MAAA,CAAOL,CAAa,CAAC;QAE3D,OADYzF,6OAAAA,CAAM,QAAA,CAAS6F,CAAI,EACpB,KAAA,CAAM,GAAG,EAAE;IACvB;IAEA,IAAIJ,IAAgB,OAAO,OAAA,CAAQrI,CAAI,EACrC,IAAA,CAAK,CAACmE,GAAqBC,IAAwB,CAACD,CAAAA,CAAE,CAAC,CAAA,GAAI,CAACC,CAAAA,CAAE,CAAC,CAAC,EAChE,GAAA,CAAI,CAAC,CAAA,EAAGkE,CAAM,CAAA,OAAyBxB,6OAAAA,EAAWwB,CAAM,CAAC,EACzD,MAAA,CAAO,CAACC,GAAkBC,IAAqBG,GAAiBJ,GAAMC,CAAI,GAAG,IAAI,YAAY,GAE3FC,GACAG;IACJ,OAAQT,GAAA;QACP,KAAK;YACJ,OAAAM,QAAOC,iPAAAA,EAAOL,CAAa,GAC3BO,IAAUhG,6OAAAA,CAAM,KAAA,CAAM6F,CAAI,EAAE,KAAA,CAAM,GAAG,EAAE,GAChC,OAAOG;QACf,KAAK;YACJ,IAAI,CAACvG,GACJ,MAAM,IAAI,MAAM,wDAAwD;YAEzE,OAAAgG,IAAgBM,GAAiBN,GAAezF,6OAAAA,CAAM,UAAA,CAAW,UAAUP,CAAI,CAAC,GAC5E6F,KAAAA,CACHG,IAAgBM,GACfN,GACAzF,6OAAAA,CAAM,UAAA,CAAW,kBAAkBsF,EAAO,QAAA,EAAU,EAAA,GAGtDO,QAAOC,iPAAAA,EAAOL,CAAa,GAC3BO,IAAUhG,6OAAAA,CAAM,KAAA,CAAM6F,CAAI,GACnB,OAAOG;QACf;YACC,MAAM,IAAI,MAAM,CAAA,gCAAA,EAAmCT,CAAW,EAAE;IAAA;AAEnE;AAEO,SAASQ,GAAiBE,CAAAA,EAAgBC,CAAAA,EAA4B;IAE5E,MAAMC,IAAc,IAAI,WAAWF,EAAG,MAAA,GAASC,EAAG,MAAM;IACxD,OAAAC,EAAY,GAAA,CAAIF,CAAE,GAClBE,EAAY,GAAA,CAAID,GAAID,EAAG,MAAM,GACtBE;AACR;AAMO,SAASC,EAAMC,CAAAA,EAAyB;IAC9C,OAAO,OAAOA,KAAM;AACrB;AAYO,SAASC,EAAAA,GAAYC,CAAAA,EAAyB;IACpD,OAAOA,EAAM,GAAA,CAAI,CAACC,IAAiBA,EAAK,OAAA,CAAQ,gBAAgB,EAAE,CAAC,EAAE,IAAA,CAAK,GAAG;AAC9E;AAEO,SAASC,GAAYC,CAAAA,EAAqB;IAChD,OAAOA,EAAI,OAAA,CAAQ,OAAO,EAAE;AAC7B;AAEO,SAAS5B,EAAUzB,CAAAA,EAAiB;IAC1C,OAAOA,EAAO,MAAA,CAAO,CAACsD,GAAa9D,IAAiB8D,IAAM9D,EAAM,MAAA,EAAQ,CAAC;AAC1E;AAEO,SAAS+D,GAAqBC,CAAAA,EAAwB;IAC5D,OAAOxH,GAAe,kBAAA,CAAmBwH,CAAc;AACxD;AAEO,MAAMC,GAAY;IAIxB,IAAW,QAAgB;QAC1B,OAAO,IAAA,CAAK,MAAA;IACb;IACA,IAAW,MAAMC,CAAAA,EAAiB;QACjC,IAAA,CAAK,MAAA,GAASA;IACf;IACA,IAAW,OAA2B;QACrC,OAAO,IAAA,CAAK,KAAA;IACb;IACA,IAAW,KAAKC,CAAAA,EAA0B;QACzC,IAAA,CAAK,KAAA,GAAQA;IACd;IAEA,YAAYD,CAAAA,CAAiB;QAC5B,IAAA,CAAK,MAAA,GAASA,GACd,IAAA,CAAK,KAAA,GAAQ;IACd;AACD;AAEO,MAAME,GAAa;IAIzB,IAAW,QAA4B;QACtC,OAAO,IAAA,CAAK,MAAA;IACb;IACA,IAAW,MAAMC,CAAAA,EAAiC;QACjD,IAAA,CAAK,MAAA,GAASA;IACf;IACA,IAAW,OAA2B;QACrC,OAAO,IAAA,CAAK,KAAA;IACb;IACA,IAAW,KAAKA,CAAAA,EAAiC;QAChD,IAAA,CAAK,KAAA,GAAQA;IACd;IAEA,IAAW,OAAe;QACzB,OAAO,IAAA,CAAK,KAAA;IACb;IACA,IAAW,KAAKb,CAAAA,EAAW;QAC1B,IAAA,CAAK,KAAA,GAAQA;IACd;IAEA,aAAc;QACb,IAAA,CAAK,MAAA,GAAS,MACd,IAAA,CAAK,KAAA,GAAQ,MACb,IAAA,CAAK,KAAA,GAAQ;IACd;IACA,QAAQU,CAAAA,EAA0B;QACjC,MAAMI,IAAU,IAAIL,GAAYC,CAAO;QACvC,OAAI,IAAA,CAAK,KAAA,KAAU,KAAK,CAAC,IAAA,CAAK,KAAA,GAAA,CAC7B,IAAA,CAAK,MAAA,GAASI,GACd,IAAA,CAAK,KAAA,GAAQA,CAAAA,IAAAA,CAEb,IAAA,CAAK,KAAA,CAAM,IAAA,GAAOA,GAClB,IAAA,CAAK,KAAA,GAAQA,CAAAA,GAEd,IAAA,CAAK,KAAA,IACE,CAAA;IACR;IACA,UAAyB;QACxB,IAAI,IAAA,CAAK,KAAA,KAAU,KAAK,CAAC,IAAA,CAAK,MAAA,CAAQ,CAAA,OAAO;QAE7C,MAAMxB,IAAO,IAAA,CAAK,MAAA;QAClB,OAAA,IAAA,CAAK,MAAA,GAASA,EAAK,IAAA,EACnBA,EAAK,IAAA,GAAO,MAEZ,IAAA,CAAK,KAAA,IACEA,EAAK,KAAA;IACb;AACD;AAMO,SAASzC,GAAUG,CAAAA,EAA6C;IACtE,OAAOA,EAAO,GAAA,CAAI,CAACtB,MAAM;QACxB,MAAMuB,IAAO;YAAE,GAAGvB,CAAAA;QAAA;QAClB,OAAA,OAAOuB,EAAK,IAAA,EACLA;IACR,CAAC;AACF;AASO,SAAS8D,GAAehK,CAAAA,EAAyB;IACvD,MAAMiK,QAAWC,6OAAAA,EAAelK,EAAK,EAAE,GACjCsF,IAAa,iBAAiB,IAAA,CAAKtF,EAAK,EAAE,GAC1CmI,IAAc7C,QAAawB,6OAAAA,EAAW9G,EAAK,EAAE,CAAA,CAAE,CAAC,CAAA,GAAI;IAC1D,OACCiI,GACCjI,EAAK,IAAA,EACLA,EAAK,IAAA,EACLA,EAAK,YAAA,EACLmI,GACA8B,KAAY,CAAC3E,OACRtF,EAAK,EAAA;AAEb;AAMA,SAASuH,GAAkBtB,CAAAA,EAAiBmB,CAAAA,EAAiC;IAC5E,MAAM+C,IAAY,CAAA,CAAA;IAClB,KAAA,MAAW1E,KAASQ,EAAQ;QAC3B,IAAImE;QACJ,IAAI;YACHA,QAAUtD,6OAAAA,EAAWrB,EAAM,EAAE;QAC9B,EAAA,OAAQ;YAEP0E,EAAU,IAAA,CAAK1E,CAAK;YACpB;QACD;QAEA,IAAI2E,CAAAA,CAAQ,CAAC,CAAA,KAAM,GAClBD,EAAU,IAAA,CAAK1E,CAAK;aAAA,IACV2E,CAAAA,CAAQ,CAAC,CAAA,KAAM,GAAM;YAC/B,IAAI,CAAChD,GACJ,MAAM,IAAI,MAAM,wEAAwE;YAGzF,IAAIiD,IAAQ,CAAA;YACZ,KAAA,MAAW9G,KAAU6D,EACpB,IAAI3B,EAAM,EAAA,KAAOlC,EAAO,EAAA,CAAG,KAAA,CAAM,GAAGkC,EAAM,EAAA,CAAG,MAAM,GAAG;gBACrDA,EAAM,EAAA,GAAKlC,EAAO,EAAA,EAClB4G,EAAU,IAAA,CAAK1E,CAAK,GACpB4E,IAAQ,CAAA;gBACR;YACD;YAED,IAAI,CAACA,GACJ,MAAM,IAAI,MACT,CAAA,6BAAA,EAAgC5E,EAAM,EAAE,CAAA,yCAAA,CAAA;QAG3C,OACC,MAAM,IAAI,MAAM,CAAA,2BAAA,EAA8B2E,CAAAA,CAAQ,CAAC,CAAC,EAAE;IAE5D;IAEA,OAAOD;AACR;AAUO,SAASG,GAAa7E,CAAAA,EAAclC,CAAAA,EAA2B;IACrE,IAAIkC,EAAM,IAAA,IAAQ,MACjB,OAAO,CAAA;IAER,MAAM8E,IAAO;QACZ,OAAGzD,6OAAAA,EAAWrB,EAAM,IAAA,CAAK,CAAC;QAC1B,OAAGqB,6OAAAA,EAAWrB,EAAM,IAAA,CAAK,CAAC;QAC1B,GAAGR,GAAYQ,EAAM,IAAA,CAAK,CAAA,IAAK,IAAI;IAAA;IAEpC,IAAI,CAAC1B,GAAoB0B,EAAM,MAAA,EAAQlC,EAAO,IAAI,GACjD,MAAM,IAAI,MAAM,CAAA,yBAAA,EAA4BkC,EAAM,MAAM,EAAE;IAE3D,MAAMxF,IAAMsD,EAAO,IAAA,CAAKkC,EAAM,MAAM,CAAA;IACpC,WAAO+E,iRAAAA,EACN,IAAI,YAAA,EAAc,MAAA,CAAO/E,EAAM,MAAM,GACrC8E,OACAE,6PAAAA,EAAahF,EAAM,CAAC,OACpBgF,6PAAAA,EAAaxK,CAAG;AAElB;AAmBA,SAASyK,GAAAA,GAAoBC,CAAAA,EAAkC;IAC9D,MAAMC,IAAcD,EAAO,MAAA,CAAO,CAACxG,GAAG0G,IAAM1G,IAAI0G,EAAE,MAAA,EAAQ,CAAC,GACrDC,IAAY,IAAI,WAAWF,CAAW;IAC5C,IAAIG,IAAU;IACd,IAAA,IAASlL,IAAI,GAAGA,IAAI8K,EAAO,MAAA,EAAQ9K,IAClCiL,EAAU,GAAA,CAAIH,CAAAA,CAAO9K,CAAC,CAAA,EAAGkL,CAAO,GAChCA,IAAUA,IAAUJ,CAAAA,CAAO9K,CAAC,CAAA,CAAE,MAAA;IAE/B,OAAOiL;AACR;AAEO,SAASE,GAAsBrF,CAAAA,EAA0B;IAC/D,MAAMsF,IAAc,IAAI,YAAA,GAClBjE,IAAWT,GAAkBZ,CAAK,GAClCuF,IAAiB9L,GAAW4H,CAAQ,GACpCR,IAASyE,EAAY,MAAA,CAAO,MAAM,GAClCxE,IAAUwE,EAAY,MAAA,CAAO,GAAG;IACtC,OAAOP,GAAiBlE,GAAQC,GAASyE,CAAc;AACxD;AAEO,SAASC,GAAsB9J,CAAAA,EAA0B;IAC/D,MAAM+J,IAAa,IAAI,YAAA,GACjB5E,IAAS4E,EAAW,MAAA,CAAO/J,EAAM,KAAA,CAAM,GAAG,CAAC,CAAC,GAC5CoF,IAAU2E,EAAW,MAAA,CAAO,IAAI,WAAW;QAAC/J,CAAAA,CAAM,CAAC,CAAC;KAAC,CAAC;IAC5D,IAAImF,MAAW,UAAUC,MAAY,KACpC,MAAM,IAAI,MAAM,0BAA0B;IAE3C,MAAM4E,IAAchK,EAAM,KAAA,CAAM,CAAC,GAC3B8B,IAAUjD,GAAWmL,CAAW;IACtC,OAAOtE,GAAkB5D,CAAO;AACjC;AAEA,SAASQ,GAAS2H,CAAAA,EAAe;IAChC,OAAOA,EAAI,MAAA,CAAO,CAACnH,GAAG0G,IAAM1G,IAAI0G,GAAG,CAAC;AACrC;AAEA,SAASxD,GAAa1B,CAAAA,EAAuB;IAE5C,OADoB;QAAC;QAAgB;QAAY;QAAU,OAAO;KAAA,CACtD,OAAA,CAAQ,CAACa,MAAmB;QAClCb,EAAM,UAAA,CAAWa,CAAM,KAAA,CAG5Bb,IAAQA,EAAM,KAAA,CAAMa,EAAO,MAAM,CAAA;IAClC,CAAC,GACMb;AACR;ACpxBA,IAAI4F;AAEA,OAAO,YAAc,OAAA,CACxBA,KAAM,SAAA;AAGA,SAASC,GAAoBC,CAAAA,EAAsB;IACzDF,KAAME;AACP;AAEO,SAASC,KAAmB;IAClC,IAAIH,OAAQ,KAAA,GACX,MAAM,IAAI,MAAM,0CAA0C;IAE3D,OAAOA;AACR;ACXO,MAAMI,IAAW;IACvB,OAAO;IACP,OAAO;IACP,MAAM;IACN,MAAM;IACN,OAAO;IACP,OAAO;AACR,GAoBaC,IAAsB;IAClC,QAAQ,EAAC;IACT,QAAQ,EAAC;IACT,OAAO,EAAC;IACR,OAAO,EAAC;IACR,QAAQ,EAAC;IACT,QAAQ,EAAC;IACT,MAAM,EAAC;AACR,GAcaC,IAAN,MAAMA,EAAgC;IAU5C,YAAYC,IAAqBH,EAAS,IAAA,CAAM;QAC/C,IAAA,CAAK,QAAA,GAAWG;IACjB;IAEQ,aAAaC,CAAAA,EAAiBpC,CAAAA,EAAiBqC,CAAAA,EAAyC;QAC/F,IAAIH,EAAc,QAAA,CAASE,CAAK,CAAA,GAAIF,EAAc,QAAA,CAAS,IAAA,CAAK,QAAQ,CAAA,CAAG,CAAA;QAC3E,MAAMI,IAAc,CAAA,CAAA,EAAIF,CAAK,CAAA,EAAA,CAAA;QAC7B,IAAIG,IAAsBvC;QAC1B,MAAMwC,IAAAA,aAAAA,GAAAA,IAAe,IAAA;QACrB,IAAIH,GAAS;YACZ,MAAMI,IAAmB,OAAO,WAAA,CAC/B,OAAO,OAAA,CAAQJ,CAAO,EAAE,GAAA,CAAI,CAAC,CAAC/L,GAAKd,CAAK,CAAA,GAAM;oBAC7Cc;oBACAd,aAAiB,QAAQ;wBAAE,SAASA,EAAM,OAAA;wBAAS,OAAOA,EAAM,KAAA;oBAAA,IAAUA;iBAC1E;YAEF+M,IAAsBvC,EAAQ,OAAA,CAAQ,cAAc,CAAC0C,GAAepM,MAAgB;gBACnF,IAAIA,KAAOmM,KAAoBA,CAAAA,CAAiBnM,CAAG,CAAA,KAAM,KAAA,GAAW;oBACnEkM,EAAS,GAAA,CAAIlM,CAAG;oBAChB,MAAMd,IAAiBiN,CAAAA,CAAiBnM,CAAG,CAAA;oBAC3C,OAAI,OAAOd,KAAU,WAAiBA,IAClC,OAAOA,KAAU,YAAY,OAAOA,KAAU,YAAkBA,EAAM,QAAA,CAAA,IACtEA,KAAS,OAAa,KACnB,KAAK,SAAA,CAAUA,CAAK;gBAC5B;gBACA,OAAOkN;YACR,CAAC;YACD,MAAMC,IAAkB,OAAO,WAAA,CAC9B,OAAO,OAAA,CAAQF,CAAgB,EAAE,MAAA,CAAO,CAAC,CAACnM,CAAG,CAAA,GAAM,CAACkM,EAAS,GAAA,CAAIlM,CAAG,CAAC,IAEhEsM,IAAgB,IAAA,CAAK,gBAAA,CAAiBR,CAAK;YAC7C,OAAO,IAAA,CAAKO,CAAe,EAAE,MAAA,GAAS,IACzCC,EAAcN,IAAcC,GAAqBI,CAAe,IAEhEC,EAAcN,IAAcC,CAAmB;QAEjD,OACC,IAAA,CAAK,gBAAA,CAAiBH,CAAK,EAAEE,IAAcC,CAAmB;IAEhE;IAAA,4DAAA;IAEQ,iBAAiBH,CAAAA,EAAgE;QACxF,OAAQA,GAAA;YACP,KAAKJ,EAAS,KAAA;YACd,KAAKA,EAAS,KAAA;gBACb,OAAO,QAAQ,KAAA;YAChB,KAAKA,EAAS,IAAA;gBACb,OAAO,QAAQ,IAAA;YAChB,KAAKA,EAAS,IAAA;gBACb,OAAO,QAAQ,IAAA;YAChB,KAAKA,EAAS,KAAA;gBACb,OAAO,QAAQ,KAAA;YAChB,KAAKA,EAAS,KAAA;gBACb,OAAO,QAAQ,KAAA;YAChB;gBAGC,OAAO,QAAQ,GAAA;QAAA;IAElB;IAAA,oBAAA;IAEA,MAAMhC,CAAAA,EAAiBqC,CAAAA,EAAyC;QAC/D,IAAA,CAAK,YAAA,CAAaL,EAAS,KAAA,EAAOhC,GAASqC,CAAO;IACnD;IACA,MAAMrC,CAAAA,EAAiBqC,CAAAA,EAAyC;QAC/D,IAAA,CAAK,YAAA,CAAaL,EAAS,KAAA,EAAOhC,GAASqC,CAAO;IACnD;IACA,KAAKrC,CAAAA,EAAiBqC,CAAAA,EAAyC;QAC9D,IAAA,CAAK,YAAA,CAAaL,EAAS,IAAA,EAAMhC,GAASqC,CAAO;IAClD;IACA,KAAKrC,CAAAA,EAAiBqC,CAAAA,EAAyC;QAC9D,IAAA,CAAK,YAAA,CAAaL,EAAS,IAAA,EAAMhC,GAASqC,CAAO;IAClD;IACA,MAAMrC,CAAAA,EAAiBqC,CAAAA,EAAyC;QAC/D,IAAA,CAAK,YAAA,CAAaL,EAAS,KAAA,EAAOhC,GAASqC,CAAO;IACnD;IACA,MAAMrC,CAAAA,EAAiBqC,CAAAA,EAAyC;QAC/D,IAAA,CAAK,YAAA,CAAaL,EAAS,KAAA,EAAOhC,GAASqC,CAAO;IACnD;IACA,IAAID,CAAAA,EAAiBpC,CAAAA,EAAiBqC,CAAAA,EAAyC;QAC9E,IAAA,CAAK,YAAA,CAAaD,GAAOpC,GAASqC,CAAO;IAC1C;AACD;AA1FCH,EAAuB,QAAA,GAAqC;IAC3D,CAACF,EAAS,KAAK,CAAA,EAAG;IAClB,CAACA,EAAS,KAAK,CAAA,EAAG;IAClB,CAACA,EAAS,IAAI,CAAA,EAAG;IACjB,CAACA,EAAS,IAAI,CAAA,EAAG;IACjB,CAACA,EAAS,KAAK,CAAA,EAAG;IAClB,CAACA,EAAS,KAAK,CAAA,EAAG;AAAA;AARb,IAAMa,KAANX;AAqGA,SAASY,KAAc;IAC7B,MAAMC,IAAQ,KAAK,GAAA,CAAA;IACnB,OAAO;QACN,SAAS,IACD,KAAK,GAAA,KAAQA;IACrB;AAEF;ACrJO,MAAMC,EAAkB;IAAxB,aAAA;QAEN,IAAA,CAAQ,aAAA,GAAA,aAAA,GAAA,IAA+C,IAAA;IAAI;IAE3D,OAAO,cAAc;QACpB,OAAKA,EAAkB,QAAA,IAAA,CACtBA,EAAkB,QAAA,GAAW,IAAIA,EAAA,CAAA,GAE3BA,EAAkB,QAAA;IAC1B;IAEA,cAAcrD,CAAAA,EAAasD,CAAAA,EAA+B;QACzD,IAAI,IAAA,CAAK,aAAA,CAAc,GAAA,CAAItD,CAAG,GAC7B,OAAO,IAAA,CAAK,aAAA,CAAc,GAAA,CAAIA,CAAG;QAElC,MAAMuD,IAAU,IAAIC,GAAaxD,GAAKsD,CAAM;QAC5C,OAAA,IAAA,CAAK,aAAA,CAAc,GAAA,CAAItD,GAAKuD,CAAO,GAC5BA;IACR;AACD;AAEO,MAAMC,GAAa;IAazB,YAAYxD,CAAAA,EAAasD,CAAAA,CAAiB;QAR1C,IAAA,CAAQ,YAAA,GAAuE,CAAA,GAC/E,IAAA,CAAQ,YAAA,GAAoD,CAAA,GAG5D,IAAA,CAAQ,KAAA,GAAQ,GAEhB,IAAA,CAAQ,gBAAA,GAAmD,CAAA,CAAA,EAG1D,IAAA,CAAK,GAAA,GAAMlB,GAAA,GACX,IAAA,CAAK,GAAA,GAAM,IAAI,IAAIpC,CAAG,GACtB,IAAA,CAAK,YAAA,GAAe,IAAIO,GAAA,GACxB,IAAA,CAAK,OAAA,GAAU+C,KAAUhB;IAC1B;IAEA,UAAU;QACT,OAAK,IAAA,CAAK,iBAAA,IAAA,CACT,IAAA,CAAK,iBAAA,GAAoB,IAAI,QAAQ,CAACmB,GAAwBC,MAAwB;YACrF,IAAI;gBACH,IAAA,CAAK,EAAA,GAAK,IAAI,IAAA,CAAK,GAAA,CAAI,IAAA,CAAK,GAAA,CAAI,QAAA,EAAU,GAC1C,IAAA,CAAK,gBAAA,GAAmB,CAAA,CAAA;YACzB,EAAA,OAASC,GAAc;gBACtBD,EAAOC,aAAe,QAAQA,IAAM,IAAI,MAAM,OAAOA,CAAG,CAAC,CAAC;gBAC1D;YACD;YACA,IAAA,CAAK,EAAA,CAAG,MAAA,GAAS,MAAM;gBACtBF,EAAA;YACD,GACA,IAAA,CAAK,EAAA,CAAG,OAAA,GAAU,MAAM;gBACvBC,EAAO,IAAI,MAAM,0BAA0B,CAAC;YAC7C,GACA,IAAA,CAAK,EAAA,CAAG,SAAA,GAAY,CAACE,MAAoB;gBACxC,IAAA,CAAK,YAAA,CAAa,OAAA,CAAQA,EAAE,IAAc,GACrC,IAAA,CAAK,gBAAA,IAAA,CACT,IAAA,CAAK,gBAAA,GAAmB,YACvB,IAAA,CAAK,iBAAA,CAAkB,IAAA,CAAK,IAAI,GAChC,EAAA;YAGH,GACA,IAAA,CAAK,EAAA,CAAG,OAAA,GAAU,CAACA,MAAkB;gBACpC,IAAA,CAAK,iBAAA,GAAoB,KAAA,GACzB,IAAA,CAAK,gBAAA,CAAiB,OAAA,CAAQ,CAACC,IAAOA,EAAGD,CAAC,CAAC;YAC5C;QACD,CAAC,CAAA,GAEK,IAAA,CAAK,iBAAA;IACb;IAIA,YAAYE,CAAAA,EAAqCC,CAAAA,EAAmC;QACnF,IAAI,IAAA,CAAK,EAAA,EAAI,eAAe,GAAG;YAC9B,IAAID,MAAW,eACd;YAED,MAAA,IAAA,CAAK,OAAA,CAAQ,KAAA,CAAM,gDAAgD,GAC7D,IAAI,MAAM,iBAAiB;QAClC;QACA,MAAMjL,IAAK,IAAA,CAAK,KAAA;QAChB,IAAA,CAAK,KAAA;QACL,MAAMwH,IAAU,KAAK,SAAA,CAAU;YAAE,SAAS;YAAO,QAAAyD;YAAQ,QAAAC;YAAQ,IAAAlL;QAAAA,CAAI;QACrE,IAAA,CAAK,EAAA,EAAI,KAAKwH,CAAO;IACtB;IAAA;;GAAA,GAKA,kBAAkB2D,CAAAA,EAAe;QAChC,IAAA,CAAK,EAAA,EAAI,KAAK,KAAK,SAAA,CAAU;YAAC;YAASA,CAAK;SAAC,CAAC;IAC/C;IAEA,eAAmCA,CAAAA,EAAeC,CAAAA,EAAuC;QACxF,CAAC,IAAA,CAAK,YAAA,CAAaD,CAAK,CAAA,GAAI,IAAA,CAAK,YAAA,CAAaA,CAAK,CAAA,IAAK,CAAA,CAAA,EAAI,IAAA,CAC3DC;IAEF;IAEQ,eACPA,CAAAA,EACAC,CAAAA,EACArL,CAAAA,EACC;QACD,IAAA,CAAK,YAAA,CAAaA,CAAE,CAAA,GAAI;YAAE,UAAAoL;YAAU,eAAAC;QAAA;IACrC;IAEQ,kBAAkBrL,CAAAA,EAA6B;QACtD,OAAO,IAAA,CAAK,YAAA,CAAaA,CAAE,CAAA;IAC5B;IAEQ,eAAmCmL,CAAAA,EAAeC,CAAAA,EAAuC;QAChG,IAAK,IAAA,CAAK,YAAA,CAAaD,CAAK,CAAA,EAG5B;YAAA,IAAI,IAAA,CAAK,YAAA,CAAaA,CAAK,CAAA,CAAE,MAAA,KAAW,GAAG;gBAC1C,OAAO,IAAA,CAAK,YAAA,CAAaA,CAAK,CAAA;gBAC9B;YACD;YACA,IAAA,CAAK,YAAA,CAAaA,CAAK,CAAA,GAAI,IAAA,CAAK,YAAA,CAAaA,CAAK,CAAA,CAAE,MAAA,CACnD,CAACG,IAAOA,MAAQF;QAAA;IAElB;IAEA,MAAM,mBAAmB;QACpB,IAAA,CAAK,EAAA,EAAI,eAAe,KAC3B,MAAM,IAAA,CAAK,OAAA,CAAA;IAEb;IAEQ,oBAAoB;QAC3B,IAAI,IAAA,CAAK,YAAA,CAAa,IAAA,KAAS,GAAG;YACjC,cAAc,IAAA,CAAK,gBAAgB,GACnC,IAAA,CAAK,gBAAA,GAAmB,KAAA;YACxB;QACD;QACA,MAAM5D,IAAU,IAAA,CAAK,YAAA,CAAa,OAAA,CAAA;QAClC,IAAI+D;QACJ,IAAI;YAEH,IADAA,IAAS,KAAK,KAAA,CAAM/D,CAAO,GACvB,YAAY+D,KAAUA,EAAO,EAAA,IAAM,MAClC,IAAA,CAAK,YAAA,CAAaA,EAAO,EAAE,CAAA,IAAA,CAC9B,IAAA,CAAK,YAAA,CAAaA,EAAO,EAAE,CAAA,CAAE,QAAA,CAAA,GAC7B,IAAA,CAAK,iBAAA,CAAkBA,EAAO,EAAE,CAAA;iBAAA,IAEvB,WAAWA,KAAUA,EAAO,EAAA,IAAM,MACxC,IAAA,CAAK,YAAA,CAAaA,EAAO,EAAE,CAAA,IAAA,CAC9B,IAAA,CAAK,YAAA,CAAaA,EAAO,EAAE,CAAA,CAAE,aAAA,CAAc,IAAI,MAAMA,EAAO,KAAA,CAAM,OAAO,CAAC,GAC1E,IAAA,CAAK,iBAAA,CAAkBA,EAAO,EAAE,CAAA;iBAAA,IAEvB,YAAYA,KAClB,CAAA,CAAA,QAAQA,CAAAA,GAEL;gBACN,MAAMJ,IAAQI,EAAO,MAAA,EAAQ;gBAC7B,IAAI,CAACJ,GACJ;gBAED,IAAI,IAAA,CAAK,YAAA,CAAaA,CAAK,CAAA,EAAG,SAAS,GAAG;oBACzC,MAAMK,IAAeD;oBACrB,IAAA,CAAK,YAAA,CAAaJ,CAAK,CAAA,CAAE,OAAA,CAAQ,CAACH,IAAOA,EAAGQ,EAAa,MAAA,EAAQ,OAAO,CAAC;gBAC1E;YACD;QAEF,EAAA,OAAST,GAAG;YACX,IAAA,CAAK,OAAA,CAAQ,KAAA,CAAM,iCAAiC;gBAAE,GAAAA;YAAAA,CAAG;YACzD;QACD;IACD;IAEA,mBACCG,CAAAA,EACAE,CAAAA,EACAC,CAAAA,EACS;QACT,IAAI,IAAA,CAAK,EAAA,EAAI,eAAe,GAC3B,MAAA,IAAA,CAAK,OAAA,CAAQ,KAAA,CAAM,uDAAuD,GACpE,IAAI,MAAM,oBAAoB;QAErC,MAAMF,IAAAA,CAAS,KAAK,MAAA,CAAA,IAAW,CAAA,EAAG,QAAA,CAAS,EAAE,EAAE,SAAA,CAAU,CAAC;QAC1D,OAAA,IAAA,CAAK,cAAA,CACJ,MAAM;YACL,IAAA,CAAK,cAAA,CAAeA,GAAOC,CAAQ;QACpC,GACAC,GACA,IAAA,CAAK,KAAA,GAEN,IAAA,CAAK,WAAA,CAAY,aAAa;YAAE,GAAGH,CAAAA;YAAQ,OAAAC;QAAAA,CAAO,GAClD,IAAA,CAAK,KAAA,IACEA;IACR;IAAA;;;;;;GAAA,GASA,mBACCA,CAAAA,EACAC,CAAAA,EACAC,CAAAA,EACC;QACD,IAAA,CAAK,cAAA,CAAeF,GAAOC,CAAQ,GACnC,IAAA,CAAK,cAAA,CACJ,MAAM;YACL,IAAA,CAAK,OAAA,CAAQ,IAAA,CAAK,wBAAwB;gBAAE,OAAAD;YAAAA,CAAO;QACpD,GACAE,KAAAA,CAAkB,CAACN,IAAa,IAAA,CAAK,OAAA,CAAQ,KAAA,CAAM,sBAAsB;gBAAE,GAAAA;YAAA,CAAG,CAAA,GAC9E,IAAA,CAAK,KAAA,GAEN,IAAA,CAAK,WAAA,CAAY,eAAe;YAAE,OAAAI;QAAA,CAAO;IAC1C;IAEA,IAAI,sBAAsB;QACzB,OAAO,OAAO,IAAA,CAAK,IAAA,CAAK,YAAY;IACrC;IAEA,QAAQ;QACH,IAAA,CAAK,EAAA,IACR,IAAA,CAAK,EAAA,EAAI,MAAA;IAEX;IAEA,QAAQC,CAAAA,EAAmC;QAC1C,IAAA,CAAK,gBAAA,CAAiB,IAAA,CAAKA,CAAQ;IACpC;AACD;ACrNO,MAAMK,KAAiB;IAC7B,SAAS;IACT,SAAS;IACT,OAAO;AACR,GAqIaC,KAAiB;IAC7B,QAAQ;IACR,SAAS;IACT,MAAM;AACP,GAQaC,KAAiB;IAC7B,QAAQ;IACR,MAAM;IACN,QAAQ;AACT;AC1JO,IAAKC,KAAAA,aAAAA,GAAAA,CAAAA,CAAAA,IAAAA,CACXA,EAAA,IAAA,GAAO,QACPA,EAAA,KAAA,GAAQ,SAFGA,CAAAA,CAAAA,EAAAA,MAAA,CAAA,CAAA;AC5BL,MAAMC,WAA0B,MAAM;IAE5C,YAAYrE,CAAAA,EAAiBsE,CAAAA,CAAgB;QAC5C,KAAA,CAAMtE,CAAO,GACb,IAAA,CAAK,MAAA,GAASsE,GACd,IAAA,CAAK,IAAA,GAAO,qBACZ,OAAO,cAAA,CAAe,IAAA,EAAMD,GAAkB,SAAS;IACxD;AACD;AAKO,MAAME,WAAqB,MAAM;IACvC,YAAYvE,CAAAA,CAAiB;QAC5B,KAAA,CAAMA,CAAO,GACb,IAAA,CAAK,IAAA,GAAO,gBACZ,OAAO,cAAA,CAAe,IAAA,EAAMuE,GAAa,SAAS;IACnD;AACD;AAOO,MAAMC,WAA2BH,GAAkB;IAEzD,YAAYI,CAAAA,EAAcC,CAAAA,CAAgB;QACzC,KAAA,CAAMA,KAAU,gCAAgC,GAAG,GACnD,IAAA,CAAK,IAAA,GAAOD,GACZ,IAAA,CAAK,IAAA,GAAO,sBACZ,OAAO,cAAA,CAAe,IAAA,EAAMD,GAAmB,SAAS;IACzD;AACD;ACzBA,IAAIG,KAAgD,CAAA,GAChDC,KAAgB3C;AAQb,SAAS4C,GAAwBC,CAAAA,EAAwC;IAC/EH,KAAuBG;AACxB;AAOO,SAASC,GAAiB9B,CAAAA,EAAsB;IACtD2B,KAAgB3B;AACjB;AAEA,eAAe+B,GAAS,EACvB,UAAAC,CAAAA,EACA,aAAAC,CAAAA,EACA,SAASC,CAAAA,EACT,GAAGL,GACJ,EAAqC;IACpC,MAAMM,IAAOF,IAAc,KAAK,SAAA,CAAUA,CAAW,IAAI,KAAA,GACnDG,IAAU;QACV,QAAQ;QACb,GAAID,IAAO;YAAE,gBAAgB;QAAA,IAAuB,KAAA,CAAA;QACpD,GAAGD,CAAAA;IAAA;IAGJ,IAAIG;IACJ,IAAI;QACHA,IAAW,MAAM,MAAML,GAAU;YAAE,MAAAG;YAAM,SAAAC;YAAS,GAAGP,CAAAA;QAAAA,CAAS;IAC/D,EAAA,OAASxB,GAAK;QAGb,MAAM,IAAIiB,GAAajB,aAAe,QAAQA,EAAI,OAAA,GAAU,wBAAwB;IACrF;IAEA,IAAI,CAACgC,EAAS,EAAA,EAAI;QACjB,IAAIC;QACJ,IAAI;YACHA,IAAa,MAAMD,EAAS,IAAA,CAAA;QAC7B,EAAA,OAAQ;YACPC,IAAY;gBAAE,OAAO;YAAA;QACtB;QAEA,IACCD,EAAS,MAAA,KAAW,OACpB,UAAUC,KACV,OAAOA,EAAU,IAAA,IAAS,YAC1B,YAAYA,KACZ,OAAOA,EAAU,MAAA,IAAW,UAE5B,MAAM,IAAIf,GAAmBe,EAAU,IAAA,EAAMA,EAAU,MAAM;QAG9D,IAAIC,IAAe;QACnB,MAAI,WAAWD,KAAa,OAAOA,EAAU,KAAA,IAAU,WACtDC,IAAeD,EAAU,KAAA,GACf,YAAYA,KAAa,OAAOA,EAAU,MAAA,IAAW,YAAA,CAC/DC,IAAeD,EAAU,MAAA,GAGpB,IAAIlB,GAAkBmB,GAAcF,EAAS,MAAM;IAC1D;IAEA,IAAI;QACH,OAAO,MAAMA,EAAS,IAAA,CAAA;IACvB,EAAA,OAAShC,GAAK;QACb,MAAAsB,GAAc,KAAA,CAAM,iCAAiC;YAAE,KAAAtB;QAAA,CAAK,GACtD,IAAIe,GAAkB,gBAAgBiB,EAAS,MAAM;IAC5D;AACD;AAEA,eAA8BG,EAAWX,CAAAA,EAAqC;IAE7E,OADa,MAAME,GAAS;QAAE,GAAGF,CAAAA;QAAS,GAAGH,EAAAA;IAAAA,CAAsB;AAEpE;ACvFO,SAASe,GACfJ,CAAAA,EACArC,CAAAA,EAC2B;IAE3B,OAAKqC,EAAS,KAAA,IAAA,CACbrC,EAAO,IAAA,CACN,oHAEG,OAAOqC,EAAS,IAAA,IAAS,aAAA,CAC5BA,EAAS,KAAA,GAAQA,EAAS,IAAA,GAAOpB,GAAe,IAAA,GAAOA,GAAe,MAAA,CAAA,GAGjEoB;AACR;ACdO,SAASK,GACfL,CAAAA,EACArC,CAAAA,EAC2B;IAE3B,OAAKqC,EAAS,KAAA,IAAA,CACbrC,EAAO,IAAA,CACN,oHAEG,OAAOqC,EAAS,IAAA,IAAS,aAAA,CAC5BA,EAAS,KAAA,GAAQA,EAAS,IAAA,GAAOnB,GAAe,IAAA,GAAOA,GAAe,MAAA,CAAA,GAGjEmB;AACR;ACnBO,SAASM,GAAqCpP,CAAAA,EAAuByM,CAAAA,EAAgB;IAG3F,OAAI,MAAM,OAAA,CAAQzM,GAAM,OAAO,KAAKA,GAAM,QAAQ,SAAS,KAAA,CAC1DA,EAAK,OAAA,GAAUA,EAAK,OAAA,CAAQ,GAAA,CAAI,CAACqP,IAE/B,MAAM,OAAA,CAAQA,CAAO,KACrBA,EAAQ,MAAA,KAAW,KACnB,OAAOA,CAAAA,CAAQ,CAAC,CAAA,IAAM,YACtB,OAAOA,CAAAA,CAAQ,CAAC,CAAA,IAAM,WAAA,CAEtB5C,EAAO,IAAA,CACN,uGAEM;YAAE,QAAQ4C,CAAAA,CAAQ,CAAC,CAAA;YAAG,MAAMA,CAAAA,CAAQ,CAAC,CAAA;QAAA,CAAA,IAEtCA,CACP,CAAA,GAEKrP;AACR;AChBO,MAAMsP,GAAS;IASrB,YAAYC,CAAAA,CAAuB;QAClC,IAAA,CAAK,SAAA,GAAYA,GACbA,EAAK,IAAA,CAAK,EAAE,CAAA,IAAA,CACf,IAAA,CAAK,kBAAA,GAAqB;YACzB,OAAO,CAAA;YACP,WAAWA,EAAK,IAAA,CAAK,EAAE,CAAA,CAAE,mBAAA,CAAoB,GAAA,CAAI,CAACC,IAAAA,CAAO;oBACxD,QAAQA,EAAE,MAAA;oBACV,OAAO,IAAI,OAAOA,EAAE,IAAI;gBAAA,CAAA,CACvB;QAAA,CAAA;IAGL;IAMA,YAAYC,CAAAA,EAAa;QACxB,OAAQA,GAAA;YACP,KAAK;YACL,KAAK;gBACJ,OAAO,IAAA,CAAK,aAAA,CAAcA,CAAG;YAE9B,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;gBACJ,OAAO,IAAA,CAAK,eAAA,CAAgBA,CAAG;YAEhC,KAAK;gBACJ,OAAO,IAAA,CAAK,UAAA,CAAA;YAEb,KAAK;gBACJ,OAAO,IAAA,CAAK,UAAA,CAAA;YAEb;gBACC,MAAM,IAAI,MAAM,kCAAkC;QACnD;IAEF;IAEA,uBAAuBC,CAAAA,EAAc;QACpC,IAAI,CAAC,IAAA,CAAK,kBAAA,EACT,OAAO,CAAA;QAER,IAAI,OAAO,IAAA,CAAK,kBAAA,CAAmB,KAAA,CAAMA,CAAI,CAAA,IAAM,WAClD,OAAO,IAAA,CAAK,kBAAA,CAAmB,KAAA,CAAMA,CAAI,CAAA;QAE1C,MAAMC,IAAsB,IAAA,CAAK,kBAAA,CAAmB,SAAA,CAAU,IAAA,CAAK,CAAC5C,IAAMA,EAAE,KAAA,CAAM,IAAA,CAAK2C,CAAI,CAAC;QAC5F,OAAA,IAAA,CAAK,kBAAA,CAAmB,KAAA,CAAMA,CAAI,CAAA,GAAIC,GAC/BA;IACR;IAEQ,gBAAgBF,CAAAA,EAAyC;QAChE,OAAI,IAAA,CAAK,SAAA,CAAU,IAAA,CAAKA,CAAG,CAAA,EAAG,YACtB;YAAE,WAAW,CAAA;QAAA,IAEd;YAAE,WAAW,CAAA;QAAA;IACrB;IACQ,cAAcA,CAAAA,EAAY;QACjC,MAAMG,IAAe,IAAA,CAAK,SAAA,CAAU,IAAA,CAAKH,CAAG,CAAA;QAC5C,OAAIG,KAAgBA,EAAa,OAAA,CAAQ,MAAA,GAAS,KAAK,CAACA,EAAa,QAAA,GAC7D;YAAE,UAAU,CAAA;YAAO,QAAQA,EAAa,OAAA;QAAA,IAEzC;YAAE,UAAU,CAAA;YAAM,QAAQA,EAAa,OAAA;QAAA;IAC/C;IACQ,aAAa;QACpB,OAAI,IAAA,CAAK,SAAA,CAAU,IAAA,CAAK,EAAE,CAAA,IAAK,IAAA,CAAK,SAAA,CAAU,IAAA,CAAK,EAAE,CAAA,CAAE,SAAA,CAAU,MAAA,GAAS,IAClE;YAAE,WAAW,CAAA;YAAM,QAAQ,IAAA,CAAK,SAAA,CAAU,IAAA,CAAK,EAAE,CAAA,CAAE,SAAA;QAAA,IAEpD;YAAE,WAAW,CAAA;QAAA;IACrB;IACQ,aAAa;QACpB,OAAI,IAAA,CAAK,SAAA,CAAU,IAAA,CAAK,EAAE,CAAA,IAAK,IAAA,CAAK,SAAA,CAAU,IAAA,CAAK,EAAE,CAAA,CAAE,OAAA,CAAQ,MAAA,GAAS,IAChE;YAAE,WAAW,CAAA;YAAM,QAAQ,IAAA,CAAK,SAAA,CAAU,IAAA,CAAK,EAAE,CAAA,CAAE,OAAA;QAAA,IAEpD;YAAE,WAAW,CAAA;QAAA;IACrB;IAEA,IAAI,UAAU;QACb,OAAO,IAAA,CAAK,SAAA,CAAU,OAAA;IACvB;IAEA,IAAI,cAAc;QACjB,OAAO,IAAA,CAAK,SAAA,CAAU,WAAA;IACvB;IAEA,IAAI,mBAAmB;QACtB,OAAO,IAAA,CAAK,SAAA,CAAU,gBAAA;IACvB;IAEA,IAAI,OAAO;QACV,OAAO,IAAA,CAAK,SAAA,CAAU,IAAA;IACvB;IAEA,IAAI,SAAS;QACZ,OAAO,IAAA,CAAK,SAAA,CAAU,MAAA;IACvB;IAEA,IAAI,OAAO;QACV,OAAO,IAAA,CAAK,SAAA,CAAU,IAAA;IACvB;IAEA,IAAI,UAAU;QACb,OAAO,IAAA,CAAK,SAAA,CAAU,OAAA;IACvB;IAEA,IAAI,OAAO;QACV,OAAO,IAAA,CAAK,SAAA,CAAU,IAAA;IACvB;IAAA;;;;GAAA,GAOA,IAAI,4BAA4B;QAC/B,OAAO,IAAA,CAAK,SAAA,CAAU,IAAA,CAAK,CAAC,CAAA,EAAG,QAAQ,KACtC,CAAC3C,IAAWA,EAAO,MAAA,KAAW,YAAYA,EAAO,OAAA,EAAS,gBAAgB,CAAA;IAE5E;AACD;AClGA,MAAM4C,EAAU;IAAA;;;;;;GAAA,GAaf,YACSC,CAAAA,EACAC,CAAAA,EACRC,CAAAA,EACA1B,CAAAA,CAGC;QANO,IAAA,CAAA,QAAA,GAAAwB,GACA,IAAA,CAAA,cAAA,GAAAC,GAXT,IAAA,CAAQ,WAAA,GAAc,CAAA,GAiBrB,IAAA,CAAK,QAAA,GAAW7G,GAAY4G,CAAQ,GACpC,IAAA,CAAK,cAAA,GAAiBC,GAClBC,KAAAA,CACH,IAAA,CAAK,WAAA,GAAc,CAAA,GACnB,IAAA,CAAK,gBAAA,GAAmBA,CAAAA,GAEzB,IAAA,CAAK,OAAA,GAAU1B,GAAS,UAAU7C,GAClC8C,GAAiB,IAAA,CAAK,OAAO;IAC9B;IAAA,yDAAA;IAIA,IAAI,UAAU;QACb,OAAO,IAAA,CAAK,QAAA;IACb;IAAA;;;;;GAAA,GAQA,aAAoB,QACnB0B,CAAAA,EACAC,CAAAA,EACAzD,CAAAA,EAC2B;QAC3B,MAAM0D,IAAa1D,KAAUhB,GAEvBqD,IAAW,MAAA,CADOoB,KAAiBjB,CAAAA,EACe;YACvD,UAAUlG,EAASkH,GAAS,UAAU;QAAA,CACtC;QAED,OADab,GAAqCN,GAAUqB,CAAU;IAEvE;IAAA;;GAAA,GAIA,MAAM,UAAoC;QACzC,OAAON,EAAU,OAAA,CAAQ,IAAA,CAAK,QAAA,EAAU,IAAA,CAAK,cAAA,EAAgB,IAAA,CAAK,OAAO;IAC1E;IAEA,MAAM,kBAAqC;QAC1C,IAAI,IAAA,CAAK,SAAA,EACR,OAAO,IAAA,CAAK,SAAA;QAEb,MAAM7P,IAAO,MAAM6P,EAAU,OAAA,CAAQ,IAAA,CAAK,QAAA,EAAU,IAAA,CAAK,cAAc;QACvE,OAAA,IAAA,CAAK,SAAA,GAAY,IAAIP,GAAStP,CAAI,GAC3B,IAAA,CAAK,SAAA;IACb;IAAA;;;;;;;GAAA,GAUA,aAAoB,KACnBiQ,CAAAA,EACAG,CAAAA,EACAF,CAAAA,EACAG,CAAAA,EACwB;QACxB,MAAMC,IAAkBJ,KAAiBjB,GACnCJ,IAAkCwB,IAAiB;YAAE,cAAcA;QAAA,IAAmB,CAAA,GACtFrQ,IAAO,MAAMsQ,EAA8B;YAChD,UAAUvH,EAASkH,GAAS,UAAU;YACtC,QAAQ;YACR,aAAaG;YACb,SAAAvB;QAAA,CACA;QAED,IAAI,CAAChG,EAAM7I,CAAI,KAAK,CAAC,MAAM,OAAA,CAAQA,GAAM,UAAU,GAClD,MAAM,IAAI,MAAMA,EAAK,MAAA,IAAU,cAAc;QAG9C,OAAOA;IACR;IAAA;;;;;GAAA,GAOA,MAAM,KAAKoQ,CAAAA,EAAiD;QAC3D,MAAMC,IAAiB,MAAM,IAAA,CAAK,eAAA,CAAgB,UAAU;QAC5D,OAAOR,EAAU,IAAA,CAAK,IAAA,CAAK,QAAA,EAAUO,GAAa,IAAA,CAAK,cAAA,EAAgBC,CAAc;IACtF;IAAA;;;;;;;;GAAA,GAWA,aAAoB,gBACnBJ,CAAAA,EACAM,CAAAA,EACAL,CAAAA,EACAG,CAAAA,EACA5D,CAAAA,EACoC;QACpC,MAAM0D,IAAa1D,KAAUhB,GACvB6E,IAAkBJ,KAAiBjB,GACnCJ,IAAkCwB,IAAiB;YAAE,cAAcA;QAAA,IAAmB,CAAA,GACtFvB,IAAW,MAAMwB,EAErB;YACD,UAAUvH,EAASkH,GAAS,uBAAuB;YACnD,QAAQ;YACR,aAAaM;YACb,SAAA1B;QAAA,CACA;QAED,OADaM,GAAkCL,GAAUqB,CAAU;IAEpE;IAAA;;;;;;GAAA,GAQA,MAAM,gBAAgBI,CAAAA,EAAuE;QAC5F,MAAMF,IAAiB,MAAM,IAAA,CAAK,eAAA,CAAgB,uBAAuB;QACzE,OAAOR,EAAU,eAAA,CAChB,IAAA,CAAK,QAAA,EACLU,GACA,IAAA,CAAK,cAAA,EACLF;IAEF;IAAA;;;;;;;;;GAAA,GAYA,aAAoB,sBACnBJ,CAAAA,EACAM,CAAAA,EACAL,CAAAA,EACAG,CAAAA,EACmC;QACnC,MAAMC,IAAkBJ,KAAiBjB,GACnCJ,IAAkCwB,IAAiB;YAAE,cAAcA;QAAA,IAAmB,CAAA;QAO5F,OANiB,MAAMC,EAAyC;YAC/D,UAAUvH,EAASkH,GAAS,uBAAuB;YACnD,QAAQ;YACR,aAAaM;YACb,SAAA1B;QAAA,CACA;IAEF;IAAA;;;;;;GAAA,GASA,MAAM,sBACL0B,CAAAA,EACmC;QACnC,MAAMF,IAAiB,MAAM,IAAA,CAAK,eAAA,CAAgB,uBAAuB;QACzE,OAAOR,EAAU,qBAAA,CAChB,IAAA,CAAK,QAAA,EACLU,GACA,IAAA,CAAK,cAAA,EACLF;IAEF;IAAA;;;;;;;GAAA,GAUA,aAAoB,eACnBJ,CAAAA,EACAO,CAAAA,EACAN,CAAAA,EACAG,CAAAA,EACA5D,CAAAA,EACoC;QACpC,MAAM0D,IAAa1D,KAAUhB,GACvB6E,IAAkBJ,KAAiBjB,GACnCJ,IAAkCwB,IAAiB;YAAE,cAAcA;QAAA,IAAmB,CAAA,GACtFvB,IAAW,MAAMwB,EAErB;YACD,UAAUvH,EAASkH,GAAS,yBAAyBO,CAAK;YAC1D,QAAQ;YACR,SAAA3B;QAAA,CACA;QAGD,OADaM,GAAkCL,GAAUqB,CAAU;IAEpE;IAAA;;;;;GAAA,GAOA,MAAM,eAAeK,CAAAA,EAAkD;QACtE,MAAMH,IAAiB,MAAM,IAAA,CAAK,eAAA,CAAgB,CAAA,sBAAA,EAAyBG,CAAK,EAAE;QAClF,OAAOX,EAAU,cAAA,CAAe,IAAA,CAAK,QAAA,EAAUW,GAAO,IAAA,CAAK,cAAA,EAAgBH,CAAc;IAC1F;IAAA;;;;;;;;GAAA,GAWA,aAAoB,qBACnBJ,CAAAA,EACAO,CAAAA,EACAN,CAAAA,EACAG,CAAAA,EACmC;QACnC,MAAMC,IAAkBJ,KAAiBjB,GACnCJ,IAAkCwB,IAAiB;YAAE,cAAcA;QAAA,IAAmB,CAAA;QAM5F,OALiB,MAAMC,EAAyC;YAC/D,UAAUvH,EAASkH,GAAS,yBAAyBO,CAAK;YAC1D,QAAQ;YACR,SAAA3B;QAAA,CACA;IAEF;IAAA;;;;;GAAA,GAQA,MAAM,qBAAqB2B,CAAAA,EAAiD;QAC3E,MAAMH,IAAiB,MAAM,IAAA,CAAK,eAAA,CAAgB,CAAA,sBAAA,EAAyBG,CAAK,EAAE;QAClF,OAAOX,EAAU,oBAAA,CAChB,IAAA,CAAK,QAAA,EACLW,GACA,IAAA,CAAK,cAAA,EACLH;IAEF;IAAA;;;;;;;GAAA,GAUA,aAAoB,KACnBJ,CAAAA,EACAQ,CAAAA,EACAP,CAAAA,EACAG,CAAAA,EACC;QACD,MAAMC,IAAkBJ,KAAiBjB,GACnCJ,IAAkCwB,IAAiB;YAAE,cAAcA;QAAA,IAAmB,CAAA,GACtFrQ,IAAO,MAAMsQ,EAA8B;YAChD,UAAUvH,EAASkH,GAAS,iBAAiB;YAC7C,QAAQ;YACR,aAAaQ;YACb,SAAA5B;QAAA,CACA;QAED,IAAI,CAAChG,EAAM7I,CAAI,KAAK,CAAC,MAAM,OAAA,CAAQA,GAAM,UAAU,GAClD,MAAM,IAAI,MAAM,cAAc;QAG/B,OAAOA;IACR;IAAA;;;;;GAAA,GAOA,MAAM,KAAKyQ,CAAAA,EAA0B;QACpC,MAAMJ,IAAiB,MAAM,IAAA,CAAK,eAAA,CAAgB,iBAAiB;QACnE,OAAOR,EAAU,IAAA,CAAK,IAAA,CAAK,QAAA,EAAUY,GAAa,IAAA,CAAK,cAAA,EAAgBJ,CAAc;IACtF;IAAA;;;;;;;;GAAA,GAWA,aAAoB,WACnBJ,CAAAA,EACAQ,CAAAA,EACAP,CAAAA,EACAG,CAAAA,EACwB;QACxB,MAAMC,IAAkBJ,KAAiBjB,GACnCJ,IAAkCwB,IAAiB;YAAE,cAAcA;QAAA,IAAmB,CAAA,GACtFrQ,IAAO,MAAMsQ,EAA8B;YAChD,UAAUvH,EAASkH,GAAS,iBAAiB;YAC7C,QAAQ;YACR,aAAaQ;YACb,SAAA5B;QAAA,CACA;QAED,IAAI,CAAChG,EAAM7I,CAAI,KAAK,CAAC,MAAM,OAAA,CAAQA,GAAM,UAAU,GAClD,MAAM,IAAI,MAAM,cAAc;QAG/B,OAAOA;IACR;IAAA;;;;;GAAA,GAQA,MAAM,WAAWyQ,CAAAA,EAAiD;QACjE,MAAMJ,IAAiB,MAAM,IAAA,CAAK,eAAA,CAAgB,iBAAiB;QACnE,OAAOR,EAAU,UAAA,CAAW,IAAA,CAAK,QAAA,EAAUY,GAAa,IAAA,CAAK,cAAA,EAAgBJ,CAAc;IAC5F;IAAA;;;;;;GAAA,GASA,aAAoB,gBACnBJ,CAAAA,EACAS,CAAAA,EACAR,CAAAA,EACAG,CAAAA,EACA5D,CAAAA,EACoC;QACpC,MAAM0D,IAAa1D,KAAUhB,GACvB6E,IAAkBJ,KAAiBjB,GACnCJ,IAAkCwB,IAAiB;YAAE,cAAcA;QAAA,IAAmB,CAAA,GACtFvB,IAAW,MAAMwB,EAErB;YACD,UAAUvH,EAASkH,GAAS,uBAAuB;YACnD,QAAQ;YACR,aAAaS;YACb,SAAA7B;QAAA,CACA,GAEK7O,IAAOkP,GAAkCJ,GAAUqB,CAAU;QAEnE,IACC,CAACtH,EAAM7I,CAAI,KACX,OAAOA,GAAM,UAAW,YACxB,OAAOA,GAAM,eAAgB,YAC7B,OAAOA,GAAM,SAAU,UAEvB,MAAM,IAAI,MAAM,cAAc;QAE/B,OAAOA;IACR;IAAA;;;;;GAAA,GAQA,MAAM,gBAAgB0Q,CAAAA,EAAuE;QAC5F,MAAML,IAAiB,MAAM,IAAA,CAAK,eAAA,CAAgB,uBAAuB;QACzE,OAAOR,EAAU,eAAA,CAChB,IAAA,CAAK,QAAA,EACLa,GACA,IAAA,CAAK,cAAA,EACLL;IAEF;IAAA;;;;;;;;;GAAA,GAYA,aAAoB,sBACnBJ,CAAAA,EACAS,CAAAA,EACAR,CAAAA,EACAG,CAAAA,EACmC;QACnC,MAAMC,IAAkBJ,KAAiBjB,GACnCJ,IAAkCwB,IAAiB;YAAE,cAAcA;QAAA,IAAmB,CAAA;QAO5F,OANiB,MAAMC,EAAyC;YAC/D,UAAUvH,EAASkH,GAAS,uBAAuB;YACnD,QAAQ;YACR,aAAaS;YACb,SAAA7B;QAAA,CACA;IAEF;IAAA;;;;;;GAAA,GASA,MAAM,sBACL6B,CAAAA,EACmC;QACnC,MAAML,IAAiB,MAAM,IAAA,CAAK,eAAA,CAAgB,uBAAuB;QACzE,OAAOR,EAAU,qBAAA,CAChB,IAAA,CAAK,QAAA,EACLa,GACA,IAAA,CAAK,cAAA,EACLL;IAEF;IAAA;;;;;;GAAA,GASA,aAAoB,eACnBJ,CAAAA,EACAO,CAAAA,EACAN,CAAAA,EACAG,CAAAA,EACA5D,CAAAA,EACoC;QACpC,MAAM0D,IAAa1D,KAAUhB,GACvB6E,IAAkBJ,KAAiBjB,GACnCJ,IAAkCwB,IAAiB;YAAE,cAAcA;QAAA,IAAmB,CAAA,GACtFvB,IAAW,MAAMwB,EAAqE;YAC3F,UAAUvH,EAASkH,GAAS,yBAAyBO,CAAK;YAC1D,QAAQ;YACR,SAAA3B;QAAA,CACA,GAEK7O,IAAOkP,GAAkCJ,GAAUqB,CAAU;QAEnE,IACC,CAACtH,EAAM7I,CAAI,KACX,OAAOA,GAAM,UAAW,YACxB,OAAOA,GAAM,eAAgB,YAC7B,OAAOA,GAAM,SAAU,YACvB,OAAOA,GAAM,SAAU,YACvB,CAAC,OAAO,MAAA,CAAO0N,EAAc,EAAE,QAAA,CAAS1N,EAAK,KAAK,GAElD,MAAM,IAAI,MAAM,cAAc;QAG/B,OAAOA;IACR;IAAA;;;;;GAAA,GAOA,MAAM,eAAewQ,CAAAA,EAAkD;QACtE,MAAMH,IAAiB,MAAM,IAAA,CAAK,eAAA,CAAgB,CAAA,sBAAA,EAAyBG,CAAK,EAAE;QAClF,OAAOX,EAAU,cAAA,CAAe,IAAA,CAAK,QAAA,EAAUW,GAAO,IAAA,CAAK,cAAA,EAAgBH,CAAc;IAC1F;IAAA;;;;;;;;;GAAA,GAYA,aAAoB,qBACnBJ,CAAAA,EACAO,CAAAA,EACAN,CAAAA,EACAG,CAAAA,EACmC;QACnC,MAAMC,IAAkBJ,KAAiBjB,GACnCJ,IAAkCwB,IAAiB;YAAE,cAAcA;QAAA,IAAmB,CAAA;QAM5F,OALiB,MAAMC,EAAyC;YAC/D,UAAUvH,EAASkH,GAAS,yBAAyBO,CAAK;YAC1D,QAAQ;YACR,SAAA3B;QAAA,CACA;IAEF;IAAA;;;;;;GAAA,GASA,MAAM,qBAAqB2B,CAAAA,EAAiD;QAC3E,MAAMH,IAAiB,MAAM,IAAA,CAAK,eAAA,CAAgB,CAAA,sBAAA,EAAyBG,CAAK,EAAE;QAClF,OAAOX,EAAU,oBAAA,CAChB,IAAA,CAAK,QAAA,EACLW,GACA,IAAA,CAAK,cAAA,EACLH;IAEF;IAAA;;;;;;;;;GAAA,GAYA,aAAoB,KACnBJ,CAAAA,EACAU,CAAAA,EACAT,CAAAA,EACAG,CAAAA,EACA5D,CAAAA,EACoC;QACpC,MAAM0D,IAAa1D,KAAUhB,GACvB6E,IAAkBJ,KAAiBjB,GACnCJ,IAAkCwB,IAAiB;YAAE,cAAcA;QAAA,IAAmB,CAAA,GACtFvB,IAAW,MAAMwB,EAAqE;YAC3F,UAAUvH,EAASkH,GAAS,iBAAiB;YAC7C,QAAQ;YACR,aAAaU;YACb,SAAA9B;QAAA,CACA,GAEK7O,IAAOkP,GAAkCJ,GAAUqB,CAAU;QAEnE,IACC,CAACtH,EAAM7I,CAAI,KACX,OAAOA,GAAM,SAAU,YACvB,CAAC,OAAO,MAAA,CAAO0N,EAAc,EAAE,QAAA,CAAS1N,EAAK,KAAK,GAElD,MAAM,IAAI,MAAM,cAAc;QAG/B,OAAOA;IACR;IAAA;;;;;;GAAA,GAQA,MAAM,KAAK2Q,CAAAA,EAA6D;QACvE,MAAMN,IAAiB,MAAM,IAAA,CAAK,eAAA,CAAgB,iBAAiB;QACnE,OAAOR,EAAU,IAAA,CAAK,IAAA,CAAK,QAAA,EAAUc,GAAa,IAAA,CAAK,cAAA,EAAgBN,CAAc;IACtF;IAAA;;;;;;;;;;GAAA,GAaA,aAAoB,WACnBJ,CAAAA,EACAU,CAAAA,EACAT,CAAAA,EACAG,CAAAA,EACmC;QACnC,MAAMC,IAAkBJ,KAAiBjB,GACnCJ,IAAkCwB,IAAiB;YAAE,cAAcA;QAAA,IAAmB,CAAA;QAO5F,OANa,MAAMC,EAAyC;YAC3D,UAAUvH,EAASkH,GAAS,iBAAiB;YAC7C,QAAQ;YACR,aAAaU;YACb,SAAA9B;QAAA,CACA;IAEF;IAAA;;;;;;;GAAA,GAUA,MAAM,WAAW8B,CAAAA,EAA4D;QAC5E,MAAMN,IAAiB,MAAM,IAAA,CAAK,eAAA,CAAgB,iBAAiB;QACnE,OAAOR,EAAU,UAAA,CAAW,IAAA,CAAK,QAAA,EAAUc,GAAa,IAAA,CAAK,cAAA,EAAgBN,CAAc;IAC5F;IAAA;;;;;;;GAAA,GAUA,aAAoB,MACnBJ,CAAAA,EACAW,CAAAA,EACAV,CAAAA,EAC8B;QAE9B,MAAMlQ,IAAO,MAAA,CADWkQ,KAAiBjB,CAAAA,EACc;YACtD,UAAUlG,EAASkH,GAAS,gBAAgB;YAC5C,QAAQ;YACR,aAAaW;QAAA,CACb;QAED,IAAI,CAAC/H,EAAM7I,CAAI,KAAK,CAAC,MAAM,OAAA,CAAQA,GAAM,MAAM,GAC9C,MAAM,IAAI,MAAM,cAAc;QAG/B,OAAOA;IACR;IAAA;;;;;;;;GAAA,GAWA,aAAoB,QACnBiQ,CAAAA,EACAY,CAAAA,EACAX,CAAAA,EAC0B;QAEtBW,KAAAA,CAEHA,IAAWA,EAAS,OAAA,CAAQ,OAAO,GAAG,EAAE,OAAA,CAAQ,OAAO,GAAG,CAAA;QAG3D,MAAM7Q,IAAO,MAAA,CADWkQ,KAAiBjB,CAAAA,EACU;YAClD,UAAU4B,IAAW9H,EAASkH,GAAS,YAAYY,CAAQ,IAAI9H,EAASkH,GAAS,UAAU;QAAA,CAC3F;QAED,IAAI,CAACpH,EAAM7I,CAAI,KAAK,CAAC,MAAM,OAAA,CAAQA,EAAK,OAAO,GAC9C,MAAM,IAAI,MAAM,cAAc;QAG/B,OAAOA;IACR;IAAA;;;;;;GAAA,GAQA,MAAM,QAAQ6Q,CAAAA,EAAmBZ,CAAAA,EAA2C;QAM3E,OALgB,MAAMJ,EAAU,OAAA,CAC/BI,KAAW,IAAA,CAAK,QAAA,EAChBY,GACA,IAAA,CAAK,cAAA;IAGP;IAAA;;;;;;GAAA,GAQA,aAAoB,WACnBZ,CAAAA,EACAC,CAAAA,EAC0B;QAE1B,OAAA,CADwBA,KAAiBjB,CAAAA,EACF;YAAE,UAAUlG,EAASkH,GAAS,aAAa;QAAA,CAAG;IACtF;IAAA;;;;GAAA,GAOA,MAAM,aAAsC;QAC3C,OAAOJ,EAAU,UAAA,CAAW,IAAA,CAAK,QAAA,EAAU,IAAA,CAAK,cAAc;IAC/D;IAAA;;;;;GAAA,GAQA,MAAM,MAAMe,CAAAA,EAA8D;QACzE,OAAOf,EAAU,KAAA,CAAM,IAAA,CAAK,QAAA,EAAUe,GAAc,IAAA,CAAK,cAAc;IACxE;IAEA,aAAoB,QACnBX,CAAAA,EACAa,CAAAA,EACAZ,CAAAA,EAC+B;QAE/B,MAAMlQ,IAAO,MAAA,CADWkQ,KAAiBjB,CAAAA,EACe;YACvD,UAAUlG,EAASkH,GAAS,aAAa;YACzC,QAAQ;YACR,aAAaa;QAAA,CACb;QAED,IAAI,CAACjI,EAAM7I,CAAI,KAAK,CAAC,MAAM,OAAA,CAAQA,GAAM,OAAO,KAAK,CAAC,MAAM,OAAA,CAAQA,GAAM,UAAU,GACnF,MAAM,IAAI,MAAM,cAAc;QAG/B,OAAOA;IACR;IAEA,MAAM,QAAQ8Q,CAAAA,EAEmB;QAChC,OAAOjB,EAAU,OAAA,CAAQ,IAAA,CAAK,QAAA,EAAUiB,GAAgB,IAAA,CAAK,cAAc;IAC5E;IAAA;;GAAA,GAKA,MAAM,mBAAmB;QACxB,IAAI,IAAA,CAAK,EAAA,EACR,MAAM,IAAA,CAAK,EAAA,CAAG,gBAAA,CAAA;aACR;YACN,MAAMb,IAAU,IAAI,IAAI,IAAA,CAAK,QAAQ,GAC/Bc,IAAY;YACdd,EAAQ,QAAA,IAAA,CACPA,EAAQ,QAAA,CAAS,QAAA,CAAS,GAAG,IAChCA,EAAQ,QAAA,IAAYc,IAEpBd,EAAQ,QAAA,IAAY,MAAMc,CAAAA,GAG5B,IAAA,CAAK,EAAA,GAAKvE,EAAkB,WAAA,CAAA,EAAc,aAAA,CACzC,GAAGyD,EAAQ,QAAA,KAAa,WAAW,QAAQ,IAAI,CAAA,GAAA,EAAMA,EAAQ,IAAI,GAAGA,EAAQ,QAAQ,EAAA;YAErF,IAAI;gBACH,MAAM,IAAA,CAAK,EAAA,CAAG,OAAA,CAAA;YACf,EAAA,OAASlD,GAAG;gBACX,MAAA,IAAA,CAAK,OAAA,CAAQ,KAAA,CAAM,qCAAqC;oBAAE,GAAAA;gBAAAA,CAAG,GACvD,IAAI,MAAM,mCAAmC;YACpD;QACD;IACD;IAAA;;GAAA,GAKA,sBAAsB;QACjB,IAAA,CAAK,EAAA,IACR,IAAA,CAAK,EAAA,CAAG,KAAA,CAAA;IAEV;IAEA,IAAI,sBAAsB;QACzB,OAAO,IAAA,CAAK,EAAA;IACb;IAEA,MAAM,gBAAgB2C,CAAAA,EAAc;QACnC,IAAI,CAAC,IAAA,CAAK,WAAA,EACT;QAGD,IAAA,CADa,MAAM,IAAA,CAAK,eAAA,CAAA,CAAA,EACf,sBAAA,CAAuBA,CAAI,GAAG;YACtC,IAAI,CAAC,IAAA,CAAK,gBAAA,EACT,MAAM,IAAI,MAAM,2DAA2D;YAE5E,OAAO,IAAA,CAAK,gBAAA,CAAA;QACb;IAED;AACD;AC92BA,MAAMsB,GAAe;IAIpB,YAAY/O,CAAAA,EAAgBgP,CAAAA,EAA8BjP,CAAAA,CAAY;QACrE,IAAA,CAAK,MAAA,GAASC,GACd,IAAA,CAAK,EAAA,GAAKgP,GACV,IAAA,CAAK,EAAA,GAAKjP;IACX;IACA,8BAAwD;QACvD,OAAO;YAAE,QAAQ,IAAA,CAAK,MAAA;YAAQ,IAAI,IAAA,CAAK,EAAA,CAAG,KAAA,CAAM,CAAA,CAAI;YAAG,IAAI,IAAA,CAAK,EAAA;QAAA;IACjE;AACD;ACSO,SAASkP,GACflS,CAAAA,EAC6B;IAC7B,OAAO,OAAOA,KAAU;AACzB;AAEA,MAAMmS,KAAAA,aAAAA,GAAAA,IAAyB,IAAI;IAAC;IAAY;IAAW;IAAU;IAAU,eAAe;CAAC,GACzFC,KAAoB;AAEnB,MAAMC,EAAqC;IAKjD,YAAYC,CAAAA,EAA0CC,CAAAA,EAAuBC,CAAAA,CAAoB;QAChG,IAAA,CAAK,MAAA,GAASA,GACd,IAAA,CAAK,cAAA,GAAiBD,GACtB,IAAA,CAAK,cAAA,GAAiBD;IACvB;IAEA,QAAQG,CAAAA,EAAiCrO,CAAAA,EAAkB;QAC1D,IAAIgH;QACAqH,EAAI,IAAA,IAAA,CACPrH,IAAO;YACN,OAAGzD,6OAAAA,EAAW8K,EAAI,IAAA,CAAK,CAAC;YACxB,OAAG9K,6OAAAA,EAAW8K,EAAI,IAAA,CAAK,CAAC;YACxB,GAAG,IAAA,CAAK,cAAA;QAAA,CAAA;QAGV,MAAMC,IAAiB;YACtB,IAAID,EAAI,EAAA;YACR,QAAQA,EAAI,MAAA;YACZ,QAAInH,6PAAAA,EAAamH,EAAI,EAAE;QAExB,GACME,QAAIrH,6PAAAA,EAAalH,EAAO,IAAA,CAAKqO,EAAI,MAAM,CAAC,GACxCnM,QAAQsM,0QAAAA,EAA0BF,GAAgB,IAAA,CAAK,cAAA,EAAgB,IAAA,CAAK,MAAA,EAAQC,CAAC;QAW3F,OAVwB;YACvB,OAAGE,+PAAAA,EAAevM,CAAK,CAAA;YACvB,GAAI8E,KAAQ;gBACX,MAAM;oBACL,OAAGrF,6OAAAA,EAAWqF,EAAK,CAAC;oBACpB,OAAGrF,6OAAAA,EAAWqF,EAAK,CAAC;oBACpB,GAAGnF,GAAoBmF,EAAK,CAAA,IAAK,OAAO,CAAC,CAAC;gBAAA;YAC3C,CAAA;QACD;IAGF;IAEA,OAAO,eACN0H,CAAAA,EAQA7P,CAAAA,EACAmB,CAAAA,EACA2O,CAAAA,EACC;QAED,OADgB5O,EAAYlB,GAAQmB,EAAO,IAAA,EAAM2O,CAAW,EAC7C,GAAA,CAAI,CAAC,IAAM,IAAA,CAAK,oBAAA,CAAqBD,GAAM,GAAG1O,EAAO,EAAE,CAAC;IACxE;IAEA,OAAO,qBACN0O,CAAAA,EAQA7P,CAAAA,EACA4O,CAAAA,EACC;QAED,MAAMmB,IAAqB,MAAM,OAAA,CAAQF,EAAK,MAAM,IAAIA,EAAK,MAAA,GAAS;YAACA,EAAK,MAAM;SAAA,EAC5EG,IAAuBH,EAAK,UAAA,IAAc,CAAA,CAAA,EAC1CI,IAAU,KAAK,GAAA,CAAI,GAAG,KAAK,GAAA,CAAIJ,EAAK,kBAAA,IAAsB,GAAGE,EAAS,MAAM,CAAC,GAC7EG,IAAY,KAAK,GAAA,CACtB,GACA,KAAK,GAAA,CAAIL,EAAK,wBAAA,IAA4B,GAAGG,EAAW,MAAA,IAAU,CAAC,IAI9DjS,IAAOgS,CAAAA,CAAS,CAAC,CAAA,EACjBI,IAAUJ,EAAS,KAAA,CAAM,CAAC,GAC1BK,IAASJ,GAGTK,IAAmB,CAAA,CAAA,EAEnBC,IAAKT,EAAK,QAAA,IAAY;QAoB5B,IAnBI,OAAO,aAAA,CAAcS,CAAE,KAAKA,KAAM,KACrCD,EAAK,IAAA,CAAK;YAAC;YAAY,OAAOC,CAAE,CAAC;SAAC,GAG/BH,EAAQ,MAAA,GAAS,KAAA,CACpBE,EAAK,IAAA,CAAK;YAAC,WAAW;eAAGF,CAAO;SAAC,GAC7BF,IAAU,KACbI,EAAK,IAAA,CAAK;YAAC;YAAU,OAAOJ,CAAO,CAAC;SAAC,CAAA,GAInCG,EAAO,MAAA,GAAS,KAAA,CACnBC,EAAK,IAAA,CAAK;YAAC,UAAU;eAAGD,CAAM;SAAC,GAC3BF,IAAY,KACfG,EAAK,IAAA,CAAK;YAAC;YAAiB,OAAOH,CAAS,CAAC;SAAC,CAAA,GAK5CL,EAAK,cAAA,EAAgB,QAAQ;YAChC,MAAMU,IAAaV,EAAK,cAAA,CAAe,GAAA,CAAI,CAAC,CAAClN,GAAM,GAAA6N,CAAI,CAAA,EAAG/S,MAAM;gBAC/D,IAAI,OAAOkF,KAAM,YAAY,CAACA,GAC7B,MAAM,IAAI,MAAM,CAAA,eAAA,EAAkBlF,CAAC,CAAA,+BAAA,CAAiC;gBAErE,IAAIyR,GAAmB,GAAA,CAAIvM,CAAC,GAC3B,MAAM,IAAI,MAAM,CAAA,0CAAA,EAA6CA,CAAC,CAAA,CAAA,CAAG;gBAElE,OAAO;oBAACA,GAAG;uBAAG6N,EAAK,GAAA,CAAI,MAAM,CAAC;iBAAA;YAC/B,CAAC;YACDH,EAAK,IAAA,CAAK,GAAGE,CAAU;QACxB;QAGA,MAAME,IAAyE;YAC9E;YACA;gBACC,WAAO3N,6OAAAA,MAAW4N,6OAAAA,EAAY,EAAE,CAAC;gBACjC,MAAA3S;gBACA,MAAAsS;YAAA;SACD,EAEK/E,IAAS,KAAK,SAAA,CAAUmF,CAAS,GAIjCE,IAAY,CAAC;eAAGrF,CAAM;SAAA,CAAE,MAAA;QAC9B,IAAIqF,IAAYxB,IACf,MAAM,IAAI,MAAM,CAAA,iBAAA,EAAoBwB,CAAS,CAAA,yBAAA,EAA4BxB,EAAiB,EAAE;QAG7F,MAAMyB,IAAc,IAAI,cAAc,MAAA,CAAOtF,CAAM,GAC7C,EAAE,GAAAuF,CAAAA,EAAG,IAAA7B,CAAAA,EAAAA,OAAO8B,6PAAAA,EAAaF,CAAW;QAG1C,OAAO,IAAIxB,EACV,IAAIL,GAAe/O,GAAQgP,GAAIJ,CAAQ,EAAE,2BAAA,CAAA,GACzCiC,GACAD;IAEF;IAEA,OAAO,iBAAiB5Q,CAAAA,EAAgBmB,CAAAA,EAAkB2O,CAAAA,EAAwB;QAEjF,OADgB5O,EAAYlB,GAAQmB,EAAO,IAAA,EAAM2O,CAAW,EAC7C,GAAA,CAAI,CAAC/N,IAAM,IAAA,CAAK,sBAAA,CAAuBA,GAAGZ,EAAO,EAAE,CAAC;IACpE;IAEA,OAAO,uBAAuBnB,CAAAA,EAAgB4O,CAAAA,EAAkB;QAC/D,MAAMmC,QAAYjO,6OAAAA,MAAW4N,6OAAAA,EAAY,EAAE,CAAC,GACtCE,IAAc,IAAI,cAAc,MAAA,CAAOG,CAAS,GAChD,EAAE,CAAA,EAAG,IAAA/B,CAAAA,EAAAA,OAAO8B,6PAAAA,EAAaF,CAAW;QAC1C,OAAO,IAAIxB,EACV,IAAIL,GAAe/O,GAAQgP,GAAIJ,CAAQ,EAAE,2BAAA,CAAA,GACzC,GACAgC;IAEF;IAEA,OAAO,wBACN5Q,CAAAA,EACAgR,CAAAA,EACAC,CAAAA,EACA9P,CAAAA,EACA2O,CAAAA,EACe;QAEf,OADgB5O,EAAYlB,GAAQmB,EAAO,IAAA,EAAM2O,CAAW,EAC7C,GAAA,CAAI,CAAC/N,GAAGtE,IACtB,IAAA,CAAK,6BAAA,CAA8BsE,GAAGiP,GAAMC,IAAUxT,GAAG0D,EAAO,EAAE;IAEpE;IAEA,OAAO,8BACNnB,CAAAA,EACAgR,CAAAA,EACAC,CAAAA,EACArC,CAAAA,EACC;QACD,MAAMgC,QAAcM,6OAAAA,EAAaF,GAAMpC,GAAUqC,CAAO,GAClDE,QAAmBrO,6OAAAA,EAAW8N,CAAW,GACzCQ,IAAkB,IAAI,cAAc,MAAA,CAAOD,CAAgB,GAC3DE,IAAiBzO,OAAc0O,6OAAAA,EAAqBN,GAAMpC,GAAUqC,CAAO,CAAC,GAC5E,EAAE,GAAAJ,CAAAA,EAAG,IAAA7B,CAAAA,CAAA,CAAA,OAAO8B,6PAAAA,EAAaM,GAAiBC,CAAc;QAC9D,OAAO,IAAIjC,EACV,IAAIL,GAAe/O,GAAQgP,GAAIJ,CAAQ,EAAE,2BAAA,CAAA,GACzCiC,GACAO;IAEF;AACD;ACvKA,MAAMG,KAA8B,GAK9BC,KAAe;AAKrB,MAAMC,GAAY;IAAA;;;;;;;;;;;;GAAA,GA0BjB,YACChN,CAAAA,EACA4H,CAAAA,CAUC;QArCF,IAAA,CAAQ,KAAA,GAAA,aAAA,GAAA,IAAmC,IAAA,GAE3C,IAAA,CAAQ,QAAA,GAAyB,CAAA,CAAA,EACjC,IAAA,CAAQ,KAAA,GAAgC,KAAA,GACxC,IAAA,CAAQ,KAAA,GAAQmF,IAChB,IAAA,CAAQ,SAAA,GAAkC,KAAA,GAC1C,IAAA,CAAQ,mBAAA,GAAsBD,IAgC7B,IAAA,CAAK,IAAA,GAAO9M,GACZ,IAAA,CAAK,OAAA,GAAU4H,GAAS,UAAU7C,GAUlC,IAAA,CAAK,OAAA,CAAQ,IAAA,CACZ;QAED,IAAI5L,IAAmB,CAAA,CAAA;QAcvB,IAbIyO,GAAS,QAAQ,CAAC,MAAM,OAAA,CAAQA,EAAQ,IAAI,IAC/CzO,IAAO;YAACyO,EAAQ,IAAI;SAAA,GACVA,GAAS,QAAQ,MAAM,OAAA,CAAQA,GAAS,IAAI,KAAA,CACtDzO,IAAOyO,GAAS,IAAA,GAEbzO,KAAMA,EAAK,OAAA,CAAQ,CAACC,IAAkB,IAAA,CAAK,KAAA,CAAM,GAAA,CAAIA,EAAI,EAAA,EAAIA,CAAG,CAAC,GACjEwO,GAAS,QAAA,CAAM,IAAA,CAAK,KAAA,GAAQA,GAAS,IAAA,GACrCA,GAAS,WAAA,CAAS,IAAA,CAAK,QAAA,GAAWA,EAAQ,OAAA,GAC1CA,GAAS,YAAA,CAAU,IAAA,CAAK,SAAA,GAAY,IAAIgB,GAAShB,EAAQ,QAAQ,CAAA,GACjEA,GAAS,sBAAA,CACZ,IAAA,CAAK,mBAAA,GAAsBA,EAAQ,kBAAA,GAGhCA,GAAS,WAAW;YACvB,IAAIA,EAAQ,SAAA,YAAqB,YAAY;gBAC5C,IAAA,CAAK,KAAA,GAAQA,EAAQ,SAAA;gBACrB;YACD;YACA,MAAM,IAAI,MAAM,sCAAsC;QACvD;QACIA,GAAS,eAAA,CACZ,IAAA,CAAK,YAAA,GAAeA,EAAQ,WAAA;IAE9B;IAEA,IAAI,OAAe;QAClB,OAAO,IAAA,CAAK,KAAA;IACb;IACA,IAAI,OAA8B;QACjC,OAAO,IAAA,CAAK,KAAA;IACb;IACA,IAAI,WAAmB;QACtB,IAAI,CAAC,IAAA,CAAK,SAAA,EACT,MAAM,IAAI,MAAM,iBAAiB;QAElC,OAAO,IAAA,CAAK,SAAA;IACb;IACA,IAAI,SAASuC,CAAAA,EAAkB;QAC9B,IAAA,CAAK,SAAA,GAAYA;IAClB;IACA,IAAI,UAAwB;QAC3B,OAAO,IAAA,CAAK,QAAA;IACb;IACA,IAAI,WAAqB;QACxB,IAAI,CAAC,IAAA,CAAK,SAAA,EACT,MAAM,IAAI,MAAM,sBAAsB;QAEvC,OAAO,IAAA,CAAK,SAAA;IACb;IAAA;;;;GAAA,GAOA,MAAM,cAAiC;QACtC,MAAM8C,IAAU,MAAM,IAAA,CAAK,IAAA,CAAK,OAAA,CAAA;QAChC,OAAA,IAAA,CAAK,SAAA,GAAY,IAAIrE,GAASqE,CAAO,GAC9B,IAAA,CAAK,SAAA;IACb;IAAA;;;;GAAA,GAOA,MAAM,kBAAqC;QAC1C,OAAK,IAAA,CAAK,SAAA,GAGH,IAAA,CAAK,SAAA,GAFJ,MAAM,IAAA,CAAK,WAAA,CAAA;IAGpB;IAAA;;;GAAA,GAMA,MAAM,WAAW;QAChB,MAAM,QAAQ,GAAA,CAAI;YACjB,IAAA,CAAK,WAAA,CAAA;YACL,IAAA,CAAK,OAAA,CAAA;SACL;IACF;IAAA;;;;;;;GAAA,GAUA,gBAAgB1M,CAAAA,EAAmC;QAClD,IAAI2M,IAAgB3M,EAAQ,MAAA,CAAO,CAACrC,IAAkBA,EAAE,MAAA,IAAUA,EAAE,IAAA,KAAS,IAAA,CAAK,KAAK;QAGvFgP,IAAgBA,EAAc,MAAA,CAAO,CAAChP,IAAkBO,GAAWP,EAAE,EAAE,CAAC;QAExE,MAAMiP,IAAeD,EAAc,IAAA,CAClC,CAAC5P,GAAeC,IAAAA,CAAmBD,EAAE,aAAA,IAAiB,CAAA,IAAA,CAAMC,EAAE,aAAA,IAAiB,CAAA,EAAA,CAC9E,CAAC,CAAA;QACH,IAAI,CAAC4P,GACJ,MAAM,IAAI,MAAM,wBAAwB;QAEzC,OAAOA;IACR;IAAA;;;;GAAA,GAOA,MAAM,aAAoC;QAEzC,MAAMC,IAAAA,CADa,MAAM,IAAA,CAAK,IAAA,CAAK,UAAA,CAAA,CAAA,EACJ,OAAA,CAAQ,MAAA,CAAO,CAAClP,IAAkBA,EAAE,IAAA,KAAS,IAAA,CAAK,KAAK;QACtF,OAAA,IAAA,CAAK,QAAA,GAAWkP,GACT,IAAA,CAAK,QAAA;IACb;IAAA;;;;;GAAA,GAQA,MAAM,aAAkC;QACvC,MAAM7M,IAAU,MAAM,IAAA,CAAK,IAAA,CAAK,OAAA,CAAA;QAChC,OAAAA,EAAQ,OAAA,CAAQ,OAAA,CAAQ,CAACrC,MAAM;YAC9B,IAAI,CAACiF,GAAejF,CAAC,GACpB,MAAM,IAAI,MAAM,CAAA,0BAAA,EAA6BA,EAAE,EAAE,EAAE;QAErD,CAAC,GACD,IAAA,CAAK,KAAA,GAAQ,IAAI,IAAIqC,EAAQ,OAAA,CAAQ,GAAA,CAAI,CAACrC,IAAgB;gBAACA,EAAE,EAAA;gBAAIA,CAAC;aAAC,CAAC,GACpE,IAAA,CAAK,QAAA,GAAW,IAAA,CAAK,eAAA,CAAgB,IAAA,CAAK,QAAQ,EAAE,EAAA,EAC7CqC,EAAQ,OAAA;IAChB;IAAA;;;;;;;;;GAAA,GAYA,MAAM,QAAQ4J,CAAAA,EAAmBkD,CAAAA,EAA2C;QAU3E,IAAA,CATI,CAAA,CAAE,IAAA,CAAK,QAAA,CAAS,MAAA,GAAS,CAAA,KAAMA,CAAAA,KAClC,MAAM,IAAA,CAAK,UAAA,CAAA,GAGPlD,KAAAA,CAEJA,IADoB,IAAA,CAAK,eAAA,CAAgB,IAAA,CAAK,QAAQ,EAC/B,EAAA,GAGpB,CAAC,IAAA,CAAK,QAAA,CAAS,IAAA,CAAK,CAACjM,IAAkBA,EAAE,EAAA,KAAOiM,CAAQ,KAAA,CAC3D,MAAM,IAAA,CAAK,UAAA,CAAA,GACP,CAAC,IAAA,CAAK,QAAA,CAAS,IAAA,CAAK,CAACjM,IAAkBA,EAAE,EAAA,KAAOiM,CAAQ,CAAA,GAC3D,MAAM,IAAI,MAAM,CAAA,8CAAA,EAAiDA,CAAQ,CAAA,OAAA,CAAS;QAKpF,IAAI,CAAC,IAAA,CAAK,KAAA,CAAM,GAAA,CAAIA,CAAQ,GAAG;YAC9B,MAAMhR,IAAO,MAAM,IAAA,CAAK,IAAA,CAAK,OAAA,CAAQgR,CAAQ;YAC7C,IAAI,CAAChH,GAAehK,EAAK,OAAA,CAAQ,CAAC,CAAC,GAClC,MAAM,IAAI,MAAM,CAAA,0BAAA,EAA6BA,EAAK,OAAA,CAAQ,CAAC,CAAA,CAAE,EAAE,EAAE;YAElE,IAAA,CAAK,KAAA,CAAM,GAAA,CAAIgR,GAAUhR,EAAK,OAAA,CAAQ,CAAC,CAAC;QACzC;QAGA,OAAA,IAAA,CAAK,QAAA,GAAWgR,GACT,IAAA,CAAK,KAAA,CAAM,GAAA,CAAIA,CAAQ;IAC/B;IAAA;;;;;;GAAA,GASQ,aAAa5O,CAAAA,EAAiB+R,CAAAA,EAAsC;QAC3E,IAAI,OAAO/R,KAAW,YAAY,CAAC,OAAO,SAAA,CAAUA,CAAM,KAAKA,KAAU,GACxE,MAAM,IAAI,MAAM,CAAA,2CAAA,EAA8C+R,CAAE,EAAE;IAEpE;IAAA;;;;;;;GAAA,GAUA,MAAM,QAAQxO,CAAAA,EAAuB8I,CAAAA,EAA4C;QAChF,MAAM,EAAE,aAAA2F,CAAAA,EAAa,UAAApD,CAAAA,EAAU,eAAAqD,CAAAA,EAAe,SAAAhB,CAAAA,EAAS,QAAAiB,CAAAA,EAAQ,SAAAC,CAAAA,EAAS,YAAAC,CAAAA,EAAY,MAAAvC,CAAAA,CAAA,CAAA,GACnFxD,KAAW,CAAA;QAGR,IAAA,CAAK,QAAA,CAAS,MAAA,KAAW,KAC5B,MAAM,IAAA,CAAK,UAAA,CAAA,GAER,OAAO9I,KAAU,YAAA,CACpBA,IAAQuB,GAAgBvB,GAAO,IAAA,CAAK,QAAQ,CAAA;QAE7C,MAAM3F,IAAO,MAAM,IAAA,CAAK,OAAA,CAAQgR,CAAQ;QACxC,IAAIoD,KACCzO,EAAM,MAAA,CAAO,IAAA,CAAK,CAAChB,IAAa,CAAC2F,GAAa3F,GAAG3E,CAAI,CAAC,GACzD,MAAM,IAAI,MAAM,yCAAyC;QAG3D,MAAMoC,IAASsF,EAAU/B,EAAM,MAAM,IAAI,IAAA,CAAK,gBAAA,CAAiBA,EAAM,MAAM;QAC3E,IAAI8O;QACAD,IACHC,IAAgB;YAAE,MAAMD;QAAA,IACd,IAAA,CAAK,YAAA,IAAA,CACfC,IAAgB;YAAE,MAAM,IAAA,CAAK,YAAA;QAAA,CAAA;QAE9B,MAAMC,IAAkB,IAAA,CAAK,iBAAA,CAC5BtS,GACAuD,EAAM,MAAA,EACN3F,GACAqU,GACAhB,GACAiB,GACAC,GACAE,GACAxC,IAEK,EAAE,YAAA0C,CAAAA,EAAAA,GAAe,MAAM,IAAA,CAAK,IAAA,CAAK,IAAA,CAAKD,EAAgB,OAAO,GAC7DzO,IAASyO,EAAgB,UAAA,CAAW,GAAA,CAAI,CAACE,GAAG/U,IAAM+U,EAAE,OAAA,CAAQD,CAAAA,CAAW9U,CAAC,CAAA,EAAGG,CAAI,CAAC,GAChF6U,IAAyB,CAAA,CAAA;QAC/B,OAAAH,EAAgB,aAAA,CAAc,OAAA,CAAQ,CAACI,GAAGnF,MAAM;YAC/CkF,CAAAA,CAAcC,CAAC,CAAA,GAAI7O,CAAAA,CAAO0J,CAAC,CAAA;QAC5B,CAAC,GACMkF;IACR;IAAA;;;;;;;GAAA,GAUA,MAAM,KAAKzS,CAAAA,EAAgB6D,CAAAA,EAAiBwI,CAAAA,EAA8C;QACzF,MAAM,EACL,SAAAsG,CAAAA,EACA,aAAAC,CAAAA,EACA,aAAAC,CAAAA,EACA,UAAAjE,CAAAA,EACA,eAAAqD,CAAAA,EACA,QAAAC,CAAAA,EACA,SAAAC,CAAAA,EACA,YAAAC,CAAAA,EAAA,GACG/F,KAAW,CAAA;QAKf,IAJA,IAAA,CAAK,YAAA,CAAarM,GAAQ,MAAM,GAC5B6S,KAAAA,CACHhP,IAASA,EAAO,MAAA,CAAO,CAACtB,IAAaA,EAAE,IAAA,IAAQ,IAAS,CAAA,GAErD+C,EAAUzB,CAAM,IAAI7D,GACvB,MAAM,IAAI,MAAM,oCAAoC;QAErD,MAAM,EAAE,MAAM8S,CAAAA,EAAmB,MAAMC,CAAAA,CAAA,CAAA,GAAqB,IAAA,CAAK,kBAAA,CAChElP,GACA7D,GACAqM,GAAS,cAEJ2G,IAAcJ,IAAc,IAAA,CAAK,gBAAA,CAAiBG,CAAgB,IAAI;QAC5E,IACC,CAACJ,KAAAA,CACArN,EAAUyN,CAAgB,KAAK/S,IAASgT,KAAAA,yCAAAA;QACxCf,KACAC,KACAC,KACAvD,KACAwD,CAAAA,GACA;YACD,MAAMa,IAAU,MAAM,IAAA,CAAK,IAAA,CAAKjT,GAAQ6D,GAAQwI,CAAO,GACjD,EAAE,MAAA6G,CAAAA,EAAM,MAAAC,CAAAA,CAAA,CAAA,GAASF,GACjBG,IAAaH,EAAQ,UAAA;YAE3B,OAAO;gBAAE,MAAAC;gBAAM,MAAAC;gBAAM,YAAAC;YAAA;QACtB;QAEA,IAAI9N,EAAUyN,CAAgB,IAAI/S,IAASgT,GAC1C,MAAM,IAAI,MAAM,oCAAoC;QAGrD,OAAO;YAAE,MAAMF;YAAmB,MAAMC;QAAA;IACzC;IAAA;;;;;;;;;;;GAAA,GAcA,mBAAmBlP,CAAAA,EAAiBwP,CAAAA,EAAsBT,IAAc,CAAA,CAAA,EAAqB;QAC5F,IAAA,CAAK,YAAA,CAAaS,GAAc,oBAAoB;QAEpD,MAAMC,IAAa,IACbC,IAAa,GACbC,IAAa,GACbC,IAAa,KACbC,IAAa,KACbC,IAAa,CAAA,GACbC,IAAQvJ,GAAA;QACd,IAAIwJ,IAAoC,MACpCC,IAAY,IAAA,GACZC,IAAa,GACbC,IAAa;QAWjB,MAAMC,IAAY,CAACjU,GAAgBkU,IAC3BlU,IAAAA,CAAU4S,IAAc,KAAK,IAAA,CAAKsB,IAAS,GAAI,IAAI,CAAA,GAGrDC,IAAe,CAAIjV,MAAoB;YAC5C,MAAMkV,IAAW,CAAC;mBAAGlV,CAAK;aAAA;YAC1B,IAAA,IAASzB,IAAI2W,EAAS,MAAA,GAAS,GAAG3W,IAAI,GAAGA,IAAK;gBAC7C,MAAM4W,IAAI,KAAK,KAAA,CAAM,KAAK,MAAA,KAAA,CAAY5W,IAAI,CAAA,CAAE;gBAC5C,CAAC2W,CAAAA,CAAS3W,CAAC,CAAA,EAAG2W,CAAAA,CAASC,CAAC,CAAC,CAAA,GAAI;oBAACD,CAAAA,CAASC,CAAC,CAAA;oBAAGD,CAAAA,CAAS3W,CAAC,CAAC;iBAAA;YACvD;YACA,OAAO2W;QACR,GAIME,IAAoB,CACzBpL,GACAnM,GACAwX,MACmB;YACnB,IAAIC,IAAO,GACVC,IAAQvL,EAAI,MAAA,GAAS,GACrB9J,IAAwB;YACzB,MAAOoV,KAAQC,GAAO;gBACrB,MAAMC,IAAM,KAAK,KAAA,CAAA,CAAOF,IAAOC,CAAAA,IAAS,CAAC,GACnCE,IAAWzL,CAAAA,CAAIwL,CAAG,CAAA,CAAE,KAAA;gBAC1B,CAAIH,IAAcI,KAAY5X,IAAQ4X,KAAY5X,CAAAA,IAAAA,CACjDqC,IAASsV,GACLH,IAAAA,IAAoBG,IAAM,IAAA,IACjBA,IAAM,CAAA,IAEfH,IAAAA,IAAqBG,IAAM,IAAA,IACnBA,IAAM;YAEpB;YACA,OAAOH,IAAcnV,IAASoV,IAAOtL,EAAI,MAAA,GAASsL,IAAO;QAC1D,GAEMI,IAAe,CAAC1L,GAAqB2L,MAA4B;YACtE,MAAM9X,IAAQ8X,EAAI,KAAA;YAClB,IAAIL,IAAO,GACVC,IAAQvL,EAAI,MAAA;YACb,MAAOsL,IAAOC,GAAO;gBACpB,MAAMC,IAAM,KAAK,KAAA,CAAA,CAAOF,IAAOC,CAAAA,IAAS,CAAC;gBACrCvL,CAAAA,CAAIwL,CAAG,CAAA,CAAE,KAAA,GAAQ3X,IAAAA,IAAc2X,IAAM,IACpCD,IAAQC;YACd;YACAxL,EAAI,MAAA,CAAOsL,GAAM,GAAGK,CAAG;QACxB,GAIMC,IAAiB,CAAC9U,GAAgBkU,IACxBD,EAAUjU,GAAQkU,CAAM,IAC1Bb,IAAqB,IAAA,IAC3BrT,IAASkU,IAAS,MAAOb;QAMjC,IAAI0B,IAAc,GACdC,IAAc;QAClB,MAAMC,IAAgBpR,EAAO,GAAA,CAAI,CAACtB,MAAM;YACvC,MAAM2S,IAAS,IAAA,CAAK,cAAA,CAAe3S,CAAC,GAC9B4S,IAAQvC,IAAcrQ,EAAE,MAAA,GAAS2S,IAAS,MAAO3S,EAAE,MAAA,EACnDsS,IAAM;gBAAE,OAAOtS;gBAAG,OAAA4S;gBAAO,QAAAD;YAAA;YAE/B,OAAA,CAAI,CAACtC,KAAeuC,IAAQ,CAAA,KAAA,CAC3BJ,KAAexS,EAAE,MAAA,EACjByS,KAAeE,CAAAA,GAETL;QACR,CAAC;QAGD,IAAIO,IAAkBxC,IACnBqC,EAAc,MAAA,CAAO,CAACJ,IAAQA,EAAI,KAAA,GAAQ,CAAC,IAC3CI;QAQH,IALAG,EAAgB,IAAA,CAAK,CAACrT,GAAGC,IAAMD,EAAE,KAAA,GAAQC,EAAE,KAAK,GAK5CoT,EAAgB,MAAA,GAAS,GAAG;YAC/B,IAAIC;YAIG;gBACN,MAAMC,IAAchB,EAAkBc,GAAiB/B,GAAc,CAAA,CAAK;gBAC1E,IAAIiC,MAAgB,MAAM;oBACzB,MAAMC,IAAkBH,CAAAA,CAAgBE,CAAW,CAAA,CAAE,KAAA,EAC/CE,IAAalB,EAAkBc,GAAiBG,GAAiB,CAAA,CAAI;oBAC3E,IAAIC,MAAe,MAClB,MAAM,IAAI,MAAM,6CAA6C;oBAE9DH,IAAWG,IAAa;gBACzB,OAECH,IAAWD,EAAgB,MAAA;YAE7B;YAEA,IAAA,IAAS3X,IAAI4X,GAAU5X,IAAI2X,EAAgB,MAAA,EAAQ3X,IAClDsX,KAAeK,CAAAA,CAAgB3X,CAAC,CAAA,CAAE,KAAA,CAAM,MAAA,EACxCuX,KAAeI,CAAAA,CAAgB3X,CAAC,CAAA,CAAE,MAAA;YAEnC2X,IAAkBA,EAAgB,KAAA,CAAM,GAAGC,CAAQ;QACpD;QAGA,MAAMI,KAAcxB,EAAUc,GAAaC,CAAW;QACtD,IAAI3B,KAAgB,KAAKA,IAAeoC,IACvC,OAAO;YAAE,MAAM5R;YAAQ,MAAM,CAAA,CAAA;QAAC;QAI/B,MAAM6R,IAAgB,KAAK,GAAA,CAC1B,KAAK,IAAA,CAAKrC,IAAAA,CAAgB,IAAIE,IAAa,GAAA,CAAI,GAC/CF,IAAeG,GACfiC;QASD,IAAA,IAASE,IAAQ,GAAGA,IAAQrC,GAAYqC,IAAS;YAIhD,MAAMC,IAAoB,CAAA,CAAA;YAC1B,IAAI5V,IAAS,GACTkU,IAAS;YACb,KAAA,MAAWW,KAAOV,EAAaiB,CAAe,EAAG;gBAChD,MAAMS,IAAY7V,IAAS6U,EAAI,KAAA,CAAM,MAAA,EAC/BiB,IAAY5B,IAASW,EAAI,MAAA,EACzBkB,IAAS9B,EAAU4B,GAAWC,CAAS;gBAK7C,IAHAF,EAAE,IAAA,CAAKf,CAAG,GACV7U,IAAS6V,GACT3B,IAAS4B,GACLC,KAAU1C,EAAc,CAAA;YAC7B;YAUA,MAAM2C,IAAO,IAAI,IAAIJ,CAAC,GAChBK,IAASb,EAAgB,MAAA,CAAO,CAACP,IAAQ,CAACmB,EAAK,GAAA,CAAInB,CAAG,CAAC,GAEvDqB,IAAU/B,EAAa,MAAM,IAAA,CAAK;gBAAE,QAAQyB,EAAE,MAAA;YAAA,GAAU,CAACO,GAAG1Y,IAAMA,CAAC,CAAC,EAAE,KAAA,CAC3E,GACAiW;YAED,KAAA,MAAWjW,KAAKyY,EAAS;gBAExB,MAAMH,IAAS9B,EAAUjU,GAAQkU,CAAM;gBACvC,IACC6B,MAAW1C,KACK0C,KAAU1C,KAAgB0C,KAAUL,GAEpD;gBAKD,MAAMU,IAAOR,CAAAA,CAAEnY,CAAC,CAAA,EACV4Y,IAAarW,IAASoW,EAAK,KAAA,CAAM,MAAA,EACjCE,IAAapC,IAASkC,EAAK,MAAA,EAC3BG,KAAatC,EAAUoC,GAAYC,CAAU,GAC7CE,KAASnD,IAAekD,IAMxBE,KAASnC,EAAkB2B,GAAQO,IAAQ7C,CAAU;gBAC3D,IAAI8C,OAAW,MAAM;oBACpB,MAAMC,KAAOT,CAAAA,CAAOQ,EAAM,CAAA;oBAEzB,CAAID,MAAU,KAAKE,GAAK,KAAA,IAASN,EAAK,KAAA,KAAA,CACrCR,CAAAA,CAAEnY,CAAC,CAAA,GAAIiZ,IACP1W,IAASqW,IAAaK,GAAK,KAAA,CAAM,MAAA,EACjCxC,IAASoC,IAAaI,GAAK,MAAA,EAC3BT,EAAO,MAAA,CAAOQ,IAAQ,CAAC,GACvB7B,EAAaqB,GAAQG,CAAI,CAAA;gBAG5B;YACD;YAEA,MAAMO,IAAQ7B,EAAe9U,GAAQkU,CAAM;YAC3C,IAAIyC,IAAQ7C,GAAW;gBACtB,IAAA,CAAK,OAAA,CAAQ,KAAA,CACZ,gGACA;oBAAE,OAAA6B;oBAAO,QAAA3V;oBAAQ,OAAA2W;gBAAA,IAElB9C,IAAa,CAAC;uBAAG+B,CAAC;iBAAA,CAAE,IAAA,CAAK,CAAC7T,GAAGC,IAAMA,EAAE,KAAA,GAAQD,EAAE,KAAK,GACpD+R,IAAY6C,GACZ5C,IAAa/T,GACbgU,IAAaE;gBAMb,MAAM0C,IAAQ,CAAC;uBAAG/C,CAAU;iBAAA;gBAC5B,MAAO+C,EAAM,MAAA,GAAS,KAAK9C,IAAY,GAAG;oBACzC,MAAMsC,IAAOQ,EAAM,GAAA,CAAA,GACbP,IAAarW,IAASoW,EAAK,KAAA,CAAM,MAAA,EACjCE,IAAapC,IAASkC,EAAK,MAAA,EAC3BS,IAAY/B,EAAeuB,GAAYC,CAAU;oBACvD,IAAIO,KAAa,IAAA,EAAU,CAAA;oBACvBA,IAAY/C,KAAAA,CACfD,IAAa,CAAC;2BAAG+C,CAAK;qBAAA,EACtB9C,IAAY+C,GACZ9C,IAAasC,GACbrC,IAAasC,GACbtW,IAASqW,GACTnC,IAASoC,CAAAA;gBAEX;YACD;YAEA,IAAIzC,KAAcC,IAAY,IAAA,GAAU;gBACvC,MAAMgD,IAAU7C,EAAUF,GAAYC,CAAU;gBAChD,IACC8C,MAAYzD,KACIyD,KAAWzD,KAAgByD,KAAWpB,GAEtD;YAEF;YAEA,IAAI9B,EAAM,OAAA,CAAA,IAAYH,GAGd;gBACN,IAAA,CAAK,OAAA,CAAQ,IAAA,CAAK,iEAAiE;gBACnF;YACD;QAEF;QAEA,IAAII,KAAcC,IAAY,IAAA,GAAU;YACvC,MAAMiD,IAAalD,EAAW,GAAA,CAAI,CAACgB,IAAQA,EAAI,KAAK,GAC9CmC,IAAgB,IAAI,IAAID,CAAU,GAClC7D,IAAOrP,EAAO,MAAA,CAAO,CAACtB,IAAM,CAACyU,EAAc,GAAA,CAAIzU,CAAC,CAAC;YACvD,OAAA,IAAA,CAAK,OAAA,CAAQ,IAAA,CAAK,iCAAiC;gBAAE,MAAMqR,EAAM,OAAA,CAAA;YAAA,CAAW,GACrE;gBAAE,MAAAV;gBAAM,MAAM6D;YAAA;QACtB;QACA,OAAO;YAAE,MAAMlT;YAAQ,MAAM,CAAA,CAAA;QAAC;IAC/B;IAAA;;;;;;GAAA,GASA,iBAAiBA,CAAAA,EAAyB;QACzC,MAAMoT,IAASpT,EAAO,MAAA,CAAO,CAAC9B,GAAG0G,IAAM1G,IAAI,IAAA,CAAK,cAAA,CAAe0G,CAAC,GAAG,CAAC;QACpE,OAAO,KAAK,IAAA,CAAKwO,IAAS,GAAI;IAC/B;IAAA;;;;;;GAAA,GASQ,eAAe5T,CAAAA,EAAc;QACpC,MAAMlC,IAAS,IAAA,CAAK,QAAA,CAAS,IAAA,CAAK,CAACwB,IAAMA,EAAE,EAAA,KAAOU,EAAM,EAAE;QAC1D,IAAI,CAAClC,GACJ,MAAM,IAAI,MAAM,CAAA,kDAAA,EAAqDkC,EAAM,EAAE,EAAE;QAEhF,OAAOlC,GAAQ,iBAAiB;IACjC;IAAA;;;;;;GAAA,GASA,iBAAiB+V,CAAAA,EAAiBtI,CAAAA,EAA0B;QAS3D,OARa,KAAK,KAAA,CACjB,KAAK,GAAA,CAAA,CACHsI,IAAAA,CAAW,IAAA,CAAK,QAAA,CAAS,IAAA,CAAK,CAACvU,IAAkBA,EAAE,EAAA,KAAOiM,CAAQ,GAAG,iBAAiB,CAAA,IACtF,GAAA,IACA,KACD;IAIH;IAAA;;;;;;;GAAA,GAUA,MAAM,KAAK5O,CAAAA,EAAgB6D,CAAAA,EAAiBwI,CAAAA,EAA8C;QACzF,IAAA,CAAK,YAAA,CAAarM,GAAQ,MAAM;QAChC,IAAI,EAAE,eAAAiS,CAAAA,EAAAA,GAAkB5F,KAAW,CAAA;QACnC,MAAM,EAAE,aAAAuG,CAAAA,EAAa,UAAAhE,CAAAA,EAAU,SAAAqC,CAAAA,EAAS,QAAAiB,CAAAA,EAAQ,SAAAC,CAAAA,EAAS,cAAAjQ,CAAAA,EAAc,YAAAkQ,CAAAA,EAAY,MAAAvC,CAAAA,CAAA,CAAA,GAClFxD,KAAW,CAAA,GACNlL,IAAS,MAAM,IAAA,CAAK,OAAA,CAAQyN,CAAQ;QAE1C,IAAIyE,IAAerT;QACnB,MAAMmX,IAAkB7R,EAAUzB,CAAM;QAExC,IAAIuT,IAAcnF,GAAe,eAAe/Q,EAAYmS,GAAclS,EAAO,IAAI;QAErF,IAAIyR,GAAa;YAChB,IAAIyE,IAAY,IAAA,CAAK,gBAAA,CAAiBD,EAAY,MAAA,EAAQjW,EAAO,EAAE,GAC/DmW,IAAiBpW,EAAYmW,GAAWlW,EAAO,IAAI;YACvD,MACC,IAAA,CAAK,gBAAA,CAAiBiW,EAAY,MAAA,CAAOE,CAAc,EAAE,MAAA,EAAQnW,EAAO,EAAE,IAAIkW,GAE9EA,KACAC,IAAiBpW,EAAYmW,GAAWlW,EAAO,IAAI;YAEpDiW,IAAcA,EAAY,MAAA,CAAOE,CAAc,GAC/CjE,KAAgBgE;QACjB;QAIA,MAAM,EAAE,MAAME,CAAAA,EAAY,MAAMC,CAAAA,CAAA,CAAA,GAAe,IAAA,CAAK,kBAAA,CACnD3T,GACAwP,GACA,CAAA,IAGKlR,IAAemD,EAAUkS,CAAU,IAAI,IAAA,CAAK,gBAAA,CAAiBA,CAAU,IAAInE;QAEjF,IAAIlR,IAAe,GAClB,MAAM,IAAI,MAAM,4BAA4B;QAI7C,IAAIsV;QACJ,IAAI,CAACxF,GAAe,eAAe,CAAC/P,GACnCuV,IAAcvW,EAAYiB,GAAchB,EAAO,IAAI;aAAA,IACzC,CAAC8Q,GAAe,eAAe/P,GACzCuV,IAAcxV,GACbC,GACAC,GACAhB,EAAO,IAAA,EACP,IAAA,CAAK,mBAAA;aAAA,IAEI8Q,GAAe;YACzB,IAAIA,EAAc,WAAA,EAAa,OAAO,CAAClQ,GAAWC,IAAcD,IAAIC,GAAG,CAAC,KAAKG,GAC5E,MAAM,IAAI,MAAM,0CAA0C;YAE3DsV,IAAcxF,EAAc,WAAA;QAC7B;QAEA,IAAIoB,IAAe,IAAA,CAAK,gBAAA,CAAiBmE,CAAU,IAAIL,GACtD,MAAA,IAAA,CAAK,OAAA,CAAQ,KAAA,CACZ,CAAA,4BAAA,EAA+BA,CAAe,CAAA,yBAAA,EAA4B9D,CAAY,CAAA,QAAA,EAAW,IAAA,CAAK,gBAAA,CACrGmE,GACA,WAAA,EAAcA,EAAW,MAAM,EAAA,GAE3B,IAAI,MAAM,qCAAqC;QAGtDvF,IAAgB;YACf,aAAAwF;YACA,aAAAL;QAAA;QAGD,MAAMM,IAAiBtF,GAAY,QAAQ,IAAA,CAAK,YAAA,EAC1CuF,IAAiBvF,GAAY,MAE7BE,IAAkB,IAAA,CAAK,iBAAA,CAC5Be,GACAmE,GACArW,GACA8Q,GACAhB,GACAiB,GACAC,GACA;YAAE,MAAMuF;YAAgB,MAAMC;QAAA,GAC9B9H,IAEK,EAAE,YAAA0C,EAAAA,EAAAA,GAAe,MAAM,IAAA,CAAK,IAAA,CAAK,IAAA,CAAKD,EAAgB,OAAO,GAC7DsF,IAAatF,EAAgB,UAAA,CAAW,GAAA,CAAI,CAACE,GAAG/U,IAAM+U,EAAE,OAAA,CAAQD,EAAAA,CAAW9U,CAAC,CAAA,EAAG0D,CAAM,CAAC,GACtF0W,IAA6B,CAAA,CAAA,EAC7BC,IAA6B,CAAA,CAAA,EAC7BC,IAAsB,MAAMzF,EAAgB,UAAA,CAAW,MAAM,GAC7D0F,IAAkB,MAAMJ,EAAW,MAAM;QAC/C,OAAAtF,EAAgB,aAAA,CAAc,OAAA,CAAQ,CAACI,GAAGjV,MAAM;YAC/Csa,CAAAA,CAAoBrF,CAAC,CAAA,GAAIJ,EAAgB,UAAA,CAAW7U,CAAC,CAAA,EACrDua,CAAAA,CAAgBtF,CAAC,CAAA,GAAIkF,CAAAA,CAAWna,CAAC,CAAA;QAClC,CAAC,GACDua,EAAgB,OAAA,CAAQ,CAACzV,GAAU9E,MAAM;YACpCsa,CAAAA,CAAoBta,CAAC,CAAA,GACxBoa,EAAkB,IAAA,CAAKtV,CAAC,IAExBuV,EAAkB,IAAA,CAAKvV,CAAC;QAE1B,CAAC,GACM;YACN,MAAM,CAAC;mBAAGsV,GAAmB;mBAAGN,CAAU;aAAA;YAC1C,MAAMO;QAAA;IAER;IAAA;;;;;;;;;;;GAAA,GAcA,MAAM,aACLG,IAAW,GAAA,EACXC,IAAY,GAAA,EACZjH,IAAU,CAAA,EACVrC,CAAAA,EACkE;QAClE,MAAMuJ,IAAuB,KAAK,IAAA,CAAKF,IAAWC,CAAS,GACrDE,IAA0B,CAAA,CAAA;QAEhC,IAAIC,GACAC,IAAoB;QAExB,MAAOA,IAAoBH,GAAsB;YAChD,MAAMI,IAAa,MAAM,IAAA,CAAK,OAAA,CAAQtH,GAASiH,GAAW;gBAAE,UAAAtJ;YAAAA,CAAU;YAClE2J,EAAW,MAAA,CAAO,MAAA,GAAS,IAAA,CAC9BD,IAAoB,GACpBF,EAAe,IAAA,CAAK,GAAGG,EAAW,MAAM,GACxCF,IAA2BE,EAAW,wBAAA,IAEtCD,KAEDrH,KAAWiH;QACZ;QACA,OAAO;YAAE,QAAQE;YAAgB,0BAAAC;QAAA;IAClC;IAAA;;;;;;;GAAA,GAUA,MAAM,QACL/N,CAAAA,EACAkO,CAAAA,EACAnM,CAAAA,EACkE;QAClE,MAAM,EAAE,UAAAuC,CAAAA,EAAAA,GAAavC,KAAW,CAAA,GAC1BzO,IAAO,MAAM,IAAA,CAAK,OAAA,CAAQgR,CAAQ;QACxC,IAAI,CAAC,IAAA,CAAK,KAAA,EACT,MAAM,IAAI,MAAM,4DAA4D;QAI7E,MAAM6J,IAAQ,MAAMD,CAAK,EAAE,IAAA,CAAK,CAAC,GAC3BpG,IAAahD,EAAW,uBAAA,CAAwB,GAAG,IAAA,CAAK,KAAA,EAAO9E,GAAO1M,GAAM6a,CAAK,GAEjF,EAAE,SAAAC,CAAAA,EAAS,YAAAnG,CAAAA,CAAA,CAAA,GAAe,MAAM,IAAA,CAAK,IAAA,CAAK,OAAA,CAAQ;YACvD,SAASH,EAAW,GAAA,CAAI,CAAC,IAAM,EAAE,cAAc;QAAA,CAC/C,GAEKuG,IAA8D,CAAA;QACpED,EAAQ,OAAA,CAAQ,CAACnL,GAAG9P,IAAOkb,CAAAA,CAAapL,EAAE,EAAE,CAAA,GAAIgF,CAAAA,CAAW9U,CAAC,CAAE;QAE9D,MAAM2a,IAA0B,CAAA,CAAA;QAChC,IAAIC;QAEJ,IAAA,IAAS5a,IAAI,GAAGA,IAAI2U,EAAW,MAAA,EAAQ3U,IAAK;YAC3C,MAAMmb,IAAcD,CAAAA,CAAavG,CAAAA,CAAW3U,CAAC,CAAA,CAAE,cAAA,CAAe,EAAE,CAAA;YAC5Dmb,KAAAA,CACHP,IAA2B/N,IAAQ7M,GACnC2U,CAAAA,CAAW3U,CAAC,CAAA,CAAE,cAAA,CAAe,MAAA,GAASmb,EAAY,MAAA,EAClDR,EAAe,IAAA,CAAKhG,CAAAA,CAAW3U,CAAC,CAAA,CAAE,OAAA,CAAQmb,GAAahb,CAAI,CAAC,CAAA;QAE9D;QAEA,OAAO;YACN,QAAQwa;YACR,0BAAAC;QAAA;IAEF;IAAA;;;;;;;;;GAAA,GAYA,MAAM,gBAAgBrY,CAAAA,EAAgBG,CAAAA,EAAkD;QACvF,IAAA,CAAK,YAAA,CAAaH,GAAQ,iBAAiB;QAC3C,MAAMsO,IAAqC;YAC1C,MAAM,IAAA,CAAK,KAAA;YACX,QAAAtO;YACA,aAAAG;QAAA,GAEK0Y,IAAM,MAAM,IAAA,CAAK,IAAA,CAAK,eAAA,CAAgBvK,CAAgB;QAC5D,OAAO;YAAE,GAAGuK,CAAAA;YAAK,QAAQA,EAAI,MAAA,IAAU7Y;YAAQ,MAAM6Y,EAAI,IAAA,IAAQ,IAAA,CAAK,IAAA;QAAA;IACvE;IAAA;;;;;;;;GAAA,GAWA,MAAM,sBACL7Y,CAAAA,EACAkS,CAAAA,EACA/R,CAAAA,EACmC;QACnC,IAAA,CAAK,YAAA,CAAaH,GAAQ,uBAAuB;QACjD,MAAM,EAAE,WAAA8Y,CAAAA,EAAAA,GAAAA,CAAe,MAAM,IAAA,CAAK,eAAA,CAAA,CAAA,EAAmB,WAAA,CAAY,EAAE;QACnE,IAAI,CAACA,GACJ,MAAM,IAAI,MAAM,8BAA8B;QAE/C,MAAMxK,IAAqC;YAC1C,MAAM,IAAA,CAAK,KAAA;YACX,QAAAtO;YACA,aAAAG;YACA,QAAA+R;QAAA,GAEK2G,IAAM,MAAM,IAAA,CAAK,IAAA,CAAK,eAAA,CAAgBvK,CAAgB;QAC5D,IAAI,OAAOuK,EAAI,MAAA,IAAW,UACzB,MAAM,IAAI,MAAM,mCAAmC;QAC7C;YACN,MAAM3G,IAAS2G,EAAI,MAAA;YACnB,OAAO;gBAAE,GAAGA,CAAAA;gBAAK,QAAA3G;gBAAQ,QAAQ2G,EAAI,MAAA,IAAU7Y;gBAAQ,MAAM6Y,EAAI,IAAA,IAAQ,IAAA,CAAK,IAAA;YAAA;QAC/E;IACD;IAAA;;;;;;;;;;GAAA,GAaA,MAAM,sBACL3G,CAAAA,EACA7F,CAAAA,EAImC;QAEnC,MAAM0M,IAAW,MAAM,IAAA,CAAK,eAAA,CAAA;QAC5B,IAAI1M,GAAS,eAAe,CAAC0M,EAAS,yBAAA,EACrC,MAAM,IAAI,MAAM,8CAA8C;QAG/D,MAAMzK,IAA2C;YAChD,QAAA4D;YACA,MAAM,IAAA,CAAK,KAAA;YACX,QAAQ7F,GAAS;YACjB,aAAaA,GAAS;QAAA;QAGvB,OAAO,IAAA,CAAK,IAAA,CAAK,qBAAA,CAAsBiC,CAAgB;IACxD;IAUA,MAAM,eACLC,CAAAA,EACwD;QACxD,MAAMyK,IAAU,OAAOzK,KAAU,WAAWA,IAAQA,EAAM,KAAA,EACpD0K,IAAU,MAAM,IAAA,CAAK,IAAA,CAAK,cAAA,CAAeD,CAAO;QACtD,OAAI,OAAOzK,KAAU,WACb0K,IAED;YAAE,GAAGA,CAAAA;YAAS,QAAQA,EAAQ,MAAA,IAAU1K,EAAM,MAAA;YAAQ,MAAM0K,EAAQ,IAAA,IAAQ1K,EAAM,IAAA;QAAA;IAC1F;IAAA;;;;;GAAA,GAQA,MAAM,qBAAqBA,CAAAA,EAAiD;QAC3E,OAAO,IAAA,CAAK,IAAA,CAAK,oBAAA,CAAqBA,CAAK;IAC5C;IAmBA,MAAM,WACLvO,CAAAA,EACAuO,CAAAA,EACAlC,CAAAA,EACmB;QACnB,OAAO,IAAA,CAAK,WAAA,CAAY,UAAUrM,GAAQuO,GAAOlC,CAAO;IACzD;IAAA;;;;;;;;;;GAAA,GAaA,MAAM,iBACLrM,CAAAA,EACAuO,CAAAA,EACA2K,CAAAA,EACA7M,CAAAA,EACmB;QACnB,OAAO,IAAA,CAAK,WAAA,CAAY,UAAUrM,GAAQuO,GAAO;YAAE,GAAGlC,CAAAA;YAAS,YAAA6M;QAAAA,CAAY;IAC5E;IAAA;;;;;;;GAAA,GAUA,MAAM,gBAAgBC,CAAAA,EAA6C;QAClE,MAAM1K,IAAqC;YAC1C,MAAM,IAAA,CAAK,KAAA;YACX,SAAS0K;QAAA,GAEJC,IAAY,MAAM,IAAA,CAAK,IAAA,CAAK,eAAA,CAAgB3K,CAAgB;QAClE,OAAO;YACN,GAAG2K,CAAAA;YACH,MAAMA,EAAU,IAAA,IAAQ,IAAA,CAAK,IAAA;YAC7B,SAASA,EAAU,OAAA,IAAWD;QAAA;IAEhC;IAAA;;;;;;;;;GAAA,GAYA,MAAM,sBACLE,CAAAA,EACAC,CAAAA,EACmC;QACnC,OAAO,IAAA,CAAK,IAAA,CAAK,qBAAA,CAAsB;YACtC,MAAM,IAAA,CAAK,KAAA;YACX,SAASD;YACT,SAASC,IACN;gBACA,YAAY;oBACX,aAAaA;gBAAA;YACd,IAEA,KAAA;QAAA,CACH;IACF;IAAA;;;;;;;GAAA,GAUA,MAAM,yBACLH,CAAAA,EACAI,CAAAA,EAC6B;QAC7B,IAAA,CAAK,YAAA,CAAaA,GAAuB,0BAA0B;QACnE,MAAM,EAAE,WAAAT,CAAAA,EAAW,QAAA7N,CAAAA,EAAAA,GAAAA,CAAY,MAAM,IAAA,CAAK,eAAA,CAAA,CAAA,EAAmB,WAAA,CAAY,EAAE;QAC3E,IAAI,CAAC6N,GACJ,MAAM,IAAI,MAAM,8BAA8B;QAE/C,IAAI,CAAC7N,GAAQ,KAAK,CAAC1I,IAAMA,EAAE,MAAA,KAAW,YAAYA,EAAE,IAAA,KAAS,IAAA,CAAK,IAAI,GACrE,MAAM,IAAI,MAAM,CAAA,yCAAA,EAA4C,IAAA,CAAK,IAAI,EAAE;QAKxE,MAAMiX,IAAgC;YACrC,KAJ4B;gBAC5B,QAAQD;YAAA;QAGH,GAEA9K,IAAqC;YAC1C,MAAM,IAAA,CAAK,KAAA;YACX,SAAS0K;YACT,SAASK;QAAA;QAGV,OAAO;YAAE,GADS,MAAM,IAAA,CAAK,IAAA,CAAK,eAAA,CAAgB/K,CAAgB,CAAA;YAC3C,SAAS0K;YAAS,MAAM,IAAA,CAAK,KAAA;QAAA;IACrD;IAUA,MAAM,eACL5K,CAAAA,EACwD;QACxD,MAAMyK,IAAU,OAAOzK,KAAU,WAAWA,IAAQA,EAAM,KAAA,EACpD6K,IAAY,MAAM,IAAA,CAAK,IAAA,CAAK,cAAA,CAAeJ,CAAO;QACxD,OAAI,OAAOzK,KAAU,WACb6K,IAED;YAAE,GAAGA,CAAAA;YAAW,SAAS7K,EAAM,OAAA;YAAS,MAAMA,EAAM,IAAA;QAAA;IAC5D;IAEA,MAAM,qBAAqBA,CAAAA,EAAiD;QAC3E,OAAO,IAAA,CAAK,IAAA,CAAK,oBAAA,CAAqBA,CAAK;IAC5C;IAAA;;;;;;;;;GAAA,GAYA,MAAM,WACL6K,CAAAA,EACAK,CAAAA,EACApN,CAAAA,EAC8B;QAC9B,OAAO,IAAA,CAAK,WAAA,CAAY,UAAU+M,GAAWK,GAAcpN,CAAO;IACnE;IAAA;;;;;;;;;GAAA,GAYA,MAAM,iBACL+M,CAAAA,EACAK,CAAAA,EACApN,CAAAA,EAIE;QACF,OAAO,IAAA,CAAK,WAAA,CAAY,UAAU+M,GAAWK,GAAcpN,CAAO;IACnE;IAAA;;;;;;;;;;;;;;GAAA,GAiBQ,kBACPrM,CAAAA,EACAyZ,CAAAA,EACAtY,CAAAA,EACA8Q,CAAAA,EACAhB,CAAAA,EACAiB,CAAAA,EACAC,CAAAA,EACAuH,CAAAA,EAIA7J,CAAAA,EAQkB;QAClB,MAAMkF,IAAc0E,EAAa,MAAA,CAAO,CAACE,GAAevT,IAAgBuT,IAAQvT,EAAK,MAAA,EAAQ,CAAC;QAC1F6L,KAAiBA,EAAc,WAAA,IAAe,CAACA,EAAc,WAAA,IAAA,CAChEA,EAAc,WAAA,GAAc/Q,EAC3B6T,IAAc/U,IAAS,IAAA,CAAK,gBAAA,CAAiByZ,CAAY,GACzDtY,EAAO,IAAA,CAAA;QAGT,MAAMyY,IAAa7E,IAAc/U,IAAS,IAAA,CAAK,gBAAA,CAAiByZ,CAAY;QAC5E,IAAI/B,IAAmC,CAAA,CAAA,EACnCC,IAAmC,CAAA,CAAA;QAEvC,IAAI+B,GAAkB,MACrB,IAAIzK,GAAoByK,EAAiB,IAAI,GAAG;YAC/C,MAAMG,IAAUH,EAAiB,IAAA;YACjBxY,EAAY0Y,GAAYzY,EAAO,IAAI,EAC3C,OAAA,CAAQ,CAACY,MAAM;gBACtB2V,EAAe,IAAA,CAAKmC,EAAQ9X,GAAGZ,CAAM,CAAC;YACvC,CAAC;QACF,OACCuW,IAAiBgC,EAAiB,IAAA;aAGnChC,IAAiB,IAAA,CAAK,gBAAA,CACrBkC,GACAzY,GACA8P,GACA,KAAA,GACAgB,GAAe,aACf,KAAA,GACA,IAAA,CAAK,YAAA;QAIP,IAAIyH,GAAkB,MACrB,IAAIzK,GAAoByK,EAAiB,IAAI,GAAG;YAC/C,MAAMG,IAAUH,EAAiB,IAAA;YACjBxY,EAAYlB,GAAQmB,EAAO,IAAI,EACvC,OAAA,CAAQ,CAACY,MAAM;gBACtB4V,EAAe,IAAA,CAAKkC,EAAQ9X,GAAGZ,CAAM,CAAC;YACvC,CAAC;QACF,OACCwW,IAAiB+B,EAAiB,IAAA;aAGnC/B,IAAiB,IAAA,CAAK,gBAAA,CACrB3X,GACAmB,GACA8P,IAAUA,IAAUyG,EAAe,MAAA,GAAS,KAAA,GAC5CxF,GACAD,GAAe,aACfpC;QAIEsC,KAAAA,CACHsH,QAAeK,wQAAAA,EAAeL,GAActH,CAAO,CAAA,GAGpDsH,IAAe/V,GAAU+V,CAAY,GAGrCA,IAAeA,EAAa,GAAA,CAAI,CAAClX,MAAa;YAC7C,MAAMwX,IACLxX,EAAE,OAAA,IAAW,OAAOA,EAAE,OAAA,IAAY,WAAW,KAAK,SAAA,CAAUA,EAAE,OAAO,IAAIA,EAAE,OAAA;YAC5E,OAAO;gBAAE,GAAGA,CAAAA;gBAAG,SAAAwX;YAAA;QAChB,CAAC;QAED,MAAMC,IAAqB,CAAC;eAAGtC,GAAgB;eAAGC,CAAc;SAAA,EAC1DzB,IAAU8D,EACd,GAAA,CAAI,CAAC7D,GAAG1Y,IAAMA,CAAC,EACf,IAAA,CACA,CAACsE,GAAGC,IACHgY,CAAAA,CAAmBjY,CAAC,CAAA,CAAE,cAAA,CAAe,MAAA,GAASiY,CAAAA,CAAmBhY,CAAC,CAAA,CAAE,cAAA,CAAe,MAAA,GAEhFiY,IAAwB;eAC1B,MAAM,IAAA,CAAK;gBAAE,QAAQvC,EAAe,MAAA;YAAA,GAAU,IAAM,CAAA,CAAI;eACxD,MAAM,IAAA,CAAK;gBAAE,QAAQC,EAAe,MAAA;YAAA,GAAU,IAAM,CAAA,CAAK;SAAA,EAGvDuC,IAAqChE,EAAQ,GAAA,CAAI,CAACzY,IAAMuc,CAAAA,CAAmBvc,CAAC,CAAC,GAC7E0c,IAA8BjE,EAAQ,GAAA,CAAI,CAACzY,IAAMwc,CAAAA,CAAWxc,CAAC,CAAC;QAEpE,OAAO;YACN,SAAS;gBACR,QAAQgc;gBACR,SAASS,EAAiB,GAAA,CAAI,CAAC1H,IAAMA,EAAE,cAAc;YAAA;YAEtD,YAAY0H;YACZ,YAAYC;YACZ,eAAejE;QAAA;IAEjB;IAAA;;;;;GAAA,GAQA,MAAM,kBAAkBrS,CAAAA,EAAwC;QAC/D,MAAMuW,IAAM,IAAI,YAAA,GACVC,IAAKxW,EAAO,GAAA,CAAI,CAACtB,QAAa+X,4PAAAA,EAAYF,EAAI,MAAA,CAAO7X,EAAE,MAAM,CAAC,EAAE,KAAA,CAAM,CAAA,CAAI,CAAC,GAE3EgY,IAAa,KACbC,IAAuB,CAAA,CAAA;QAC7B,IAAA,IAAS/c,IAAI,GAAGA,IAAI4c,EAAG,MAAA,EAAQ5c,KAAK8c,EAAY;YAC/C,MAAME,IAAUJ,EAAG,KAAA,CAAM5c,GAAGA,IAAI8c,CAAU,GACpC,EAAE,QAAQG,CAAAA,CAAA,CAAA,GAAgB,MAAM,IAAA,CAAK,IAAA,CAAK,KAAA,CAAM;gBACrD,IAAID;YAAA,CACJ,GACKE,IAAwC,CAAA;YAC9CD,EAAY,OAAA,CAAQ,CAAChI,MAAM;gBAC1BiI,CAAAA,CAASjI,EAAE,CAAC,CAAA,GAAIA;YACjB,CAAC;YACD,IAAA,IAAS2B,IAAI,GAAGA,IAAIoG,EAAQ,MAAA,EAAQpG,IAAK;gBACxC,MAAMuG,IAAQD,CAAAA,CAASF,CAAAA,CAAQpG,CAAC,CAAC,CAAA;gBACjC,IAAI,CAACuG,GACJ,MAAM,IAAI,MAAM,4CAA4CH,CAAAA,CAAQpG,CAAC,CAAC;gBAEvEmG,EAAO,IAAA,CAAKI,CAAK;YAClB;QACD;QACA,OAAOJ;IACR;IAAA;;;;;;;GAAA,GAUA,MAAM,mBACLK,CAAAA,EACA1P,CAAAA,EACAC,CAAAA,EACiC;QAEjC,IADA,MAAM,IAAA,CAAK,IAAA,CAAK,gBAAA,CAAA,GACZ,CAAC,IAAA,CAAK,IAAA,CAAK,mBAAA,EACd,MAAM,IAAI,MAAM,2CAA2C;QAE5D,MAAMF,IAAQ,IAAA,CAAK,IAAA,CAAK,mBAAA,CAAoB,kBAAA,CAC3C;YAAE,MAAM;YAAqB,SAAS2P;QAAA,GACtC1P,GACAC;QAED,OAAO,MAAM;YACZ,IAAA,CAAK,IAAA,CAAK,mBAAA,EAAqB,mBAAmBF,GAAOC,CAAQ;QAClE;IACD;IAAA;;;;;;;GAAA,GAUA,MAAM,gBACL6N,CAAAA,EACA7N,CAAAA,EACAC,CAAAA,EACiC;QACjC,OAAO,IAAA,CAAK,kBAAA,CACX;YAAC4N,CAAO;SAAA,EACR,CAACzW,MAAM;YACFA,EAAE,KAAA,KAAUkJ,GAAe,IAAA,IAC9BN,EAAS5I,CAAC;QAEZ,GACA6I;IAEF;IAAA;;;;;;;GAAA,GAUA,MAAM,gBACL4N,CAAAA,EACA7N,CAAAA,EACAC,CAAAA,EACiC;QACjC,OAAO,IAAA,CAAK,kBAAA,CACX;YAAC4N,CAAO;SAAA,EACR,CAACzW,MAAM;YACFA,EAAE,KAAA,KAAUmJ,GAAe,IAAA,IAC9BP,EAAS5I,CAAC;QAEZ,GACA6I;IAEF;IAAA;;;;;;;GAAA,GAUA,MAAM,mBACLyP,CAAAA,EACA1P,CAAAA,EACAC,CAAAA,EACiC;QAEjC,IADA,MAAM,IAAA,CAAK,IAAA,CAAK,gBAAA,CAAA,GACZ,CAAC,IAAA,CAAK,IAAA,CAAK,mBAAA,EACd,MAAM,IAAI,MAAM,2CAA2C;QAE5D,MAAMF,IAAQ,IAAA,CAAK,IAAA,CAAK,mBAAA,CAAoB,kBAAA,CAC3C;YAAE,MAAM;YAAqB,SAAS2P;QAAA,GACtC1P,GACAC;QAED,OAAO,MAAM;YACZ,IAAA,CAAK,IAAA,CAAK,mBAAA,EAAqB,mBAAmBF,GAAOC,CAAQ;QAClE;IACD;IAAA;;;;;;;GAAA,GAUA,MAAM,oBACLtH,CAAAA,EACAsH,CAAAA,EACAC,CAAAA,EACiC;QAEjC,IADA,MAAM,IAAA,CAAK,IAAA,CAAK,gBAAA,CAAA,GACZ,CAAC,IAAA,CAAK,IAAA,CAAK,mBAAA,EACd,MAAM,IAAI,MAAM,2CAA2C;QAE5D,MAAMgP,IAAM,IAAI,YAAA,GACVU,IAAmC,CAAA;QACzC,IAAA,IAASrd,IAAI,GAAGA,IAAIoG,EAAO,MAAA,EAAQpG,IAAK;YACvC,MAAMsd,QAAIT,4PAAAA,EAAYF,EAAI,MAAA,CAAOvW,CAAAA,CAAOpG,CAAC,CAAA,CAAE,MAAM,CAAC,EAAE,KAAA,CAAM,CAAA,CAAI;YAC9Dqd,CAAAA,CAASC,CAAC,CAAA,GAAIlX,CAAAA,CAAOpG,CAAC,CAAA;QACvB;QACA,MAAMud,IAAK,OAAO,IAAA,CAAKF,CAAQ,GACzB5P,IAAQ,IAAA,CAAK,IAAA,CAAK,mBAAA,CAAoB,kBAAA,CAC3C;YAAE,MAAM;YAAe,SAAS8P;QAAA,GAChC,CAACzY,MAAkB;YAClB4I,EAAS;gBAAE,GAAG5I,CAAAA;gBAAG,OAAOuY,CAAAA,CAASvY,EAAE,CAAC,CAAA;YAAA,CAAG;QACxC,GACA6I;QAED,OAAO,MAAM;YACZ,IAAA,CAAK,IAAA,CAAK,mBAAA,EAAqB,mBAAmBF,GAAOC,CAAQ;QAClE;IACD;IAAA;;;;;;;;;;;;;GAAA,GAgBQ,iBACPnL,CAAAA,EACAmB,CAAAA,EACA8P,CAAAA,EACAiB,CAAAA,EACAD,CAAAA,EACApC,CAAAA,EAQAgK,CAAAA,EACmB;QACnB,IAAIzH;QACJ,IAAIF,GACHE,IAAahD,EAAW,cAAA,CACvB;YAAE,QAAA8C;YAAQ,gBAAgBrC,GAAM;QAAA,GAChC7P,GACAmB,GACA8Q;aAAA,IAEShB,KAAWA,MAAY,GAAG;YACpC,IAAI,CAAC,IAAA,CAAK,KAAA,EACT,MAAM,IAAI,MAAM,mDAAmD;YAEpEmB,IAAahD,EAAW,uBAAA,CACvBpP,GACA,IAAA,CAAK,KAAA,EACLiR,GACA9P,GACA8Q;QAEF,OAAWpC,IACVuC,IAAahD,EAAW,cAAA,CAAeS,GAAM7P,GAAQmB,GAAQ8Q,CAAa,IAChE4H,IAEVzH,IADgBlR,EAAYlB,GAAQmB,EAAO,IAAI,EAC1B,GAAA,CAAI,CAACY,IAAM8X,EAAQ9X,GAAGZ,CAAM,CAAC,IAElDiR,IAAahD,EAAW,gBAAA,CAAiBpP,GAAQmB,GAAQ8Q,CAAa;QAEvE,OAAOG;IACR;IAAA;;;;;;;;;GAAA,GAYQ,mBACPpS,CAAAA,EACAmB,CAAAA,EACA8P,CAAAA,EACA4I,CAAAA,EACmB;QACnB,IAAIrB,IAAQ,KAAK,IAAA,CAAK,KAAK,IAAA,CAAKxY,CAAM,CAAC,KAAK;QAExCwY,IAAQ,KAAA,CACXA,IAAQ,CAAA;QAGT,MAAMC,IAAQD,IAAQ,MAAMA,CAAK,EAAE,IAAA,CAAK,CAAC,IAAI,CAAA,CAAA;QAC7C,OAAO,IAAA,CAAK,gBAAA,CAAiB,GAAGrX,GAAQ8P,GAAS,KAAA,GAAWwH,GAAO,KAAA,GAAWoB,CAAO;IACtF;IAAA;;;;;;;;GAAA,GAWA,MAAc,YACb7O,CAAAA,EACAhL,CAAAA,EACAuO,CAAAA,EACAlC,CAAAA,EACmB;QACnB,IAAA,CAAK,YAAA,CAAarM,GAAQ,aAAa;QACvC,IAAI,EAAE,eAAAiS,CAAAA,EAAAA,GAAkB5F,KAAW,CAAA;QACnC,MAAM,EAAE,SAAA4E,CAAAA,EAAS,QAAAiB,CAAAA,EAAQ,MAAArC,CAAAA,EAAM,UAAAjB,CAAAA,EAAU,cAAA1M,CAAAA,EAAc,YAAAkQ,CAAAA,EAAY,YAAA8G,CAAAA,EAAAA,GAAe7M,KAAW,CAAA,GAEvFlL,IAAS,MAAM,IAAA,CAAK,OAAA,CAAQyN,CAAQ;QACtC,CAACqD,KAAiB/P,KAAAA,CACrB+P,IAAgB;YACf,aAAahQ,GAAeC,GAAclC,GAAQmB,EAAO,IAAA,EAAM,IAAA,CAAK,mBAAmB;YACvF,aAAa,CAAA,CAAA;QAAC,CAAA;QAGhB,IAAI8Z,IAAgC,CAAA,CAAA;QACpC,IAAI7I,GACH,IAAInD,GAAoBmD,CAAU,GAAG;YACpC,MAAM8I,IAAUha,EAAYlB,GAAQmB,EAAO,IAAA,EAAM8Q,GAAe,WAAW;YAC3E,IAAA,IAASxU,IAAI,GAAGA,IAAIyd,EAAQ,MAAA,EAAQzd,IACnCwd,EAAgB,IAAA,CAAK7I,EAAW8I,CAAAA,CAAQzd,CAAC,CAAA,EAAG0D,CAAM,CAAC;QAErD,OACC8Z,IAAkB7I;aAAA,IAET,IAAA,CAAK,YAAA,EAAc;YAC7B,MAAM8I,IAAUha,EAAYlB,GAAQmB,EAAO,IAAA,EAAM8Q,GAAe,WAAW;YAC3E,IAAA,IAASxU,IAAI,GAAGA,IAAIyd,EAAQ,MAAA,EAAQzd,IACnCwd,EAAgB,IAAA,CAAK,IAAA,CAAK,YAAA,CAAaC,CAAAA,CAAQzd,CAAC,CAAA,EAAG0D,CAAM,CAAC;QAE5D,OACC8Z,IAAkB,IAAA,CAAK,gBAAA,CACtBjb,GACAmB,GACA8P,GACAiB,GACAD,GAAe,aACfpC;QAGF,MAAMsL,IAAkBF,EAAgB,GAAA,CAAI,CAACzI,IAAMA,EAAE,cAAc,GAC7DhE,IAA2B;YAChC,SAAS2M;YACT,OAAO,OAAO5M,KAAU,WAAWA,IAAQA,EAAM,KAAA;QAAA;QAElD,IAAI,OAAOA,KAAU,YAAYA,EAAM,MAAA,EAAQ;YAC9C,IAAI,CAAC2K,GACJ,MAAM,IAAI,MAAM,+CAA+C;YAEhE1K,EAAY,SAAA,OAAY4M,uQAAAA,EAAclC,GAAY3K,EAAM,KAAA,EAAO4M,CAAe;QAC/E;QACA,IAAInQ,MAAW,UAAU;YACxB,MAAM,EAAE,YAAAuH,CAAAA,CAAAA,CAAAA,GAAe,MAAM,IAAA,CAAK,IAAA,CAAK,UAAA,CAAW/D,CAAW;YAC7D,OAAOyM,EAAgB,GAAA,CAAI,CAACzI,GAAG/U,IAAM+U,EAAE,OAAA,CAAQD,CAAAA,CAAW9U,CAAC,CAAA,EAAG0D,CAAM,CAAC;QACtE;QACA,MAAM,EAAE,YAAAoR,CAAAA,CAAA,CAAA,GAAe,MAAM,IAAA,CAAK,IAAA,CAAK,IAAA,CAAK/D,CAAW;QACvD,OAAOyM,EAAgB,GAAA,CAAI,CAACzI,GAAG/U,IAAM+U,EAAE,OAAA,CAAQD,CAAAA,CAAW9U,CAAC,CAAA,EAAG0D,CAAM,CAAC;IACtE;IAAA;;;;;;;;GAAA,GAWA,MAAc,YACb6J,CAAAA,EACAoO,CAAAA,EACAK,CAAAA,EACApN,CAAAA,EAC8B;QAC9B,MAAM,EAAE,UAAAuC,CAAAA,EAAU,SAAAqC,CAAAA,EAAS,SAAAkB,CAAAA,CAAA,CAAA,GAAY9F,KAAW,CAAA,GAC5CzO,IAAO,MAAM,IAAA,CAAK,OAAA,CAAQgR,CAAQ,GAClCwD,IAAa,IAAA,CAAK,kBAAA,CACvB9M,EAAUmU,CAAY,IAAIL,EAAU,MAAA,EACpCxb,GACAqT,GACA,IAAA,CAAK,YAAA;QAEFkB,KAAW,QAAA,CACdsH,QAAeK,wQAAAA,EAAeL,GAActH,CAAO,CAAA,GAGpDsH,IAAe/V,GAAU+V,CAAY,GAGrCA,IAAeA,EAAa,GAAA,CAAI,CAAClX,MAAa;YAC7C,MAAMwX,IACLxX,EAAE,OAAA,IAAW,OAAOA,EAAE,OAAA,IAAY,WAAW,KAAK,SAAA,CAAUA,EAAE,OAAO,IAAIA,EAAE,OAAA;YAC5E,OAAO;gBAAE,GAAGA,CAAAA;gBAAG,SAAAwX;YAAA;QAChB,CAAC;QAED,MAAMrL,IAA2B;YAChC,OAAO0K,EAAU,KAAA;YACjB,QAAQK;YACR,SAASrH,EAAW,GAAA,CAAI,CAACI,IAAMA,EAAE,cAAc;QAAA;QAEhD,IAAIxH,MAAW,UAAU;YACxB,MAAMqQ,IAAe,MAAM,IAAA,CAAK,IAAA,CAAK,UAAA,CAAW3M,CAAW;YAC3D,OAAO;gBACN,OAAO;oBAAE,GAAG2M,CAAAA;oBAAc,MAAMjC,EAAU,IAAA;oBAAM,SAASA,EAAU,OAAA;gBAAA;gBACnE,QAAQiC,EAAa,MAAA,EAAQ,IAAI,CAAC3I,GAAGjV,IAAM2U,CAAAA,CAAW3U,CAAC,CAAA,CAAE,OAAA,CAAQiV,GAAG9U,CAAI,CAAC,KAAK,CAAA,CAAA;YAAC;QAEjF;QACA,MAAMyd,IAAe,MAAM,IAAA,CAAK,IAAA,CAAK,IAAA,CAAK3M,CAAW;QACrD,OAAO;YACN,OAAO;gBAAE,GAAG2M,CAAAA;gBAAc,MAAMjC,EAAU,IAAA;gBAAM,SAASA,EAAU,OAAA;YAAA;YACnE,QAAQiC,EAAa,MAAA,EAAQ,IAAI,CAAC3I,GAAGjV,IAAM2U,CAAAA,CAAW3U,CAAC,CAAA,CAAE,OAAA,CAAQiV,GAAG9U,CAAI,CAAC,KAAK,CAAA,CAAA;QAAC;IAEjF;AACD;AChvDA,MAAM0d,EAAc;IAAA;;;;GAAA,GAMnB,YACSzN,CAAAA,EACAC,CAAAA,CACP;QAFO,IAAA,CAAA,QAAA,GAAAD,GACA,IAAA,CAAA,cAAA,GAAAC,GAER,IAAA,CAAK,QAAA,GAAW7G,GAAY4G,CAAQ,GACpC,IAAA,CAAK,cAAA,GAAiBC;IACvB;IAEA,IAAI,UAAU;QACb,OAAO,IAAA,CAAK,QAAA;IACb;IAAA;;;;;;;;GAAA,GAWA,aAAoB,KACnBE,CAAAA,EACAQ,CAAAA,EACA+M,CAAAA,EACAtN,CAAAA,EACC;QACD,MAAMI,IAAkBJ,KAAiBjB,GACnCJ,IAAU;YACf,cAAc,GAAG2O,CAAc,EAAA;QAAA,GAE1Bxd,IAAO,MAAMsQ,EAAuC;YACzD,UAAUvH,EAASkH,GAAS,qBAAqB;YACjD,QAAQ;YACR,aAAaQ;YACb,SAAA5B;QAAA,CACA;QAED,IAAI,CAAChG,EAAM7I,CAAI,KAAK,CAAC,MAAM,OAAA,CAAQA,GAAM,UAAU,GAClD,MAAM,IAAI,MAAM,cAAc;QAG/B,OAAOA;IACR;IAAA;;;;;;GAAA,GAQA,MAAM,KAAKyQ,CAAAA,EAAmC+M,CAAAA,EAAwB;QACrE,OAAOD,EAAc,IAAA,CAAK,IAAA,CAAK,QAAA,EAAU9M,GAAa+M,GAAgB,IAAA,CAAK,cAAc;IAC1F;IAAA;;;;;;;;GAAA,GAWA,aAAoB,QACnBvN,CAAAA,EACAY,CAAAA,EACAX,CAAAA,EAC0B;QAE1B,MAAMlQ,IAAO,MAAA,CADWkQ,KAAiBjB,CAAAA,EACU;YAClD,UAAU4B,IACP9H,EAASkH,GAAS,uBAAuBY,CAAQ,IACjD9H,EAASkH,GAAS,qBAAqB;QAAA,CAC1C;QAED,IAAI,CAACpH,EAAM7I,CAAI,KAAK,CAAC,MAAM,OAAA,CAAQA,EAAK,OAAO,GAC9C,MAAM,IAAI,MAAM,cAAc;QAG/B,OAAOA;IACR;IAAA;;;;;;GAAA,GAQA,MAAM,QAAQ6Q,CAAAA,EAAmBZ,CAAAA,EAA2C;QAM3E,OALgB,MAAMsN,EAAc,OAAA,CACnCtN,KAAW,IAAA,CAAK,QAAA,EAChBY,GACA,IAAA,CAAK,cAAA;IAGP;IAAA;;;;;;GAAA,GAQA,aAAoB,WACnBZ,CAAAA,EACAC,CAAAA,EAC0B;QAE1B,OAAA,CADwBA,KAAiBjB,CAAAA,EACF;YACtC,UAAUlG,EAASkH,GAAS,wBAAwB;QAAA,CACpD;IACF;IAAA;;;;GAAA,GAOA,MAAM,aAAsC;QAC3C,OAAOsN,EAAc,UAAA,CAAW,IAAA,CAAK,QAAA,EAAU,IAAA,CAAK,cAAc;IACnE;AACD;AChIA,MAAME,GAAgB;IAAA;;;;GAAA,GAarB,YACC/W,CAAAA,EACA4H,CAAAA,CAIC;QAlBF,IAAA,CAAQ,KAAA,GAAA,aAAA,GAAA,IAAmC,IAAA,GAE3C,IAAA,CAAQ,QAAA,GAAyB,CAAA,CAAA,EACjC,IAAA,CAAQ,KAAA,GAAQ,QAgBf,IAAA,CAAK,IAAA,GAAO5H;QACZ,IAAI7G,IAAmB,CAAA,CAAA;QACnByO,GAAS,QAAQ,CAAC,MAAM,OAAA,CAAQA,EAAQ,IAAI,IAC/CzO,IAAO;YAACyO,EAAQ,IAAI;SAAA,GACVA,GAAS,QAAQ,MAAM,OAAA,CAAQA,GAAS,IAAI,KAAA,CACtDzO,IAAOyO,GAAS,IAAA,GAEbzO,KAAMA,EAAK,OAAA,CAAQ,CAACC,IAAkB,IAAA,CAAK,KAAA,CAAM,GAAA,CAAIA,EAAI,EAAA,EAAIA,CAAG,CAAC,GACjEwO,GAAS,WAAA,CAAS,IAAA,CAAK,QAAA,GAAWA,EAAQ,OAAA;IAC/C;IAEA,IAAI,OAA8B;QACjC,OAAO,IAAA,CAAK,KAAA;IACb;IACA,IAAI,WAAmB;QACtB,IAAI,CAAC,IAAA,CAAK,SAAA,EACT,MAAM,IAAI,MAAM,iBAAiB;QAElC,OAAO,IAAA,CAAK,SAAA;IACb;IACA,IAAI,SAASuC,CAAAA,EAAkB;QAC9B,IAAA,CAAK,SAAA,GAAYA;IAClB;IACA,IAAI,UAAwB;QAC3B,OAAO,IAAA,CAAK,QAAA;IACb;IAAA;;;GAAA,GAMA,MAAM,WAAW;QAChB,MAAM,IAAA,CAAK,UAAA,CAAA,GACX,MAAM,IAAA,CAAK,OAAA,CAAA;IACZ;IAAA;;;;;;;GAAA,GAUA,gBAAgB5J,CAAAA,EAAmC;QAClD,IAAI2M,IAAgB3M,EAAQ,MAAA,CAAO,CAACrC,IAAkBA,EAAE,MAAM;QAG9DgP,IAAgBA,EAAc,MAAA,CAAO,CAAChP,IAAkBA,EAAE,EAAA,CAAG,UAAA,CAAW,IAAI,CAAC;QAE7E,MAAMiP,IAAeD,EAAc,IAAA,CAClC,CAAC5P,GAAeC,IAAAA,CAAmBD,EAAE,aAAA,IAAiB,CAAA,IAAA,CAAMC,EAAE,aAAA,IAAiB,CAAA,EAAA,CAC9E,CAAC,CAAA;QACH,IAAI,CAAC4P,GACJ,MAAM,IAAI,MAAM,wBAAwB;QAEzC,OAAOA;IACR;IAAA;;;;GAAA,GAOA,MAAM,aAAoC;QAEzC,MAAMC,IAAAA,CADa,MAAM,IAAA,CAAK,IAAA,CAAK,UAAA,CAAA,CAAA,EACJ,OAAA,CAAQ,MAAA,CAAO,CAAClP,IAAkBA,EAAE,IAAA,KAAS,IAAA,CAAK,KAAK;QACtF,OAAA,IAAA,CAAK,QAAA,GAAWkP,GACT,IAAA,CAAK,QAAA;IACb;IAAA;;;;;GAAA,GAQA,MAAM,aAAkC;QACvC,MAAM7M,IAAU,MAAM,IAAA,CAAK,IAAA,CAAK,OAAA,CAAA;QAChC,OAAA,IAAA,CAAK,KAAA,GAAQ,IAAI,IAAIA,EAAQ,OAAA,CAAQ,GAAA,CAAI,CAACrC,IAAgB;gBAACA,EAAE,EAAA;gBAAIA,CAAC;aAAC,CAAC,GACpE,IAAA,CAAK,QAAA,GAAW,IAAA,CAAK,eAAA,CAAgB,IAAA,CAAK,QAAQ,EAAE,EAAA,EAC7CqC,EAAQ,OAAA;IAChB;IAAA;;;;;;;;;GAAA,GAYA,MAAM,QAAQ4J,CAAAA,EAAmBkD,CAAAA,EAA2C;QAU3E,IAAA,CATI,CAAA,CAAE,IAAA,CAAK,QAAA,CAAS,MAAA,GAAS,CAAA,KAAMA,CAAAA,KAClC,MAAM,IAAA,CAAK,UAAA,CAAA,GAGPlD,KAAAA,CAEJA,IADoB,IAAA,CAAK,eAAA,CAAgB,IAAA,CAAK,QAAQ,EAC/B,EAAA,GAGpB,CAAC,IAAA,CAAK,QAAA,CAAS,IAAA,CAAK,CAACjM,IAAkBA,EAAE,EAAA,KAAOiM,CAAQ,KAAA,CAC3D,MAAM,IAAA,CAAK,UAAA,CAAA,GACP,CAAC,IAAA,CAAK,QAAA,CAAS,IAAA,CAAK,CAACjM,IAAkBA,EAAE,EAAA,KAAOiM,CAAQ,CAAA,GAC3D,MAAM,IAAI,MAAM,CAAA,8CAAA,EAAiDA,CAAQ,CAAA,OAAA,CAAS;QAKpF,IAAI,CAAC,IAAA,CAAK,KAAA,CAAM,GAAA,CAAIA,CAAQ,GAAG;YAC9B,MAAMhR,IAAO,MAAM,IAAA,CAAK,IAAA,CAAK,OAAA,CAAQgR,CAAQ;YAC7C,IAAA,CAAK,KAAA,CAAM,GAAA,CAAIA,GAAUhR,EAAK,OAAA,CAAQ,CAAC,CAAC;QACzC;QAGA,OAAA,IAAA,CAAK,QAAA,GAAWgR,GACT,IAAA,CAAK,KAAA,CAAM,GAAA,CAAIA,CAAQ;IAC/B;IAAA;;;;;;;GAAA,GAUA,MAAM,WACL5O,CAAAA,EACAub,CAAAA,EACAlP,CAAAA,EAGmB;QACnB,MAAMlL,IAAS,MAAM,IAAA,CAAK,OAAA,CAAQkL,GAAS,QAAQ,GAC7C+F,IAAahD,EAAW,gBAAA,CAAiBpP,GAAQmB,CAAM,GAEvDqN,IAAoC;YACzC,SAAS4D,EAAW,GAAA,CAAI,CAACI,IAAMA,EAAE,cAAc;QAAA,GAE1C,EAAE,YAAAD,CAAAA,EAAAA,GAAe,MAAM,IAAA,CAAK,IAAA,CAAK,IAAA,CAAK/D,GAAa+M,CAAc,GACjEE,IAAarJ,EAAW,GAAA,CAAI,CAACI,GAAG/U,IAAM+U,EAAE,OAAA,CAAQD,CAAAA,CAAW9U,CAAC,CAAA,EAAG0D,CAAM,CAAC;QAC5E,IAAIsa,EAAW,IAAA,CAAK,CAAClZ,IAAM,CAAC2F,GAAa3F,GAAGpB,CAAM,CAAC,GAClD,MAAM,IAAI,MAAM,6CAA6C;QAE9D,OAAOsa;IACR;AACD;AC7KO,SAASC,GAAoBrY,CAAAA,EAAsB;IACzD,MAAME,IAAQ;QACb,IAAIF,EAAM,EAAA;QACV,QAAQA,EAAM,MAAA;QACd,GAAGA,EAAM,CAAA;IAAA,GAEJiB,QAAaV,6OAAAA,EAAmBL,CAAK;IAG3C,OAFe,SACC,MACUe;AAC3B;AAEA,eAAsBqX,GAAoB3b,CAAAA,EAAgBkH,CAAAA,EAAaqU,CAAAA,EAAwB;IAC9F,MAAMK,IAAW,IAAIN,EAAcpU,CAAG;IAGtC,OAAA,CADmB,MADA,IAAIsU,GAAgBI,CAAQ,EACX,UAAA,CAAW5b,GAAQub,CAAc,CAAA,EACnD,GAAA,CAAI,CAAChZ,IAAMmZ,GAAoBnZ,CAAC,CAAC;AACpD"}}]
}